# Termination Companion — Full Mathematical & Algorithmic Dossier

Version: 2025-08-09 (WORKING DRAFT – exhaustive exposition)  
Scope: Strong Normalization (SN) + structural termination strategy for the OperatorKernelO6 rewrite system.  
Audience: Authors, reviewers, automated agents.  
Prime Directive: No kernel alteration. All reasoning meta-level, axiom‑free (no `sorry`).

---

## 0. Executive Abstract

We study strong normalization of the rewrite system generated by the 8 kernel rules on the inductive type `Trace`. We aim to construct a *single*, well‑founded, ordinal‑valued measure `μ : Trace → Ordinal` such that for every rewrite step `t → u` we have `μ u < μ t`. This ensures termination via `InvImage.wf`. Confluence (normalize–join) and higher constructions (arithmetic, equality, provability encodings) depend on a canonical normalizing *geometry*, hence SN is foundational.

Current status: All rules except the `recΔ` successor (`R_rec_succ`) have established strict `μ` decrease lemmas (or sketches very close to final form). The blocker is an unconditional, non‑circular, ordinal decrease for:

```
recΔ b s (delta n)  →  merge s (recΔ b s n)
```

We *can* show decrease for tailored lexicographic measures `(κ, μ)` where `κ` counts `delta` height, but we are pursuing a refined pure‑μ account. The crux: transporting strict inequality through potentially *large right additions* (ordinal addition non‑strict on the right) without extraneous structural constraints between parameters `s` and `n`.

---

## 1. Kernel Recap (Immutable Substrate)

Constructors of `Trace`:
1. `void`
2. `delta t`
3. `integrate t`
4. `merge a b`
5. `recΔ b s n`
6. `eqW a b`

Rewrite rules (`Step`):
- (Int‑Δ) `integrate (delta t) → void`
- (M‑0L) `merge void t → t`
- (M‑0R) `merge t void → t`
- (M‑C)  `merge t t → t`
- (Rec‑0) `recΔ b s void → b`
- (Rec‑S) `recΔ b s (delta n) → merge s (recΔ b s n)`
- (Eq‑Refl) `eqW a a → void`
- (Eq‑Diff) `eqW a b → integrate (merge a b)` (always fires; reflexive case already catches equality)

`StepStar` is the reflexive–transitive closure used for normalization and confluence arguments.

---

## 2. Strategic Design of the Ordinal Measure μ

### 2.1 Architecture Principles
We build `μ` as a *Cantor normal form inspired* composite whose leading exponents isolate constructor *strata*. The ordinal growth tiers strictly separate constructors, ensuring no ambiguity in dominance comparisons:

```
μ void              := 0
μ (delta t)         := ω^(5) * (μ t + 1) + 1
μ (integrate t)     := ω^(4) * (μ t + 1) + 1
μ (merge a b)       := ω^(3) * (μ a + 1) + ω^(2) * (μ b + 1) + 1
μ (recΔ b s n)      := ω^( μ n + μ s + 6 ) + ω * (μ b + 1) + 1
μ (eqW a b)         := ω^( μ a + μ b + 9 ) + 1
```

### 2.2 Rationale for Exponent Slots
| Constructor | Leading Component | Justification |
|-------------|-------------------|---------------|
| `delta`     | `ω^5`             | Fixed high finite exponent reserved for unary growth steps |
| `integrate` | `ω^4`             | Below delta to ensure integrate∘delta collapses massively |
| `merge`     | `ω^3`, `ω^2`      | Binary layering; left operand prioritized over right |
| `recΔ`      | `ω^(μ n + μ s + 6)` | Dynamic tower capturing recursive depth parameter interplay |
| `eqW`       | `ω^(μ a + μ b + 9)` | High tier bounding combination before reduction via merge/integrate |

Finite offsets (`+1`, `+6`, `+9`) ensure separation margins and space for arithmetic safety lemmas (e.g., successor bridging and exponent bumping).

### 2.3 Design Invariants
1. **Constructor Stratification:** Any dynamic exponent (`μ n + μ s + 6`) strictly dominates all *fixed finite* exponent shells (≤ 5) whenever either `μ n` or `μ s` grows beyond finite ranges, thereby giving room for recursion descent.
2. **Additive Principal Usage:** `ω^κ` with `κ ≥ 1` is additive principal. Used to absorb finite and lower‑order sums and maintain canonical dominance ordering.
3. **Payload Normalization:** Each non-leading summand is controlled (e.g., `ω*(μ b + 1)` subordinate to preceding tower) ensuring additive absorption lemmas apply uniformly.

---

## 3. Proof Skeleton for Strong Normalization

### 3.1 Goal
Show: `∀ t u, Step t u → μ u < μ t`. Then `WellFounded (StepRev)` where `StepRev a b := Step b a` follows from `InvImage.wf` of `<` on ordinals.

### 3.2 Rule‑By‑Rule Decrease Concepts
| Rule | Structural Effect | Decrease Mechanism Sketch |
|------|-------------------|---------------------------|
| Int‑Δ | Eliminates a full `delta` layer via `integrate` | `ω^4 * (...) + 1` vs `0` ⇒ trivial large drop |
| Merge‑Void (L/R) | Erases leading merge shell | Removes entire `ω^3/ω^2` frame |
| Merge‑Cancel | Collapses duplicate symmetric merge | Strictly fewer large blocks |
| Rec‑0 | Base case of recursion | Drops dynamic exponent tower to underlying base `b` |
| Rec‑S | Moves one delta inward, reorganizes as merge | Requires bounding merge payload under the *larger* dynamic tower of successor state |
| Eq‑Refl | Eliminates equality wrapper | Removes `ω^(...) + 1` tower |
| Eq‑Diff | Converts equality to integrate(merge …) | `ω^(exp+9)+1` outclasses integrate + merge composite |

### 3.3 Typical Lemma Pattern
1. **Local Growth Fact:** Show payload subcomponents `< ω^κ` individually.
2. **Principal Absorption:** Use additive principal property to fold finite or subordinate sums into `ω^κ`.
3. **Exponent Lift:** Convert product of towers via `opow_add` to unify exponent arithmetic.
4. **Strict Gap:** Use arithmetic offset (e.g., `+4`, `+6`, `+9`) to secure strict inequality on exponents.

---

## 4. Established Lemmas (Conceptual Summaries)

NOTE: Some referenced lemmas exist in `Termination_C.lean` or the legacy `Termination.lean`. Names may vary but conceptual content is stabilized.

| Lemma | Intent | Status |
|-------|--------|--------|
| `mu_void_lt_integrate_delta` | `μ void < μ (integrate (delta t))` | Proven |
| `mu_void_lt_eq_refl` | Reflexive equality adds large tower | Proven |
| `mu_lt_merge_void_left/right` | Merge with void dominates original | Proven |
| `mu_lt_merge_cancel` | Idempotent merge strictly larger | Proven |
| `mu_n_add_two_le_mu_delta` | Finite padding below δ tower | Needs refinement (orientation fixes) |
| `mu_lt_mu_delta` | Strict growth from `n` to `delta n` | In progress (orientation cleanup) |
| `mu_ns_lt_mu_delta_ns` | Exponent bump transport over tail | BLOCKED (ordinal right-add non‑strict) |
| `termA_le` | `ω^3*(x+1) ≤ ω^(x+4)` | Proven |
| `termB_le` | `ω^2*(x+1) ≤ ω^(x+3)` | Proven (legacy file) |
| `merge_inner_bound_simple` | Merge payload `< ω^(μ a + μ b + 5)` | Proven (earlier phase) |
| `mu_lt_eq_diff_both_void` | Corner reduction void/void | Proven |
| `omega_pow_fin_mul_cnf_lt` | Finite left factor absorption | Partially simplified |
| `rec_tail_block_lt` | Tail bounding for Rec‑S | Incomplete; depends on additive transport |
| `mu_lt_rec_succ_uncond` | Core Rec‑S decrease | Draft (relies on incomplete tail lemma) |

---

## 5. The Rec‑Successor Bottleneck

### 5.1 Desired Inequality
Need: `μ (merge s (recΔ b s n)) < μ (recΔ b s (delta n))`.

Expansions (RHS vs LHS major parts):

```
μ (recΔ b s (delta n)) = ω^( μ (delta n) + μ s + 6 ) + ω*(μ b + 1) + 1
μ (recΔ b s n)         = ω^( μ n + μ s + 6 ) + ω*(μ b + 1) + 1
μ (merge s (recΔ b s n))
	= ω^3*(μ s + 1) + ω^2*(μ (recΔ b s n) + 1) + 1
```

So it suffices to place both `ω^3*(μ s + 1)` and `ω^2*(μ (recΔ b s n) + 1)` *strictly below* the dominant tower `A := ω^( μ (delta n) + μ s + 6 )`, then show RHS adds a *new positive tail* after `A`, giving strict growth.

### 5.2 Obstruction
To prove `ω^2*(μ (recΔ b s n) + 1) < A`, we reduce to showing `μ (recΔ b s n) + 1 < A`. By additive principal normality of `ω^(...)`, we need the leading part `ω^( μ n + μ s + 6 )` strictly below `A`. That reduces to the exponent inequality:

```
μ n + μ s + 6 < μ (delta n) + μ s + 6  (⋆)
```

But `(⋆)` is *not derivable just from* `μ n < μ (delta n)` because ordinal right addition can erase strictness if the right summand eclipses the left difference. Without constraints on `μ s`, `(⋆)` may fail—hence attempts using `add_lt_add_right` or syntactic shift tactics are invalid.

### 5.3 Standard Workarounds Considered
1. **Lexicographic Pair `(kappa, μ)`:** Works (kappa counts `delta` height so `Rec‑S` strictly decreases first component) but sacrifices the elegance of pure ordinal synthesis.
2. **Strengthen μ’s δ Layer:** Modify δ exponent (e.g., escalate to an inaccessible offset) to dominate any `μ s`. Disruptive: forces sweeping revalidation of previously proved decreases.
3. **Structural Restriction:** Enforce semantic relation tying `s` to `n` (not allowed; kernel semantics treat them independent parameters).
4. **Tail‑Dominance Lemma (Option A Chosen):** Explicit side conditions capturing that the *specific* tail we add is finite / controlled relative to new leading tower. Requires a *provable* bound on `μ s` in terms of `μ n`—not available; thus we must encode a *conditional* lemma with a domination hypothesis.

### 5.4 Formal Shape for the Needed New Lemma
We propose introducing a *conditional* transport lemma:

```
lemma add_tail_strict
	{a b t : Ordinal}
	(h : a < b)
	(finite_tail : t < ω^(5) * (a + 1)) : a + t < b + t
```

Then instantiate with `a := μ n`, `b := μ (delta n)` and `t := μ s + 6` **if** we can ensure `μ s + 6 < ω^5*(μ n + 1)`. This is exactly the missing domination hypothesis.

### 5.5 Why Domination Hypothesis is Non‑Trivial
`μ s` can itself contain a `recΔ` term with exponent `ω^( μ n' + μ s' + 6 )`, potentially arbitrarily large; there is no a priori bound by a fixed finite tower over `μ n` unless we track `delta` depth separately.

Thus unconditional Option A fails unless we augment the measure or reintroduce an auxiliary component capturing a well‑founded *delta depth bound* to ensure finite transport safety.

---

## 6. Current Mathematical Blocker — Precise Statement

We cannot (presently) prove, *for arbitrary traces*, the strict inequality:

`μ n + μ s + 6 < μ (delta n) + μ s + 6`.

Reason: Need `μ s` constrained to avoid swallowing the δ‑bump. Ordinal arithmetic only guarantees left‑addition strictness (`add_lt_add_left`), not right‑addition strictness in general. Right summand may be a limit dominating the added difference.

---

## 7. Resolution Paths & Tradeoffs

| Path | Action | Pros | Cons |
|------|--------|------|------|
| P1 | Reinstate lexicographic measure `(κ, μ)` | Immediate SN | Additional complexity for later arithmetic simplifications |
| P2 | Redefine μ with higher δ tier (e.g., elevate base exponent tier separation) | Single measure vision preserved | Cascading re‑proof for all earlier lemmas |
| P3 | Add semantic restriction linking `s` and `n` | Light patch | Violates kernel abstraction / generality |
| P4 | Hybrid measure (μ plus bounded auxiliary ordinal counter) | Balanced compromise | New infrastructure & proofs |

Preferred pragmatic step: **P1 (lexicographic fallback)** to obtain a green SN theorem, then pursue P2 experimentally on a feature branch.

---

## 8. Tactics & Ordinal API Usage (Meta Layer)

| Category | Tool / Lemma | Role |
|----------|--------------|------|
| Positivity | `Ordinal.opow_pos` | Show tower > 0 for multiplicative monotonicity |
| Exponent Monotone | `Ordinal.opow_le_opow_right`, local `opow_lt_opow_right` | Lift (≤ / <) through ω‑powers |
| Additive Principal | `Ordinal.principal_add_omega0_opow` | Absorb subordinate finite / smaller tower sums |
| Finite Absorption | `omega_pow_fin_mul_cnf_lt` (project lemma) | Embed `ω^k * X` under higher tower |
| Structural Rewrites | `opow_add` | Collapse tower products |
| Successor Bridge | `Order.lt_add_one_iff`, `Order.add_one_le_of_lt` | Normalize +1 / succ manipulations |

Simp strategy: restrict to associativity/commutativity and the μ definition expansions; avoid aggressive normalization that could collapse intended ordinal stratification.

---

## 9. Roadmap to Green Build (If Choosing P1 Now)

1. Re‑introduce `(kappa : Trace → ℕ)` delta‑depth counter (already present, currently unused) as primary lex component.
2. Define `μκ t := (kappa t, μ t)` with lex order `Prod.Lex (<) (<)`.
3. Prove: Every rule either strictly decreases `kappa` or leaves `kappa` unchanged while strictly decreasing `μ`.
4. Rec‑Successor: strictly decreases `kappa` (depth of the argument `n` reduced by one delta); ignore μ complications.
5. Conclude WellFoundedness via lexicographic composition of `<` on `ℕ` and `<` on Ordinal.
6. Preserve existing pure‑μ lemmas for all other rules (reuse work).
7. Mark experimental pure‑μ rec successor strategy as future improvement with required domination lemma specification.

---

## 10. Future Pure‑μ Research Track (P2)

Objective: Refactor μ so that δ promotion produces a *guaranteed* exponent jump dominating any context `μ s` that could appear simultaneously in a `recΔ`. Candidate strategies:

1. **Introduce Tier Parameter:** Replace `ω^(5)` with `ω^(Ω · (μ t + 1) + c)` for some higher‑order ordinal `Ω = ω^(ω)` to isolate δ growth.
2. **Use Multiplicative Tower Elevation:** Encode constructor levels as iterated exponent layers (`ω^(ω^(level + payload))`) ensuring that δ always injects a higher tower tier than any merge/rec composition using previous payloads.
3. **Ordinal Collapsing Function:** Apply a collapsing function `ψ` to shape complexity; heavy machinery—may exceed project minimalism goals.

Risks: Each redesign demands re‑establishing all monotonicity and strictness lemmas with expanded algebraic overhead.

---

## 11. Confluence & Downstream Dependencies

Once SN is secured (via lex pair if necessary), confluence follows the normalize–join plan:
1. Define deterministic normalizer `normalize : Trace → Trace` folding by exhaustive Step reduction guided by the well‑founded measure.
2. Show every trace reduces to its normal form.
3. Show uniqueness of normal forms ⇒ Church–Rosser (confluent rewrite system).

Subsequent arithmetic & equality developments assume canonical evaluation, so expediting SN (even via lexicographic fallback) unlocks progress in those modules without waiting for a perfected one‑measure architecture.

---

## 12. Summary of Blocked vs Ready Components

| Component | Status | Action |
|-----------|--------|--------|
| Non‑rec rules μ decrease | READY | Minor polishing only |
| Rec‑Zero μ decrease | READY | — |
| Rec‑Succ pure μ | BLOCKED | Needs domination or alternative measure |
| Lexicographic SN | AVAILABLE | Re‑activate and finalize |
| Confluence pipeline | PENDING | Await finalized SN theorem |
| Pure μ research branch | FUTURE | Design alternate μ tiering |

---

## 13. Actionable Next Steps (Immediate Implementation Plan)

1. Restore and finalize lexicographic SN proof (fast path to green build).
2. Isolate current pure‑μ rec successor attempt in a separate section guarded by a feature flag comment.
3. Document precise formal statement needed for future elimination of `kappa`.
4. Add invariant tests / fuzz rewriting harness exercising random traces to empirically confirm decreasing `(kappa, μ)`.
5. After green SN: proceed to normalize–join confluence proofs.

---

## 14. Appendix: Notational & Lemma Glossary

| Symbol | Meaning |
|--------|---------|
| `μ t` | Ordinal measure of trace `t` |
| `κ t` (`kappa`) | Delta depth (number of nested `recΔ` argument deltas peeled) |
| `Step` | One-step rewrite relation |
| `StepStar` | Reflexive–transitive closure of `Step` |
| `A` | Shorthand `ω^( μ (delta n) + μ s + 6 )` in rec successor reasoning |
| `principal_add_omega0_opow` | Additive principal lemma for `ω^κ` |
| `opow_lt_opow_right` | Strict monotonicity of exponentiation in exponent |
| `termA_le`, `termB_le` | Bounding lemmas raising fixed tower tiers |

---

## 15. Precise Mathematical Blocker Statement (For Tracking)

> Open Problem (Pure μ SN Rec‑Succ): Prove for arbitrary traces `n s`:
> `μ n + μ s + 6 < μ (delta n) + μ s + 6`.
>
> This is equivalent to demonstrating that the ordinal difference `μ (delta n) − μ n` remains observable after right addition of `μ s + 6`. Ordinal arithmetic shows counterexamples unless a structural dominance on the added right summand is imposed.

Mitigation: Lexicographic fallback `(kappa, μ)` avoids needing this inequality.

---

## 16. Roadmap Milestones Table

| Milestone | Description | ETA (Relative) |
|-----------|-------------|----------------|
| M1 | Lexicographic SN proof re‑enabled & green | Short |
| M2 | Confluence proof (normalize–join) | After M1 |
| M3 | Arithmetic layer finalized using SN engine | After M2 |
| M4 | Equality canonicalization via normalization | Parallel M3 |
| M5 | Pure μ research branch created | Post M1 baseline |
| M6 | Domination lemma or μ redesign evaluated | Research |

---

## 17. Closing

This companion consolidates the theoretical blueprint, identifies the precise obstruction to a monolithic `μ` termination argument, and delineates pragmatic and research trajectories. The recommended immediate path to unblock downstream development is the lexicographic measure finalization, while preserving an annotated sandbox for the pure `μ` refinement.

End of Document.

