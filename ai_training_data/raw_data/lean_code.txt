=== LEAN SOURCE: lakefile.lean ===
import Lake
open Lake DSL

package OperatorKernelO6 where
  -- Focus on diagnostics options
  moreLeanArgs := #[
  "-Dpp.notation=true",
  -- "-Dtrace.Meta.Tactic.simp.rewrite=true",
  -- "-Dpp.proofs=true",
  -- "-Dpp.explicit=true",
  "-Dtrace.profiler.threshold=5"
  ]

@[default_target]
lean_lib OperatorKernelO6 where
  roots := #[`OperatorKernelO6]
  globs := #[.submodules `OperatorKernelO6]

require mathlib from git "https://github.com/leanprover-community/mathlib4.git"
require LeanSearchClient from git "https://github.com/leanprover-community/LeanSearchClient.git" @ "main"

lean_exe OperatorKernelO6Exe where
  root := `Main



=== LEAN SOURCE: Main.lean ===
import OperatorKernelO6.Kernel
import OperatorKernelO6.Meta.Meta
-- import OperatorKernelO6.Meta.Termination
import OperatorKernelO6.Meta.Termination_C
-- import LeanSearchClient  -- Enable search commands (temporarily disabled)
-- import OperatorKernelO6.Meta.Arithmetic
-- import OperatorKernelO6.Meta.Equality
-- import OperatorKernelO6.Meta.Godel
-- import OperatorKernelO6.Meta.Normalize
-- import OperatorKernelO6.Meta.FixedPoint
-- import OperatorKernelO6.Meta.Confluence
-- import OperatorKernelO6.Meta.ProofSystem

open OperatorKernelO6
open MetaSN

-- Example of search-first development workflow:
-- Before writing any theorem, search for existing definitions
-- #search "ordinal addition"  -- (disabled until LeanSearchClient is working)

/-- GREEN-CHANNEL: Demonstration of search-first workflow --/
example : ∀ n : ℕ, n + 0 = n := by
  intro n
  rfl  -- This should work since it's basic arithmetic

-- -- Add a deliberate error to test if settings work
-- theorem test_error : 2 + 2 = 5 := by
--   sorry -- This should cause the build to fail

def main (args : List String) : IO UInt32 := do
  IO.println "OperatorKernelO6 loaded successfully"
  IO.println "Search-first development workflow enabled"
  return 0



=== LEAN SOURCE: OperatorKernelO6.lean ===
-- Temporarily disabling imports while resolving Lake configuration issues
import OperatorKernelO6.Kernel
import OperatorKernelO6.Meta.Meta
-- import OperatorKernelO6.Meta.Termination
import OperatorKernelO6.Meta.Termination_C
-- import OperatorKernelO6.Meta.Arithmetic
-- import OperatorKernelO6.Meta.Equality
-- import OperatorKernelO6.Meta.Godel
-- import OperatorKernelO6.Meta.Normalize
-- import OperatorKernelO6.Meta.FixedPoint
-- import OperatorKernelO6.Meta.Confluence
-- import OperatorKernelO6.Meta.ProofSystem

open OperatorKernelO6
open MetaSN

-- SN-rewrite branch: Starting Strong Normalization proof development
-- This file will be the entry point for the new SN proof system

 -- #check Nat



=== LEAN SOURCE: Aesop.lean ===
import Aesop.Main
import Aesop.Frontend.Command
import Aesop.Frontend.Saturate
import Aesop.BuiltinRules



=== LEAN SOURCE: BaseM.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Stats.Basic
import Aesop.RulePattern.Cache

set_option linter.missingDocs true

open Lean

namespace Aesop

/-- State of the `BaseM` monad. -/
structure BaseM.State where
  /-- The rule pattern cache. -/
  rulePatternCache : RulePatternCache
  /-- The RPINF cache. -/
  rpinfCache : RPINFCache
  /-- Stats collected during an Aesop call. -/
  stats : Stats
  deriving Inhabited

instance : EmptyCollection BaseM.State :=
  ⟨by refine' { .. } <;> exact ∅⟩

/-- Aesop's base monad. Contains no interesting data, only various caches and
stats. -/
abbrev BaseM := StateRefT BaseM.State MetaM

namespace BaseM

/-- Run a `BaseM` action. -/
protected def run (x : BaseM α) (stats : Stats := ∅) : MetaM (α × Stats) := do
  let (a, s) ← StateRefT'.run x { stats, rulePatternCache := ∅, rpinfCache := ∅ }
  return (a, s.stats)

instance : MonadHashMapCacheAdapter Expr RulePatternCache.Entry BaseM where
  getCache := return (← get).rulePatternCache.map
  modifyCache f := modify λ s =>
    { s with rulePatternCache.map := f s.rulePatternCache.map }

instance : MonadHashMapCacheAdapter Expr RPINFRaw BaseM where
  getCache := return (← get).rpinfCache.map
  modifyCache f := modify λ s => { s with rpinfCache.map := f s.rpinfCache.map }

instance : MonadStats BaseM where
  modifyGetStats f := modifyGet λ s =>
    let (a, stats) := f s.stats
    (a, { s with stats })
  getStats := return (← get).stats
  modifyStats f := modify λ s => { s with stats := f s.stats }

instance : MonadBacktrack Meta.SavedState BaseM where
  saveState := Meta.saveState
  restoreState := (·.restore)

end Aesop.BaseM



=== LEAN SOURCE: Builder.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Builder.Apply
import Aesop.Builder.Basic
import Aesop.Builder.Cases
import Aesop.Builder.Constructors
import Aesop.Builder.Default
import Aesop.Builder.Forward
import Aesop.Builder.NormSimp
import Aesop.Builder.Tactic
import Aesop.Builder.Unfold



=== LEAN SOURCE: BuiltinRules.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

-- The Aesop.BuiltinRules.* imports are needed to ensure that the tactics from
-- these files are registered.
import Aesop.BuiltinRules.Assumption
import Aesop.BuiltinRules.ApplyHyps
import Aesop.BuiltinRules.DestructProducts
import Aesop.BuiltinRules.Ext
import Aesop.BuiltinRules.Intros
import Aesop.BuiltinRules.Rfl
import Aesop.BuiltinRules.Split
import Aesop.BuiltinRules.Subst
import Aesop.Frontend.Attribute

namespace Aesop.BuiltinRules

attribute [aesop (rule_sets := [builtin]) safe 0 apply] PUnit.unit

-- Hypotheses of product type are split by a separate builtin rule because the
-- `cases` builder currently cannot be used for norm rules.
attribute [aesop (rule_sets := [builtin]) safe 101 constructors]
  And Prod PProd MProd

attribute [aesop (rule_sets := [builtin]) unsafe 30% constructors]
  Exists Subtype Sigma PSigma

-- Sums are split and introduced lazily.
attribute [aesop (rule_sets := [builtin]) [safe 100 cases, 50% constructors]]
  Or Sum PSum

-- A goal ⊢ P ↔ Q is split into ⊢ P → Q and ⊢ Q → P. Hypotheses of type `P ↔ Q`
-- are treated as equations `P = Q` by the simplifier and by our builtin subst
-- rule.
attribute [aesop (rule_sets := [builtin]) safe 100 constructors] Iff

-- A negated goal Γ ⊢ ¬ P is transformed into Γ, P ⊢ ⊥. A goal with a
-- negated hypothesis Γ, h : ¬ P ⊢ Q is transformed into Γ[P := ⊥] ⊢ Q[P := ⊥]
-- by the simplifier. Quantified negated hypotheses h : ∀ x : T, ¬ P x are also
-- supported by the simplifier if the premises x can be discharged.
@[aesop (rule_sets := [builtin]) safe 0]
theorem not_intro (h : P → False) : ¬ P := h

@[aesop (rule_sets := [builtin]) norm destruct]
theorem empty_false (h : Empty) : False := nomatch h

@[aesop (rule_sets := [builtin]) norm destruct]
theorem pEmpty_false (h : PEmpty) : False := nomatch h

attribute [aesop (rule_sets := [builtin]) norm constructors] ULift

attribute [aesop (rule_sets := [builtin]) norm 0 destruct] ULift.down

@[aesop (rule_sets := [builtin]) norm simp]
theorem heq_iff_eq (x y : α) : x ≍ y ↔ x = y :=
  ⟨eq_of_heq, heq_of_eq⟩

end Aesop.BuiltinRules



=== LEAN SOURCE: Check.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Lean.Data.Options

open Lean

namespace Aesop

initialize Check.all : Lean.Option Bool ←
  Option.register `aesop.check.all
    { defValue := false
      descr := "(aesop) Enable all runtime checks. Individual checks can still be disabled."
      group := "tactic" }

structure Check where
  toOption : Lean.Option Bool

namespace Check

def get (opts : Options) (opt : Check) : Bool :=
  if let some val := opt.toOption.get? opts then
    val
  else
    Check.all.get opts

def isEnabled [Monad m] [MonadOptions m] (opt : Check) : m Bool :=
  return opt.get (← getOptions)

def name (opt : Check) : Name :=
  opt.toOption.name

end Check

-- Inspired by `Lean.Data.Options`.
local macro "register_aesop_check_option" optName:ident descr:str : command =>
  `(initialize option : Lean.Option Bool ←
      Lean.Option.register $(quote $ `aesop.check ++ optName.getId)
        { defValue := false, descr := $descr, group := "tactic" }

    def $(mkIdent $ `Check ++ optName.getId) : Aesop.Check := ⟨option⟩)

register_aesop_check_option proofReconstruction
    "(aesop) Typecheck partial proof terms during proof reconstruction."

register_aesop_check_option tree
    "(aesop) Check search tree invariants after every iteration of the search loop. Quite expensive."

register_aesop_check_option rules
    "(aesop) Check that information reported by rules is correct."

register_aesop_check_option script
    "(aesop) Check that the tactic script generated by Aesop proves the goal. When this check is active, Aesop generates a tactic script even if the user did not request one."

register_aesop_check_option script.steps
    "(aesop) Check each step of the tactic script generated by Aesop. When this check is active, Aesop generates a tactic script even if the user did not request one."

end Aesop



=== LEAN SOURCE: Constants.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Percent

namespace Aesop

def unificationGoalPenalty : Percent :=
  ⟨0.8⟩

def postponedSafeRuleSuccessProbability : Percent :=
  ⟨0.9⟩

end Aesop



=== LEAN SOURCE: ElabM.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Lean

open Lean Lean.Meta Lean.Elab

namespace Aesop.ElabM

structure Context where
  parsePriorities : Bool
  goal : MVarId

namespace Context

def forAdditionalRules (goal : MVarId) : Context where
  parsePriorities := true
  goal := goal

-- HACK: Some of the elaboration functions require that we pass in the current
-- goal. The goal is used exclusively to look up fvars in the lctx, so when
-- we operate outside a goal, we pass in a dummy mvar with empty lctx.
def forAdditionalGlobalRules : MetaM Context := do
  let mvarId := (← mkFreshExprMVarAt {} {} (.const ``True [])).mvarId!
  return .forAdditionalRules mvarId

def forErasing (goal : MVarId) : Context where
  parsePriorities := false
  goal := goal

-- HACK: See `forAdditionalGlobalRules`
def forGlobalErasing : MetaM Context := do
  let mvarId := (← mkFreshExprMVarAt {} {} (.const ``True [])).mvarId!
  return .forErasing mvarId

end ElabM.Context


abbrev ElabM := ReaderT ElabM.Context $ TermElabM

-- Generate specialized pure/bind implementations so we don't need to optimise
-- them on the fly at each use site.
instance : Monad ElabM :=
  { inferInstanceAs (Monad ElabM) with }

protected def ElabM.run (ctx : Context) (x : ElabM α) : TermElabM α := do
  ReaderT.run x ctx

def shouldParsePriorities : ElabM Bool :=
  return (← read).parsePriorities

def getGoal : ElabM MVarId :=
  return (← read).goal

end Aesop



=== LEAN SOURCE: Exception.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Lean

open Lean

namespace Aesop

scoped macro "declare_aesop_exception"
    excName:ident idName:ident testName:ident : command =>
  `(initialize $idName : InternalExceptionId ←
      Lean.registerInternalExceptionId $(quote $ `Aesop ++ excName.getId)

    def $excName : Exception :=
      .internal $idName

    def $testName : Exception → Bool
      | .internal id _ => id == $idName
      | _ => false)

end Aesop



=== LEAN SOURCE: Frontend.lean ===
import Aesop.Frontend.Attribute
import Aesop.Frontend.Command
import Aesop.Frontend.RuleExpr
import Aesop.Frontend.Tactic



=== LEAN SOURCE: Index.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Forward.Match
import Aesop.Index.Basic
import Aesop.Index.RulePattern
import Aesop.RulePattern
import Aesop.Rule.Basic
import Aesop.Tracing
import Batteries.Lean.Meta.InstantiateMVars
import Batteries.Lean.PersistentHashSet
import Batteries.Lean.Meta.DiscrTree

open Lean
open Lean.Meta

namespace Aesop

structure Index (α : Type) where
  byTarget : DiscrTree (Rule α)
  byHyp : DiscrTree (Rule α)
  unindexed : PHashSet (Rule α)
  deriving Inhabited

namespace Index

variable [BEq α] [Ord α] [Hashable α]

def trace [ToString (Rule α)] (ri : Index α) (traceOpt : TraceOption) :
    CoreM Unit := do
  if ! (← traceOpt.isEnabled) then
    return
  withConstAesopTraceNode traceOpt (return "Indexed by target") do
    traceArray ri.byTarget.values
  withConstAesopTraceNode traceOpt (return "Indexed by hypotheses") do
    traceArray ri.byHyp.values
  withConstAesopTraceNode traceOpt (return "Unindexed") do
    traceArray $ PersistentHashSet.toArray ri.unindexed
  where
    traceArray (as : Array (Rule α)) : CoreM Unit :=
      as.map toString |>.qsortOrd.forM λ r => do aesop_trace![traceOpt] r

instance : EmptyCollection (Index α) where
  emptyCollection := {
    byTarget := {}
    byHyp := {}
    unindexed := {}
  }

def merge (ri₁ ri₂ : Index α) : Index α where
  byTarget := ri₁.byTarget.mergePreservingDuplicates ri₂.byTarget
  byHyp := ri₁.byHyp.mergePreservingDuplicates ri₂.byHyp
  unindexed := ri₁.unindexed.merge ri₂.unindexed

@[specialize]
partial def add (r : Rule α) (imode : IndexingMode) (ri : Index α) :
    Index α :=
  match imode with
  | IndexingMode.unindexed =>
    { ri with unindexed := ri.unindexed.insert r }
  | IndexingMode.target keys =>
    { ri with byTarget := ri.byTarget.insertCore keys r }
  | IndexingMode.hyps keys =>
    { ri with byHyp := ri.byHyp.insertCore keys r }
  | IndexingMode.or imodes =>
    imodes.foldl (init := ri) λ ri imode =>
      ri.add r imode

def unindex (ri : Index α) (p : Rule α → Bool) : Index α :=
  let (byTarget, unindexed) := filterDiscrTree' ri.unindexed ri.byTarget
  let (byHyp,    unindexed) := filterDiscrTree' unindexed ri.byHyp
  { byTarget, byHyp, unindexed }
  where
    @[inline, always_inline]
    filterDiscrTree' (unindexed : PHashSet (Rule α)) (t : DiscrTree (Rule α)) :
        DiscrTree (Rule α) × PHashSet (Rule α) :=
      filterDiscrTree (not ∘ p) (λ unindexed v => unindexed.insert v) unindexed
        t

def foldM [Monad m] (ri : Index α) (f : σ → Rule α → m σ) (init : σ) : m σ :=
  match ri with
  | { byHyp, byTarget, unindexed} => do
    let mut s := init
    s ← byHyp.foldValuesM (init := s) f
    s ← byTarget.foldValuesM (init := s) f
    unindexed.foldM (init := s) f

@[inline]
def fold (ri : Index α) (f : σ → Rule α → σ) (init : σ) : σ :=
  Id.run $ ri.foldM (init := init) f

-- May return duplicate `IndexMatchLocation`s.
@[inline]
private def applicableByTargetRules (ri : Index α) (goal : MVarId)
    (include? : Rule α → Bool) :
    MetaM (Array (Rule α × Array IndexMatchLocation)) :=
  goal.withContext do
    let rules ← getUnify ri.byTarget (← goal.getType)
    let mut rs := Array.mkEmpty rules.size
      -- Assumption: include? is true for most rules.
    for r in rules do
      if include? r then
        rs := rs.push (r, #[.target])
    return rs

-- May return duplicate `IndexMatchLocation`s.
@[inline]
private def applicableByHypRules (ri : Index α) (goal : MVarId)
    (include? : Rule α → Bool) :
    MetaM (Array (Rule α × Array IndexMatchLocation)) :=
  goal.withContext do
    let mut rs := #[]
    for localDecl in ← getLCtx do
      if localDecl.isImplementationDetail then
        continue
      let rules ← getUnify ri.byHyp localDecl.type
      for r in rules do
        if include? r then
          rs := rs.push (r, #[.hyp localDecl])
    return rs

-- May return duplicate `IndexMatchLocation`s.
@[inline]
private def applicableUnindexedRules (ri : Index α) (include? : Rule α → Bool) :
    Array (Rule α × Array IndexMatchLocation) :=
  ri.unindexed.fold (init := #[]) λ acc r =>
    if include? r then
      acc.push (r, #[.none])
    else
      acc

-- Returns the rules in the order given by the `Ord α` instance.
@[specialize]
def applicableRules (ri : Index α) (goal : MVarId)
    (patSubstMap : RulePatternSubstMap)
    (additionalRules : Array (IndexMatchResult (Rule α)))
    (include? : Rule α → Bool) :
    MetaM (Array (IndexMatchResult (Rule α))) := do
  withConstAesopTraceNode .debug (return "rule selection") do
  goal.instantiateMVars
  let result := addRules additionalRules #[
    (← applicableByTargetRules ri goal include?),
    (← applicableByHypRules ri goal include?),
    (applicableUnindexedRules ri include?)
  ]
  let result := result.qsort λ x y => x.rule.compareByPriorityThenName y.rule |>.isLT
  aesop_trace[debug] "selected rules:{.joinSep (result.map (m!"{·.rule.name}") |>.toList) "\n"}"
  return result
where
  addRules (acc : Array (IndexMatchResult (Rule α)))
      (ruless : Array (Array (Rule α × Array IndexMatchLocation))) :
      Array (IndexMatchResult (Rule α)) := Id.run do
    let mut locMap : Std.HashMap (Rule α) (Std.HashSet IndexMatchLocation) := ∅
    for rules in ruless do
      for (rule, locs) in rules do
        if let some locs' := locMap[rule]? then
          locMap := locMap.insert rule (locs'.insertMany locs)
        else
          locMap := locMap.insert rule (.ofArray locs)
    let mut result := acc
    for (rule, locations) in locMap do
      if rule.pattern?.isSome then
        let patternSubsts? := patSubstMap[rule.name]?
        if patternSubsts?.isSome then
          result := result.push { rule, locations, patternSubsts? }
      else
        result := result.push { rule, locations, patternSubsts? := none }
    return result

end Aesop.Index



=== LEAN SOURCE: Main.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Search.Main
import Aesop.Frontend.Tactic
import Aesop.Stats.Extension

open Lean
open Lean.Elab.Tactic

namespace Aesop

@[tactic Frontend.Parser.aesopTactic, tactic Frontend.Parser.aesopTactic?]
def evalAesop : Tactic := λ stx => do
  profileitM Exception "aesop" (← getOptions) do
  let goal ← getMainGoal
  goal.withContext do
    let (_, stats) ← go stx goal |>.run ∅
    recordStatsForCurrentFileIfEnabled stx stats
    stats.trace .stats
where
  go (stx : Syntax) (goal : MVarId) : StateRefT Stats TacticM Unit :=
    profiling (λ s _ t => { s with total := t }) do
      let config ← profiling (λ s _ t => { s with configParsing := t }) do
        Frontend.TacticConfig.parse stx goal
      let ruleSet ←
        profiling (λ s _ t => { s with ruleSetConstruction := t }) do
          config.getRuleSet goal
      withConstAesopTraceNode .ruleSet (return "Rule set") do
        ruleSet.trace .ruleSet
      profiling (λ s _ t => { s with search := t }) do
        let (goals, stats) ←
          search goal ruleSet config.options config.simpConfig
            config.simpConfigSyntax? (← getStats)
        replaceMainGoal goals.toList
        modifyStats λ _ => stats

end Aesop



=== LEAN SOURCE: Nanos.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

namespace Aesop

structure Nanos where
  nanos : Nat
  deriving Inhabited, BEq, Ord

namespace Nanos

instance : OfNat Nanos n where
  ofNat := ⟨n⟩

instance : LT Nanos where
  lt | ⟨n₁⟩, ⟨n₂⟩ => n₁ < n₂

instance : DecidableRel (α := Nanos) (· < ·) :=
  λ ⟨n₁⟩ ⟨n₂⟩ => inferInstanceAs (Decidable (n₁ < n₂))

instance : LE Nanos where
  le | ⟨n₁⟩, ⟨n₂⟩ => n₁ ≤ n₂

instance : DecidableRel (α := Nanos) (· ≤ ·) :=
  λ ⟨n₁⟩ ⟨n₂⟩ => inferInstanceAs (Decidable (n₁ ≤ n₂))

instance : Add Nanos where
  add n m := ⟨n.nanos + m.nanos⟩

instance : HDiv Nanos Nat Nanos where
  hDiv n m := ⟨n.nanos / m⟩

def printAsMillis (n : Nanos) : String :=
  let str := toString (n.nanos.toFloat / 1000000)
  match str.split λ c => c == '.' with
  | [beforePoint] => beforePoint ++ "ms"
  | [beforePoint, afterPoint] => beforePoint ++ "." ++ afterPoint.take 1 ++ "ms"
  | _ => unreachable!

end Aesop.Nanos



=== LEAN SOURCE: Options.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Options.Internal
import Aesop.Options.Public



=== LEAN SOURCE: Percent.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg, Asta Halkjær From
-/

namespace Aesop

open Lean
open Std

/-
Invariant: between 0 and 1.0
-/
structure Percent where
  toFloat : Float
  deriving Inhabited

namespace Percent

protected def ofFloat (f : Float) : Option Percent :=
  if 0 <= f && f <= 1.0 then some ⟨f⟩ else none

instance : Mul Percent where
  mul p q := ⟨p.toFloat * q.toFloat⟩

@[inline]
def δ : Percent :=
  ⟨0.00001⟩

instance : BEq Percent where
  beq | ⟨p⟩, ⟨q⟩ => if p > q then p - q < δ.toFloat else q - p < δ.toFloat

instance : Ord Percent where
  compare p q :=
    if p == q then Ordering.eq
    else if p.toFloat < q.toFloat then Ordering.lt
    else Ordering.gt

-- NOTE: This is not the same as
--
--     p < q := p.toFloat < q.toFloat
--
-- That definition would not agree with the Ord instance.
instance : LT Percent :=
  ltOfOrd

instance : LE Percent :=
  leOfOrd

instance : ToString Percent where
  toString p := toString p.toFloat

instance : HPow Percent Nat Percent where
  hPow | ⟨p⟩, n => ⟨p ^ n.toFloat⟩

def hundred : Percent :=
  ⟨1⟩

def fifty : Percent :=
  ⟨0.5⟩

def toHumanString (p : Percent) : String :=
  let str := toString (p.toFloat * 100)
  match str.split λ c => c == '.' with
  | [beforePoint] => beforePoint ++ "%"
  | [beforePoint, afterPoint] =>
    beforePoint ++ "." ++ afterPoint.take 4 ++ "%"
  | _ => unreachable!

protected def ofNat (n : Nat) : Option Percent :=
  Percent.ofFloat $ n.toFloat / 100

end Aesop.Percent



=== LEAN SOURCE: RPINF.lean ===
import Aesop.Util.Basic
import Aesop.BaseM

open Lean Lean.Meta

namespace Aesop

local instance : MonadCache Expr Expr BaseM where
  findCached? e :=
    return (← MonadCache.findCached? e : Option RPINFRaw).map (·.toExpr)
  cache k v := MonadCache.cache k (⟨v⟩ : RPINFRaw)

@[specialize]
partial def rpinfRaw (e : Expr) : BaseM RPINFRaw :=
  withReducible do return ⟨← go e⟩
where
  go (e : Expr) : BaseM Expr :=
    withIncRecDepth do
    checkCache e λ _ => do
      if ← isProof e then
        return .mdata (mdataSetIsProof {}) e
      let e ← whnf e
      match e with
      | .app .. =>
          let f ← go e.getAppFn'
          let mut args := e.getAppArgs'
          for i in [:args.size] do
            let arg := args[i]!
            args := args.set! i default -- prevent nonlinear access to args[i]
            let arg ← go arg
            args := args.set! i arg
          if f.isConstOf ``Nat.succ && args.size == 1 && args[0]!.isRawNatLit then
            return mkRawNatLit (args[0]!.rawNatLit?.get! + 1)
          else
            return mkAppN f args
      | .lam .. =>
        -- TODO disable cache?
        lambdaTelescope e λ xs e => withNewFVars xs do
          mkLambdaFVars xs (← go e)
      | .forallE .. =>
        -- TODO disable cache?
        forallTelescope e λ xs e => withNewFVars xs do
          mkForallFVars xs (← go e)
      | .proj t i e =>
        return .proj t i (← go e)
      | .sort .. | .mvar .. | .lit .. | .const .. | .fvar .. =>
        return e
      | .letE .. | .mdata .. | .bvar .. => unreachable!

  withNewFVars {α} (fvars : Array Expr) (k : BaseM α) : BaseM α := do
    let mut lctx ← (getLCtx : MetaM _)
    for fvar in fvars do
      let fvarId := fvar.fvarId!
      let ldecl ← fvarId.getDecl
      let ldecl := ldecl.setType $ ← go ldecl.type
      lctx := lctx.modifyLocalDecl fvarId λ _ => ldecl
    withLCtx lctx (← getLocalInstances) k

def rpinf (e : Expr) : BaseM RPINF :=
  withConstAesopTraceNode .rpinf (return m!"rpinf") do
    aesop_trace[rpinf] "input:{indentExpr e}"
    let e ← rpinfRaw e
    let hash := pinfHash e.toExpr
    aesop_trace[rpinf] "result hash: {hash}"
    aesop_trace[rpinf] "resut:{indentExpr e.toExpr}"
    return { e with hash }

end Aesop



=== LEAN SOURCE: Rule.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg, Asta Halkjær From
-/

import Aesop.Rule.Basic
import Aesop.Percent

namespace Aesop

open Lean
open Lean.Meta

/-! ### Normalisation Rules -/

structure NormRuleInfo where
  penalty : Int
  deriving Inhabited

instance : Ord NormRuleInfo where
  compare i j := compare i.penalty j.penalty

instance : LT NormRuleInfo :=
  ltOfOrd

instance : LE NormRuleInfo :=
  leOfOrd

abbrev NormRule := Rule NormRuleInfo

instance : ToString NormRule where
  toString r := s!"[{r.extra.penalty}] {r.name}"

def defaultNormPenalty : Int := 1

def defaultSimpRulePriority : Int := eval_prio default


/-! ### Safe and Almost Safe Rules -/

inductive Safety
  | safe
  | almostSafe
  deriving Inhabited

namespace Safety

instance : ToString Safety where
  toString
    | safe => "safe"
    | almostSafe => "almostSafe"

end Safety

structure SafeRuleInfo where
  penalty : Int
  safety : Safety
  deriving Inhabited

instance : Ord SafeRuleInfo where
  compare i j := compare i.penalty j.penalty

instance : LT SafeRuleInfo :=
  ltOfOrd

instance : LE SafeRuleInfo :=
  leOfOrd

abbrev SafeRule := Rule SafeRuleInfo

instance : ToString SafeRule where
  toString r := s!"[{r.extra.penalty}/{r.extra.safety}] {r.name}"

def defaultSafePenalty : Int := 1


/-! ### Unsafe Rules -/

structure UnsafeRuleInfo where
  successProbability : Percent
  deriving Inhabited

instance : Ord UnsafeRuleInfo where
  compare i j := compare j.successProbability i.successProbability
  -- NOTE: Rule with greater success probabilities are considered smaller.
  -- This is because we take 'small' to mean 'high priority'.

instance : LT UnsafeRuleInfo :=
  ltOfOrd

instance : LE UnsafeRuleInfo :=
  leOfOrd

abbrev UnsafeRule := Rule UnsafeRuleInfo

instance : ToString UnsafeRule where
  toString r := s!"[{r.extra.successProbability.toHumanString}] {r.name}"

def defaultSuccessProbability : Percent := .fifty


/-! ### Regular Rules -/

inductive RegularRule
  | safe (r : SafeRule)
  | «unsafe» (r : UnsafeRule)
  deriving Inhabited, BEq

namespace RegularRule

instance : ToFormat RegularRule where
  format
    | safe r => format r
    | «unsafe» r => format r

def successProbability : RegularRule → Percent
  | safe _ => Percent.hundred
  | «unsafe» r => r.extra.successProbability

def isSafe : RegularRule → Bool
  | safe _ => true
  | «unsafe» _ => false

def isUnsafe : RegularRule → Bool
  | safe _ => false
  | «unsafe» _ => true

@[inline]
def withRule (f : ∀ {α}, Rule α → β) : RegularRule → β
  | safe r => f r
  | «unsafe» r => f r

def name (r : RegularRule) : RuleName :=
  r.withRule (·.name)

def indexingMode (r : RegularRule) : IndexingMode :=
  r.withRule (·.indexingMode)

def tac (r : RegularRule) : RuleTacDescr :=
  r.withRule (·.tac)

end RegularRule


/-! ### Normalisation Simp Rules -/

/--
A global rule for the norm simplifier. Each `SimpEntry` represents a member
of the simp set, e.g. a declaration whose type is an equality or a smart
unfolding theorem for a declaration.
-/
structure NormSimpRule where
  name : RuleName
  entries : Array SimpEntry
  deriving Inhabited

namespace NormSimpRule

instance : BEq NormSimpRule where
  beq r s := r.name == s.name

instance : Hashable NormSimpRule where
  hash r := hash r.name

end NormSimpRule


/--
A local rule for the norm simplifier.
-/
structure LocalNormSimpRule where
  id : Name
  simpTheorem : Term
  deriving Inhabited

namespace LocalNormSimpRule

instance : BEq LocalNormSimpRule where
  beq r₁ r₂ := r₁.id == r₂.id

instance : Hashable LocalNormSimpRule where
  hash r := hash r.id

def name (r : LocalNormSimpRule) : RuleName :=
  { name := r.id, scope := .local, builder := .simp, phase := .norm }

end LocalNormSimpRule


structure UnfoldRule where
  decl : Name
  unfoldThm? : Option Name
  deriving Inhabited

namespace UnfoldRule

instance : BEq UnfoldRule where
  beq r s := r.decl == s.decl

instance : Hashable UnfoldRule where
  hash r := hash r.decl

def name (r : UnfoldRule) : RuleName :=
  { name := r.decl, builder := .unfold, phase := .norm, scope := .global }

end Aesop.UnfoldRule



=== LEAN SOURCE: RulePattern.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Forward.Substitution
import Aesop.RPINF
import Aesop.Rule.Name
import Aesop.Tracing
import Aesop.Index.DiscrTreeConfig

open Lean Lean.Meta

namespace Aesop

/--
A rule pattern. For a rule of type `∀ (x₀ : T₀) ... (xₙ : Tₙ), U`, a valid rule
pattern is an expression `p` such that `x₀ : T₁, ..., xₙ : Tₙ ⊢ p : P`. Let
`y₀, ..., yₖ` be those variables `xᵢ` on which `p` depends. When `p` matches an
expression `e`, this means that `e` is defeq to `p` (where each `yᵢ` is replaced
with a metavariable) and we obtain a substitution

    {y₀ ↦ t₀ : T₀, y₁ ↦ t₁ : T₁[x₀ := t₀], ...}

Now suppose we want to match the above rule type against a type `V` (where `V`
is the target for an `apply`-like rule and a hypothesis type for a
`forward`-like rule). To that end, we take `U` and replace each `xᵢ` where
`xᵢ = yⱼ` with `tⱼ` and each `xᵢ` with `xᵢ ≠ yⱼ ∀ j` with a metavariable. The
resulting expression `U'` is then matched against `V`.
-/
structure RulePattern where
  /--
  An expression of the form `λ y₀ ... yₖ, p` representing the
  pattern.
  -/
  pattern : AbstractMVarsResult
  /--
  A partial map from the index set `{0, ..., n-1}` into `{0, ..., k-1}`. If
  `argMap[i] = j`, this indicates that when matching against the rule type, the
  instantiation `tⱼ` of `yⱼ` should be substituted for `xᵢ`.
  -/
  argMap : Array (Option Nat)
  /--
  A partial map from the level metavariables occurring in the rule to the
  pattern's level params.
  -/
  levelArgMap : Array (Option Nat)
  /--
  Discrimination tree keys for `p`.
  -/
  discrTreeKeys : Array DiscrTree.Key
  deriving Inhabited

namespace RulePattern

def boundPremises (pat : RulePattern) : Array Nat := Id.run do
  let mut result := Array.mkEmpty pat.argMap.size
  for h : i in [:pat.argMap.size] do
    if pat.argMap[i].isSome then
      result := result.push i
  return result

-- Largely copy-paste from openAbstractMVarsResult
def «open» (pat : RulePattern) :
    MetaM (Array MVarId × Array LMVarId × Expr) := do
  let a := pat.pattern
  let us ← a.paramNames.mapM fun _ => mkFreshLevelMVar
  let e := a.expr.instantiateLevelParamsArray a.paramNames us
  let (mvars, _, e) ← lambdaMetaTelescope e (some a.numMVars)
  return (mvars.map (·.mvarId!), us.map (·.mvarId!) , e)

def «match» (e : Expr) (pat : RulePattern) : BaseM (Option Substitution) :=
  withNewMCtxDepth do
    let (mvarIds, lmvarIds, p) ← pat.open
    if ! (← isDefEq e p) then
      return none
    let mut subst := .empty pat.argMap.size pat.levelArgMap.size
    for h : i in [:pat.argMap.size] do
      if let some j := pat.argMap[i] then
        let mvarId := mvarIds[j]!
        let mvar := .mvar mvarId
        let inst ← instantiateMVars mvar
        if inst == mvar then
          throwError "RulePattern.match: while matching pattern '{p}' against expression '{e}': expected metavariable ?{(← mvarId.getDecl).userName} ({mvarId.name}) to be assigned"
        subst := subst.insert ⟨i⟩ (← rpinf inst)
    for h : i in [:pat.levelArgMap.size] do
      if let some j := pat.levelArgMap[i] then
        let mvar := .mvar lmvarIds[j]!
        let inst ← instantiateLevelMVars mvar
        if inst != mvar then
          subst := subst.insertLevel ⟨i⟩ inst
    return some subst

open Lean.Elab Lean.Elab.Term in
def «elab» (stx : Term) (rule : Expr) : TermElabM RulePattern :=
  withConstAesopTraceNode .debug (return m!"elaborating rule pattern") do
   -- TODO withNewMCtxDepth produces an error, but I don't understand why
  withLCtx {} {} $ withoutModifyingState do
    aesop_trace[debug] "rule: {rule}"
    aesop_trace[debug] "pattern: {stx}"
    let lmvarIds := collectLevelMVars {} (← instantiateMVars rule) |>.result
    aesop_trace[debug] "level metavariables in rule: {lmvarIds.map Level.mvar}"
    forallTelescope (← inferType rule) λ fvars _ => do
      let pat := (← elabPattern stx).consumeMData
      let (pat, mvarIds) ← fvarsToMVars fvars pat
      let discrTreeKeys ← mkDiscrTreePath pat
      let (pat, mvarIdToPatternPos, lmvarIdToPatternPos) ← abstractMVars' pat
      let argMap := mvarIds.map (mvarIdToPatternPos[·]?)
      let levelArgMap := lmvarIds.map (lmvarIdToPatternPos[·]?)
      aesop_trace[debug] "result: '{pat.expr}' with arg map{indentD $ toMessageData argMap}\nand level arg map{indentD $ toMessageData levelArgMap}"
      return { pattern := pat, argMap, levelArgMap, discrTreeKeys }
where
  fvarsToMVars (fvars : Array Expr) (e : Expr) :
      MetaM (Expr × Array MVarId) := do
    let e ← mkLambdaFVars fvars (← instantiateMVars e)
    let (mvars, _, e) ← lambdaMetaTelescope e (maxMVars? := some fvars.size)
    return (e, mvars.map (·.mvarId!))

  -- Largely copy-pasta of `abstractMVars`.
  abstractMVars' (e : Expr) :
      MetaM (AbstractMVarsResult × Std.HashMap MVarId Nat × Std.HashMap LMVarId Nat) := do
    let e ← instantiateMVars e
    let (e, s) := AbstractMVars.abstractExprMVars e
      { mctx := (← getMCtx)
        lctx := (← getLCtx)
        ngen := (← getNGen)
        abstractLevels := true }
    setNGen s.ngen
    setMCtx s.mctx
    let e := s.lctx.mkLambda s.fvars e
    let mut fvarIdToMVarId : Std.HashMap FVarId MVarId := ∅
    for (mvarId, e) in s.emap do
      if let .fvar fvarId := e then
        fvarIdToMVarId := fvarIdToMVarId.insert fvarId mvarId
    let mut mvarIdToPos := ∅
    for h : i in [:s.fvars.size] do
      mvarIdToPos := mvarIdToPos.insert fvarIdToMVarId[s.fvars[i].fvarId!]! i
    let mut paramToLMVarId : Std.HashMap Name LMVarId := ∅
    for (lmvarId, l) in s.lmap do
      if let .param n := l then
        paramToLMVarId := paramToLMVarId.insert n lmvarId
    let mut lmvarIdToPos := ∅
    for h : i in [:s.paramNames.size] do
      lmvarIdToPos := lmvarIdToPos.insert paramToLMVarId[s.paramNames[i]]! i
    let result :=
      { paramNames := s.paramNames, mvars := s.mvars, expr := e }
    return (result, mvarIdToPos, lmvarIdToPos)

end Aesop.RulePattern



=== LEAN SOURCE: RuleSet.lean ===
/-
Copyright (c) 2021-2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/
import Aesop.Index
import Aesop.Index.Forward
import Aesop.RuleSet.Filter
import Aesop.RuleSet.Member
import Aesop.Tree.Data.ForwardRuleMatches

open Lean Lean.Meta

namespace Aesop

section Types

set_option linter.missingDocs true

/--
The Aesop-specific parts of an Aesop rule set. A `BaseRuleSet` stores global
Aesop rules, e.g. safe and unsafe rules. It does not store simp theorems for
the builtin norm simp rule; these are instead stored in a simp extension.
-/
structure BaseRuleSet where
  /--
  Normalisation rules registered in this rule set.
  -/
  normRules : Index NormRuleInfo
  /--
  Unsafe rules registered in this rule set.
  -/
  unsafeRules : Index UnsafeRuleInfo
  /--
  Safe rules registered in this rule set.
  -/
  safeRules : Index SafeRuleInfo
  /--
  Rules for the builtin unfold rule. A pair `(decl, unfoldThm?)` in this map
  represents a declaration `decl` which should be unfolded. `unfoldThm?` should
  be the output of `getUnfoldEqnFor? decl` and is cached here for efficiency.
  -/
  -- TODO Don't cache equation name; this may lead to bugs and the performance
  -- cost is negligible.
  unfoldRules : PHashMap Name (Option Name)
  /--
  Forward rules. There's a special procedure for applying forward rules, so we
  don't store them in the regular indices.
  -/
  forwardRules : ForwardIndex
  /-- The names of all rules in `forwardRules`. -/
  -- HACK to be removed once we switch fully to stateful forward reasoning.
  forwardRuleNames : PHashSet RuleName
  /--
  An index for the rule patterns associated with rules contained in this rule
  set. When rules are removed from the rule set, their patterns are not removed
  from this index.
  -/
  rulePatterns : RulePatternIndex
  /--
  The set of rules that were erased from `normRules`, `unsafeRules`, `safeRules`
  and `forwardRules`. When we erase a rule which is present in any of these four
  indices, the rule is not removed from the indices but just added to this set.
  By contrast, when we erase a rule from `unfoldRules`, we actually delete it.
  -/
  erased : PHashSet RuleName
  /--
  A cache of the names of all rules registered in this rule set. Invariant:
  `ruleNames` contains exactly the names of the rules present in `normRules`,
  `unsafeRules`, `safeRules`, `forwardRules` and `unfoldRules` and not present
  in `erased`. We use this cache (a) to quickly determine whether a rule is
  present in the rule set and (b) to find the full rule names associated with
  the fvar or const identified by a name.
  -/
  ruleNames : PHashMap Name (UnorderedArraySet RuleName)
  deriving Inhabited

/--
A global Aesop rule set. When we tag a declaration with `@[aesop]`, it is stored
in one or more of these rule sets. Internally, a `GlobalRuleSet` is composed of
a `BaseRuleSet` (stored in an Aesop rule set extension) plus a set of simp
theorems (stored in a `SimpExtension`).
-/
structure GlobalRuleSet extends BaseRuleSet where
  /--
  The simp theorems stored in this rule set.
  -/
  simpTheorems : SimpTheorems
  /--
  The simprocs stored in this rule set.
  -/
  simprocs : Simprocs
  deriving Inhabited

/--
The rule set used by an Aesop tactic call. A local rule set is produced by
combining several global rule sets and possibly adding or erasing some
individual rules.
-/
structure LocalRuleSet extends BaseRuleSet where
  /--
  The simp theorems used by the builtin norm simp rule.
  -/
  simpTheoremsArray : Array (Name × SimpTheorems)
  /--
  The simp theorems array must contain at least one `SimpTheorems` structure.
  When a simp theorem is added to a `LocalRuleSet`, it is stored in this first
  `SimpTheorems` structure.
  -/
  simpTheoremsArrayNonempty : 0 < simpTheoremsArray.size
  /--
  The simprocs used by the builtin norm simp rule.
  -/
  simprocsArray : Array (Name × Simprocs)
  /--
  The simprocs array must contain at least one `Simprocs` structure, for the
  same reason as above.
  -/
  simprocsArrayNonempty : 0 < simprocsArray.size
  /--
  FVars that were explicitly added as simp rules.
  -/
  localNormSimpRules : Array LocalNormSimpRule

end Types


namespace GlobalRuleSet

@[inline, always_inline]
def onBaseM [Monad m] (f : BaseRuleSet → m (BaseRuleSet × α))
    (rs : GlobalRuleSet) : m (GlobalRuleSet × α) := do
  let (toBaseRuleSet, a) ← f rs.toBaseRuleSet
  let rs := { rs with toBaseRuleSet }
  return (rs, a)

@[inline, always_inline]
def onBase (f : BaseRuleSet → BaseRuleSet × α) (rs : GlobalRuleSet) :
    GlobalRuleSet × α :=
  rs.onBaseM (m := Id) f

@[inline, always_inline]
def modifyBaseM [Monad m] (f : BaseRuleSet → m BaseRuleSet)
    (rs : GlobalRuleSet) : m GlobalRuleSet :=
  (·.fst) <$> rs.onBaseM (λ rs => return (← f rs, ()))

@[inline, always_inline]
def modifyBase (f : BaseRuleSet → BaseRuleSet) (rs : GlobalRuleSet) :
    GlobalRuleSet :=
  rs.modifyBaseM (m := Id) f

end GlobalRuleSet


namespace LocalRuleSet

@[inline, always_inline]
def onBaseM [Monad m] (f : BaseRuleSet → m (BaseRuleSet × α))
    (rs : LocalRuleSet) : m (LocalRuleSet × α) := do
  let (toBaseRuleSet, a) ← f rs.toBaseRuleSet
  return ({ rs with toBaseRuleSet }, a)

@[inline, always_inline]
def onBase (f : BaseRuleSet → (BaseRuleSet × α)) (rs : LocalRuleSet) :
    LocalRuleSet × α :=
  rs.onBaseM (m := Id) f

def modifyBaseM [Monad m] (f : BaseRuleSet → m BaseRuleSet) (rs : LocalRuleSet) :
    m LocalRuleSet :=
  (·.fst) <$> rs.onBaseM (λ rs => return (← f rs, ()))

def modifyBase (f : BaseRuleSet → BaseRuleSet) (rs : LocalRuleSet) :
    LocalRuleSet :=
  rs.modifyBaseM (m := Id) f

end LocalRuleSet


def BaseRuleSet.trace (rs : BaseRuleSet) (traceOpt : TraceOption) :
    CoreM Unit := do
  if ! (← traceOpt.isEnabled) then
    return
  withConstAesopTraceNode traceOpt (return "Erased rules") do
    aesop_trace![traceOpt] "(Note: even if these rules appear in the sections below, they will not be applied by Aesop.)"
    let erased := rs.erased.fold (init := #[])
      λ ary r => ary.push r
    for r in erased.qsortOrd do
      aesop_trace![traceOpt] r
  withConstAesopTraceNode traceOpt (return "Unsafe rules") do
    rs.unsafeRules.trace traceOpt
  withConstAesopTraceNode traceOpt (return "Safe rules") do
    rs.safeRules.trace traceOpt
  withConstAesopTraceNode traceOpt (return "Forward rules") do
    rs.forwardRules.trace traceOpt
  withConstAesopTraceNode traceOpt (return "Normalisation rules") do
    rs.normRules.trace traceOpt
  withConstAesopTraceNode traceOpt (return "Constants to unfold") do
    for r in rs.unfoldRules.toArray.map (·.fst.toString) |>.qsortOrd do
      aesop_trace![traceOpt] r

def GlobalRuleSet.trace (rs : GlobalRuleSet) (traceOpt : TraceOption) :
    CoreM Unit := do
  if ! (← traceOpt.isEnabled) then
    return
  rs.toBaseRuleSet.trace traceOpt
  withConstAesopTraceNode traceOpt (return "Normalisation simp theorems:") do
    traceSimpTheorems rs.simpTheorems traceOpt
  -- TODO trace simprocs

def LocalRuleSet.trace (rs : LocalRuleSet) (traceOpt : TraceOption) :
    CoreM Unit := do
  if ! (← traceOpt.isEnabled) then
    return
  rs.toBaseRuleSet.trace traceOpt
  withConstAesopTraceNode traceOpt (return "Simp sets used by normalisation simp:") do
    rs.simpTheoremsArray.map (printSimpSetName ·.fst) |>.qsortOrd.forM λ s => do
      aesop_trace![traceOpt] s
  withConstAesopTraceNode traceOpt (return "Local normalisation simp theorems") do
    for r in rs.localNormSimpRules.map (·.simpTheorem) do
      aesop_trace![traceOpt] r
where
  printSimpSetName : Name → String
    | `_ => "<default>"
    | n => toString n


def BaseRuleSet.empty : BaseRuleSet := by
  refine' {..} <;> exact {}

instance : EmptyCollection BaseRuleSet :=
  ⟨.empty⟩

def GlobalRuleSet.empty : GlobalRuleSet := by
  refine' {..} <;> exact {}

instance : EmptyCollection GlobalRuleSet :=
  ⟨.empty⟩

def LocalRuleSet.empty : LocalRuleSet where
  toBaseRuleSet := .empty
  simpTheoremsArray := #[(`_, {})]
  simpTheoremsArrayNonempty := by decide
  simprocsArray := #[(`_, {})]
  simprocsArrayNonempty := by decide
  localNormSimpRules := ∅

instance : EmptyCollection LocalRuleSet :=
  ⟨.empty⟩

instance : Inhabited LocalRuleSet :=
  ⟨∅⟩


private def BaseRuleSet.isErased (rs : BaseRuleSet) (n : RuleName) : Bool :=
  rs.erased.contains n

def BaseRuleSet.contains (rs : BaseRuleSet) (n : RuleName) : Bool :=
  ! rs.isErased n &&
  if let some ns := rs.ruleNames.find? n.name then
    ns.contains n
  else
    false

def GlobalRuleSet.contains (rs : GlobalRuleSet) (n : RuleName) : Bool :=
  rs.toBaseRuleSet.contains n ||
  (n.builder == .simp && n.scope == .global &&
    SimpTheorems.containsDecl rs.simpTheorems n.name)

def LocalRuleSet.containsGlobalSimpTheorem (rs : LocalRuleSet) (decl : Name) :
    Bool :=
  rs.simpTheoremsArray.any λ (_, simpTheorems) =>
    SimpTheorems.containsDecl simpTheorems decl

def LocalRuleSet.contains (rs : LocalRuleSet) (n : RuleName) : Bool :=
  rs.toBaseRuleSet.contains n ||
  (n.builder == .simp &&
    match n.scope with
    | .global => rs.containsGlobalSimpTheorem n.name
    | .local  => rs.localNormSimpRules.any (·.id == n.name))


def BaseRuleSet.merge (rs₁ rs₂ : BaseRuleSet) : BaseRuleSet where
  normRules := rs₁.normRules.merge rs₂.normRules
  unsafeRules := rs₁.unsafeRules.merge rs₂.unsafeRules
  safeRules := rs₁.safeRules.merge rs₂.safeRules
  forwardRules := rs₁.forwardRules.merge rs₂.forwardRules
  forwardRuleNames := rs₁.forwardRuleNames.merge rs₂.forwardRuleNames
  rulePatterns := rs₁.rulePatterns.merge rs₂.rulePatterns
  unfoldRules := rs₁.unfoldRules.mergeWith rs₂.unfoldRules
    λ _ unfoldThm?₁ _ => unfoldThm?₁
  ruleNames :=
    rs₁.ruleNames.mergeWith rs₂.ruleNames λ _ ns₁ ns₂ =>
      ns₁ ++ ns₂
  erased :=
    -- Add the erased rules from `rs₁` to `init`, except those rules which are
    -- present (and not erased) in `rs₂`.
    let go (rs₁ rs₂ : BaseRuleSet) (init : PHashSet RuleName) :
        PHashSet RuleName :=
      rs₁.erased.fold (init := init) λ x n =>
        match rs₂.ruleNames.find? n.name with
        | none => x.insert n
        | some ns =>
          if ns.contains n then x else x.insert n
    go rs₂ rs₁ $ go rs₁ rs₂ {}

def BaseRuleSet.add (rs : BaseRuleSet) (r : BaseRuleSetMember) :
    BaseRuleSet :=
  let erased := rs.erased.erase r.name
  let name := r.name.name
  let ruleNames :=
    match rs.ruleNames.find? name with
    | none => rs.ruleNames.insert name $ .singleton r.name
    | some ns => rs.ruleNames.insert name $ ns.insert r.name
  let rs := { rs with erased, ruleNames }
  match r with
  | .normRule r =>
    let rs := { rs with normRules := rs.normRules.add r r.indexingMode }
    addRulePattern r.name r.pattern? rs
  | .unsafeRule r =>
    let rs := { rs with unsafeRules := rs.unsafeRules.add r r.indexingMode }
    addRulePattern r.name r.pattern? rs
  | .safeRule r =>
    let rs := { rs with safeRules := rs.safeRules.add r r.indexingMode }
    addRulePattern r.name r.pattern? rs
  | .unfoldRule r =>
    { rs with unfoldRules := rs.unfoldRules.insert r.decl r.unfoldThm? }
  | .normForwardRule r₁ r₂ =>
    let rs := {
      rs with
      forwardRules := rs.forwardRules.insert r₁
      forwardRuleNames := rs.forwardRuleNames.insert r₁.name
      normRules := rs.normRules.add r₂ r₂.indexingMode
    }
    addRulePattern r₂.name r₂.pattern? rs
  | .unsafeForwardRule r₁ r₂ =>
    let rs := {
      rs with
      forwardRules := rs.forwardRules.insert r₁
      forwardRuleNames := rs.forwardRuleNames.insert r₁.name
      unsafeRules := rs.unsafeRules.add r₂ r₂.indexingMode
    }
    addRulePattern r₂.name r₂.pattern? rs
  | .safeForwardRule r₁ r₂ =>
    let rs := {
      rs with
      forwardRules := rs.forwardRules.insert r₁
      forwardRuleNames := rs.forwardRuleNames.insert r₁.name
      safeRules := rs.safeRules.add r₂ r₂.indexingMode
    }
    addRulePattern r₂.name r₂.pattern? rs
where
  addRulePattern (n : RuleName) (pat? : Option RulePattern)
      (rs : BaseRuleSet) : BaseRuleSet :=
    match pat? with
    | none => rs
    | some pat => { rs with rulePatterns := rs.rulePatterns.add n pat }

def LocalRuleSet.add (rs : LocalRuleSet) :
    LocalRuleSetMember → LocalRuleSet
  | .global (.base m) => rs.modifyBase (·.add m)
  | .global (.normSimpRule r) =>
    let simpTheoremsArray :=
      rs.simpTheoremsArray.modify 0 λ (name, simpTheorems) =>
        let simpTheorems :=
          r.entries.foldl (init := simpTheorems) SimpTheorems.addSimpEntry
        (name, simpTheorems)
    let simpTheoremsArrayNonempty : 0 < simpTheoremsArray.size := by
      simp [simpTheoremsArray, Array.size_modify, rs.simpTheoremsArrayNonempty]
    { rs with simpTheoremsArray, simpTheoremsArrayNonempty }
  | .localNormSimpRule r =>
    { rs with localNormSimpRules := rs.localNormSimpRules.push r }


def BaseRuleSet.erase (rs : BaseRuleSet) (f : RuleFilter) :
    BaseRuleSet × Bool := Id.run do
  let some ns := rs.ruleNames.find? f.name
    | return (rs, false)
  let (toErase, toKeep) := ns.partition f.matches
  if toErase.isEmpty then
    return (rs, false)

  let ruleNames :=
    if toKeep.isEmpty then
      rs.ruleNames.erase f.name
    else
      rs.ruleNames.insert f.name toKeep

  let mut erased := rs.erased
  let mut unfoldRules := rs.unfoldRules
  for r in toErase do
    match r.builder with
    | .unfold => unfoldRules := unfoldRules.erase r.name
    | .tactic | .forward | .destruct | .constructors | .cases | .apply =>
      erased := erased.insert r
    | .simp => continue

  let res := { rs with ruleNames, erased, unfoldRules }
  return (res, true)

def GlobalRuleSet.erase (rs : GlobalRuleSet) (f : RuleFilter) :
    GlobalRuleSet × Bool := Id.run do
  let (rs, anyErased) := rs.onBase (·.erase f)
  if let some decl := f.matchesSimpTheorem? then
    if SimpTheorems.containsDecl rs.simpTheorems decl then
      let simpTheorems := rs.simpTheorems.eraseCore (.decl decl (inv := false))
      return ({ rs with simpTheorems := simpTheorems }, true)
  return (rs, anyErased)

def LocalRuleSet.erase (rs : LocalRuleSet) (f : RuleFilter) :
    LocalRuleSet × Bool := Id.run do
  let (rs, anyErased) := rs.onBase (·.erase f)
  let mut anyErased := anyErased
  let mut localNormSimpRules := rs.localNormSimpRules
  let mut simpTheoremsArray' :
      Σ' a : Array (Name × SimpTheorems), a.size = rs.simpTheoremsArray.size :=
    ⟨rs.simpTheoremsArray, rfl⟩
  if let some id := f.matchesLocalNormSimpRule? then
    if let some idx := localNormSimpRules.findFinIdx? (·.id == id) then
      localNormSimpRules := localNormSimpRules.eraseIdx idx
  if let some decl := f.matchesSimpTheorem? then
    for h : i in [:rs.simpTheoremsArray.size] do
      have i_valid : i < simpTheoremsArray'.fst.size := by
        simp_all +zetaDelta [Membership.mem, simpTheoremsArray'.snd]
      let (name, simpTheorems) := simpTheoremsArray'.fst[i]
      if SimpTheorems.containsDecl simpTheorems decl then
        let origin := .decl decl (inv := false)
        simpTheoremsArray' :=
          ⟨simpTheoremsArray'.fst.set i
            (name, simpTheorems.eraseCore origin),
           by simp [simpTheoremsArray'.snd, Array.size_set]⟩
        anyErased := true
  let simpTheoremsArray := simpTheoremsArray'.fst
  let simpTheoremsArrayNonempty : 0 < simpTheoremsArray.size := by
    simp [simpTheoremsArray, simpTheoremsArray'.snd, rs.simpTheoremsArrayNonempty]
  let rs := { rs with
    localNormSimpRules, simpTheoremsArray, simpTheoremsArrayNonempty
  }
  return (rs, anyErased)


namespace LocalRuleSet

@[inline, always_inline]
private def fwdRulePredicate (opts : Lean.Options) (rs : LocalRuleSet)
    (include? : Rule α → Bool) (r : Rule α) : Bool :=
  aesop.dev.statefulForward.get opts && include? r && ! rs.isErased r.name

@[inline, always_inline]
private def rulePredicate (opts : Lean.Options) (rs : LocalRuleSet)
    (include? : Rule α → Bool) : Rule α → Bool :=
  -- HACK When stateful forward reasoning is active, we exclude rules which are
  -- already covered by equivalent `ForwardRule`s.
  if aesop.dev.statefulForward.get opts then
    λ r => include? r && ! rs.isErased r.name &&
           ! rs.forwardRuleNames.contains r.name
  else
    λ r => include? r && ! rs.isErased r.name

private def postprocessForwardMatchRules (opts : Lean.Options) (rs : LocalRuleSet)
    (include? : Rule α → Bool) (rules : Array (Rule α)) :
    Array (IndexMatchResult (Rule α)) :=
  rules.filter (fwdRulePredicate opts rs include?) |>.map λ rule =>
    { rule, locations := ∅, patternSubsts? := none }

def applicableNormalizationRulesWith (rs : LocalRuleSet)
    (fms : ForwardRuleMatches) (goal : MVarId)
    (include? : NormRule → Bool) : BaseM (Array (IndexMatchResult NormRule)) := do
  let opts ← getOptions
  let normFwdRules := postprocessForwardMatchRules opts rs include? fms.normRules
  let patInstMap ← rs.rulePatterns.getInGoal goal
  rs.normRules.applicableRules goal patInstMap normFwdRules
    (rulePredicate opts rs include?)

@[inline, always_inline]
def applicableNormalizationRules (rs : LocalRuleSet) (fms : ForwardRuleMatches)
    (goal : MVarId) : BaseM (Array (IndexMatchResult NormRule)) :=
  rs.applicableNormalizationRulesWith fms goal (include? := λ _ => true)

def applicableUnsafeRulesWith (rs : LocalRuleSet) (fms : ForwardRuleMatches)
    (goal : MVarId) (include? : UnsafeRule → Bool) :
    BaseM (Array (IndexMatchResult UnsafeRule)) := do
  let opts ← getOptions
  let unsafeFwdRules := postprocessForwardMatchRules opts rs include? fms.unsafeRules
  let patInstMap ← rs.rulePatterns.getInGoal goal
  rs.unsafeRules.applicableRules goal patInstMap unsafeFwdRules
    (rulePredicate opts rs include?)

@[inline, always_inline]
def applicableUnsafeRules (rs : LocalRuleSet) (fms : ForwardRuleMatches)
    (goal : MVarId) : BaseM (Array (IndexMatchResult UnsafeRule)) :=
  rs.applicableUnsafeRulesWith fms goal (include? := λ _ => true)

def applicableSafeRulesWith (rs : LocalRuleSet) (fms : ForwardRuleMatches)
    (goal : MVarId) (include? : SafeRule → Bool) :
    BaseM (Array (IndexMatchResult SafeRule)) := do
  let opts ← getOptions
  let safeFwdRules := postprocessForwardMatchRules opts rs include? fms.safeRules
  let patInstMap ← rs.rulePatterns.getInGoal goal
  rs.safeRules.applicableRules goal patInstMap safeFwdRules
    (rulePredicate opts rs include?)

@[inline, always_inline]
def applicableSafeRules (rs : LocalRuleSet) (fms : ForwardRuleMatches)
    (goal : MVarId) : BaseM (Array (IndexMatchResult SafeRule)) :=
  rs.applicableSafeRulesWith fms goal (include? := λ _ => true)

def applicableForwardRulesWith (rs : LocalRuleSet) (e : Expr)
    (include? : ForwardRule → Bool) :
    MetaM (Array (ForwardRule × PremiseIndex)) :=
  withConstAesopTraceNode .forward (return m!"selected forward rules:") do
    let rules ← rs.forwardRules.get e
    let rules := rules.filter λ (rule, _) =>
      include? rule && !rs.isErased rule.name
    aesop_trace[forward] do
      for (r, i) in rules do
        aesop_trace![forward] mkMsg r i
    return rules
  where
    mkMsg r i := m!"{r}, premise {i}" -- Inlining this triggers a Lean bug.

@[inline, always_inline]
def applicableForwardRules (rs : LocalRuleSet) (e : Expr) :
    MetaM (Array (ForwardRule × PremiseIndex)) :=
  rs.applicableForwardRulesWith e (include? := λ _ => true)

def constForwardRuleMatches (rs : LocalRuleSet) : Array ForwardRuleMatch :=
  rs.forwardRules.getConstRuleMatches

section ForwardRulePattern

private def postprocessPatSubstMap (rs : LocalRuleSet)
    (m : RulePatternSubstMap) : Array (ForwardRule × Substitution) :=
  m.toFlatArray.filterMap λ (n, patSubst) =>
    rs.forwardRules.getRuleWithName? n |>.map (·, patSubst)

def forwardRulePatternSubstsInExpr (rs : LocalRuleSet) (e : Expr) :
    BaseM (Array (ForwardRule × Substitution)) := do
  withConstAesopTraceNode .forward (return m!"rule patterns in expr {e}:") do
    let ms ← rs.rulePatterns.get e
    let ms := postprocessPatSubstMap rs ms
    aesop_trace[forward] do
      for (r, inst) in ms do
        aesop_trace![forward] m!"{r}, {inst}"
    return ms

def forwardRulePatternSubstsInLocalDecl (rs : LocalRuleSet) (ldecl : LocalDecl) :
    BaseM (Array (ForwardRule × Substitution)) := do
  withConstAesopTraceNode .forward (return m!"rule patterns in hyp {ldecl.userName}:") do
    let ms ← rs.rulePatterns.getInLocalDecl ldecl
    let ms := postprocessPatSubstMap rs ms
    aesop_trace[forward] do
      for (r, inst) in ms do
        aesop_trace![forward] m!"{r}, {inst}"
    return ms

end ForwardRulePattern

-- NOTE: only non-forward norm/safe/unsafe rules can be unindexed.
def unindex (rs : LocalRuleSet) (p : RuleName → Bool) : LocalRuleSet := {
  rs with
  normRules := rs.normRules.unindex (p ·.name)
  unsafeRules := rs.unsafeRules.unindex (p ·.name)
  safeRules := rs.safeRules.unindex (p ·.name)
}

end LocalRuleSet


@[inline, always_inline]
def unindexPredicate? (options : Options') : Option (RuleName → Bool) :=
  if options.destructProductsTransparency == .reducible then
    none
  else
    some λ n => n.name == `Aesop.BuiltinRules.destructProducts

def mkLocalRuleSet (rss : Array (GlobalRuleSet × Name × Name))
    (options : Options') : CoreM LocalRuleSet := do
  let mut result := ∅
  let simpTheorems ← getSimpTheorems
  let simprocs ← Simp.getSimprocs
  result := {
    toBaseRuleSet := ∅
    simpTheoremsArray :=
      if options.useDefaultSimpSet then
        Array.mkEmpty (rss.size + 1) |>.push (`_, simpTheorems)
      else
        Array.mkEmpty (rss.size + 1) |>.push (`_, {})
    simprocsArray :=
      if options.useDefaultSimpSet then
        Array.mkEmpty (rss.size + 1) |>.push (`_, simprocs)
      else
        Array.mkEmpty (rss.size + 1) |>.push ((`_, {}))
    simpTheoremsArrayNonempty := by split <;> simp
    simprocsArrayNonempty := by split <;> simp
    localNormSimpRules := ∅
  }
  for (rs, simpExtName, simprocExtName) in rss do
    result := { result with
      toBaseRuleSet := result.toBaseRuleSet.merge rs.toBaseRuleSet
      simpTheoremsArray :=
        result.simpTheoremsArray.push (simpExtName, rs.simpTheorems)
      simpTheoremsArrayNonempty := by simp
      simprocsArray :=
        result.simprocsArray.push (simprocExtName, rs.simprocs)
      simprocsArrayNonempty := by simp
    }
  if let some p := unindexPredicate? options then
    return result.unindex p
  else
    return result

end Aesop



=== LEAN SOURCE: RuleTac.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.RuleTac.Apply
import Aesop.RuleTac.Basic
import Aesop.RuleTac.Cases
import Aesop.RuleTac.Forward
import Aesop.RuleTac.Preprocess
import Aesop.RuleTac.Tactic

open Lean

namespace Aesop.RuleTacDescr

protected def run : RuleTacDescr → RuleTac
  | apply t md => RuleTac.apply t md
  | constructors cs md => RuleTac.applyConsts cs md
  | forward t immediate clear => RuleTac.forward t immediate clear
  | cases target md isRecursiveType ctorNames =>
    RuleTac.cases target md isRecursiveType ctorNames
  | tacticM decl => RuleTac.tacticM decl
  | singleRuleTac decl => RuleTac.singleRuleTac decl
  | ruleTac decl => RuleTac.ruleTac decl
  | tacticStx stx => RuleTac.tacticStx stx
  | tacGen decl => RuleTac.tacGen decl
  | preprocess => RuleTac.preprocess
  | forwardMatches m => RuleTac.forwardMatches m

end RuleTacDescr



=== LEAN SOURCE: Saturate.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Forward.State.ApplyGoalDiff
import Aesop.Forward.State.Initial
import Aesop.RuleSet
import Aesop.RuleTac
import Aesop.Search.Expansion.Basic
import Aesop.Script.Check
import Batteries.Data.BinomialHeap.Basic

open Lean Lean.Meta
open Batteries (BinomialHeap)

namespace Aesop

def isForwardOrDestructRuleName (n : RuleName) : Bool :=
  n.builder == .forward || n.builder == .destruct

structure SaturateM.Context where
  options : Aesop.Options'
  deriving Inhabited

structure SaturateM.State where
  rulePatternCache : RulePatternCache := {}
  rpinfCache : RPINFCache := ∅
  deriving Inhabited

abbrev SaturateM :=
  ReaderT SaturateM.Context $ StateRefT SaturateM.State $ ScriptT BaseM

namespace SaturateM

def run (options : Aesop.Options') (x : SaturateM α) :
    MetaM (α × Array Script.LazyStep) :=
  (·.fst) <$> (ReaderT.run x { options } |>.run' {} |>.run.run)

end SaturateM

def getSingleGoal [Monad m] [MonadError m] (o : RuleTacOutput) :
    m (GoalDiff × Meta.SavedState × Option (Array Script.LazyStep)) := do
  let #[app] := o.applications
    | throwError "rule produced more than one rule application"
  let #[goal] := app.goals
    | throwError "rule did not produce exactly one subgoal"
  return (goal.diff, app.postState, app.scriptSteps?)

initialize
  registerTraceClass `saturate

partial def saturateCore (rs : LocalRuleSet) (goal : MVarId) : SaturateM MVarId :=
  withExceptionPrefix "saturate: internal error: " do
  goal.checkNotAssigned `saturate
  -- We use the forward state only to track the hypotheses present in the goal.
  let (fs, _) ← rs.mkInitialForwardState goal
  go goal fs
where
  go (goal : MVarId) (fs : ForwardState) : SaturateM MVarId :=
    withIncRecDepth do
    trace[saturate] "goal {goal.name}:{indentD goal}"
    let mvars := UnorderedArraySet.ofHashSet $ ← goal.getMVarDependencies
    let preState ← show MetaM _ from saveState
    if let some diff ← tryNormRules goal mvars preState fs.hypTypes then
      let (fs, _) ← fs.applyGoalDiff rs diff
      return ← go diff.newGoal fs
    else if let some diff ← trySafeRules goal mvars preState fs.hypTypes then
      let (fs, _) ← fs.applyGoalDiff rs diff
      return ← go diff.newGoal fs
    else
      clearForwardImplDetailHyps goal

  tryNormRules (goal : MVarId) (mvars : UnorderedArraySet MVarId)
      (preState : Meta.SavedState) (hypTypes : PHashSet RPINF) :
      SaturateM (Option GoalDiff) :=
    withTraceNode `saturate (λ res => return m!"{exceptOptionEmoji res} trying normalisation rules") do
      let matchResults ←
        withTraceNode `saturate (λ res => return m!"{exceptEmoji res} selecting normalisation rules") do
        rs.applicableNormalizationRulesWith ∅ goal
          (include? := (isForwardOrDestructRuleName ·.name))
      runFirstRule goal mvars preState matchResults hypTypes

  trySafeRules (goal : MVarId) (mvars : UnorderedArraySet MVarId)
      (preState : Meta.SavedState) (hypTypes : PHashSet RPINF) :
      SaturateM (Option GoalDiff) :=
    withTraceNode `saturate (λ res => return m!"{exceptOptionEmoji res} trying safe rules") do
      let matchResults ←
        withTraceNode `saturate (λ res => return m!"{exceptEmoji res} selecting safe rules") do
        rs.applicableSafeRulesWith ∅ goal
          (include? := (isForwardOrDestructRuleName ·.name))
      runFirstRule goal mvars preState matchResults hypTypes

  runRule {α} (goal : MVarId) (mvars : UnorderedArraySet MVarId)
      (preState : Meta.SavedState) (matchResult : IndexMatchResult (Rule α))
      (hypTypes : PHashSet RPINF) :
      SaturateM (Option (GoalDiff × Option (Array Script.LazyStep))) := do
    withTraceNode `saturate (λ res => return m!"{exceptOptionEmoji res} running rule {matchResult.rule.name}") do
    let input := {
      indexMatchLocations := matchResult.locations
      patternSubsts? := matchResult.patternSubsts?
      options := (← read).options
      hypTypes, goal, mvars
    }
    let tacResult ←
      runRuleTac matchResult.rule.tac.run matchResult.rule.name preState input
    match tacResult with
    | .error exc =>
      trace[saturate] exc.toMessageData
      return none
    | .ok output =>
      let (diff, postState, scriptSteps?) ← getSingleGoal output
      postState.restore
      return (diff, scriptSteps?)

  runFirstRule {α} (goal : MVarId) (mvars : UnorderedArraySet MVarId)
      (preState : Meta.SavedState)
      (matchResults : Array (IndexMatchResult (Rule α)))
      (hypTypes : PHashSet RPINF) : SaturateM (Option GoalDiff) := do
    for matchResult in matchResults do
      let ruleResult? ← runRule goal mvars preState matchResult hypTypes
      if let some (diff, scriptSteps?) := ruleResult? then
        if (← read).options.generateScript then
          let some scriptSteps := scriptSteps?
            | throwError "rule '{matchResult.rule.name}' does not support script generation (saturate?)"
          recordScriptSteps scriptSteps
        return some diff
    return none

namespace Stateful

abbrev Queue := BinomialHeap ForwardRuleMatch ForwardRuleMatch.le

partial def saturateCore (rs : LocalRuleSet) (goal : MVarId)
    (options : Options') : SaturateM MVarId :=
  withExceptionPrefix "saturate: internal error: " do
  goal.withContext do
    goal.checkNotAssigned `saturate
    let (fs, ruleMatches) ← rs.mkInitialForwardState goal
    let queue := ruleMatches.foldl (init := ∅) λ queue m => queue.insert m
    go ∅ fs queue ∅ goal
where
  go (hypDepths : Std.HashMap FVarId Nat) (fs : ForwardState) (queue : Queue)
      (erasedHyps : Std.HashSet FVarId) (goal : MVarId) : SaturateM MVarId := do
    withIncRecDepth do
    goal.withContext do
      if let some (m, queue) := queue.deleteMin then
        if m.rule.name.phase == .unsafe || m.anyHyp erasedHyps.contains then
          return ← go hypDepths fs queue erasedHyps goal
        trace[saturate] "goal:{indentD goal}"
        let oldGoal := goal
        let some (goal, hyp, removedHyps) ←
          m.apply goal (skip? := some (fs.hypTypes.contains ·))
          | return ← go hypDepths fs queue erasedHyps goal
        goal.withContext do
          -- TODO use applyGoalDiff
          let fs ← removedHyps.foldlM (init := fs) λ fs h => do
            let type ← oldGoal.withContext do rpinf (← h.getType)
            return fs.eraseHyp h type
          let type ← hyp.getType
          let erasedHyps := erasedHyps.insertMany removedHyps
          let mut depth := 0
          let mut hypDepths := hypDepths
          let maxDepth? := options.forwardMaxDepth?
          if maxDepth?.isSome then
            depth := 1 + m.foldHyps (init := 0) λ depth h =>
              max depth (hypDepths[h]?.getD 0)
            hypDepths := hypDepths.insert hyp depth
          trace[saturate] "added hyp (depth {depth}) {Expr.fvar hyp} : {type}"
          if maxDepth?.isSome && depth ≥ maxDepth?.get! then
            go hypDepths fs queue erasedHyps goal
          else
            let rules ← rs.applicableForwardRules type
            let patInsts ←
              rs.forwardRulePatternSubstsInLocalDecl (← hyp.getDecl)
            let (fs, ruleMatches) ←
              fs.addHypWithPatSubsts goal hyp rules patInsts
            let queue :=
              ruleMatches.foldl (init := queue) λ queue m => queue.insert m
            go hypDepths fs queue erasedHyps goal
      else
        return goal

end Stateful

def saturateMain (rs : LocalRuleSet) (goal : MVarId) (options : Aesop.Options') :
    MetaM (MVarId × Array Script.LazyStep) := do
  let doSaturate :=
    if aesop.dev.statefulForward.get (← getOptions) then
      Stateful.saturateCore rs goal options
    else
      saturateCore rs goal
  doSaturate.run options

def saturate (rs : LocalRuleSet) (goal : MVarId) (options : Aesop.Options') :
    MetaM MVarId := do
  if ! options.generateScript then
    (·.fst) <$> saturateMain rs goal options
  else
    let preState ← saveState
    let tacticState ← Script.TacticState.mkInitial goal
    let preGoal := goal
    let (goal, steps) ← saturateMain rs goal options
    let options ← options.toOptions'
    if options.generateScript then
      let uscript : Script.UScript ← steps.mapM (·.toStep)
      let tacticSeq ← `(tacticSeq| $(← uscript.render tacticState):tactic*)
      checkRenderedScriptIfEnabled tacticSeq preState preGoal
        (expectCompleteProof := false)
      if options.traceScript then
        addTryThisTacticSeqSuggestion (← getRef) tacticSeq
    return goal

end Aesop



=== LEAN SOURCE: Tracing.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Util.Basic
import Batteries.Data.Array.Basic
import Lean.Elab.Term
import Lean.Meta.Tactic.Simp

open Lean Lean.Meta

namespace Aesop

structure TraceOption where
  traceClass : Name
  option : Lean.Option Bool
  deriving Inhabited

def registerTraceOption (traceName : Name) (descr : String) :
    IO TraceOption := do
  let option ← Option.register (`trace.aesop ++ traceName) {
    defValue := false
    group := "trace"
    descr
  }
  return { traceClass := `aesop ++ traceName, option }

namespace TraceOption

def isEnabled [Monad m] [MonadOptions m] (opt : TraceOption) : m Bool :=
  return opt.option.get (← getOptions)

def withEnabled [MonadWithOptions m] (opt : TraceOption) (k : m α) : m α :=
  withOptions (λ opts => opt.option.set opts true) k

initialize steps : TraceOption ←
  registerTraceOption .anonymous
    "(aesop) Print actions taken by Aesop during the proof search."

initialize ruleSet : TraceOption ←
  registerTraceOption `ruleSet
    "(aesop) Print the rule set before starting the search."

initialize proof : TraceOption ←
  registerTraceOption `proof
    "(aesop) If the search is successful, print the produced proof term."

initialize tree : TraceOption ←
  registerTraceOption `tree
    "(aesop) Once the search has concluded (successfully or unsuccessfully), print the final search tree."

initialize extraction : TraceOption ←
  registerTraceOption `extraction
    "(aesop) Print a trace of the proof extraction procedure."

initialize stats : TraceOption ←
  registerTraceOption `stats
    "(aesop) If the search is successful, print some statistics."

initialize debug : TraceOption ←
  registerTraceOption `debug
    "(aesop) Print various debugging information."

initialize script : TraceOption ←
  registerTraceOption `script
    "(aesop) Print a trace of script generation."

initialize forward : TraceOption ←
  registerTraceOption `forward
    "(aesop) Trace forward reasoning."

initialize forwardDebug : TraceOption ←
  registerTraceOption `forward.debug
    "(aesop) Trace more information about forward reasoning. Mostly intended for performance analysis."

initialize rpinf : TraceOption ←
  registerTraceOption `rpinf
    "(aesop) Trace RPINF calculations."

end TraceOption

section

open Lean.Elab Lean.Elab.Term

private def isFullyQualifiedGlobalName (n : Name) : MacroM Bool :=
  return (← Macro.resolveGlobalName n).any (·.fst == n)

def resolveTraceOption (stx : Ident) : MacroM Name :=
  withRef stx do
    let n := stx.getId
    let fqn := ``TraceOption ++ n
    if ← isFullyQualifiedGlobalName fqn then
      return fqn
    else
      return n

macro "aesop_trace![" opt:ident "] " msg:(interpolatedStr(term) <|> term) :
    doElem => do
  let opt ← mkIdent <$> resolveTraceOption opt
  let msg := msg.raw
  let msg ← if msg.getKind == interpolatedStrKind then
    `(m! $(⟨msg⟩):interpolatedStr)
  else
    `(toMessageData ($(⟨msg⟩)))
  `(doElem| Lean.addTrace (Aesop.TraceOption.traceClass $opt) $msg)

macro "aesop_trace[" opt:ident "] "
    msg:(interpolatedStr(term) <|> Parser.Term.do <|> term) : doElem => do
  let msg := msg.raw
  let opt ← mkIdent <$> resolveTraceOption opt
  match msg with
  | `(do $action) =>
    `(doElem| do
        if ← Aesop.TraceOption.isEnabled $opt then
          $action)
  | _ =>
    `(doElem| do
        if ← Aesop.TraceOption.isEnabled $opt then
          aesop_trace![$opt] $(⟨msg⟩))

end

def ruleSuccessEmoji    := checkEmoji
def ruleFailureEmoji    := crossEmoji
def ruleProvedEmoji     := "🏁"
def ruleErrorEmoji      := bombEmoji
def rulePostponedEmoji  := "⏳️"
def ruleSkippedEmoji    := "⏩️"
def nodeUnknownEmoji    := "❓️"
def nodeProvedEmoji     := ruleProvedEmoji
def nodeUnprovableEmoji := ruleFailureEmoji
def newNodeEmoji        := "🆕"

def exceptRuleResultToEmoji (toEmoji : α → String) : Except ε α → String
  | .error _ => ruleFailureEmoji
  | .ok r => toEmoji r

section

variable [Monad m] [MonadTrace m] [MonadLiftT BaseIO m] [MonadLiftT IO m]
    [MonadRef m] [AddMessageContext m] [MonadOptions m] [MonadAlwaysExcept ε m]

@[inline, always_inline]
def withAesopTraceNode (opt : TraceOption)
    (msg : Except ε α → m MessageData) (k : m α) (collapsed := true) : m α :=
  withTraceNode opt.traceClass msg k collapsed

@[inline, always_inline]
def withAesopTraceNodeBefore [ExceptToEmoji ε α] (opt : TraceOption)
    (msg : m MessageData) (k : m α) (collapsed := true) : m α :=
  withTraceNodeBefore opt.traceClass msg k collapsed

@[inline, always_inline]
def withConstAesopTraceNode (opt : TraceOption) (msg : m MessageData) (k : m α)
    (collapsed := true) : m α :=
  withAesopTraceNode opt (λ _ => msg) k collapsed

end

def traceSimpTheoremTreeContents (t : SimpTheoremTree) (opt : TraceOption) :
    CoreM Unit := do
  if ! (← opt.isEnabled) then
    return
  for e in t.values.map (toString ·.origin.key) |>.qsortOrd do
    aesop_trace![opt] e

def traceSimpTheorems (s : SimpTheorems) (opt : TraceOption) : CoreM Unit := do
  if ! (← opt.isEnabled) then
    return
  withConstAesopTraceNode opt (return "Erased entries") do
    aesop_trace![opt] "(Note: even if these entries appear in the sections below, they will not be used by simp.)"
    for e in PersistentHashSet.toArray s.erased |>.map (toString ·.key) |>.qsortOrd do
      aesop_trace![opt] e
  withConstAesopTraceNode opt (return "Pre lemmas") do
    traceSimpTheoremTreeContents s.pre opt
  withConstAesopTraceNode opt (return "Post lemmas") do
    traceSimpTheoremTreeContents s.post opt
  withConstAesopTraceNode opt (return "Constants to unfold") do
    for e in PersistentHashSet.toArray s.toUnfold |>.map toString |>.qsortOrd do
      aesop_trace![opt] e

end Aesop



=== LEAN SOURCE: Tree.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Tree.AddRapp
import Aesop.Tree.Check
import Aesop.Tree.Data
import Aesop.Tree.ExtractProof
import Aesop.Tree.ExtractScript
import Aesop.Tree.Free
import Aesop.Tree.RunMetaM
import Aesop.Tree.State
import Aesop.Tree.Tracing
import Aesop.Tree.Traversal
import Aesop.Tree.TreeM
import Aesop.Tree.UnsafeQueue



=== LEAN SOURCE: Apply.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Builder.Basic

open Lean
open Lean.Meta

namespace Aesop

namespace RuleBuilderOptions

def applyTransparency (opts : RuleBuilderOptions) : TransparencyMode :=
  opts.transparency?.getD .default

def applyIndexTransparency (opts : RuleBuilderOptions) : TransparencyMode :=
  opts.indexTransparency?.getD .reducible

end RuleBuilderOptions

namespace RuleBuilder

def getApplyIndexingMode (indexMd : TransparencyMode) (type : Expr) :
    MetaM IndexingMode :=
  if indexMd != .reducible then
    return .unindexed
  else
    IndexingMode.targetMatchingConclusion type

def checkNoIff (type : Expr) : MetaM Unit := do
  if aesop.warn.applyIff.get (← getOptions) then
    forallTelescope type λ _ conclusion => do
      if ← testHelper conclusion λ e => return e.isAppOf' ``Iff then
        logWarning m!"Apply builder was used for a theorem with conclusion A ↔ B.\nYou probably want to use the simp builder or create an alias that applies the theorem in one direction.\nUse `set_option aesop.warn.applyIff false` to disable this warning."

def applyCore (t : ElabRuleTerm) (pat? : Option RulePattern)
    (imode? : Option IndexingMode) (md indexMd : TransparencyMode)
    (phase : PhaseSpec) : MetaM LocalRuleSetMember := do
  let e ← t.expr
  let type ← inferType e
  let imode ← imode?.getDM $ getApplyIndexingMode indexMd type
  let tac := .apply t.toRuleTerm md
  return .global $ .base $ phase.toRule (← t.name) .apply t.scope tac imode pat?

def apply : RuleBuilder := λ input => do
  let opts := input.options
  let e ← elabRuleTermForApplyLike input.term
  let t := ElabRuleTerm.ofElaboratedTerm input.term e
  let type ← inferType e
  checkNoIff type
  let pat? ← opts.pattern?.mapM (RulePattern.elab · e)
  applyCore t pat? opts.indexingMode? opts.applyTransparency
    opts.applyIndexTransparency input.phase

end Aesop.RuleBuilder



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.ElabM
import Aesop.Rule.Name
import Aesop.RuleSet.Member
import Aesop.RuleTac.ElabRuleTerm

open Lean Lean.Meta Lean.Elab.Term

namespace Aesop

/--
Options for the builders. Most options are only relevant for certain builders.
-/
structure RuleBuilderOptions where
  immediatePremises? : Option (Array Name)
  indexingMode? : Option IndexingMode
  casesPatterns? : Option (Array CasesPattern)
  pattern? : Option Term
  /-- The transparency used by the rule tactic. -/
  transparency? : Option TransparencyMode
  /-- The transparency used for indexing the rule. Currently, the rule is not
  indexed unless this is `.reducible`. -/
  indexTransparency? : Option TransparencyMode
  deriving Inhabited

namespace RuleBuilderOptions

protected def default : RuleBuilderOptions :=
  ⟨none, none, none, none, none, none⟩

instance : EmptyCollection RuleBuilderOptions :=
  ⟨.default⟩

end RuleBuilderOptions

structure CoreRuleBuilderOutput where
  ruleExprName : Name
  builderName : BuilderName
  scopeName : ScopeName
  tac : RuleTacDescr
  indexingMode : IndexingMode
  pattern? : Option RulePattern

inductive PhaseSpec
  | safe (info : SafeRuleInfo)
  | norm (info : NormRuleInfo)
  | «unsafe» (info : UnsafeRuleInfo)
  deriving Inhabited

namespace PhaseSpec

def phase : PhaseSpec → PhaseName
  | safe .. => .safe
  | «unsafe» .. => .unsafe
  | norm .. => .norm

def toRule (phase : PhaseSpec) (ruleExprName : Name) (builder : BuilderName)
    (scope : ScopeName) (tac : RuleTacDescr) (indexingMode : IndexingMode)
    (pattern? : Option RulePattern) : BaseRuleSetMember :=
  let name := {
    name := ruleExprName
    phase := phase.phase
    builder, scope
  }
  match phase with
  | .safe info => .safeRule {
      extra := info
      name, indexingMode, pattern?, tac
    }
  | .unsafe info => .unsafeRule {
      extra := info
      name, indexingMode, pattern?, tac
    }
  | .norm info => .normRule {
      extra := info
      name, indexingMode, pattern?, tac
    }

end PhaseSpec


structure RuleBuilderInput where
  term : Term
  options : RuleBuilderOptions
  phase : PhaseSpec
  deriving Inhabited

namespace RuleBuilderInput

def phaseName (input : RuleBuilderInput) : PhaseName :=
  input.phase.phase

end RuleBuilderInput


abbrev RuleBuilder := RuleBuilderInput → ElabM LocalRuleSetMember


def elabGlobalRuleIdent (builderName : BuilderName) (term : Term) :
    TermElabM Name := do
  if let some decl ← elabGlobalRuleIdent? term then
    return decl
  else
    throwError "aesop: {builderName} builder: expected '{term}' to be an unambiguous global constant"

def elabInductiveRuleIdent (builderName : BuilderName) (term : Term) :
    TermElabM InductiveVal := do
  if let some info ← elabInductiveRuleIdent? term then
    return info
  else
    throwError "aesop: {builderName} builder: expected '{term}' to be an inductive type or structure"

end Aesop



=== LEAN SOURCE: Cases.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Builder.Basic
import Aesop.RuleTac.Cases

open Lean
open Lean.Meta

namespace Aesop

namespace CasesPattern

def check (decl : Name) (p : CasesPattern) : MetaM Unit :=
  withoutModifyingState do
    let p ← p.toExpr
    unless p.isAppOf' decl do
      throwError "expected pattern '{p}' ({toString p}) to be an application of '{decl}'"

def toIndexingMode (p : CasesPattern) : MetaM IndexingMode :=
  withoutModifyingState do .hyps <$> mkDiscrTreePath (← p.toExpr)

end CasesPattern


namespace RuleBuilderOptions

def casesTransparency (opts : RuleBuilderOptions) : TransparencyMode :=
  opts.transparency?.getD .reducible

def casesIndexTransparency (opts : RuleBuilderOptions) : TransparencyMode :=
  opts.indexTransparency?.getD .reducible

def casesPatterns (opts : RuleBuilderOptions) : Array CasesPattern :=
  opts.casesPatterns?.getD #[]

end RuleBuilderOptions

namespace RuleBuilder

def mkCasesTarget (decl : Name) (casesPatterns : Array CasesPattern) :
    CasesTarget :=
  if casesPatterns.isEmpty then
    .decl decl
  else
    .patterns casesPatterns

def getCasesIndexingMode (decl : Name) (indexMd : TransparencyMode)
    (casesPatterns : Array CasesPattern) : MetaM IndexingMode := do
  if indexMd != .reducible then
    return .unindexed
  if casesPatterns.isEmpty then
    IndexingMode.hypsMatchingConst decl
  else
    .or <$> casesPatterns.mapM (·.toIndexingMode)

def casesCore (info : InductiveVal) (pats : Array CasesPattern)
    (imode? : Option IndexingMode) (md indexMd : TransparencyMode)
    (phase : PhaseSpec) : MetaM LocalRuleSetMember := do
  let decl := info.name
  pats.forM (·.check decl)
  let imode ← imode?.getDM $ getCasesIndexingMode decl indexMd pats
  let target := mkCasesTarget decl pats
  let ctorNames ← mkCtorNames info
  let tac := .cases target md info.isRec ctorNames
  return .global $ .base $ phase.toRule decl .cases .global tac imode none

def cases : RuleBuilder := λ input => do
  let opts := input.options
  if input.phase.phase == .norm then throwError
    "aesop: cases builder cannot currently be used for norm rules."
    -- TODO `Meta.cases` may assign and introduce metavariables.
    -- (Specifically, it can *replace* existing metavariables, which Aesop
    -- counts as an assignment and an introduction.)
  let info ← elabInductiveRuleIdent .cases input.term
  casesCore info opts.casesPatterns opts.indexingMode? opts.casesTransparency
    opts.casesIndexTransparency input.phase

end Aesop.RuleBuilder



=== LEAN SOURCE: Constructors.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Builder.Basic

open Lean
open Lean.Meta

namespace Aesop.RuleBuilderOptions

def constructorsTransparency (opts : RuleBuilderOptions) : TransparencyMode :=
  opts.transparency?.getD .default

def constructorsIndexTransparency (opts : RuleBuilderOptions) : TransparencyMode :=
  opts.indexTransparency?.getD .reducible

end RuleBuilderOptions

namespace RuleBuilder

def getConstructorsIndexingMode (indexMd : TransparencyMode)
    (info : InductiveVal) : MetaM IndexingMode := do
  if indexMd != .reducible then
    return .unindexed
  else
    let mut imodes := Array.mkEmpty info.numCtors
    for ctor in info.ctors do
      let ctorInfo ← getConstInfo ctor
      let imode ← IndexingMode.targetMatchingConclusion ctorInfo.type
      imodes := imodes.push imode
    return .or imodes

def constructorsCore (info : InductiveVal) (imode? : Option IndexingMode)
    (md indexMd : TransparencyMode) (phase : PhaseSpec) :
    MetaM LocalRuleSetMember := do
  let tac := .constructors info.ctors.toArray md
  let imode ← imode?.getDM $ getConstructorsIndexingMode indexMd info
  return .global $ .base $
    phase.toRule info.name .constructors .global tac imode none

def constructors : RuleBuilder := λ input => do
  let info ← elabInductiveRuleIdent .constructors input.term
  let opts := input.options
  constructorsCore info opts.indexingMode? opts.constructorsTransparency
    opts.constructorsIndexTransparency input.phase

end Aesop.RuleBuilder



=== LEAN SOURCE: Default.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Builder.Constructors
import Aesop.Builder.NormSimp
import Aesop.Builder.Tactic
import Aesop.Builder.Apply

open Lean
open Lean.Meta

namespace Aesop

-- TODO In the default builders below, we should distinguish between fatal and
-- nonfatal errors. E.g. if the `tactic` builder finds a declaration that is not
-- of tactic type, this is a nonfatal error and we should continue with the next
-- builder. But if the simp builder finds an equation that cannot be interpreted
-- as a simp lemma for some reason, this is a fatal error. Continuing with the
-- next builder is more confusing than anything because the user probably
-- intended to add a simp lemma.

def RuleBuilder.default : RuleBuilder := λ input =>
  match input.phase.phase with
  | .safe =>
    constructors input <|>
    tactic input <|>
    apply input <|>
    err "a safe" input
  | .unsafe =>
    constructors input <|>
    tactic input <|>
    apply input <|>
    err "an unsafe" input
  | .norm =>
    constructors input <|>
    tactic input <|>
    simp input <|>
    apply input <|>
    err "a norm" input
where
  err (ruleType : String) : RuleBuilder := λ input =>
    throwError m!"aesop: Unable to interpret '{input.term}' as {ruleType} rule. Try specifying a builder."

end Aesop



=== LEAN SOURCE: Forward.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Builder.Basic

open Lean
open Lean.Meta

namespace Aesop

namespace RuleBuilderOptions

def forwardTransparency (opts : RuleBuilderOptions) : TransparencyMode :=
  opts.transparency?.getD .reducible

def forwardIndexTransparency (opts : RuleBuilderOptions) : TransparencyMode :=
  opts.indexTransparency?.getD .reducible

end RuleBuilderOptions

namespace RuleBuilder

def getForwardIndexingMode (type : Expr)
    (immediate : UnorderedArraySet PremiseIndex) : MetaM IndexingMode := do
  let immediate := immediate.toArray.map (·.toNat)
  match immediate.max? with
  | some i =>
    withoutModifyingState do
      let (args, _, _) ← withReducible $ forallMetaTelescopeReducing type
      match args[i]? with
      | some arg =>
        let argT := (← arg.mvarId!.getDecl).type
        let keys ← mkDiscrTreePath argT
        return .hyps keys
      | none => throwError
        "aesop: internal error: immediate arg for forward rule is out of range"
  | none => return .unindexed

def getImmediatePremises  (type : Expr) (pat? : Option RulePattern) :
    Option (Array Name) → MetaM (UnorderedArraySet PremiseIndex)
  | none =>
    -- If no immediate names are given, every argument becomes immediate,
    -- except instance args, dependent args and args determined by a rule
    -- pattern.
    withReducible $ forallTelescopeReducing type λ args _ => do
      let mut result := #[]
      for h : i in [:args.size] do
        if isPatternInstantiated i then
          continue
        let fvarId := args[i].fvarId!
        let ldecl ← fvarId.getDecl
        let isNondep : MetaM Bool :=
          args.allM (start := i + 1) λ arg => do
            let type ← instantiateMVars (← arg.fvarId!.getDecl).type
            return ! type.containsFVar fvarId
        if ← pure ! ldecl.binderInfo.isInstImplicit <&&> isNondep then
          result := result.push ⟨i⟩
      return UnorderedArraySet.ofDeduplicatedArray result
  | some immediate =>
    -- If immediate names are given, we check that corresponding arguments
    -- exists and record these arguments' positions.
    withReducible $ forallTelescopeReducing type λ args _ => do
      let mut unseen := immediate.sortDedup (ord := ⟨Name.quickCmp⟩)
      let mut result := #[]
      for h : i in [:args.size] do
        let argName := (← args[i].fvarId!.getDecl).userName
        if immediate.contains argName then
          if isPatternInstantiated i then
            throwError "{errPrefix}argument '{argName}' cannot be immediate since it is already determined by a pattern"
          else
            result := result.push ⟨i⟩
            unseen := unseen.erase argName
      if ! unseen.isEmpty then throwError
        "{errPrefix}function does not have arguments with these names: '{unseen}'"
      return UnorderedArraySet.ofDeduplicatedArray result
where
  isPatternInstantiated (i : Nat) : Bool :=
    let idx? : Option Nat := do ← (← pat?).argMap[i]?
    idx?.isSome

  errPrefix : MessageData :=
    m!"aesop: forward builder: "

def forwardCore₂ (t : ElabRuleTerm) (immediate? : Option (Array Name))
    (pat? : Option RulePattern) (phase : PhaseSpec) (isDestruct : Bool) :
    MetaM ForwardRule := do
  let expr ← t.expr
  let name ← t.name
  let immediate ← getImmediatePremises (← inferType expr) pat? immediate?
  let info ← ForwardRuleInfo.ofExpr expr pat? immediate
  aesop_trace[forward] "rule type:{indentExpr $ ← inferType expr}"
  withConstAesopTraceNode .forward (return m!"slot clusters") do
    aesop_trace[forward] do
      for h : i in [:info.slotClusters.size] do
        let cluster := info.slotClusters[i]
        withConstAesopTraceNode .forward (return m!"cluster {i}") do
          for s in cluster do
            aesop_trace![forward] "slot {s.index} (premise {s.premiseIndex}, deps {s.deps.toArray.qsortOrd}, common {s.common.toArray.qsortOrd}, forward deps {s.forwardDeps.qsortOrd})"
  aesop_trace[forward] "conclusion deps: {info.conclusionDeps}"
  let prio :=
    match phase with
    | .safe info => .normSafe info.penalty
    | .norm info => .normSafe info.penalty
    | .unsafe info => .unsafe info.successProbability
  let builder := if isDestruct then .destruct else .forward
  let name := { phase := phase.phase, name, scope := t.scope, builder }
  return {
    toForwardRuleInfo := info
    term := t.toRuleTerm
    name, prio
  }

def forwardCore (t : ElabRuleTerm) (immediate? : Option (Array Name))
    (pat? : Option RulePattern) (phase : PhaseSpec) (isDestruct : Bool) :
    MetaM LocalRuleSetMember := do
  let builderName : BuilderName := if isDestruct then .destruct else .forward
  let type ← inferType (← t.expr)
  aesop_trace[debug] "decl type: {type}"
  let immediate ← getImmediatePremises type pat? immediate?
  aesop_trace[debug] "immediate premises: {immediate}"
  let imode ← getForwardIndexingMode type immediate
  aesop_trace[debug] "imode: {imode}"
  let tac := .forward t.toRuleTerm immediate isDestruct
  let member := phase.toRule (← t.name) builderName t.scope tac imode pat?
  -- HACK we currently add two rule set members for each forward rule; one
  -- normal, tactic-based rule and one `ForwardRule`. Eventually, only the
  -- `ForwardRule` will remain.
  let forwardRule ← forwardCore₂ t immediate? pat? phase isDestruct
  let member :=
    match member with
    | .normRule r => .normForwardRule forwardRule r
    | .safeRule r => .safeForwardRule forwardRule r
    | .unsafeRule r => .unsafeForwardRule forwardRule r
    | _ => unreachable!
  return .global $ .base member

def forward (isDestruct : Bool) : RuleBuilder := λ input => do
  withConstAesopTraceNode .debug (return "forward builder") do
    let opts := input.options
    let e ← elabRuleTermForApplyLike input.term
    let t := ElabRuleTerm.ofElaboratedTerm input.term e
    let pat? ← opts.pattern?.mapM (RulePattern.elab · e)
    forwardCore t opts.immediatePremises? pat? input.phase
      (isDestruct := isDestruct)

end Aesop.RuleBuilder



=== LEAN SOURCE: NormSimp.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Builder.Basic

open Lean
open Lean.Meta

namespace Aesop

private def getSimpEntriesFromPropConst (decl : Name) :
    MetaM (Array SimpEntry) := do
  let thms ← ({} : SimpTheorems).addConst decl
  return SimpTheorems.simpEntries thms

private def getSimpEntriesForConst (decl : Name) : MetaM (Array SimpEntry) := do
  let info ← getConstInfo decl
  let mut thms : SimpTheorems := {}
  if (← isProp info.type) then
    thms ← thms.addConst decl
  else if info.hasValue then
    thms ← thms.addDeclToUnfold decl
  return SimpTheorems.simpEntries thms

def PhaseSpec.getSimpPrio [Monad m] [MonadError m] : PhaseSpec → m Nat
  | .norm info =>
    if info.penalty ≥ 0 then
      return info.penalty.toNat
    else
      throwError "aesop: simp rules must be given a non-negative integer priority"
  | _ => throwError "aesop: simp builder can only construct 'norm' rules"

namespace RuleBuilder

def simpCore (decl : Name) (phase : PhaseSpec) : MetaM LocalRuleSetMember :=
  withExceptionTransform (λ msg => m!"aesop: simp builder: exception while trying to add {decl} as a simp theorem:{indentD msg}") do
    let entries ← getSimpEntriesForConst decl
    let prio ← phase.getSimpPrio
    let entries := entries.map (updateSimpEntryPriority prio)
    let name :=
      { name := decl, scope := .global, builder := .simp, phase := .norm }
    return .global $ .normSimpRule { name, entries }

def simp : RuleBuilder := λ input => do
  if let some decl ← elabGlobalRuleIdent? input.term then
    simpCore decl input.phase
  else
    checkElabRuleTermForSimp input.term (isSimpAll := true) -- TODO (isSimpAll := true) correct?
    return .localNormSimpRule {
      id := ← mkFreshId
      simpTheorem := input.term
    }

end Aesop.RuleBuilder



=== LEAN SOURCE: Tactic.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Builder.Basic

open Lean Lean.Meta
open Lean.Elab.Tactic (TacticM)
open Lean.Parser.Tactic (tacticSeq)

namespace Aesop

def matchByTactic? : Term → Option (TSyntax ``tacticSeq)
  | `(by $ts:tacticSeq) => some ts
  | _ => none

namespace RuleBuilder

def tacticIMode (imode? : Option IndexingMode) : IndexingMode :=
  imode?.getD .unindexed

def tacticCore (t : Sum Name (TSyntax ``tacticSeq)) (imode? : Option IndexingMode) (phase : PhaseSpec) :
    MetaM LocalRuleSetMember := do
  let imode := imode?.getD .unindexed
  match t with
  | .inl decl =>
    let type := (← getConstInfo decl).type
    let tac ←
      if ← isDefEq (mkApp (mkConst ``TacticM) (mkConst ``Unit)) type then
        pure $ .tacticM decl
      else if ← isDefEq (mkConst ``SingleRuleTac) type then
        pure $ .singleRuleTac decl
      else if ← isDefEq (mkConst ``RuleTac) type then
        pure $ .ruleTac decl
      else if ← isDefEq (mkConst ``TacGen) type then
        pure $ .tacGen decl
      else
        throwError "aesop: tactic builder: expected {decl} to be a tactic, i.e. to have one of these types:\n  TacticM Unit\n  SimpleRuleTac\n  RuleTac\n  TacGen\nHowever, it has type{indentExpr type}"
    return .global $ .base $ phase.toRule decl .tactic .global tac imode none
  | .inr tacticSeq =>
    let name ← mkFreshId
    let tac := .tacticStx tacticSeq
    return .global $ .base $ phase.toRule name .tactic .global tac imode none

def tactic : RuleBuilder := λ input => do
  let opts := input.options
  let t ←
    if input.term.raw.isIdent then
      .inl <$> elabGlobalRuleIdent .tactic input.term
    else if let some stx := matchByTactic? input.term then
      pure $ .inr stx
    else
      throwError "aesop: tactic builder: expected '{input.term}' to be a tactic"
  tacticCore t opts.indexingMode? input.phase

end Aesop.RuleBuilder



=== LEAN SOURCE: Unfold.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Builder.Basic
import Aesop.Util.Tactic.Unfold

open Lean
open Lean.Meta

namespace Aesop.RuleBuilder

-- Somewhat inefficient since `foldConsts` doesn't short-circuit.
def hasConst (c : Name) (e : Expr) : Bool :=
  e.foldConsts (init := false) λ c' acc => acc || c' == c

def checkUnfoldableConst (decl : Name) : MetaM (Option Name) :=
  withoutModifyingState do
    let e ← mkConstWithFreshMVarLevels decl
    let t := (← getConstInfo decl).type
    let unfoldThm? ← getUnfoldEqnFor? decl
    forallTelescope t λ args _ => do
      let testExpr := mkAppN e args
      let unfoldResult ←
        unfoldMany (if · == decl then some unfoldThm? else none) testExpr
      match unfoldResult with
      | none =>
        throwError "Declaration '{decl}' cannot be unfolded."
      | some (e', _) =>
        if hasConst decl e' then
          throwError "Recursive definition '{decl}' cannot be used as an unfold rule (it would be unfolded infinitely often). Try adding a simp rule for it."
    return unfoldThm?

def unfoldCore (decl : Name) : MetaM LocalRuleSetMember := do
  let unfoldThm? ← checkUnfoldableConst decl
  return .global $ .base $ .unfoldRule { decl, unfoldThm? }

-- TODO support local unfold rules
def unfold : RuleBuilder := λ input => do
  let decl ← elabGlobalRuleIdent .unfold input.term
  unfoldCore decl

end Aesop.RuleBuilder



=== LEAN SOURCE: ApplyHyps.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Frontend.Attribute

namespace Aesop.BuiltinRules

open Lean
open Lean.Meta

def applyHyp (hyp : FVarId) (goal : MVarId) (md : TransparencyMode) :
    BaseM RuleApplication := do
  let (goals, #[step]) ← applyS goal (.fvar hyp) none md |>.run
    | throwError "aesop: internal error in applyHyps: multiple steps"
  return {
    goals := goals.map λ mvarId => { diff := .empty goal mvarId }
    postState := step.postState
    scriptSteps? := #[step]
    successProbability? := none
  }

@[aesop unsafe 75% tactic (rule_sets := [builtin])]
def applyHyps : RuleTac := λ input =>
  input.goal.withContext do
    let lctx ← getLCtx
    let md := input.options.applyHypsTransparency
    let mut rapps := Array.mkEmpty lctx.decls.size
    for localDecl in lctx do
      if localDecl.isImplementationDetail then continue
      let initialState ← saveState
      try
        let rapp ← applyHyp localDecl.fvarId input.goal md
        rapps := rapps.push rapp
      catch _ => continue
      finally restoreState initialState
    return ⟨rapps⟩

end Aesop.BuiltinRules



=== LEAN SOURCE: Assumption.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Frontend.Attribute

open Lean
open Lean.Meta

namespace Aesop.BuiltinRules

@[aesop safe -50 (rule_sets := [builtin])]
def assumption : RuleTac := λ input => do
  let goal := input.goal
  let md := input.options.assumptionTransparency
  goal.withContext do
    goal.checkNotAssigned `Aesop.BuiltinRules.assumption
    goal.instantiateMVars
    let tgt ← goal.getType
    let tgtHasMVar := tgt.hasMVar
    let initialState ← saveState
    let mut applications := #[]
    for ldecl in ← getLCtx do
      if ldecl.isImplementationDetail then
        continue
      restoreState initialState
      let (some (application, proofHasMVar)) ← tryHyp goal ldecl.fvarId md
        | continue
      if ! tgtHasMVar && ! proofHasMVar then
        applications := #[application]
        break
      else
        applications := applications.push application
    if applications.isEmpty then
      throwTacticEx `Aesop.BuiltinRules.assumption goal "no matching assumption found"
    return ⟨applications⟩
  where
    tryHyp (goal : MVarId) (fvarId : FVarId) (md : TransparencyMode) :
        BaseM (Option (RuleApplication × Bool)) := do
      let (true, steps) ← tryExactFVarS goal fvarId md |>.run
        | return none
      let #[step] := steps
        | throwError "aesop: internal error in assumption: multiple steps"
      let proofHasMVar := (← fvarId.getType).hasMVar
      let app := {
        goals := #[]
        postState := step.postState
        scriptSteps? := #[step]
        successProbability? := none
      }
      return some (app, proofHasMVar)

end Aesop.BuiltinRules



=== LEAN SOURCE: DestructProducts.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Frontend.Attribute

open Lean Lean.Meta Aesop.Script

namespace Aesop.BuiltinRules

private def destructProductHyp? (goal : MVarId) (hyp : FVarId)
    (md : TransparencyMode) : MetaM (Option (LazyStep × MVarId)) :=
  goal.withContext do
    let hypType ← hyp.getType
    let (f, args) ← withTransparency md $ getAppUpToDefeq hypType
    match args with
    | #[α, β] =>
      match f with
      | (.const ``And _) =>
        go hypType (.const ``And.casesOn [← mkFreshLevelMVar]) α β
          ``And.intro `left `right
      | (.const ``Prod lvls) =>
        go hypType (.const ``Prod.casesOn  ((← mkFreshLevelMVar) :: lvls)) α β
          ``Prod.mk `fst `snd
      | (.const ``PProd lvls) =>
        go hypType (.const ``PProd.casesOn ((← mkFreshLevelMVar) :: lvls)) α β
          ``PProd.mk `fst `snd
      | (.const ``MProd lvls) =>
        go hypType (.const ``MProd.casesOn ((← mkFreshLevelMVar) :: lvls)) α β
          ``MProd.mk `fst `snd
      | (.const ``Exists lvls) =>
        go hypType (.const ``Exists.casesOn lvls) α β ``Exists.intro `w `h
      | (.const ``Subtype lvls) =>
        go hypType (.const ``Subtype.casesOn ((← mkFreshLevelMVar) :: lvls)) α β
          ``Subtype.mk `val `property
      | (.const ``Sigma lvls) =>
        go hypType (.const ``Sigma.casesOn ((← mkFreshLevelMVar) :: lvls)) α β
          ``Sigma.mk `fst `snd
      | (.const ``PSigma lvls) =>
        go hypType (.const ``PSigma.casesOn ((← mkFreshLevelMVar) :: lvls)) α β
          ``PSigma.mk `fst `snd
      | _ => return none
    | _ => return none
  where
    -- `rec` is the partially applied recursor. Missing arguments to `rec` are
    -- the motive, the hypothesis and the new proof.
    go (hypType rec lType rType : Expr) (ctor lName rName : Name) :
        MetaM (LazyStep × MVarId) := do
      let (step, mvarId, _) ← LazyStep.build goal {
        tac := tac hypType rec lType rType lName rName
        postGoals := (#[·.1])
        tacticBuilder := λ (_, lName, rName) =>
          TacticBuilder.obtain goal (.fvar hyp)
            { ctor, args := #[lName, rName], hasImplicitArg := false }
      }
      return (step, mvarId)

    tac (hypType rec lType rType : Expr) (lName rName : Name) :
        MetaM (MVarId × Name × Name) := do
      let (genHyps, goal) ← goal.revert #[hyp] (preserveOrder := true)
      let (hyp, goal) ← intro1Core goal (preserveBinderNames := true)
      let hypExpr := mkFVar hyp
      let tgt ← instantiateMVars (← goal.getType)
      let motive := mkLambda `h .default hypType $ tgt.abstract #[hypExpr]
      let prf := mkApp4 rec lType rType motive hypExpr
      goal.withContext $ check prf
      let [goal] ← goal.apply prf
        | throwError "destructProducts: apply did not return exactly one goal"
      let goal ← goal.clear hyp
      let lctx := (← goal.getDecl).lctx
      -- The following is only valid if `lName` and `rName` are distinct.
      -- Otherwise they could yield two identical unused names.
      let lName := lctx.getUnusedName lName
      let rName := lctx.getUnusedName rName
      let (_, goal) ← goal.introN 2 [lName, rName]
      let (_, goal) ← introNCore goal (genHyps.size - 1) []
        (preserveBinderNames := true) (useNamesForExplicitOnly := false)
      return (goal, lName, rName)

partial def destructProductsCore (goal : MVarId) (md : TransparencyMode) :
    BaseM (MVarId × Array LazyStep) := do
  let result ← go 0 goal |>.run
  if result.fst == goal then
    throwError "destructProducts: found no hypothesis with a product-like type"
  return result
where
  go (i : Nat) (goal : MVarId) : ScriptM MVarId := do
    withIncRecDepth $ goal.withContext do
      let lctx ← getLCtx
      if h : i < lctx.decls.size then
        match lctx.decls[i] with
        | none => go (i + 1) goal
        | some ldecl =>
          if ldecl.isImplementationDetail then
            go (i + 1) goal
          else
            let result? ← destructProductHyp? goal ldecl.fvarId md
            if let some (newScriptStep, newGoal) := result? then
              recordScriptStep newScriptStep
              go i newGoal
            else
              go (i + 1) goal
      else
        return goal

-- This tactic splits hypotheses of product-like types: `And`, `Prod`, `PProd`,
-- `MProd`, `Exists`, `Subtype`, `Sigma` and `PSigma`. It's a restricted version
-- of `cases`. We have this separate tactic because `cases` interacts badly with
-- metavariables and therefore can't be used for norm rules.
--
-- NOTE: If `destructProductsTransparency` != `.reducible`, then this rule is
-- moved from the by-hyp index to the unindexed rules. The rule is identified by
-- name, so if you change its name, you must also adjust the function
-- responsible for dynamically unindexing rules.
@[aesop norm 0 (rule_sets := [builtin]) tactic
    (index := [hyp And _ _, hyp Prod _ _, hyp PProd _ _, hyp MProd _ _,
               hyp Exists _, hyp Subtype _, hyp Sigma _, hyp PSigma _])]
partial def destructProducts : RuleTac := RuleTac.ofSingleRuleTac λ input => do
  let md := input.options.destructProductsTransparency
  let (goal, steps) ← destructProductsCore input.goal md
  return (#[{ diff := ← diffGoals input.goal goal }], steps, none)

end Aesop.BuiltinRules



=== LEAN SOURCE: Ext.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Frontend.Attribute

namespace Aesop.BuiltinRules

open Lean Lean.Meta

def extCore (goal : MVarId) : ScriptM (Option (Array MVarId)) :=
  saturate1 goal λ goal => do
    let r ← straightLineExtS goal
    if r.depth == 0 then
      return none
    else
      return r.goals.map (·.1)

@[aesop 80% tactic (index := [target _ = _]) (rule_sets := [builtin])]
def ext : RuleTac := RuleTac.ofSingleRuleTac λ input => do
  let (some goals, steps) ← extCore input.goal |>.run
    | throwError "found no applicable ext lemma"
  let goals ← goals.mapM (mvarIdToSubgoal (parentMVarId := input.goal) ·)
  return (goals, steps, none)

end Aesop.BuiltinRules



=== LEAN SOURCE: Intros.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg, Kyle Miller
-/

import Aesop.Frontend.Attribute

open Lean
open Lean.Meta

namespace Aesop.BuiltinRules

@[aesop norm -100 (rule_sets := [builtin])]
def intros : RuleTac := RuleTac.ofSingleRuleTac λ input => do
    let md? := input.options.introsTransparency?
    let ((goal, newFVarIds), steps) ←
      match md? with
      | none => introsS input.goal |>.run
      | some md => introsUnfoldingS input.goal md |>.run
    if newFVarIds.size == 0 then
      throwError "nothing to introduce"
    let addedFVars := newFVarIds.foldl (init := ∅) λ set fvarId =>
      set.insert fvarId
    let diff := {
      oldGoal := input.goal
      newGoal := goal
      addedFVars
      removedFVars := ∅
      targetChanged := .true
    }
    return (#[{ diff }], steps, none)

end Aesop.BuiltinRules



=== LEAN SOURCE: Rfl.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Frontend.Attribute

open Lean Lean.Elab.Tactic

namespace Aesop.BuiltinRules

@[aesop safe 0 (rule_sets := [builtin])]
def rfl : RuleTac :=
  RuleTac.ofTacticSyntax λ _ => `(tactic| rfl)

end Aesop.BuiltinRules



=== LEAN SOURCE: Split.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sebastian Ullrich, Jannis Limperg
-/

import Aesop.Frontend.Attribute

open Lean
open Lean.Meta

namespace Aesop.BuiltinRules

@[aesop (rule_sets := [builtin]) safe 100]
def splitTarget : RuleTac := RuleTac.ofSingleRuleTac λ input => do
  let (some goals, steps) ← splitTargetS? input.goal |>.run | throwError
    "nothing to split in target"
  let goals ← goals.mapM (mvarIdToSubgoal input.goal ·)
  return (goals, steps, none)

partial def splitHypothesesCore (goal : MVarId) :
    ScriptM (Option (Array MVarId)) :=
  withIncRecDepth do
  let some goals ← splitFirstHypothesisS? goal
    | return none
  let mut subgoals := #[]
  for g in goals do
    if let some subgoals' ← splitHypothesesCore g then
      subgoals := subgoals ++ subgoals'
    else
      subgoals := subgoals.push g
  return subgoals

@[aesop (rule_sets := [builtin]) safe 1000]
def splitHypotheses : RuleTac := RuleTac.ofSingleRuleTac λ input => do
  let (some goals, steps) ← splitHypothesesCore input.goal |>.run
    | throwError "no splittable hypothesis found"
  let goals ← goals.mapM (mvarIdToSubgoal input.goal ·)
  return (goals, steps, none)

end Aesop.BuiltinRules



=== LEAN SOURCE: Subst.lean ===
/-
Copyright (c) 2022--2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Frontend.Attribute
import Aesop.RuleTac.Forward.Basic

open Lean Lean.Meta Aesop.Script

namespace Aesop.BuiltinRules

def matchSubstitutableIff? (e : Expr) : Option (Expr × Expr) := do
  let some (lhs, rhs) := e.iff?
    | failure
  if lhs.isFVar || rhs.isFVar then
    return (lhs, rhs)
  else
    failure

def prepareIff? (mvarId : MVarId) (fvarId : FVarId) :
    ScriptM (Option (MVarId × FVarId)) :=
  mvarId.withContext do
    let ty ← fvarId.getType
    let some (lhs, rhs) ← matchHelper? ty (pure ∘ matchSubstitutableIff?)
      | return none
    let eqPrf ← mkPropExt (.fvar fvarId)
    let eqType ← mkEq lhs rhs
    let preState ← show MetaM _ from saveState
    let (newMVarId, newFVarId, clearSuccess) ←
      replaceFVarS mvarId fvarId eqType eqPrf
    if ! clearSuccess then
      preState.restore
      return none
    return some (newMVarId, newFVarId)

def prepareIffs (mvarId : MVarId) (fvarIds : Array FVarId) :
    ScriptM (MVarId × Array FVarId) := do
  let mut mvarId := mvarId
  let mut newFVarIds := Array.mkEmpty fvarIds.size
  for fvarId in fvarIds do
    if let some (newMVarId, newFVarId) ← prepareIff? mvarId fvarId then
      mvarId := newMVarId
      newFVarIds := newFVarIds.push newFVarId
    else
      newFVarIds := newFVarIds.push fvarId
  return (mvarId, newFVarIds)

def substEqs? (goal : MVarId) (fvarIds : Array FVarId) :
    ScriptM (Option MVarId) := do
  let preGoal := goal
  let preState ← show MetaM _ from saveState
  let userNames ← goal.withContext do fvarIds.mapM (·.getUserName)
  let mut goal := goal
  let mut substitutedUserNames := Array.mkEmpty userNames.size
  for userName in userNames do
    let ldecl ← goal.withContext $ getLocalDeclFromUserName userName
    if let some goal' ← subst? goal ldecl.fvarId then
      goal := goal'
      substitutedUserNames := substitutedUserNames.push userName
  if goal == preGoal then
    return none
  goal ← hideForwardImplDetailHyps goal -- HACK
  let postState ← show MetaM _ from saveState
  recordScriptStep {
    postGoals := #[goal]
    tacticBuilders := #[TacticBuilder.substFVars' substitutedUserNames]
    preGoal, preState, postState
  }
  return goal

def substEqsAndIffs? (goal : MVarId) (fvarIds : Array FVarId) :
    ScriptM (Option MVarId) := do
  let preState ← show MetaM _ from saveState
  let (goal, fvarIds) ← prepareIffs goal fvarIds
  if let some goal ← substEqs? goal fvarIds then
    return goal
  else
    preState.restore
    return none

@[aesop (rule_sets := [builtin]) norm -50 tactic (index := [hyp _ = _, hyp _ ↔ _])]
def subst : RuleTac := RuleTac.ofSingleRuleTac λ input =>
  input.goal.withContext do
    let hyps ← input.indexMatchLocations.toArray.mapM λ
      | .hyp ldecl => pure ldecl.fvarId
      | _ => throwError "unexpected index match location"
    let (some goal, steps) ← substEqsAndIffs? input.goal hyps |>.run
      | throwError "no suitable hypothesis found"
    -- TODO we can construct a better diff here, and doing so would be important
    -- since `subst` often renames fvars.
    let goal ← mvarIdToSubgoal input.goal goal
    return (#[goal], steps, none)

end Aesop.BuiltinRules



=== LEAN SOURCE: CompleteMatchQueue.lean ===
import Batteries.Data.BinomialHeap.Basic
import Aesop.Forward.Match

set_option linter.missingDocs true

namespace Aesop

open Batteries (BinomialHeap)

/-- A complete match queue. -/
abbrev CompleteMatchQueue := BinomialHeap ForwardRuleMatch ForwardRuleMatch.le

namespace CompleteMatchQueue

/-- Drop elements satisfying `f` from the front of `queue` until we reach
an element that does not satisfy `f` (or until the queue is empty). -/
partial def dropInitial (queue : CompleteMatchQueue)
    (f : ForwardRuleMatch → Bool) : CompleteMatchQueue :=
  match queue.deleteMin with
  | none => queue
  | some (m, queue') =>
    if f m then
      dropInitial queue' f
    else
      queue

end Aesop.CompleteMatchQueue



=== LEAN SOURCE: LevelIndex.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

namespace Aesop

structure LevelIndex where
  toNat : Nat
  deriving Inhabited, BEq, Hashable, DecidableEq, Ord

instance : LT LevelIndex where
  lt i j := i.toNat < j.toNat

instance : DecidableRel (α := LevelIndex) (· < ·) :=
  λ i j => inferInstanceAs $ Decidable (i.toNat < j.toNat)

instance : LE LevelIndex where
  le i j := i.toNat ≤ j.toNat

instance : DecidableRel (α := LevelIndex) (· ≤ ·) :=
  λ i j => inferInstanceAs $ Decidable (i.toNat ≤ j.toNat)

instance : ToString LevelIndex where
  toString i := toString i.toNat

end Aesop



=== LEAN SOURCE: Match.lean ===
/-
Copyright (c) 2024 Xavier Généreux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Xavier Généreux, Jannis Limperg
-/

import Aesop.Forward.Match.Types
import Aesop.Forward.PremiseIndex
import Aesop.Forward.SlotIndex
import Aesop.Rule
import Aesop.Rule.Forward
import Aesop.RuleTac.Descr
import Aesop.RuleTac.ElabRuleTerm
import Aesop.RuleTac.Forward.Basic
import Aesop.Script.SpecificTactics
import Batteries.Lean.Meta.UnusedNames
import Lean

set_option linter.missingDocs true

open Lean Lean.Meta

namespace Aesop

/-- Elaborate the term of a forward rule in the current goal. -/
def elabForwardRuleTerm (goal : MVarId) : RuleTerm → MetaM Expr
  | .const n => mkConstWithFreshMVarLevels n
  | .term stx =>
    (withFullElaboration $ elabRuleTermForApplyLikeMetaM goal stx).run'

namespace Match

/-- Create a one-element match. `subst` is the substitution that results from
matching a hypothesis against slot 0, or from a pattern substitution.
`isPatSubst` is `true` if the substitution resulted from a rule pattern.
`forwardDeps` are the forward dependencies of slot 0. `conclusionDeps` are the
conclusion dependencies of the rule to which this match belongs. -/
def initial (subst : Substitution) (isPatSubst : Bool)
    (forwardDeps conclusionDeps : Array PremiseIndex) : Match where
  subst := subst
  patInstSubsts := if isPatSubst then #[subst] else #[]
  level := ⟨0⟩
  forwardDeps := forwardDeps
  conclusionDeps := conclusionDeps

/-- Add a hyp or pattern substitution to the match. `subst` is the substitution
that results from matching a hypothesis against slot `m.level + 1`, or from the
pattern. `isPatSubst` is `true` if the substitution resulted from a pattern
substitution. `forwardDeps` are the forward dependencies of slot
`m.level + 1`. -/
def addHypOrPatSubst (subst : Substitution) (isPatSubst : Bool)
    (forwardDeps : Array PremiseIndex) (m : Match) : Match where
  subst := m.subst.mergeCompatible subst
  patInstSubsts :=
    if isPatSubst then m.patInstSubsts.push subst else m.patInstSubsts
  level := m.level + 1
  forwardDeps := forwardDeps
  conclusionDeps := m.conclusionDeps

/-- Returns `true` if the match contains the given hyp. -/
def containsHyp (hyp : FVarId) (m : Match) : Bool :=
  m.subst.premises.any (·.any (·.toExpr.containsFVar hyp))

/-- Returns `true` if the match contains the given pattern substitution. -/
def containsPatSubst (subst : Substitution) (m : Match) : Bool :=
  m.patInstSubsts.any (· == subst)

end Match

namespace CompleteMatch

/-- Given a complete match `m` for `r`, get arguments to `r` contained in the
match's slots and substitution. For non-immediate arguments, we return `none`.
The returned levels are suitable assignments for the level mvars of `r`. -/
def reconstructArgs (r : ForwardRule) (m : CompleteMatch) :
    Array (Option RPINF) × Array (Option Level) := Id.run do
  assert! m.clusterMatches.size == r.slotClusters.size
  let mut subst : Substitution := .empty r.numPremises r.numLevelParams
  for m in m.clusterMatches do
    subst := m.subst.mergeCompatible subst
  let mut args := Array.mkEmpty r.numPremises
  for i in [:r.numPremises] do
    args := args.push $ subst.find? ⟨i⟩
  let mut levels := Array.mkEmpty r.numLevelParams
  for i in [:r.numLevelParams] do
    levels := levels.push $ subst.findLevel? ⟨i⟩
  return (args, levels)

set_option linter.missingDocs false in
protected def toMessageData (r : ForwardRule) (m : CompleteMatch) :
    MessageData :=
  m!"{m.reconstructArgs r |>.1.map λ | none => m!"_" | some e => m!"{e}"}"

end CompleteMatch

namespace ForwardRuleMatch

instance : ToMessageData ForwardRuleMatch where
  toMessageData m := m!"{m.rule.name} {m.match.toMessageData m.rule}"

/-- Fold over the hypotheses contained in a match. -/
def foldHypsM [Monad M] (f : σ → FVarId → M σ) (init : σ)
    (m : ForwardRuleMatch) : M σ :=
  m.match.clusterMatches.foldlM (init := init) λ s cm =>
    cm.subst.premises.foldlM (init := s) λ
      | s, some { toExpr := e, .. } =>
        if let .fvar hyp := e.consumeMData then f s hyp else pure s
      | s, _ => pure s

/-- Fold over the hypotheses contained in a match. -/
def foldHyps (f : σ → FVarId → σ) (init : σ) (m : ForwardRuleMatch) : σ :=
  m.foldHypsM (M := Id) f init

/-- Returns `true` if any hypothesis contained in `m` satisfies `f`. -/
def anyHyp (m : ForwardRuleMatch) (f : FVarId → Bool) : Bool :=
  m.match.clusterMatches.any λ m =>
    m.subst.premises.any λ
      | some { toExpr := e, .. } =>
        if let .fvar hyp := e.consumeMData then f hyp else false
      | _ => false

/-- Get the hypotheses from the match whose types are propositions.  -/
def getPropHyps (m : ForwardRuleMatch) : MetaM (Array FVarId) :=
  m.foldHypsM (init := Array.mkEmpty m.rule.numPremises) λ hs h => do
    if ← isProof (.fvar h) then return hs.push h else return hs

/-- Construct the proof of the new hypothesis represented by `m`. -/
def getProof (goal : MVarId) (m : ForwardRuleMatch) : MetaM (Option Expr) :=
  withExceptionPrefix s!"while constructing a new hyp for forward rule {m.rule.name}:\n" do
  withConstAesopTraceNode .forward (return m!"proof construction for forward rule match") do
  goal.withContext do
  withNewMCtxDepth do
    aesop_trace[forward] "rule: {m.rule.name}"
    let e ← elabForwardRuleTerm goal m.rule.term
    let lmvars := collectLevelMVars {} e |>.result
    let eType ← instantiateMVars (← inferType e)
    aesop_trace[forward] "term: {e} : {eType}"
    let (argMVars, binderInfos, _) ← withReducible do
      forallMetaTelescope (← inferType e)
    if argMVars.size != m.rule.numPremises then
      throwError "rule term{indentExpr e}\nwith type{indentExpr eType}\n was expected to have {m.rule.numPremises} arguments, but has {argMVars.size}"
    if lmvars.size != m.rule.numLevelParams then
      throwError "rule term{indentExpr e}\nwith type{indentExpr eType}\n was expected to have {m.rule.numLevelParams} level metavariables, but has {lmvars.size}"
    let (args, levels) := m.match.reconstructArgs m.rule
    aesop_trace[forward] "args:   {args.map λ | none => m!"_" | some e => m!"{e}"}"
    aesop_trace[forward] "levels: {levels.map λ | none => m!"_" | some l => m!"{l}"}"
    for level? in levels, lmvarId in lmvars do
      if let some level := level? then
        assignLevelMVar lmvarId level
    for arg? in args, mvar in argMVars do
      if let some arg := arg? then
        mvar.mvarId!.assign arg.toExpr
    try
      synthAppInstances `aesop goal argMVars binderInfos
        (synthAssignedInstances := false) (allowSynthFailures := false)
    catch _ =>
      aesop_trace[forward] "instance synthesis failed"
      return none
    let result := (← abstractMVars $ mkAppN e argMVars).expr
    aesop_trace[forward] "result: {result}"
    return result

/-- Apply a forward rule match to a goal. This adds the hypothesis corresponding
to the match to the local context. Returns the new goal, the added hypothesis
and the hypotheses that were removed (if any). Hypotheses may be removed if the
match is for a `destruct` rule. If the `skip` function, when applied to the
normalised type of the new hypothesis, returns true, then the hypothesis is not
added to the local context. -/
def apply (goal : MVarId) (m : ForwardRuleMatch) (skip? : Option (RPINF → Bool)) :
    ScriptT BaseM (Option (MVarId × FVarId × Array FVarId)) :=
  withConstAesopTraceNode .forward (return m!"apply complete match") do
  goal.withContext do
    let name ← getUnusedUserName forwardHypPrefix
    let some prf ← m.getProof goal
      | return none
    let type ← inferType prf
    if let some skip := skip? then
      let doSkip ← withConstAesopTraceNode .forwardDebug (return m!"check whether hyp already exists") do
        let result := skip (← rpinf type)
        aesop_trace[forwardDebug] "already exists: {result}"
        pure result
      if doSkip then
        return none
    let hyp := { userName := name, value := prf, type }
    let (goal, #[hyp]) ← assertHypothesisS goal hyp (md := .default)
      | unreachable!
    if ! m.rule.destruct then
      return some (goal, hyp, #[])
    let usedPropHyps ← goal.withContext $ m.getPropHyps
    let (goal, _) ← tryClearManyS goal usedPropHyps
    return some (goal, hyp, usedPropHyps)

end ForwardRuleMatch

private def forwardRuleMatchesToRules? (ms : Array ForwardRuleMatch)
    (mkExtra? : ForwardRuleMatch → Option α) :
    Option (Array (Rule α)) := Id.run do
  let mut ruleMap : Std.HashMap RuleName (Array ForwardRuleMatch) := ∅
  for m in ms do
    let name := m.rule.name
    if let some ms := ruleMap[name]? then
      ruleMap := ruleMap.insert name (ms.push m)
    else
      ruleMap := ruleMap.insert name #[m]
  let mut result := Array.mkEmpty ruleMap.size
  for (name, ms) in ruleMap do
    let some extra := mkExtra? ms[0]!
      | return none
    result := result.push {
      indexingMode := .unindexed
      pattern? := none
      tac := .forwardMatches ms
      name, extra
    }
  return some result

/-- Convert forward rule matches to norm rules. Fails if any of the matches is
not a norm rule match.  -/
def forwardRuleMatchesToNormRules? (ms : Array ForwardRuleMatch) :
    Option (Array NormRule) :=
  forwardRuleMatchesToRules? ms
    (·.rule.prio.penalty?.map ({ penalty := · }))

/-- Convert forward rule matches to safe rules. Fails if any of the matches is
not a safe rule match. -/
def forwardRuleMatchesToSafeRules? (ms : Array ForwardRuleMatch) :
    Option (Array SafeRule) :=
  forwardRuleMatchesToRules? ms
    (·.rule.prio.penalty?.map ({ penalty := ·, safety := .safe }))

/-- Convert forward rule matches to unsafe rules. Fails if any of the matches
is not an unsafe rule match. -/
def forwardRuleMatchesToUnsafeRules? (ms : Array ForwardRuleMatch) :
    Option (Array UnsafeRule) :=
  forwardRuleMatchesToRules? ms
    (·.rule.prio.successProbability?.map ({ successProbability := · }))

end Aesop



=== LEAN SOURCE: PremiseIndex.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

namespace Aesop

structure PremiseIndex where
  toNat : Nat
  deriving Inhabited, BEq, Hashable, DecidableEq, Ord

instance : LT PremiseIndex where
  lt i j := i.toNat < j.toNat

instance : DecidableRel (α := PremiseIndex) (· < ·) :=
  λ i j => inferInstanceAs $ Decidable (i.toNat < j.toNat)

instance : LE PremiseIndex where
  le i j := i.toNat ≤ j.toNat

instance : DecidableRel (α := PremiseIndex) (· ≤ ·) :=
  λ i j => inferInstanceAs $ Decidable (i.toNat ≤ j.toNat)

instance : ToString PremiseIndex where
  toString i := toString i.toNat

end Aesop



=== LEAN SOURCE: RuleInfo.lean ===
/-
Copyright (c) 2024 Xavier Généreux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Xavier Généreux, Jannis Limperg
-/

import Aesop.Forward.PremiseIndex
import Aesop.Forward.SlotIndex
import Aesop.RulePattern
import Aesop.Util.Basic
import Aesop.Util.UnionFind

set_option linter.missingDocs true

open Lean Lean.Meta

namespace Aesop

/-- A slot represents a maximal premise of a forward rule, i.e. a premise with
no forward dependencies. The goal of forward reasoning is to assign a
hypothesis to each slot in such a way that the assignments agree on all
variables shared between them.

Exceptionally, a slot can also represent the rule pattern substitution. Rules
with a rule pattern have exactly one such slot, which is assigned an arbitrary
premise index. -/
structure Slot where
  /-- Discrimination tree keys for the type of this slot. If the slot is for the
  rule pattern, it is not associated with a premise, so doesn't have
  discrimination tree keys. -/
  typeDiscrTreeKeys? : Option (Array DiscrTree.Key)
  /-- Index of the slot. Slots are always part of a list of slots, and `index`
  is the 0-based index of this slot in that list. -/
  index : SlotIndex
  /-- 0-based index of the premise represented by this slot in the rule type.
  Note that the slots array may use a different ordering than the original
  order of premises, so we *don't* always have `index ≤ premiseIndex`. Rule
  pattern slots are assigned an arbitrary premise index. -/
  premiseIndex : PremiseIndex
  /-- The previous premises that the premise of this slot depends on. -/
  deps : Std.HashSet PremiseIndex
  /-- Common variables shared between this slot and the previous slots. -/
  common : Std.HashSet PremiseIndex
  /-- The forward dependencies of this slot. These are all the premises that
  appear in slots *after* this one. -/
  forwardDeps : Array PremiseIndex
  deriving Inhabited

local instance : BEq Slot :=
  ⟨λ s₁ s₂ => s₁.premiseIndex == s₂.premiseIndex⟩

local instance : Hashable Slot :=
  ⟨(hash ·.premiseIndex)⟩

/-- Information about the decomposed type of a forward rule. -/
structure ForwardRuleInfo where
  /-- The rule's number of premises. -/
  numPremises : Nat
  /-- The number of distinct level parameters and level metavariables occurring
  in the rule's type. We expect that these turn into level metavariables when
  the rule is elaborated. -/
  numLevelParams : Nat
  /-- Slots representing the maximal premises of the forward rule, partitioned
  into metavariable clusters. -/
  slotClusters : Array (Array Slot)
  /-- The premises that appear in the rule's conclusion. -/
  conclusionDeps : Array PremiseIndex
  /-- The rule's rule pattern and the premise index that was assigned to it. -/
  rulePatternInfo? : Option (RulePattern × PremiseIndex)
  deriving Inhabited

namespace ForwardRuleInfo

/-- Is this rule a constant rule (i.e., does it have neither premises nor a rule
pattern)? -/
def isConstant (r : ForwardRuleInfo) : Bool :=
  r.numPremises == 0 && r.rulePatternInfo?.isNone

/-- Construct a `ForwardRuleInfo` for the theorem `thm`. -/
def ofExpr (thm : Expr) (rulePattern? : Option RulePattern)
    (immediate : UnorderedArraySet PremiseIndex) : MetaM ForwardRuleInfo :=
  withNewMCtxDepth do
  let e ← instantiateMVars (← inferType thm)
  let numLevelParams :=
    (collectLevelParams {} e).params.size +
    (collectLevelMVars {} e).result.size
  let (premises, _, conclusion) ← withReducible $ forallMetaTelescope e
  let premises := premises.map (·.mvarId!)
  let mut premiseToIdx : Std.HashMap MVarId PremiseIndex := ∅
  for h : i in [:premises.size] do
    premiseToIdx := premiseToIdx.insert premises[i] ⟨i⟩
  let mut slots : Array Slot := Array.mkEmpty premises.size
  let mut allDeps : Std.HashSet PremiseIndex := ∅
  for h : i in [:premises.size] do
    let mvarId := premises[i]
    let typeDiscrTreeKeys ← mkDiscrTreePath (← mvarId.getType)
    let mut deps : Std.HashSet PremiseIndex := ∅
    for dep in ← mvarId.getMVarDependencies do
      if let some idx := premiseToIdx[dep]? then
        deps := deps.insert idx
    -- We update the `default` fields with correct info later.
    slots := slots.push {
      typeDiscrTreeKeys? := typeDiscrTreeKeys
      index := default
      premiseIndex := ⟨i⟩
      common := default
      forwardDeps := default
      deps
    }
    allDeps := allDeps.insertMany deps
  -- Slots are created only for premises which are maximal, i.e. which do not
  -- appear in any other premises, and which are not bound by the rule pattern.
  let patBoundPremises : Std.HashSet PremiseIndex :=
    rulePattern?.map (.ofArray $ ·.boundPremises.map (⟨·⟩)) |>.getD ∅
  slots := slots.filter λ s =>
    let idx := s.premiseIndex
    ! allDeps.contains idx && ! patBoundPremises.contains idx &&
    immediate.contains idx
  -- If the rule has a pattern, an additional slot is created for the rule
  -- pattern substitution. Again, we update the `default` fields with correct
  -- info later.
  if rulePattern?.isSome then
    slots := slots.push {
      typeDiscrTreeKeys? := none
      index := default
      premiseIndex := ⟨premises.size⟩
      common := default
      deps := patBoundPremises
      forwardDeps := default
    }
  -- Slots are clustered into metavariable clusters and sorted as indicated
  -- below.
  let slotClusters := cluster (·.deps.toArray) slots |>.map sortSlots
  -- The sorting ensures that for each slot in a cluster (except the first), the
  -- slot has some variables in common with the previous slots.
  assert! ! slotClusters.any λ cluster => cluster.any λ slot =>
    slot.index.toNat > 0 && slot.common.isEmpty
  let conclusionDeps := (← getMVars conclusion).filterMap (premiseToIdx[·]?)
  let rulePatternInfo? := rulePattern?.map (·, ⟨premises.size⟩)
  return {
    numPremises := premises.size
    slotClusters, rulePatternInfo?, conclusionDeps, numLevelParams
  }
where
  /-- Sort slots such that each slot has at least one variable in common with
  the previous slots. -/
  sortSlots (slots : Array Slot) : Array Slot := Id.run do
    if slots.isEmpty then
      panic! "empty slot cluster"
    -- Slots with more dependencies are preferred. In case of a tie, later slots
    -- are preferred since they tend to be more specific.
    have : Ord Slot := ⟨λ x y =>
      compareOn (·.deps.size) x y
      |>.then (compareOn (·.premiseIndex) x y)
    ⟩
    let firstSlot := slots.maxI
    let mut unseen := slots |>.erase firstSlot
    let firstSlotForwardDeps : Std.HashSet PremiseIndex :=
      unseen.foldl (init := ∅) λ deps s => deps.insertMany s.deps
    let firstSlot := {
      firstSlot with
      index := ⟨0⟩
      common := ∅
      forwardDeps := firstSlotForwardDeps.toArray
    }
    let mut newSlots := Array.mkEmpty slots.size |>.push firstSlot
    let mut previousDeps := firstSlot.deps
    let mut i := 1
    while newSlots.size != slots.size do
      let candidates := unseen.filter (·.deps.any (previousDeps.contains ·))
      let some slot := candidates.max?
        | panic! "no suitable slot found"
      unseen := unseen.erase slot
      let common := previousDeps.filter (slot.deps.contains ·)
      let forwardDeps : Std.HashSet PremiseIndex :=
        unseen.foldl (init := ∅) λ deps s => deps.insertMany s.deps
      let forwardDeps := forwardDeps.toArray
      newSlots := newSlots.push { slot with index := ⟨i⟩, common, forwardDeps }
      previousDeps := previousDeps.insertMany slot.deps
      i := i + 1
    return newSlots

end ForwardRuleInfo



=== LEAN SOURCE: SlotIndex.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

namespace Aesop

structure SlotIndex where
  toNat : Nat
  deriving Inhabited, BEq, Hashable, DecidableEq, Ord

instance : LT SlotIndex where
  lt i j := i.toNat < j.toNat

instance : DecidableRel (α := SlotIndex) (· < ·) :=
  λ i j => inferInstanceAs $ Decidable (i.toNat < j.toNat)

instance : LE SlotIndex where
  le i j := i.toNat ≤ j.toNat

instance : DecidableRel (α := SlotIndex) (· ≤ ·) :=
  λ i j => inferInstanceAs $ Decidable (i.toNat ≤ j.toNat)

instance : HAdd SlotIndex Nat SlotIndex where
  hAdd i j := ⟨i.toNat + j⟩

instance : HSub SlotIndex Nat SlotIndex where
  hSub i j := ⟨i.toNat - j⟩

instance : ToString SlotIndex where
  toString i := toString i.toNat

end Aesop



=== LEAN SOURCE: State.lean ===
/-
Copyright (c) 2024 Xavier Généreux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Xavier Généreux, Jannis Limperg
-/

import Aesop.Forward.Match

open Lean Lean.Meta
open ExceptToEmoji (toEmoji)

set_option linter.missingDocs true

namespace Aesop

private def ppPHashMap [BEq α] [Hashable α] [ToMessageData α]
    [ToMessageData β] (indent : Bool) (m : PHashMap α β) : MessageData :=
  flip MessageData.joinSep "\n" $
    m.foldl (init := []) λ xs a b =>
      let x :=
        if indent then
          m!"{a} =>{indentD $ toMessageData b}"
        else
          m!"{a} => {b}"
      x :: xs

private def ppPHashSet [BEq α] [Hashable α] [ToMessageData α] (s : PHashSet α) :
    MessageData :=
  toMessageData $ s.fold (init := #[]) λ as a => as.push a

/-- A hypothesis that has not yet been matched against a premise, or a rule
pattern substitution. -/
inductive RawHyp where
  /-- The hypothesis. -/
  | fvarId (fvarId : FVarId)
  /-- The rule pattern substitution. -/
  | patSubst (subst : Substitution)
  deriving Inhabited, BEq, Hashable

/-- A hypothesis that was matched against a premise, or a rule pattern
substitution. -/
structure Hyp where
  /-- The hypothesis, or `none` if this is a rule pattern substitution. -/
  fvarId? : Option FVarId
  /-- The substitution that results from matching the hypothesis against a
  premise or that was derived from the pattern. -/
  subst : Substitution
  deriving Inhabited

namespace Hyp

instance : BEq Hyp where
  beq h₁ h₂ :=
    match h₁.fvarId?, h₂.fvarId? with
    | some h₁, some h₂ => h₁ == h₂
    | none, none => h₁.subst == h₂.subst
    | _, _ => false

instance : Hashable Hyp where
  hash h :=
    match h.fvarId? with
    | some h => hash h
    | none => hash h.subst

/-- Returns `true` if `h` is the hyp `fvarId` or is a pattern substitution
containing `fvarId`. -/
def containsHyp (fvarId : FVarId) (h : Hyp) : Bool :=
  h.fvarId? == some fvarId || h.subst.containsHyp fvarId

/-- Does this `Hyp` represent a pattern substitution? -/
def isPatSubst (h : Hyp) : Bool :=
  h.fvarId?.isSome

end Hyp

set_option linter.missingDocs false in
/-- Partial matches associated with a particular slot instantiation. An entry
`s ↦ e ↦ (ms, hs)` indicates that for the instantiation `e` of slot `s`, we have
partial matches `ms` and hypotheses `hs`. -/
structure InstMap where
  map : PHashMap SlotIndex (PHashMap RPINF (PHashSet Match × PHashSet Hyp))
  deriving Inhabited

namespace InstMap

instance : EmptyCollection InstMap := ⟨⟨.empty⟩⟩

instance : ToMessageData InstMap where
  toMessageData m :=
    ppPHashMap (indent := true) $
      m.map.map λ instMap =>
        ppPHashMap (indent := false) $
          instMap.map λ (ms, hs) =>
            let hs : Array MessageData :=
              hs.fold (init := #[]) λ hs (h : Hyp) =>
                match h.fvarId? with
                | none => hs.push m!"{h.subst}"
                | some fvarId => hs.push m!"{Expr.fvar fvarId}"
            m!"{(ppPHashSet ms, hs)}"

/-- Returns the set of matches and hypotheses associated with a slot `slot`
with instantiation `inst`. -/
@[inline]
def find? (imap : InstMap) (slot : SlotIndex) (inst : RPINF) :
    Option (PHashSet Match × PHashSet Hyp) :=
  imap.map.find? slot |>.bind λ slotMap => slotMap.find? inst

/-- Returns the set of matches and hypotheses associated with a slot `slot`
with instantiation `inst`, or `(∅, ∅)` if `slot` and `inst` do not have any
associated matches. -/
@[inline]
def findD (imap : InstMap) (slot : SlotIndex) (inst : RPINF) :
    PHashSet Match × PHashSet Hyp :=
  imap.find? slot inst |>.getD (∅, ∅)

/-- Applies a transfomation to the data associated to `slot` and `inst`.
If there is no such data, the transformation is applied to `(∅, ∅)`. Returns the
new instantiation map and the result of `f`. -/
def modify (imap : InstMap) (slot : SlotIndex) (inst : RPINF)
    (f : PHashSet Match → PHashSet Hyp → PHashSet Match × PHashSet Hyp × α) :
    InstMap × α :=
  let (ms, hyps) := imap.findD slot inst
  let (ms, hyps, a) := f ms hyps
  let slotMap := imap.map.findD slot .empty |>.insert inst (ms, hyps)
  (⟨imap.map.insert slot slotMap⟩, a)

/-- Inserts a hyp associated with slot `slot` and instantiation `inst`.
The hyp must be a valid assignment for the slot's premise. Returns `true` if
the hyp was not previously associated with `slot` and `inst`. -/
def insertHyp (imap : InstMap) (slot : SlotIndex) (inst : RPINF) (hyp : Hyp) :
    InstMap × Bool :=
  imap.modify slot inst λ ms hs =>
    if hs.contains hyp then
      (ms, hs, false)
    else
      (ms, hs.insert hyp, true)

/-- Inserts a match associated with slot `slot` and instantiation `inst`.
The match's level must be `slot`. Returns `true` if the match was not previously
associated with `slot` and `inst`. -/
def insertMatchCore (imap : InstMap) (slot : SlotIndex) (inst : RPINF)
    (m : Match) : InstMap × Bool :=
  imap.modify slot inst λ ms hs =>
    if ms.contains m then
      (ms, hs, false)
    else
      (ms.insert m, hs, true)

/-- Inserts a match. The match `m` is associated with the slot given by its
level (i.e., the maximal slot for which `m` contains a hypothesis) and the
instantiation of `var` given by the map's substitution. Returns `true` if the
match was not previously associated with this slot and instantiation. -/
def insertMatch (imap : InstMap) (var : PremiseIndex) (m : Match) :
    InstMap × Bool := Id.run do
  let some inst := m.subst.find? var
    | panic! s!"variable {var} is not assigned in substitution"
  imap.insertMatchCore m.level inst m

/-- Modify the maps for slot `slot` and all later slots. -/
def modifyMapsForSlotsFrom (imap : InstMap) (slot : SlotIndex)
    (f : PHashSet Match → PHashSet Hyp → (PHashSet Match × PHashSet Hyp)) :
    InstMap := Id.run do
  let mut imaps := imap.map
  -- TODO Could remove this fold by passing the number of slots to this function.
  let nextSlots : Array SlotIndex :=
    imap.map.foldl (init := #[]) λ acc slot' _ =>
      if slot ≤ slot' then acc.push slot' else acc
  for i in nextSlots do
    let maps := imap.map.find! i |>.map λ (ms, hs) => f ms hs
    imaps := imaps.insert i maps
  return { map := imaps }

/-- Remove `hyp` from `slot` and all later slots. For each mapping
`s ↦ e ↦ (ms, hs)` in `imap`, if `s ≥ slot`, then `hyp` is removed from `hs` and
any matches containing `hyp` are removed from `ms`. -/
def eraseHyp (imap : InstMap) (hyp : FVarId) (slot : SlotIndex) :
    InstMap :=
  imap.modifyMapsForSlotsFrom slot λ ms hs =>
    let ms := PersistentHashSet.filter (! ·.containsHyp hyp) ms
    let hs := hs.erase { fvarId? := hyp, subst := default }
    (ms, hs)

/-- Remove the pattern substitution `subst` from `slot` and all later slots.
For each mapping `s ↦ e ↦ (ms, hs)` in `imap`, if `s ≥ slot`, then `subst` is
removed from `hs` and any matches containing `subst` are removed from `ms`. -/
def erasePatSubst (imap : InstMap) (subst : Substitution) (slot : SlotIndex) :
    InstMap :=
  imap.modifyMapsForSlotsFrom slot λ ms hs =>
    let ms := PersistentHashSet.filter (! ·.containsPatSubst subst) ms
    let hs := hs.erase { fvarId? := none, subst }
    (ms, hs)

end InstMap

set_option linter.missingDocs false in
/-- Map from variables to the matches and hypotheses of slots whose types
contain the variables. -/
structure VariableMap where
  map : PHashMap PremiseIndex InstMap
  deriving Inhabited

namespace VariableMap

instance : EmptyCollection VariableMap :=
  ⟨⟨.empty⟩⟩

instance : ToMessageData VariableMap where
  toMessageData m := ppPHashMap (indent := true) m.map

/-- Get the `InstMap` associated with a variable. -/
def find? (vmap : VariableMap) (var : PremiseIndex) : Option InstMap :=
  vmap.map.find? var

/-- Get the `InstMap` associated with a variable, or an empty `InstMap`. -/
def find (vmap : VariableMap) (var : PremiseIndex) : InstMap :=
  vmap.find? var |>.getD ∅

/-- Modify the `InstMap` associated to variable `var`. If no such `InstMap`
exists, the function `f` is applied to the empty `InstMap` and the result is
associated with `var`. Returns the new variable map and the result of `f`. -/
def modify (vmap : VariableMap) (var : PremiseIndex) (f : InstMap → InstMap × α) :
    VariableMap × α :=
  match vmap.map.find? var with
  | none =>
    let (m, a) := f ∅
    (⟨vmap.map.insert var m⟩, a)
  | some m =>
    let (m, a) := f m
    (⟨vmap.map.insert var m⟩, a)

/-- Add a hypothesis `hyp`. Precondition: `hyp` matches the premise of slot
`slot` with substitution `hyp.subst` (and hence `hyp.subst` contains a mapping
for each variable in `slot.common`). Returns `true` if the variable map
changed. -/
def addHyp (vmap : VariableMap) (slot : Slot) (hyp : Hyp) : VariableMap × Bool :=
  slot.common.fold (init := (vmap, false)) λ (vmap, changed) var =>
    if let some inst := hyp.subst.find? var then
      let (vmap, changed') := vmap.modify var (·.insertHyp slot.index inst hyp)
      (vmap, changed || changed')
    else
      panic! s!"substitution contains no instantiation for variable {var}"

/-- Add a match `m`. Precondition: `nextSlot` is the slot with index
`m.level + 1`. Returns `true` if the variable map changed. -/
def addMatch (vmap : VariableMap) (nextSlot : Slot) (m : Match) :
    VariableMap × Bool :=
  nextSlot.common.fold (init := (vmap, false)) λ (vmap, changed) var =>
    let (vmap, changed') := vmap.modify var (·.insertMatch var m)
    (vmap, changed || changed')

/-- Remove a hyp from `slot` and all later slots. -/
def eraseHyp (vmap : VariableMap) (hyp : FVarId) (slot : SlotIndex) :
    VariableMap :=
  ⟨vmap.map.map (·.eraseHyp hyp slot)⟩

/-- Remove the pattern substitution `subst` from `slot` and all later slots. -/
def erasePatSubst (vmap : VariableMap) (subst : Substitution) (slot : SlotIndex) :
    VariableMap :=
  ⟨vmap.map.map (·.erasePatSubst subst slot)⟩

/-- Find matches in slot `slot - 1` whose substitutions are compatible with
`subst`. Preconditions: `slot.index` is nonzero, `slot.common` is nonempty and
each variable contained in `slot.common` is also contained in `subst`. -/
def findMatches (vmap : VariableMap) (slot : Slot) (subst : Substitution) :
    Std.HashSet Match := Id.run do
  if slot.index == ⟨0⟩ then
    panic! "slot has index 0"
  let common := slot.common.toArray
  if h : 0 < common.size then
    let firstVar := common[0]
    let mut ms := prevSlotMatches firstVar |> PersistentHashSet.toHashSet
    for var in common[1:] do
      if ms.isEmpty then
        break
      let ms' := prevSlotMatches var
      ms := ms.filter (ms'.contains ·)
    return ms
  else
    panic! "no common variables"
where
  prevSlotMatches (var : PremiseIndex) : PHashSet Match :=
    if let some inst := subst.find? var then
      vmap.find var |>.findD (slot.index - 1) inst |>.1
    else
      panic! s!"substitution contains no instantiation for variable {var}"

/-- Find hyps in `slot` whose substitutions are compatible with `subst`.
Precondition: `slot.common` is nonempty and each variable contained in it is
also contained in `subst`. -/
def findHyps (vmap : VariableMap) (slot : Slot) (subst : Substitution) :
    Std.HashSet Hyp := Id.run do
  let common := slot.common.toArray
  if h : 0 < common.size then
    let mut hyps := slotHyps common[0] |> PersistentHashSet.toHashSet
    for var in common[1:] do
      if hyps.isEmpty then
        break
      let hyps' := slotHyps var
      hyps := hyps.filter (hyps'.contains ·)
    return hyps
  else
    panic! "no common variables"
where
  slotHyps (var : PremiseIndex) : PHashSet Hyp :=
    if let some inst := subst.find? var then
      vmap.find var |>.findD slot.index inst |>.2
    else
      panic! s!"substitution contains no instantiation for variable {var}"

end VariableMap

/-- Structure representing the state of a slot cluster. -/
structure ClusterState where
  /-- The cluster's slots. -/
  slots : Array Slot
  /-- The premises that appear in the rule's conclusion. These are the same for
  all cluster states of a rule, but are stored here for convenience. -/
  conclusionDeps : Array PremiseIndex
  /-- The variable map for this cluster. -/
  variableMap : VariableMap
  /-- Complete matches for this cluster. -/
  completeMatches : PHashSet Match
  /-- When this flag is `true`, hyps are added to the `slotQueues` rather than
  the `variableMap`. This is an optimisation that avoids performing unifications
  until a rule can potentially generate a complete match. More precisely:

  - `addHypsLazily` is initially set to `true`.
  - While `addHypsLazily` is `true`, hyps are added to (and deleted from) the
    `slotQueues` and are not added to the `variableMap`.
    Once an addition causes all slot queues to have at least one element,
    `addHypsLazily` is permanently set to `false` and hyps for slot 0 are added
    to the `variableMap`.
  - While `addHypsLazily` is `false`:
    - Hyps for slot `i` are added directly to the variable maps if `i = 0` or
      the slot `i - 1` has matches. Otherwise they are added to the slot queue
      for `i`. (More precisely, we only track whether slot `i - 1` has had
      matches at some point. This allows us to ignore deletions.)
    - The insertion of a match into slot `i` causes all hyps at slot `i + 1`
      to be moved from the slot queue into the `variableMap`.
  -/
  addHypsLazily : Bool
  /-- Hypotheses or pattern substitutions that have been added to the cluster
  state, but have not yet been added to the `variableMap`. -/
  slotQueues : Array (Array RawHyp)
  /-- There is exactly one queue for each slot. -/
  slotQueues_size : slotQueues.size = slots.size
  /-- The `i`th element of this array is `true` if a match was at some point
  added to slot `i`. -/
  slotMaybeHasMatches : Array Bool
  /-- There is exactly one boolean for each slot. -/
  slotMaybeHasMatches_size : slotMaybeHasMatches.size = slots.size

namespace ClusterState

instance : Inhabited ClusterState where
  default := by refine' {
    slots := #[]
    slotQueues := #[]
    slotQueues_size := by simp
    slotMaybeHasMatches := #[]
    slotMaybeHasMatches_size := by simp
    ..
  } <;> exact default

instance : ToMessageData ClusterState where
  toMessageData cs :=
    m!"variables:{indentD $ toMessageData cs.variableMap}\n\
       complete matches:{indentD $ .joinSep (PersistentHashSet.toList cs.completeMatches |>.map toMessageData) "\n"}"

/-- Get the slot with the given index. Panic if the index is invalid. -/
@[macro_inline, always_inline]
def slot! (cs : ClusterState) (slot : SlotIndex) : Slot :=
  cs.slots[slot.toNat]!

/-- Get the slot with the given premise index. -/
def findSlot? (cs : ClusterState) (i : PremiseIndex) : Option Slot :=
  cs.slots.find? (·.premiseIndex == i)

/-- Match hypothesis `hyp` against the slot with index `slot` in `cs` (which
must be a valid index). -/
def matchPremise? (premises : Array MVarId) (lmvarIds : Array LMVarId)
    (cs : ClusterState) (slot : SlotIndex) (hyp : FVarId) :
    BaseM (Option Substitution) := do
  let some slot := cs.slots[slot.toNat]?
    | throwError "aesop: internal error: matchPremise?: no slot with index {slot}"
  let premiseIdx := slot.premiseIndex.toNat
  let some slotPremise := premises[premiseIdx]?
    | throwError "aesop: internal error: matchPremise?: slot with premise index {premiseIdx}, but only {premises.size} premises"
  let premiseType ← slotPremise.getType
  let hypType ← hyp.getType
  withAesopTraceNodeBefore .forward (return m!"match against premise {premiseIdx}: {hypType} ≟ {premiseType}") do
  withoutModifyingState do
    let isDefEq ←
      withConstAesopTraceNode .forwardDebug (return m!"defeq check") do
      withReducible do
        isDefEq premiseType hypType
    if isDefEq then
      let mut subst := .empty premises.size lmvarIds.size
      for var in slot.deps do
        subst ← updateSubst premises var subst
      subst := subst.insert slot.premiseIndex $ ← rpinf (.fvar hyp)
      for h : i in [:lmvarIds.size] do
        if let some l ← getLevelMVarAssignment? lmvarIds[i] then
          subst := subst.insertLevel ⟨i⟩ (← instantiateLevelMVars l)
      aesop_trace[forward] "substitution: {subst}"
      return subst
    else
      return none
where
  updateSubst (premises : Array MVarId) (var : PremiseIndex)
      (subst : Substitution) : BaseM Substitution :=
    withConstAesopTraceNode .forwardDebug (return m!"update var {var}") do
      let some varMVarId := premises[var.toNat]?
        | throwError "aesop: internal error: matchPremise?: dependency with index {var}, but only {premises.size} premises"
      let mvar := .mvar varMVarId
      let assignment ← instantiateMVars mvar
      if assignment == mvar then
        throwError "aesop: internal error: matchPremise?: while matching hyp {hyp.name}: no assignment for variable {var}"
      if ← hasAssignableMVar assignment then
        throwError "aesop: internal error: matchPremise?: assignment has mvar:{indentExpr assignment}"
      let assignment ← rpinf assignment
      return subst.insert var assignment

/-- Context for the `AddM` monad. -/
structure AddM.Context where
  /-- Metavariables for the premises of the rule for which a hyp or match is
  being added. When adding hyps, they are unified with these metavariables. -/
  premiseMVars : Array MVarId
  /-- Metavariables for level parameters appearing in the rule's premises. -/
  premiseLMVars : Array LMVarId

/-- A monad for operations that add hyps or matches to a cluster state. The
monad's state is an array of complete matches discovered while adding
hyps/matches. -/
abbrev AddM := ReaderT AddM.Context $ StateRefT (Array Match) $ BaseM

/-- Run an `AddM` action. -/
def AddM.run (premiseMVars : Array MVarId) (premiseLMVars : Array LMVarId)
    (x : AddM α) : BaseM (α × Array Match) :=
  ReaderT.run x { premiseMVars, premiseLMVars } |>.run #[]

mutual
  /-- Add a match to the cluster state. Returns the new cluster state and any new
  complete matches for this cluster. -/
  partial def addMatch (cs : ClusterState) (m : Match) : AddM ClusterState := do
    let mut cs := cs
    let slotIdx := m.level
    if slotIdx.toNat == cs.slots.size - 1 then
      if cs.completeMatches.contains m then
        aesop_trace[forward] "complete match {m} already present"
        return cs
      else
        cs := { cs with completeMatches := cs.completeMatches.insert m }
        modify (·.push m)
        return cs
    else
      let nextSlot := cs.slot! $ slotIdx + 1
      aesop_trace[forward] "add match {m} for slot {slotIdx}"
      let (vmap, changed) := cs.variableMap.addMatch nextSlot m  -- This is correct; VariableMap.addMatch needs the next slot.
      if ! changed then
        aesop_trace[forward] "match already present"
        return cs
      cs := {
        cs with
        variableMap := vmap
        slotMaybeHasMatches := cs.slotMaybeHasMatches.set! slotIdx.toNat true
        slotMaybeHasMatches_size := by simp [cs.slotMaybeHasMatches_size]
      }
      cs ← cs.addQueuedRawHyps nextSlot
      for hyp in cs.variableMap.findHyps nextSlot m.subst do
        let m := m.addHypOrPatSubst hyp.subst hyp.isPatSubst nextSlot.forwardDeps
        cs ← cs.addMatch m
      return cs

  /-- Add a hypothesis to the cluster state. `hyp.subst` must be the substitution
  that results from applying `h` to `slot`. -/
  partial def addHyp (cs : ClusterState) (slot : Slot) (h : Hyp) :
      AddM ClusterState := do
    withConstAesopTraceNode .forward (return m!"add hyp or pattern inst for slot {slot.index} with substitution {h.subst}") do
    if slot.index.toNat == 0 then
      let m :=
        Match.initial h.subst h.isPatSubst (forwardDeps := slot.forwardDeps)
          (conclusionDeps := cs.conclusionDeps)
      cs.addMatch m
    else
      let (vmap, changed) := cs.variableMap.addHyp slot h
      if ! changed then
        aesop_trace[forward] "hyp already present"
        return cs
      let mut cs := { cs with variableMap := vmap }
      for pm in cs.variableMap.findMatches slot h.subst do
        let m := pm.addHypOrPatSubst h.subst h.isPatSubst slot.forwardDeps
        cs ← cs.addMatch m
      return cs

  /-- Add a hypothesis or pattern substitution to the cluster state. -/
  partial def addRawHypCore (h : RawHyp) (slot : Slot) (cs : ClusterState) :
      AddM ClusterState :=
    match h with
    | .fvarId fvarId =>
      withConstAesopTraceNode .forwardDebug (return m!"add hyp {Expr.fvar fvarId} ({fvarId.name}) to slot {slot.index}") do
        let some subst ←
          cs.matchPremise? (← read).premiseMVars (← read).premiseLMVars
            slot.index fvarId
          | return cs
        cs.addHyp slot { fvarId? := fvarId, subst }
    | .patSubst subst =>
      withConstAesopTraceNode .forwardDebug (return m!"add pattern subst {subst} to slot {slot.index}") do
        cs.addHyp slot { fvarId? := none, subst }

  /-- Insert the raw hyps from `slot`'s queue into the variable map. -/
  partial def addQueuedRawHyps (slot : Slot) (cs : ClusterState) :
      AddM ClusterState :=
    withConstAesopTraceNode .forward (return m!"add queued hyps for slot {slot.index}") do
      let cs ← cs.slotQueues[slot.index.toNat]!.foldlM (init := cs) λ cs h =>
        cs.addRawHypCore h slot
      return {
        cs with
        slotQueues := cs.slotQueues.set! slot.index.toNat #[]
        slotQueues_size := by simp [cs.slotQueues_size]
      }
end

/-- Add a hypothesis or pattern substitution to the queue for its slot. If
afterwards each slot queue contains at least one element, then the returned
cluster state `cs` has `cs.addHypsLazily = false`. -/
def enqueueRawHyp (h : RawHyp) (slot : Slot) (cs : ClusterState) :
    ClusterState := Id.run do
  let mut cs := {
    cs with
    slotQueues := cs.slotQueues.modify slot.index.toNat (·.push h)
    slotQueues_size := by simp [cs.slotQueues_size]
  }
  if cs.slotQueues.all (·.size > 0) then
    cs := { cs with addHypsLazily := false }
  return cs

/-- Add a hypothesis or pattern substitution to the cluster state. If a
hypothesis is given and its type does not match the premise corresponding to
`slot`, it is not added. -/
def addRawHyp (cs : ClusterState) (i : PremiseIndex) (h : RawHyp) :
    AddM ClusterState := do
  let some slot := cs.findSlot? i
    | return cs
  if cs.addHypsLazily then
    let cs := cs.enqueueRawHyp h slot
    if ! cs.addHypsLazily then
      cs.addQueuedRawHyps (cs.slot! ⟨0⟩)
    else
      return cs
  else if slot.index.toNat == 0 || cs.slotMaybeHasMatches[slot.index.toNat - 1]! then
    cs.addRawHypCore h slot
  else
    return cs.enqueueRawHyp h slot

/-- Erase a `RawHyp` from the slot queue of the given slot. -/
def eraseEnqueuedRawHyp (h : RawHyp) (slot : Slot) (cs : ClusterState) :
    ClusterState := {
  cs with
  slotQueues := cs.slotQueues.modify slot.index.toNat λ q => q.erase h
  slotQueues_size := by simp [cs.slotQueues_size]
}

private def filterPHashSet [BEq α] [Hashable α] (p : α → Bool)
    (s : PHashSet α) : PHashSet α :=
  let toDelete := s.fold (init := #[]) λ toDelete a =>
    if p a then toDelete else toDelete.push a
  toDelete.foldl (init := s) λ s a => s.erase a

/-- Erase a hypothesis from the cluster state's variable map. -/
def eraseHyp (h : FVarId) (pi : PremiseIndex) (cs : ClusterState) :
    ClusterState := Id.run do
  let some slot := cs.findSlot? pi
    | return cs
  if cs.addHypsLazily then
    return cs.eraseEnqueuedRawHyp (.fvarId h) slot
  else
    return {
      cs with
      variableMap := cs.variableMap.eraseHyp h slot.index
      completeMatches := filterPHashSet (! ·.containsHyp h) cs.completeMatches
      -- TODO inefficient: complete matches should only be filtered once
    }

/-- Erase a pattern substitution from the cluster state. -/
def erasePatSubst (subst : Substitution) (pi : PremiseIndex) (cs : ClusterState) :
    ClusterState := Id.run do
  let some slot := cs.findSlot? pi
    | return cs
  if cs.addHypsLazily then
    return cs.eraseEnqueuedRawHyp (.patSubst subst) slot
  else
    return {
      cs with
      variableMap := cs.variableMap.erasePatSubst subst slot.index
      completeMatches := filterPHashSet (! ·.containsPatSubst subst) cs.completeMatches
    }

end ClusterState

/-- The source of a pattern substitution. The same substitution can have
multiple sources. -/
inductive PatSubstSource
  /-- The pattern substitution came from the given hypothesis. -/
  | hyp (fvarId : FVarId)
  /-- The pattern substitution came from the goal's target. -/
  | target
  deriving Inhabited, Hashable, BEq

/-- Forward state for one rule. -/
structure RuleState where
  /-- The rule to which this state belongs. -/
  rule : ForwardRule
  /-- States for each of the rule's slot clusters. -/
  clusterStates : Array ClusterState
  /-- The sources of all pattern substitutions present in the
  `clusterStates`. Invariant: each pattern substitution in the cluster states
  is associated with a nonempty set. -/
  patSubstSources : PHashMap Substitution (PHashSet PatSubstSource)
  deriving Inhabited

instance : ToMessageData RuleState where
  toMessageData rs :=
    flip MessageData.joinSep "\n" $
      rs.clusterStates.toList.mapIdx λ i cs =>
        m!"cluster {i}:{indentD $ toMessageData cs}"

/-- The initial (empty) rule state for a given forward rule. -/
def ForwardRule.initialRuleState (r : ForwardRule) : RuleState :=
  let clusterStates := r.slotClusters.map λ slots => {
    variableMap := ∅
    completeMatches := {}
    conclusionDeps := r.conclusionDeps
    slotQueues := .replicate slots.size #[]
    slotQueues_size := by simp
    slotMaybeHasMatches := .replicate slots.size false
    slotMaybeHasMatches_size := by simp
    addHypsLazily := true
    slots
  }
  { rule := r, clusterStates, patSubstSources := {} }

namespace RuleState

/-- Add a hypothesis or pattern substitution to the rule state. Returns the new
rule state and any newly completed matches. If a hypothesis is given and it does
not match premise `pi`, nothing happens. -/
def addRawHyp (goal : MVarId) (h : RawHyp) (pi : PremiseIndex) (rs : RuleState) :
    BaseM (RuleState × Array CompleteMatch) :=
  withNewMCtxDepth do
    -- TODO We currently open the rule expression also if `h` is a pattern
    -- substitution, which is unnecessary.
    let some ruleExpr ←
      withConstAesopTraceNode .forwardDebug (return m!"elab rule term") do
        show MetaM _ from observing? $ elabForwardRuleTerm goal rs.rule.term
      | return (rs, #[])
    let lmvars := collectLevelMVars {} ruleExpr |>.result
    if lmvars.size != rs.rule.numLevelParams then
      aesop_trace[forward] "failed to add hyp or pat inst: rule term{indentD $ toMessageData rs.rule.term}\ndoes not have expected number of level mvars {rs.rule.numLevelParams}"
      return (rs, #[])
    let ruleType ← instantiateMVars (← inferType ruleExpr)
    let (premises, _, _) ←
      withConstAesopTraceNode .forwardDebug (return m!"open rule term") do
      withReducible do
        forallMetaTelescope ruleType
    if premises.size != rs.rule.numPremises then
      aesop_trace[forward] "failed to add hyp or pat inst: rule term{indentD $ toMessageData rs.rule.term}\ndoes not have expected number of premises {rs.rule.numPremises}"
      return (rs, #[])
    let premises := premises.map (·.mvarId!)
    let mut rs := rs
    let mut clusterStates := rs.clusterStates
    let mut completeMatches := #[]
    for i in [:clusterStates.size] do
      let cs := clusterStates[i]!
      let (cs, newCompleteMatches) ← cs.addRawHyp pi h |>.run premises lmvars
      clusterStates := clusterStates.set! i cs
      completeMatches ←
        withConstAesopTraceNode .forwardDebug (return m!"construct new complete matches") do
          return completeMatches ++
                 getCompleteMatches clusterStates i newCompleteMatches
    return ({ rs with clusterStates }, completeMatches)
where
  getCompleteMatches (clusterStates : Array ClusterState) (clusterIdx : Nat)
      (newCompleteMatches : Array Match) :
      Array CompleteMatch := Id.run do
    if newCompleteMatches.isEmpty ||
       clusterStates.any (·.completeMatches.isEmpty) then
      return #[]
    else
      let mut completeMatches := #[]
      for h : i in [:clusterStates.size] do
        completeMatches :=
          if i == clusterIdx then
            addMatches completeMatches newCompleteMatches
          else
            addMatches completeMatches $
              PersistentHashSet.toArray clusterStates[i].completeMatches
      return completeMatches

  addMatches (completeMatches : Array CompleteMatch)
      (clusterMatches : Array Match) : Array CompleteMatch := Id.run do
    if completeMatches.isEmpty then
      return clusterMatches.map ({ clusterMatches := #[·] })
    else
      let mut newCompleteMatches :=
        Array.mkEmpty (completeMatches.size * clusterMatches.size)
      for completeMatch in completeMatches do
        for clusterMatch in clusterMatches do
          newCompleteMatches := newCompleteMatches.push
            { clusterMatches := completeMatch.clusterMatches.push clusterMatch }
      return newCompleteMatches

/-- Erase a pattern substitution that was obtained from the given source. -/
def erasePatSubst (subst : Substitution) (source : PatSubstSource)
    (rs : RuleState) : RuleState := Id.run do
  let some sources := rs.patSubstSources[subst]
    | panic! s!"unknown pattern substitution {subst.premises} for rule {rs.rule.name}"
  let sources := sources.erase source
  if sources.isEmpty then
    let some (pat, patPremiseIdx) := rs.rule.rulePatternInfo?
      | panic! s!"rule {rs.rule.name} does not have a pattern"
    let some csIdx := rs.clusterStates.findIdx? λ cs =>
      cs.findSlot? patPremiseIdx |>.isSome
      | panic! s!"pattern slot {patPremiseIdx} not found for rule {rs.rule.name}"
    return {
      rs with
      clusterStates := rs.clusterStates.modify csIdx λ cs =>
        cs.erasePatSubst subst patPremiseIdx
      patSubstSources := rs.patSubstSources.erase subst
    }
  else
    return { rs with patSubstSources := rs.patSubstSources.insert subst sources }

/-- Erase a hypothesis from the rule state. -/
def eraseHyp (h : FVarId) (pi : PremiseIndex) (rs : RuleState) : RuleState :=
  let clusterStates := rs.clusterStates.map (·.eraseHyp h pi)
  { rs with clusterStates }

end RuleState

/-- State representing the non-complete matches of a given set of forward rules
in a given local context. -/
structure ForwardState where
  /-- Map from each rule's name to its `RuleState`-/
  ruleStates : PHashMap RuleName RuleState
  /-- A map from hypotheses to the rules and premises that they matched against
  when they were initially added to the rule state. Invariant: the rule states
  in which a hypothesis `h` appear are exactly those identified by the rule
  names in `hyps[h]`. Furthermore, `h` only appears in slots with premise
  indices greater than or equal to those in `hyps[h]`. -/
  hyps : PHashMap FVarId (PArray (RuleName × PremiseIndex))
  /-- The pattern substitutions present in the rule states. Invariant:
  `patSubsts` maps the source `s` to a rule name `r` and pattern substitution `i`
  iff the rule state of `r` contains `i` with source `s`. -/
  patSubsts : PHashMap PatSubstSource (PArray (RuleName × Substitution))
  /-- Normalised types of all non-implementation detail hypotheses in the
  local context. -/
  hypTypes : PHashSet RPINF
 deriving Inhabited

namespace ForwardState

instance : EmptyCollection ForwardState where
  emptyCollection := by refine' {..} <;> exact .empty

instance : ToMessageData ForwardState where
  toMessageData fs :=
    flip MessageData.joinSep "\n" $
      fs.ruleStates.foldl (init := []) λ result r rs =>
        m!"{r}:{indentD $ toMessageData rs}" :: result

private def addForwardRuleMatches (acc : Array ForwardRuleMatch)
    (r : ForwardRule) (completeMatches : Array CompleteMatch) :
    MetaM (Array ForwardRuleMatch) := do
  let ruleMatches :=
    completeMatches.foldl (init := acc) λ ruleMatches «match» =>
      ruleMatches.push { rule := r, «match» }
  aesop_trace[forward] do
    for m in ruleMatches do
      aesop_trace![forward] "new complete match for {m.rule.name}:{indentD $ toMessageData m}"
  return ruleMatches

/-- Add a hypothesis to the forward state. If `fs` represents a local context
`lctx`, then `fs.addHyp h ms` represents `lctx` with `h` added. `ms` must
overapproximate the rules for which `h` may unify with a maximal premise. -/
def addHypCore (ruleMatches : Array ForwardRuleMatch) (goal : MVarId)
    (h : FVarId) (ms : Array (ForwardRule × PremiseIndex))
    (fs : ForwardState) : BaseM (ForwardState × Array ForwardRuleMatch) := do
  goal.withContext do
  withConstAesopTraceNode .forward (return m!"add hyp {Expr.fvar h} ({h.name})") do
    let hTypeRPINF ← rpinf (← h.getType)
    if (← isProp hTypeRPINF.toExpr) && fs.hypTypes.contains hTypeRPINF then
      aesop_trace[forward] "a hyp with the same (propositional) type was already added"
      return (fs,ruleMatches)
    let fs := { fs with hypTypes := fs.hypTypes.insert hTypeRPINF }
    ms.foldlM (init := (fs, ruleMatches)) λ (fs, ruleMatches) (r, i) => do
      withConstAesopTraceNode .forward (return m!"rule {r.name}, premise {i}") do
        let rs := fs.ruleStates.find? r.name |>.getD r.initialRuleState
        let (rs, newRuleMatches) ← rs.addRawHyp goal (.fvarId h) i
        let ruleStates := fs.ruleStates.insert r.name rs
        let hyps := fs.hyps.insert h $
          ms.map (λ (r, i) => (r.name, i)) |>.toPArray'
        let fs := { fs with ruleStates, hyps }
        let ms ← addForwardRuleMatches ruleMatches r newRuleMatches
        return (fs, ms)

@[inherit_doc addHypCore]
def addHyp (goal : MVarId) (h : FVarId)
    (ms : Array (ForwardRule × PremiseIndex)) (fs : ForwardState) :
    BaseM (ForwardState × Array ForwardRuleMatch) :=
  fs.addHypCore #[] goal h ms

/-- Add a pattern substitution to the forward state. -/
def addPatSubstCore (ruleMatches : Array ForwardRuleMatch) (goal : MVarId)
    (r : ForwardRule) (patSubst : Substitution) (fs : ForwardState) :
    BaseM (ForwardState × Array ForwardRuleMatch) :=
  goal.withContext do
  withConstAesopTraceNode .forward (return m!"add pat inst {patSubst} to rule {r.name}") do
    let rs := fs.ruleStates.find? r.name |>.getD r.initialRuleState
    let some (_, patSlotPremiseIdx) := r.rulePatternInfo?
      | throwError "aesop: internal error: addPatSubstCore: rule {r.name} does not have a rule pattern"
    let (rs, newRuleMatches) ←
      rs.addRawHyp goal (.patSubst patSubst) patSlotPremiseIdx
    let fs := { fs with ruleStates := fs.ruleStates.insert r.name rs }
    let ms ← addForwardRuleMatches ruleMatches r newRuleMatches
    return (fs, ms)

@[inherit_doc addPatSubstCore]
def addPatSubst (goal : MVarId) (r : ForwardRule) (patSubst : Substitution)
    (fs : ForwardState) : BaseM (ForwardState × Array ForwardRuleMatch) :=
  fs.addPatSubstCore #[] goal r patSubst

/-- Add multiple pattern substitutions to the forward state. -/
def addPatSubstsCore (ruleMatches : Array ForwardRuleMatch) (goal : MVarId)
    (patSubsts : Array (ForwardRule × Substitution)) (fs : ForwardState) :
    BaseM (ForwardState × Array ForwardRuleMatch) := do
  patSubsts.foldlM (init := (fs, ruleMatches))
    λ (fs, ruleMatches) (r, patSubst) =>
      fs.addPatSubstCore ruleMatches goal r patSubst

@[inherit_doc addPatSubstsCore]
def addPatSubsts (goal : MVarId) (patSubsts : Array (ForwardRule × Substitution))
    (fs : ForwardState) : BaseM (ForwardState × Array ForwardRuleMatch) :=
  fs.addPatSubstsCore #[] goal patSubsts

/-- Add a hypothesis and to the forward state, along with any rule pattern
substitutions obtained from it. -/
def addHypWithPatSubstsCore (ruleMatches : Array ForwardRuleMatch) (goal : MVarId)
    (h : FVarId) (ms : Array (ForwardRule × PremiseIndex))
    (patSubsts : Array (ForwardRule × Substitution)) (fs : ForwardState) :
    BaseM (ForwardState × Array ForwardRuleMatch) := do
  let (fs, ruleMatches) ← fs.addHypCore ruleMatches goal h ms
  fs.addPatSubstsCore ruleMatches goal patSubsts

@[inherit_doc addHypWithPatSubstsCore]
def addHypWithPatSubsts (goal : MVarId) (h : FVarId)
    (ms : Array (ForwardRule × PremiseIndex))
    (patSubsts : Array (ForwardRule × Substitution)) (fs : ForwardState) :
    BaseM (ForwardState × Array ForwardRuleMatch) :=
  fs.addHypWithPatSubstsCore #[] goal h ms patSubsts

/-- Erase pattern substitutions with the given source. -/
def erasePatSubsts (source : PatSubstSource) (fs : ForwardState) :
    ForwardState := Id.run do
  let mut ruleStates := fs.ruleStates
  for (r, inst) in fs.patSubsts[source].getD {} do
    let some rs := ruleStates.find? r
      | panic! s!"patSubsts entry for rule {r}, but no rule state"
    let rs := rs.erasePatSubst inst source
    ruleStates := ruleStates.insert r rs
  return { fs with patSubsts := fs.patSubsts.erase source, ruleStates }

/-- Remove a hypothesis from the forward state. If `fs` represents a local
context `lctx`, then `fs.eraseHyp h ms` represents `lctx` with `h` removed.
`type` must be the normalised type of `h`. `ms` must contain all rules for which
`h` may unify with a maximal premise. -/
def eraseHyp (h : FVarId) (type : RPINF) (fs : ForwardState) :
    ForwardState := Id.run do
  let mut ruleStates := fs.ruleStates
  for (r, i) in fs.hyps[h].getD {} do
    let some rs := ruleStates.find? r
      | panic! s!"hyps entry for rule {r}, but no rule state"
    let rs := rs.eraseHyp h i
    ruleStates := ruleStates.insert r rs
  let fs := {
    fs with
    hyps := fs.hyps.erase h, ruleStates
    hypTypes := fs.hypTypes.erase type
  }
  fs.erasePatSubsts (.hyp h)

/-- Erase all pattern substitutions whose source is the target. -/
def eraseTargetPatSubsts (fs : ForwardState) : ForwardState :=
  fs.erasePatSubsts .target

/-- Update the pattern substitutions after the goal's target changed.
`goal` is the new goal. `newPatSubsts` are the new target's pattern
substitutions. -/
def updateTargetPatSubstsCore (ruleMatches : Array ForwardRuleMatch)
    (goal : MVarId)
    (newPatSubsts : Array (ForwardRule × Substitution)) (fs : ForwardState) :
    BaseM (ForwardState × Array ForwardRuleMatch) :=
  -- TODO Instead of erasing all target pattern substitutions, erase only those
  -- not present in the new target.
  let fs := fs.eraseTargetPatSubsts
  fs.addPatSubstsCore ruleMatches goal newPatSubsts

@[inherit_doc updateTargetPatSubstsCore]
def updateTargetPatSubsts (goal : MVarId)
    (newPatSubsts : Array (ForwardRule × Substitution))
    (fs : ForwardState) : BaseM (ForwardState × Array ForwardRuleMatch) :=
  fs.updateTargetPatSubstsCore #[] goal newPatSubsts

end Aesop.ForwardState



=== LEAN SOURCE: Substitution.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Forward.LevelIndex
import Aesop.Forward.PremiseIndex
import Aesop.RPINF.Basic
import Aesop.Util.Basic

namespace Aesop

open Lean Lean.Meta

set_option linter.missingDocs true

/-- A substitution for the premises of a rule. Given a rule with type
`∀ (x₁ : T₁) ... (xₙ : Tₙ), U` a substitution is a finite partial map with
domain `{1, ..., n}` that associates an expression with some or all of the
premises. -/
structure Substitution where
  /-- The substitution. -/
  premises : Array (Option RPINF)
  /-- The level substitution implied by the premise substitution. If `e` is the
  elaborated rule expression (with level params replaced by level mvars), and
  `collectLevelMVars (← instantiateMVars e) = [?m₁, ..., ?mₙ]`, then `levels[i]`
  is the level assigned to `?mᵢ`. -/
  levels : Array (Option Level)
  deriving Inhabited

namespace Substitution

instance : BEq Substitution where
  beq s₁ s₂ := s₁.premises == s₂.premises

instance : Hashable Substitution where
  hash s := hash s.premises

instance : Ord Substitution where
  compare s₁ s₂ :=
    compare s₁.premises.size s₂.premises.size |>.then $
    compareArrayLex compare s₁.premises s₂.premises

/-- The empty substitution for a rule with the given number of premise
indexes. -/
def empty (numPremises numLevels : Nat) : Substitution where
  premises := .replicate numPremises none
  levels   := .replicate numLevels   none

/-- Insert the mapping `pi ↦ inst` into the substitution `s`. Precondition: `pi`
is in the domain of `s`. -/
def insert (pi : PremiseIndex) (inst : RPINF) (s : Substitution) :
    Substitution :=
  { s with premises := s.premises.set! pi.toNat inst }

/-- Get the instantiation associated with premise `pi` in `s`. Precondition:
`pi` is in the domain of `s`. -/
def find? (pi : PremiseIndex) (s : Substitution) : Option RPINF :=
  s.premises[pi.toNat]!

/-- Insert the mapping `li ↦ inst` into the substitution `s`. Precondition: `li`
is in the domain of `s` and `inst` is normalised. -/
def insertLevel (li : LevelIndex) (inst : Level) (s : Substitution) :
    Substitution :=
  { s with levels := s.levels.set! li.toNat inst }

/-- Get the instantiation associated with level `li` in `s`. Precondition:
`li` is in the domain of `s`. -/
def findLevel? (li : PremiseIndex) (s : Substitution) : Option Level :=
  s.levels[li.toNat]!

instance : ToMessageData Substitution where
  toMessageData s :=
    let ps := s.premises.filterMap id |>.mapIdx (λ i e => m!"{i} ↦ {e}") |>.toList
    let ls := s.levels.filterMap   id |>.mapIdx (λ i l => m!"{i} ↦ {l}") |>.toList
    .bracket "{" (.joinSep ps ", " ++ " | " ++ .joinSep ls ", ") "}"

/-- Merge two substitutions. Precondition: the substitutions are compatible, so
they must have the same size and if `s₁[x]` and `s₂[x]` are both defined, they
must be the same value. -/
def mergeCompatible (s₁ s₂ : Substitution) : Substitution := Id.run do
  assert! s₁.premises.size == s₂.premises.size
  assert! s₁.levels.size == s₂.levels.size
  let mut result := s₁
  for h : i in [:s₂.premises.size] do
    if let some e := s₂.premises[i] then
      assert! let r := s₁.find? ⟨i⟩; r.isNone || r == some e
      if s₁.premises[i]!.isNone then
        result := result.insert ⟨i⟩ e
  for h : i in [:s₂.levels.size] do
    if let some l := s₂.levels[i] then
      if s₁.levels[i]!.isNone then
        result := result.insertLevel ⟨i⟩ l
  return result

/-- Returns `true` if any expression in the codomain of `s` contains `hyp`. -/
def containsHyp (hyp : FVarId) (s : Substitution) : Bool :=
  s.premises.any λ
    | none => false
    | some e => e.toExpr.containsFVar hyp

/-- Given `e` with type `∀ (x₁ : T₁) ... (xₙ : Tₙ), U` and a substitution `σ`
for the arguments `xᵢ`, replace occurrences of `xᵢ` in the body `U` with fresh
metavariables (like `forallMetaTelescope`). Then, for each mapping `xᵢ ↦ tᵢ` in
`σ`, assign `tᵢ` to the metavariable corresponding to `xᵢ`. Returns the newly
created metavariables (which may be assigned!), their binder infos and the
updated body. -/
def openRuleType (e : Expr) (subst : Substitution) :
    MetaM (Array MVarId × Array BinderInfo × Expr) := do
  let lmvarIds := collectLevelMVars {} (← instantiateMVars e) |>.result
  if subst.levels.size != lmvarIds.size then
    throwError "openRuleType: substitution contains incorrect number of levels. Rule:{indentExpr e}\nSubstitution:{indentD $ toMessageData subst}"
  let type ← inferType e
  let (mvars, binfos, body) ← forallMetaTelescopeReducing type
  let mvarIds := mvars.map (·.mvarId!)
  if subst.premises.size != mvars.size then
    throwError "openRuleType: substitution has incorrect size. Rule:{indentExpr e}\nRule type:{indentExpr type}\nSubstitution:{indentD $ toMessageData subst}"
  for h : i in [:lmvarIds.size] do
    if let some inst := subst.findLevel? ⟨i⟩ then
      assignLevelMVar lmvarIds[i] inst
  for h : i in [:mvarIds.size] do
    if let some inst := subst.find? ⟨i⟩ then
      mvarIds[i].assign inst.toExpr
  return (mvarIds, binfos, body)

/-- Given `rule` of type `∀ (x₁ : T₁) ... (xₙ : Tₙ), U` and a substitution `σ` for
the arguments `xᵢ`, specialise `rule` with the arguments given by `σ`. That is,
construct `U t₁ ... tₙ` where `tⱼ` is `σ(xⱼ)` if `xⱼ ∈ dom(σ)` and is otherwise
a fresh fvar, then λ-abstract the fresh fvars. -/
def specializeRule (rule : Expr) (subst : Substitution) : MetaM Expr :=
  withNewMCtxDepth do
    let lmvarIds := collectLevelMVars {} (← instantiateMVars rule) |>.result
    for h : i in [:lmvarIds.size] do
      if let some l := subst.findLevel? ⟨i⟩ then
        assignLevelMVar lmvarIds[i] l
    forallTelescopeReducing (← inferType rule) λ fvarIds _ => do
      let mut args := Array.mkEmpty fvarIds.size
      let mut remainingFVarIds := Array.mkEmpty fvarIds.size
      for h : i in [:fvarIds.size] do
        if let some inst := subst.find? ⟨i⟩ then
          args := args.push $ some inst.toExpr
        else
          let fvarId := fvarIds[i]
          args := args.push $ some fvarId
          remainingFVarIds := remainingFVarIds.push fvarId
      let result ← mkLambdaFVars remainingFVarIds (← mkAppOptM' rule args)
      return result

end Substitution

/-- Open the type of a rule `e`. If a substitution `σ` is given, this function
acts like `Substitution.openRuleType σ`. Otherwise it acts like
`forallMetaTelescope`. -/
def openRuleType (subst? : Option Substitution) (e : Expr) :
    MetaM (Array MVarId × Array BinderInfo × Expr) := do
  match subst? with
  | some subst => do
    subst.openRuleType e
  | none =>
    let (premises, binfos, conclusion) ←
      forallMetaTelescopeReducing (← inferType e)
    return (premises.map (·.mvarId!), binfos, conclusion)

end Aesop



=== LEAN SOURCE: Types.lean ===
import Aesop.Forward.PremiseIndex
import Aesop.Forward.SlotIndex
import Aesop.Forward.Substitution
import Aesop.Rule.Forward

set_option linter.missingDocs true

namespace Aesop

open Lean

/-- A match associates hypotheses to (a prefix of) the slots of a slot
cluster. -/
structure Match where
  /-- The substitution induced by the hyps or pattern substitutions added to
  the slots. -/
  subst : Substitution
  /-- The pattern substitutions that have been added to the match. -/
  patInstSubsts : Array Substitution
  /-- The match's level is the index of the maximal slot for which a hyp or
  pattern substitution has been added to the match. -/
  level : SlotIndex
  /-- Premises that appear in slots which are as yet unassigned in this match
  (i.e., in slots with index greater than `level`). This is a property of the
  rule, but we include it here because it's used to check whether two matches
  are equivalent. -/
  forwardDeps : Array PremiseIndex
  /-- Premises that appear in the rule's conclusion. This is a property of the
  rule, but we include it here because it's used to check whether two matches
  are equivalent. -/
  conclusionDeps : Array PremiseIndex
  deriving Inhabited

namespace Match

/-- Two matches are equivalent if (a) they have the same level; (b) for each
premise that appears in a slot greater than the matches' level, their
substitution assigns the same value; (c) for each premise that appears in the
rule's conclusion, their substitution assigns the same value.

If we already have a match `m₁` and we obtain an equivalent match `m₂`, then
`m₂` is redundant. This is because if the matches are partial, then `m₂` can be
completed by exactly the hypotheses that complete `m₁`, since they agree on the
premise instantiations that are relevant for the possible completions. And if
the matches are complete, then they assign the same instantiations to the
variables that appear in the rule's conclusion, and these are the only ones that
ultimately matter. -/
-- TODO I believe we could be even more aggressive when forwardDeps and
-- conclusionDeps contain proofs of propositions and consider any such proofs
-- equal.
protected def equiv (m₁ m₂ : Match) : Bool :=
  m₁.level == m₂.level &&
  m₁.forwardDeps.all    (λ p => m₁.subst.find? p == m₂.subst.find? p) &&
  m₁.conclusionDeps.all (λ p => m₁.subst.find? p == m₂.subst.find? p)

instance : BEq Match :=
  ⟨Match.equiv⟩

instance : Hashable Match where
  hash m :=
    let h := hash m.level
    let h :=
      m.forwardDeps.foldl  (init := h) λ h p => mixHash h $ hash (m.subst.find? p)
    m.conclusionDeps.foldl (init := h) λ h p => mixHash h $ hash (m.subst.find? p)

instance : Ord Match where
  compare m₁ m₂ :=
    compare m₁.level m₂.level |>.then $
    if m₁ == m₂ then .eq else
    compare m₁.subst m₂.subst

instance : ToMessageData Match where
  toMessageData m := m!"{m.subst}"

end Match

set_option linter.missingDocs false in
/-- A complete match contains complete matches for each slot cluster. This means
there is one match for each slot cluster and each such match contains a
hypothesis for each of the slots. -/
structure CompleteMatch where
  clusterMatches : Array Match
  deriving Inhabited, BEq, Hashable

-- TODO hash as a computed field

instance : EmptyCollection CompleteMatch :=
  ⟨{ clusterMatches := ∅ }⟩

instance : Ord CompleteMatch where
  compare m₁ m₂ :=
    compareArraySizeThenLex compare m₁.clusterMatches m₂.clusterMatches

/-- An entry in the forward state queues. Represents a complete match. -/
structure ForwardRuleMatch where
  /-- The rule to which this match belongs. -/
  rule : ForwardRule
  /-- The match. -/
  «match» : CompleteMatch
  deriving Inhabited, BEq, Hashable

namespace ForwardRuleMatch

/-- Compare two queue entries by rule priority, rule name and the expressions
contained in the match. Higher-priority rules are considered less (since the
queues are min-queues). The ordering on expressions is arbitrary. -/
protected instance ord : Ord ForwardRuleMatch where
  compare m₁ m₂ :=
    compare m₁.rule m₂.rule |>.then $
    compare m₁.match m₂.match

@[inherit_doc ForwardRuleMatch.ord]
protected def le (m₁ m₂ : ForwardRuleMatch) : Bool :=
  compare m₁ m₂ |>.isLE

end Aesop.ForwardRuleMatch



=== LEAN SOURCE: ApplyGoalDiff.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Forward.State
import Aesop.RuleSet

namespace Aesop

open Lean Lean.Meta

/-- Apply a goal diff to the state, adding and removing hypotheses as indicated
by the diff. -/
def ForwardState.applyGoalDiff (rs : LocalRuleSet) (diff : GoalDiff)
    (fs : ForwardState) : BaseM (ForwardState × Array ForwardRuleMatch) := do
  if ! aesop.dev.statefulForward.get (← getOptions) then
    -- We still update the hyp types since these are also used by stateless
    -- forward reasoning.
    return ({ fs with hypTypes := ← updateHypTypes fs.hypTypes } , #[])
  let fs ← diff.oldGoal.withContext do
    diff.removedFVars.foldM (init := fs) λ fs h => do eraseHyp h fs
  diff.newGoal.withContext do
    let (fs, ruleMatches) ←
      diff.addedFVars.foldM (init := (fs, ∅)) λ (fs, ruleMatches) h => do
        addHyp h fs ruleMatches
    if ← diff.targetChanged' then
      updateTarget fs ruleMatches
    else
      return (fs, ruleMatches)
where
  eraseHyp (h : FVarId) (fs : ForwardState) : BaseM ForwardState :=
    withConstAesopTraceNode .forward (return m!"erase hyp {Expr.fvar h} ({h.name})") do
      return fs.eraseHyp h (← rpinf (← h.getType))

  addHyp (h : FVarId) (fs : ForwardState)
      (ruleMatches : Array ForwardRuleMatch) :
      BaseM (ForwardState × Array ForwardRuleMatch) := do
    let rules ← rs.applicableForwardRules (← h.getType)
    let patInsts ← rs.forwardRulePatternSubstsInLocalDecl (← h.getDecl)
    fs.addHypWithPatSubstsCore ruleMatches diff.newGoal h rules patInsts

  updateTarget (fs : ForwardState) (ruleMatches : Array ForwardRuleMatch) :
      BaseM (ForwardState × Array ForwardRuleMatch) := do
    let patInsts ←
      rs.forwardRulePatternSubstsInExpr (← diff.newGoal.getType)
    fs.updateTargetPatSubstsCore ruleMatches diff.newGoal patInsts

  updateHypTypes (hypTypes : PHashSet RPINF) : BaseM (PHashSet RPINF) := do
    let mut hypTypes := hypTypes
    for fvarId in diff.removedFVars do
      let type ← diff.oldGoal.withContext do rpinf (← fvarId.getType)
      hypTypes := hypTypes.erase type
    for fvarId in diff.addedFVars do
      let type ← diff.newGoal.withContext do rpinf (← fvarId.getType)
      hypTypes := hypTypes.insert type
    return hypTypes

end Aesop



=== LEAN SOURCE: Initial.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Forward.State
import Aesop.RuleSet

open Lean Lean.Meta

namespace Aesop.LocalRuleSet

def mkInitialForwardState (goal : MVarId) (rs : LocalRuleSet) :
    BaseM (ForwardState × Array ForwardRuleMatch) :=
  goal.withContext do
    if ! aesop.dev.statefulForward.get (← getOptions) then
      -- We still initialise the hyp types since these are also used by
      -- stateless forward reasoning.
      let mut hypTypes := ∅
      for ldecl in ← getLCtx do
        if ! ldecl.isImplementationDetail then
          hypTypes := hypTypes.insert (← rpinf ldecl.type)
      return ({ (∅ : ForwardState) with hypTypes }, #[])
    let mut fs : ForwardState := ∅
    let mut ruleMatches := rs.constForwardRuleMatches
    aesop_trace[forward] do
      for m in ruleMatches do
        aesop_trace![forward] "match for constant rule {m.rule.name}"
    for ldecl in ← show MetaM _ from getLCtx do
      if ldecl.isImplementationDetail then
        continue
      let rules ← rs.applicableForwardRules ldecl.type
      let patInsts ← rs.forwardRulePatternSubstsInLocalDecl ldecl
      let (fs', ruleMatches') ←
        fs.addHypWithPatSubstsCore ruleMatches goal ldecl.fvarId rules patInsts
      fs := fs'
      ruleMatches := ruleMatches'
    let patInsts ← rs.forwardRulePatternSubstsInExpr (← goal.getType)
    fs.addPatSubstsCore ruleMatches goal patInsts

end Aesop.LocalRuleSet



=== LEAN SOURCE: Attribute.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Frontend.Extension
import Aesop.Frontend.RuleExpr

open Lean
open Lean.Elab

namespace Aesop.Frontend

namespace Parser

declare_syntax_cat Aesop.attr_rules

syntax Aesop.rule_expr : Aesop.attr_rules
syntax "[" Aesop.rule_expr,+,? "]" : Aesop.attr_rules

syntax (name := aesop) "aesop " Aesop.attr_rules : attr

end Parser

structure AttrConfig where
  rules : Array RuleExpr
  deriving Inhabited

namespace AttrConfig

def «elab» (stx : Syntax) : TermElabM AttrConfig :=
  withRef stx do
    match stx with
    | `(attr| aesop $e:Aesop.rule_expr) => do
      let r ← RuleExpr.elab e |>.run $ ← ElabM.Context.forAdditionalGlobalRules
      return { rules := #[r] }
    | `(attr| aesop [ $es:Aesop.rule_expr,* ]) => do
      let ctx ← ElabM.Context.forAdditionalGlobalRules
      let rs ← (es : Array Syntax).mapM λ e => RuleExpr.elab e |>.run ctx
      return { rules := rs }
    | _ => throwUnsupportedSyntax

end AttrConfig


initialize registerBuiltinAttribute {
  name := `aesop
  descr := "Register a declaration as an Aesop rule."
  applicationTime := .afterCompilation
  add := λ decl stx attrKind => withRef stx do
    let rules ← runTermElabMAsCoreM do
      let config ← AttrConfig.elab stx
      config.rules.flatMapM (·.buildAdditionalGlobalRules decl)
    for (rule, rsNames) in rules do
      for rsName in rsNames do
        addGlobalRule rsName rule attrKind (checkNotExists := true)
  erase := λ decl =>
    let ruleFilter :=
      { name := decl, scope := .global, builders := #[], phases := #[] }
    eraseGlobalRules RuleSetNameFilter.all ruleFilter (checkExists := true)
}

end Aesop.Frontend



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Lean

open Lean Lean.Elab Lean.Elab.Term

namespace Aesop.Frontend.Parser

declare_syntax_cat Aesop.bool_lit (behavior := symbol)

syntax "true" : Aesop.bool_lit
syntax "false" : Aesop.bool_lit

end Parser

def elabBoolLit [Monad m] [MonadRef m] [MonadExceptOf Exception m]
    (stx : TSyntax `Aesop.bool_lit) : m Bool :=
  withRef stx do
    match stx with
    | `(bool_lit| true) => return true
    | `(bool_lit| false) => return false
    | _ => throwUnsupportedSyntax

end Aesop.Frontend



=== LEAN SOURCE: Command.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Frontend.Basic
import Aesop.Stats.Report
import Batteries.Linter.UnreachableTactic
import Aesop.Frontend.Extension
import Aesop.Frontend.RuleExpr

open Lean Lean.Elab Lean.Elab.Command

namespace Aesop.Frontend.Parser

syntax (name := declareRuleSets)
  "declare_aesop_rule_sets " "[" ident,+,? "]"
  (" (" &"default" " := " Aesop.bool_lit ")")? : command

elab_rules : command
  | `(declare_aesop_rule_sets [ $ids:ident,* ]
       $[(default := $dflt?:Aesop.bool_lit)]?) => do
    let rsNames := (ids : Array Ident).map (·.getId)
    let dflt := (← dflt?.mapM (elabBoolLit ·)).getD false
    rsNames.forM checkRuleSetNotDeclared
    elabCommand $ ← `(initialize ($(quote rsNames).forM $ declareRuleSetUnchecked (isDefault := $(quote dflt))))

elab (name := addRules)
    attrKind:attrKind "add_aesop_rules " e:Aesop.rule_expr : command => do
  let attrKind :=
    match attrKind with
    | `(Lean.Parser.Term.attrKind| local) => .local
    | `(Lean.Parser.Term.attrKind| scoped) => .scoped
    | _ => .global
  let rules ← liftTermElabM do
    let e ← RuleExpr.elab e |>.run (← ElabM.Context.forAdditionalGlobalRules)
    e.buildAdditionalGlobalRules none
  for (rule, rsNames) in rules do
    for rsName in rsNames do
      addGlobalRule rsName rule attrKind (checkNotExists := true)

initialize Batteries.Linter.UnreachableTactic.addIgnoreTacticKind ``addRules

elab (name := eraseRules)
    "erase_aesop_rules " "[" es:Aesop.rule_expr,* "]" : command => do
  let filters ← Elab.Command.liftTermElabM do
    let ctx ← ElabM.Context.forGlobalErasing
    (es : Array _).mapM λ e => do
      let e ← RuleExpr.elab e |>.run ctx
      e.toGlobalRuleFilters
  for fs in filters do
    for (rsFilter, rFilter) in fs do
      eraseGlobalRules rsFilter rFilter (checkExists := true)

syntax (name := showRules)
  withPosition("#aesop_rules" (colGt ppSpace ident)*) : command

elab_rules : command
  | `(#aesop_rules $ns:ident*) => do
    liftTermElabM do
      let lt := λ (n₁, _) (n₂, _) => n₁.cmp n₂ |>.isLT
      let rss ←
        if ns.isEmpty then
          let rss ← getDeclaredGlobalRuleSets
          pure $ rss.qsort lt
        else
          ns.mapM λ n => return (n.getId, ← getGlobalRuleSet n.getId)
      TraceOption.ruleSet.withEnabled do
        for (name, rs, _) in rss do
          withConstAesopTraceNode .ruleSet (return m!"Rule set '{name}'") do
            rs.trace .ruleSet

def evalStatsReport? (name : Name) : CoreM (Option StatsReport) := do
  try
    unsafe evalConstCheck StatsReport ``StatsReport name
  catch _ =>
    return none

syntax (name := showStats) withPosition("#aesop_stats " (colGt ident)?) : command

elab_rules : command
  | `(#aesop_stats) => do
    logInfo $ StatsReport.default $ ← getStatsArray
  | `(#aesop_stats $report:ident) => do
    let openDecl := OpenDecl.simple ``Aesop.StatsReport []
    withScope (λ s => { s with openDecls := openDecl :: s.openDecls }) do
      let names ← resolveGlobalConst report
      liftTermElabM do
        for name in names do
          if let some report ← evalStatsReport? name then
            logInfo $ report $ ← getStatsArray
            break
        throwError "'{report}' is not a constant of type 'Aesop.StatsReport'"

end Aesop.Frontend.Parser



=== LEAN SOURCE: Extension.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Frontend.Extension.Init

open Lean Lean.Meta

namespace Aesop.Frontend

def extensionDescr (rsName : RuleSetName) :
    SimpleScopedEnvExtension.Descr BaseRuleSetMember BaseRuleSet where
  name := rsName
  addEntry rs r := rs.add r
  initial := ∅

def declareRuleSetUnchecked (rsName : RuleSetName) (isDefault : Bool) :
    IO Unit := do
  let ext ← registerSimpleScopedEnvExtension $ extensionDescr rsName
  let simpExtName := .mkStr1 s!"aesop_{rsName}"
  discard $ registerSimpAttr simpExtName (ref := simpExtName)
    s!"simp theorems in the Aesop rule set '{rsName}'"
  let simprocExtName := .mkStr1 s!"aesop_{rsName}_proc"
  discard $ Simp.registerSimprocAttr simprocExtName (name := simprocExtName)
    (ref? := none) s!"simprocs in the Aesop rule set '{rsName}'"
  declaredRuleSetsRef.modify λ rs =>
    let ruleSets := rs.ruleSets.insert rsName (ext, simpExtName, simprocExtName)
    let defaultRuleSets :=
      if isDefault then
        rs.defaultRuleSets.insert rsName
      else
        rs.defaultRuleSets
    { ruleSets, defaultRuleSets }

def isRuleSetDeclared (rsName : RuleSetName) : IO Bool :=
  return (← getDeclaredRuleSets).contains rsName

variable [Monad m] [MonadError m] [MonadLiftT IO m]
  [MonadLiftT (ST IO.RealWorld) m] [MonadEnv m] [MonadResolveName m]

def checkRuleSetNotDeclared (rsName : RuleSetName) : m Unit := do
  if ← isRuleSetDeclared rsName then
    throwError "rule set '{rsName}' already exists"

def declareRuleSet (rsName : RuleSetName) (isDefault : Bool) : m Unit := do
  checkRuleSetNotDeclared rsName
  declareRuleSetUnchecked rsName isDefault

initialize
  builtinRuleSetNames.forM (declareRuleSetUnchecked (isDefault := true))

def getGlobalRuleSetData (rsName : RuleSetName) :
    m (RuleSetExtension × Name × SimpExtension × Name × Simp.SimprocExtension) := do
  let (some (ext, simpExtName, simprocExtName)) :=
    (← getDeclaredRuleSets)[rsName]?
    | throwError "no such rule set: '{rsName}'\n  (Use 'declare_aesop_rule_set' to declare rule sets.\n   Declared rule sets are not visible in the current file; they only become visible once you import the declaring file.)"
  let some simpExt ← getSimpExtension? simpExtName
    | throwError "internal error: expected '{simpExtName}' to be a declared simp extension"
  let some simprocExt ← Simp.getSimprocExtension? simpExtName
    | throwError "internal error: expected '{simpExtName}' to be a declared simp extension"
  return (ext, simpExtName, simpExt, simprocExtName, simprocExt)

def getGlobalRuleSetFromData (ext : RuleSetExtension) (simpExt : SimpExtension)
    (simprocExt : Simp.SimprocExtension) : m GlobalRuleSet := do
  let env ← getEnv
  let base := ext.getState env
  let simpTheorems := simpExt.getState env
  let simprocs := simprocExt.getState env
  return { base with simpTheorems, simprocs }

def getGlobalRuleSet (rsName : RuleSetName) :
    CoreM (GlobalRuleSet × Name × Name) := do
  let (ext, simpExtName, simpExt, simprocExtName, simprocExt) ←
    getGlobalRuleSetData rsName
  let rs ← getGlobalRuleSetFromData ext simpExt simprocExt
  return (rs , simpExtName, simprocExtName)

def getGlobalRuleSets (rsNames : Array RuleSetName) :
    CoreM (Array (GlobalRuleSet × Name × Name)) :=
  rsNames.mapM getGlobalRuleSet

def getDefaultGlobalRuleSets : CoreM (Array (GlobalRuleSet × Name × Name)) := do
  getGlobalRuleSets (← getDefaultRuleSetNames).toArray

def getDeclaredGlobalRuleSets :
    CoreM (Array (RuleSetName × GlobalRuleSet × Name × Name)) := do
  (← getDeclaredRuleSets).toArray.mapM λ (rsName, _) =>
    return (rsName, ← getGlobalRuleSet rsName)

def modifyGetGlobalRuleSet (rsName : RuleSetName)
    (f : GlobalRuleSet → α × GlobalRuleSet) : m α := do
  let (ext, _, simpExt, _, simprocExt) ← getGlobalRuleSetData rsName
  let env ← getEnv
  let base := ext.getState env
  let simpTheorems := simpExt.getState env
  let simprocs := simprocExt.getState env
  let env := ext.modifyState env λ _ => default     -- an attempt to preserve linearity
  let env := simpExt.modifyState env λ _ => default -- ditto
  let env := simprocExt.modifyState env λ _ => default -- ditto
  let rs := { base with simpTheorems, simprocs }
  let (a, rs) := f rs
  let env := ext.modifyState env λ _ => rs.toBaseRuleSet
  let env := simpExt.modifyState env λ _ => rs.simpTheorems
  setEnv env
  return a

def modifyGlobalRuleSet (rsName : RuleSetName)
    (f : GlobalRuleSet → GlobalRuleSet) : CoreM Unit := do
  modifyGetGlobalRuleSet rsName λ rs => ((), f rs)

def addGlobalRule (rsName : RuleSetName) (r : GlobalRuleSetMember)
    (kind : AttributeKind) (checkNotExists : Bool) : m Unit := do
  let (ext, _, simpExt, _, simprocExt) ← getGlobalRuleSetData rsName
  if checkNotExists then
    let rs ← getGlobalRuleSetFromData ext simpExt simprocExt
    if rs.contains r.name then
      throwError "aesop: rule '{r.name.name}' is already registered in rule set '{rsName}'"
  match r with
  | .base m => ext.add m kind
  | .normSimpRule r => do
    for e in r.entries do
      simpExt.add e kind
      -- Workaround for a Lean bug.
      if let .thm l := e then
        setEnv $ simpExt.modifyState (← getEnv) λ simpTheorems =>
          { simpTheorems with erased := simpTheorems.erased.erase l.origin }

def eraseGlobalRules (rsf : RuleSetNameFilter) (rf : RuleFilter)
    (checkExists : Bool) : m Unit := do
  match rsf.matchedRuleSetNames with
  | none =>
    let anyErased ←
      (← getDeclaredRuleSets).foldM (init := false) λ b rsName _ => go b rsName
    if checkExists && ! anyErased then
      throwError "'{rf.name}' is not registered (with the given features) in any rule set."
  | some rsNames =>
    let anyErased ← rsNames.foldlM (init := false) go
    if checkExists && ! anyErased then
      throwError "'{rf.name}' is not registered (with the given features) in any of the rule sets {rsNames.map toString}."
  where
    go (anyErased : Bool) (rsName : RuleSetName) : m Bool :=
      modifyGetGlobalRuleSet rsName λ rs =>
        let (rs, anyErasedFromRs) := rs.erase rf
        (anyErased || anyErasedFromRs, rs)

end Aesop.Frontend



=== LEAN SOURCE: RuleExpr.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.ElabM
import Aesop.Percent
import Aesop.Rule.Name
import Aesop.Builder.Cases
import Aesop.Builder.Default
import Aesop.Builder.Forward
import Aesop.Builder.Unfold
import Aesop.RuleSet.Filter

open Lean
open Lean.Meta
open Lean.Elab
open Lean.Elab.Term


variable [Monad m] [MonadError m]


namespace Aesop.Frontend

namespace Parser

declare_syntax_cat Aesop.priority

syntax num "%" : Aesop.priority
syntax "-"? num : Aesop.priority

end Parser

inductive Priority
  | int (i : Int)
  | percent (p : Percent)
  deriving Inhabited

namespace Priority

def «elab» (stx : Syntax) : ElabM Priority :=
  withRef stx do
    unless ← shouldParsePriorities do throwError
      "unexpected priority."
    match stx with
    | `(priority| $p:num %) =>
      let p := p.raw.toNat
      match Percent.ofNat p with
      | some p => return percent p
      | none => throwError "percentage '{p}%' is not between 0 and 100."
    | `(priority| - $i:num) =>
      return int $ - i.raw.toNat
    | `(priority| $i:num) =>
      return int i.raw.toNat
    | _ => throwUnsupportedSyntax

instance : ToString Priority where
  toString
    | int i => toString i
    | percent p => p.toHumanString

def toInt? : Priority → Option Int
  | int i => some i
  | _ => none

def toPercent? : Priority → Option Percent
  | percent p => some p
  | _ => none

end Priority



namespace Parser

declare_syntax_cat Aesop.phase (behavior := symbol)

syntax "safe" : Aesop.phase
syntax "norm" : Aesop.phase
syntax "unsafe" : Aesop.phase

end Parser

def PhaseName.«elab» (stx : Syntax) : ElabM PhaseName :=
  withRef stx do
    match stx with
    | `(phase| safe) => return .safe
    | `(phase| norm) => return .norm
    | `(phase| unsafe) => return .«unsafe»
    | _ => throwUnsupportedSyntax


namespace Parser

declare_syntax_cat Aesop.builder_name (behavior := symbol)

syntax "apply" : Aesop.builder_name
syntax "simp" : Aesop.builder_name
syntax "unfold" : Aesop.builder_name
syntax "tactic" : Aesop.builder_name
syntax "constructors" : Aesop.builder_name
syntax "forward" : Aesop.builder_name
syntax "destruct" : Aesop.builder_name
syntax "cases" : Aesop.builder_name
syntax "default" : Aesop.builder_name

end Parser

inductive DBuilderName
  | regular (b : BuilderName)
  | «default»
  deriving Inhabited

namespace DBuilderName

def «elab» (stx : Syntax) : ElabM DBuilderName :=
  withRef stx do
    match stx with
    | `(builder_name| apply) => return regular .apply
    | `(builder_name| simp) => return regular .simp
    | `(builder_name| unfold) => return regular .unfold
    | `(builder_name| tactic) => return regular .tactic
    | `(builder_name| constructors) => return regular .constructors
    | `(builder_name| forward) => return regular .forward
    | `(builder_name| destruct) => return regular .destruct
    | `(builder_name| cases) => return regular .cases
    | `(builder_name| default) => return «default»
    | _ => throwUnsupportedSyntax

instance : ToString DBuilderName where
  toString
    | regular b => toString b
    | default => "default"

def toBuilderName? : DBuilderName → Option BuilderName
  | regular b => some b
  | _ => none

def toRuleBuilder : DBuilderName → RuleBuilder
  | .regular .apply => RuleBuilder.apply
  | .regular .cases => RuleBuilder.cases
  | .regular .constructors => RuleBuilder.constructors
  | .regular .destruct => RuleBuilder.forward (isDestruct := true)
  | .regular .forward => RuleBuilder.forward (isDestruct := false)
  | .regular .simp => RuleBuilder.simp
  | .regular .tactic => RuleBuilder.tactic
  | .regular .unfold => RuleBuilder.unfold
  | .default => RuleBuilder.default

end DBuilderName


namespace Parser

declare_syntax_cat Aesop.indexing_mode (behavior := symbol)

syntax "target " term : Aesop.indexing_mode
syntax "hyp " term : Aesop.indexing_mode
syntax "unindexed " : Aesop.indexing_mode

end Parser

def elabSingleIndexingMode (stx : Syntax) : ElabM IndexingMode :=
  withRef stx do
    match stx with
    | `(indexing_mode| target $t:term) => .target <$> elabKeys t
    | `(indexing_mode| hyp $t:term) => .hyps <$> elabKeys t
    | `(indexing_mode| unindexed) => return .unindexed
    | _ => throwUnsupportedSyntax
  where
    elabKeys (stx : Syntax) : ElabM (Array DiscrTree.Key) :=
      show TermElabM _ from withoutModifyingState do
        mkDiscrTreePath (← elabPattern stx)

def IndexingMode.elab (stxs : Array Syntax) : ElabM IndexingMode :=
  .or <$> stxs.mapM elabSingleIndexingMode

def CasesPattern.elab (stx : Syntax) : TermElabM CasesPattern := do
  abstractMVars (← elabPattern stx)


namespace Parser

syntax transparency := &"default" <|> &"reducible" <|> &"instances" <|> &"all"

end Parser

open Parser in
def elabTransparency : TSyntax ``transparency → TermElabM TransparencyMode
  | `(transparency| default) => return .default
  | `(transparency| reducible) => return .reducible
  | `(transparency| instances) => return .instances
  | `(transparency| all) => return .all
  | _ => throwUnsupportedSyntax

namespace Parser

declare_syntax_cat Aesop.builder_option

syntax " (" &"immediate" " := " "[" ident,+,? "]" ")" : Aesop.builder_option
syntax " (" &"index" " := " "[" Aesop.indexing_mode,+,? "]" ")" : Aesop.builder_option
syntax " (" &"pattern" " := " term ")" : Aesop.builder_option
syntax " (" &"cases_patterns" " := " "[" term,+,? "]" ")" : Aesop.builder_option
syntax " (" &"transparency" " := " transparency ")" : Aesop.builder_option
syntax " (" &"transparency!" " := " transparency ")" : Aesop.builder_option

end Parser

inductive BuilderOption
  | immediate (names : Array Name)
  | index (imode : IndexingMode)
  | pattern (stx : Term)
  | casesPatterns (pats : Array CasesPattern)
  | transparency (md : TransparencyMode) (alsoForIndex : Bool)

namespace BuilderOption

def «elab» (stx : TSyntax `Aesop.builder_option) : ElabM BuilderOption :=
  withRef stx do
    match stx with
    | `(builder_option| (immediate := [$ns:ident,*])) =>
      return immediate $ (ns : Array Syntax).map (·.getId)
    | `(builder_option| (index := [$imodes:Aesop.indexing_mode,*])) =>
      index <$> IndexingMode.elab imodes
    | `(builder_option| (pattern := $pat:term)) =>
      return pattern pat
    | `(builder_option| (cases_patterns := [$pats:term,*])) =>
      casesPatterns <$> (pats : Array Syntax).mapM (CasesPattern.elab ·)
    | `(builder_option| (transparency := $md)) =>
      let md ← elabTransparency md
      return transparency md (alsoForIndex := false)
    | `(builder_option| (transparency! := $md)) =>
      let md ← elabTransparency md
      return transparency md (alsoForIndex := true)
    | _ => throwUnsupportedSyntax

end BuilderOption



def addBuilderOption (bos : RuleBuilderOptions) :
    BuilderOption → RuleBuilderOptions
  | .immediate ns => { bos with immediatePremises? := ns }
  | .index imode => { bos with indexingMode? := imode }
  | .pattern pat => { bos with pattern? := pat }
  | .casesPatterns ps => { bos with casesPatterns? := ps }
  | .transparency md alsoForIndex =>
    let bos := { bos with transparency? := md }
    if alsoForIndex then
      { bos with indexTransparency? := md }
    else
      bos


namespace Parser

syntax ruleSetsFeature := "(" &"rule_sets" " := " "[" ident,+,? "]" ")"

end Parser

def RuleSetName.elab (stx : Syntax) : RuleSetName :=
  stx.getId.eraseMacroScopes
  -- We erase macro scopes to support macros such as
  --   macro &"aesop_test" : tactic => `(tactic| aesop (rule_sets [test]))
  -- Here the macro hygienifies `test` by appending macro scopes, but we want
  -- to interpret `test` as a global name.

structure RuleSets where
  ruleSets : Array RuleSetName
  deriving Inhabited

namespace RuleSets

def «elab» (stx : Syntax) : ElabM RuleSets :=
  withRef stx do
    match stx with
    | `(Parser.ruleSetsFeature| (rule_sets := [$ns:ident,*])) =>
      return ⟨(ns : Array Syntax).map RuleSetName.elab⟩
    | _ => throwUnsupportedSyntax

end RuleSets


namespace Parser

declare_syntax_cat Aesop.feature (behavior := symbol)

-- NOTE: This grammar has overlapping rules `ident`, `Aesop.phase` and
-- `Aesop.builder_name`, which can all consist of a single ident. For ambiguous
-- parses, a `choice` node with two children is created; one being an
-- `Aesop.phase` or `Aesop.builder_name` node and the other being a `featIdent`
-- node. When we process these `choice` nodes, we select the non-`ident` one.

syntax Aesop.phase : Aesop.feature
syntax Aesop.priority : Aesop.feature
syntax Aesop.builder_name : Aesop.feature
syntax Aesop.builder_option : Aesop.feature
syntax ruleSetsFeature : Aesop.feature
syntax (name := featIdent) ident : Aesop.feature
syntax "(" term ")" : Aesop.feature

end Parser

inductive Feature
  | phase (p : PhaseName)
  | priority (p : Priority)
  | builder (b : DBuilderName)
  | builderOption (o : BuilderOption)
  | term (i : Term)
  | ruleSets (rs : RuleSets)
  deriving Inhabited

namespace Feature

-- Workaround for codegen bug, see #182
set_option compiler.extract_closed false in
partial def «elab» (stx : Syntax) : ElabM Feature :=
  withRef stx do
    match stx with
    | `(feature| $p:Aesop.priority) => priority <$> Priority.elab p
    | `(feature| $p:Aesop.phase) => phase <$> PhaseName.elab p
    | `(feature| $b:Aesop.builder_name) => builder <$> DBuilderName.elab b
    | `(feature| $o:Aesop.builder_option) => builderOption <$> BuilderOption.elab o
    | `(feature| $rs:ruleSetsFeature) => ruleSets <$> RuleSets.elab rs
    | `(feature| $i:ident) => return term i
    | `(feature| ($t:term)) => return term t
    | stx => do
      if stx.isOfKind choiceKind then
        let nonIdentAlts :=
          stx.getArgs.filter λ stx => ! stx.isOfKind ``Parser.featIdent
        if h : nonIdentAlts.size = 1 then
          return ← «elab» $ nonIdentAlts[0]
      throwUnsupportedSyntax

end Feature


namespace Parser

declare_syntax_cat Aesop.rule_expr (behavior := symbol)

syntax Aesop.feature : Aesop.rule_expr
syntax Aesop.feature ppSpace Aesop.rule_expr : Aesop.rule_expr
syntax Aesop.feature " [" Aesop.rule_expr,+,? "]" : Aesop.rule_expr

end Parser


inductive RuleExpr
  | node (f : Feature) (children : Array RuleExpr)
  deriving Inhabited

namespace RuleExpr

partial def «elab» (stx : Syntax) : ElabM RuleExpr :=
  withRef stx do
    match stx with
    | `(rule_expr| $f:Aesop.feature $e:Aesop.rule_expr) => do
      return node (← Feature.elab f) #[← «elab» e]
    | `(rule_expr| $f:Aesop.feature [ $es:Aesop.rule_expr,* ]) => do
      return node (← Feature.elab f) (← (es : Array Syntax).mapM «elab»)
    | `(rule_expr| $f:Aesop.feature) => do
      return node (← Feature.elab f) #[]
    | _ => throwUnsupportedSyntax

-- Fold the branches of a `RuleExpr`. We treat each branch as a list of features
-- which we fold over. The result is an array containing one result per branch.
partial def foldBranchesM {m} [Monad m] (f : σ → Feature → m σ) (init : σ)
    (e : RuleExpr) : m (Array σ) :=
  go init #[] e
  where
    go (c : σ) (acc : Array σ) : RuleExpr → m (Array σ)
      | RuleExpr.node feat cs => do
        let c ← f c feat
        if cs.isEmpty then
          return acc.push c
        else
          cs.foldlM (init := acc) (go c)

end RuleExpr

structure RuleConfig where
  term? : Option Term
  phase? : Option PhaseName
  priority? : Option Priority
  builder? : Option DBuilderName
  builderOptions : RuleBuilderOptions
  ruleSets : RuleSets

namespace RuleConfig

def addFeature (c : RuleConfig) : Feature → m RuleConfig
  | .phase phase => return { c with phase? := phase }
  | .priority priority => return { c with priority? := priority }
  | .term term => do
    if let some oldTerm := c.term? then
      throwError "duplicate rule '{term}'; rule '{oldTerm}' was already given.\nUse [<term>,...] to give multiple rules."
    return { c with term? := term }
  | .builder builder => return { c with builder? := builder }
  | .builderOption opt =>
    return { c with builderOptions := addBuilderOption c.builderOptions opt }
  | .ruleSets newRuleSets =>
    have _ : Ord RuleSetName := ⟨Name.quickCmp⟩
    let ruleSets := ⟨Array.mergeDedup c.ruleSets.ruleSets newRuleSets.ruleSets.qsortOrd⟩
    return { c with ruleSets := ruleSets }

def getPenalty (phase : PhaseName) (c : RuleConfig) : m Int := do
  let (some priority) := c.priority? | throwError
    "{phase} rules must specify an integer penalty"
  let (some penalty) := priority.toInt? | throwError
    "{phase} rules must specify an integer penalty (not a success probability)"
  return penalty

def getSuccessProbability (c : RuleConfig) : m Percent := do
  let (some priority) := c.priority? | throwError
    "unsafe rules must specify a success probability"
  let (some prob) := priority.toPercent? | throwError
    "unsafe rules must specify a success probability (not an integer penalty)"
  return prob

def getSimpPriority (c : RuleConfig) : m Nat := do
  let prio? := do
    let priority ← (← c.priority?).toInt?
    guard $ priority ≥ 0
    return priority.toNat
  let (some prio) := prio? | throwError
    "simp rules must specify a non-negative integer priority"
  return prio

def getTerm (c : RuleConfig) : m Term := do
  let some term := c.term? | throwError
    "missing rule"
  return term

def getPhase (c : RuleConfig) : m PhaseName := do
  let some phase := c.phase? | throwError
    "missing phase (norm/safe/unsafe)"
  return phase

def getBuilder (c : RuleConfig) : m DBuilderName := do
  let some builder := c.builder? | throwError
    "missing rule builder (apply, forward, simp, ...)"
  return builder

def getPhaseSpec (c : RuleConfig) : m PhaseSpec := do
  match ← c.getPhase with
  | .safe =>
    return .safe { penalty := ← c.getPenalty .safe, safety := .safe }
  | .unsafe =>
    return .unsafe { successProbability := ← c.getSuccessProbability }
  | .norm =>
    return .norm { penalty := ← c.getPenalty .norm }

def getRuleBuilderInput (c : RuleConfig) : TermElabM RuleBuilderInput := do
  let term ← c.getTerm
  let phase ← c.getPhaseSpec
  let options := c.builderOptions
  return { term, options, phase }

def buildRule (c : RuleConfig) :
    ElabM (LocalRuleSetMember × Array RuleSetName) := do
  let builder ← c.getBuilder
  let builderInput ← c.getRuleBuilderInput
  let ruleSetMember ← builder.toRuleBuilder builderInput
  return (ruleSetMember, c.ruleSets.ruleSets)

def buildGlobalRule (c : RuleConfig) :
    ElabM (GlobalRuleSetMember × Array RuleSetName) := do
  let (m, rsNames) ← buildRule c
  if let some m := m.toGlobalRuleSetMember? then
    return (m, rsNames)
  else
    throwError "internal error: buildGlobalRule: unexpected local rule"

def buildLocalRule (c : RuleConfig) : ElabM LocalRuleSetMember :=
  (·.fst) <$> c.buildRule

def toRuleFilter (c : RuleConfig) : ElabM (RuleSetNameFilter × RuleFilter) := do
  let term ← c.getTerm
  if ! term.raw.isIdent then
    throwError "erase rule must be a name, not a composite term"
  let some e ← resolveId? term
    | throwError "unknown identifier: {term}"
  let (name, scope) ←
    match e with
    | .const decl _ => pure (decl, .global)
    | .fvar fvarId => pure ((← fvarId.getDecl).userName, .local)
    | _ => throwError "internal error: expected const or fvar, but got '{e}'"
  let builders ←
    match c.builder? with
    | none => pure #[]
    | some b => do
      let (some builder) := b.toBuilderName? | throwError
        "{b} cannot be used when erasing rules.\nUse the corresponding non-default builder (e.g. 'apply' or 'constructors') instead."
        -- We could instead look for the correct non-default builder ourselves
        -- by re-running the logic that determines which builder to use.
      pure #[builder]
  let phases :=
    match c.phase? with
    | none => #[]
    | some p => #[p]
  let ruleSetNames := c.ruleSets.ruleSets
  return ({ ns := ruleSetNames }, { name, scope, builders, phases })

def validateForAdditionalRules (c : RuleConfig) (defaultRuleSet : RuleSetName) :
    m RuleConfig := do
  let term ← c.getTerm
  let (phase, priority) ← getPhaseAndPriority c
  let builder := c.builder?.getD .default
  let builderOptions := c.builderOptions
  let ruleSets :=
    if c.ruleSets.ruleSets.isEmpty then
      ⟨#[defaultRuleSet]⟩
    else
      c.ruleSets
  return {
    term? := term
    phase? := phase
    priority? := priority
    builder? := builder
    builderOptions, ruleSets
  }
where
  getPhaseAndPriority (c : RuleConfig) : m (PhaseName × Priority) :=
    match c.builder?, c.phase?, c.priority? with
    | _, some phase, some prio =>
      return (phase, prio)
    | some (.regular .simp), none, none =>
      return (.norm, .int defaultSimpRulePriority)
    | some (.regular .simp), none, some prio =>
      return (.norm, prio)
    | some (.regular .simp), some phase, none =>
      return (phase, .int defaultSimpRulePriority)
    | _, some .unsafe, none =>
      return (.unsafe, .percent defaultSuccessProbability)
    | _, some .safe, none =>
      return (.safe, .int defaultSafePenalty)
    | _, some .norm, none =>
      return (.norm, .int defaultNormPenalty)
    | _, none, some prio@(.percent _) =>
      return (.unsafe, prio)
    | _, none, _ =>
      throwError "phase (safe/unsafe/norm) not specified."

end RuleConfig


namespace RuleExpr

def toRuleConfigs (e : RuleExpr) (init : RuleConfig) :
    m (Array RuleConfig) :=
  e.foldBranchesM (init := init) λ c feature => c.addFeature feature

def toAdditionalRules (e : RuleExpr) (init : RuleConfig)
    (defaultRuleSet : RuleSetName) : m (Array RuleConfig) := do
  let cs ← e.toRuleConfigs init
  cs.mapM (·.validateForAdditionalRules defaultRuleSet)

def toAdditionalGlobalRules (decl? : Option Name) (e : RuleExpr) :
    m (Array RuleConfig) :=
  let init := {
    term? := decl?.map (mkIdent ·)
    phase? := none
    priority? := none
    builder? := none
    builderOptions := ∅
    ruleSets := ⟨#[]⟩
  }
  toAdditionalRules e init defaultRuleSetName

def buildAdditionalGlobalRules (decl? : Option Name) (e : RuleExpr) :
    TermElabM (Array (GlobalRuleSetMember × Array RuleSetName)) := do
  let go : ElabM _ := do
    (← e.toAdditionalGlobalRules decl?).mapM (·.buildGlobalRule)
  go.run $ ← ElabM.Context.forAdditionalGlobalRules

def toAdditionalLocalRules (e : RuleExpr) : MetaM (Array RuleConfig) :=
  let init := {
    term? := none
    phase? := none
    priority? := none
    builder? := none
    builderOptions := ∅
    ruleSets := ⟨#[]⟩
  }
  toAdditionalRules e init localRuleSetName

def buildAdditionalLocalRules (goal : MVarId) (e : RuleExpr) :
    TermElabM (Array LocalRuleSetMember) :=
  let go : ElabM _ := do (← e.toAdditionalLocalRules).mapM (·.buildLocalRule)
  go.run $ .forAdditionalRules goal

def toRuleFilters (e : RuleExpr) :
    ElabM (Array (RuleSetNameFilter × RuleFilter)) := do
  let initialConfig := {
      term? := none
      phase? := none
      priority? := none
      builder? := none
      builderOptions := ∅
      ruleSets := ⟨#[]⟩
  }
  let configs ← e.toRuleConfigs initialConfig
  configs.mapM (·.toRuleFilter)

def toGlobalRuleFilters (e : RuleExpr) :
    TermElabM (Array (RuleSetNameFilter × RuleFilter)) := do
  e.toRuleFilters |>.run $ ← ElabM.Context.forGlobalErasing

def toLocalRuleFilters (e : RuleExpr) : ElabM (Array RuleFilter) :=
  return (← e.toRuleFilters).map (·.snd)

end Aesop.Frontend.RuleExpr



=== LEAN SOURCE: Saturate.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Saturate
import Aesop.Frontend.Extension
import Aesop.Builder.Forward

open Lean Lean.Meta Lean.Elab Lean.Elab.Term Lean.PrettyPrinter

namespace Aesop.Frontend.Parser

syntax usingRuleSets := "using " ident+
syntax additionalRule := "*" <|> term
syntax additionalRules := "[" additionalRule,* "]"

end Parser

open Parser

def _root_.Aesop.ElabM.runForwardElab (goal : MVarId) (x : ElabM α) :
    TermElabM α :=
  x |>.run { parsePriorities := true, goal }

def mkForwardOptions (maxDepth? : Option Nat) (traceScript : Bool) :
    CoreM Options' :=
  ({ traceScript } : Aesop.Options).toOptions' maxDepth?

def elabGlobalRuleSets (rsNames : Array Ident) :
    CoreM (Array (GlobalRuleSet × Name × Name)) := do
  getGlobalRuleSets $
    (← getDefaultRuleSetNames).toArray ++ rsNames.map (·.getId)

def elabForwardRule (term : Term) : ElabM LocalRuleSetMember := do
  let builderInput := {
    options := ∅
    phase := .safe { penalty := 1, safety := .safe }
    term
  }
  let ctx := { parsePriorities := true, goal := (← read).goal }
  RuleBuilder.forward (isDestruct := false) builderInput |>.run ctx

def mkHypForwardRule (fvarId : FVarId) : ElabM LocalRuleSetMember := do
  elabForwardRule (← delab $ .fvar fvarId)

-- TODO mv
def isImplication (e : Expr) : MetaM Bool :=
  forallBoundedTelescope e (some 1) λ args body =>
    pure (! args.isEmpty) <&&> isProp body

def mkHypImplicationRule? (fvarId : FVarId) :
    ElabM (Option LocalRuleSetMember) := do
  let goal := (← read).goal
  goal.withContext do
  withTransparency .reducible do
    if ← isImplication (← fvarId.getType) then
        mkHypForwardRule fvarId
    else
        return none

def addLocalImplications (rs : LocalRuleSet) : ElabM LocalRuleSet := do
  let goal := (← read).goal
  let mut rs := rs
  for ldecl in (← goal.getDecl).lctx do
    if ldecl.isImplementationDetail then
      continue
    if let some rsMember ← mkHypImplicationRule? ldecl.fvarId then
      rs := rs.add rsMember
  return rs

def elabAdditionalForwardRules (rs : LocalRuleSet) (rules : Array (TSyntax ``additionalRule)) : ElabM LocalRuleSet := do
  let mut rs := rs
  let mut addImplications := false
  for rule in rules do
    match rule with
    | `(additionalRule| *) => addImplications := true
    | `(additionalRule| $t:term) => do
      rs := rs.add (← elabForwardRule t)
    | _ => throwUnsupportedSyntax
  if addImplications then
    rs ← addLocalImplications rs
  return rs

def elabForwardRuleSetCore (rsNames : Array Ident)
    (additionalRules : Array (TSyntax ``additionalRule))
    (options : Options') : ElabM LocalRuleSet := do
  let rss ← elabGlobalRuleSets rsNames
  let rs ← mkLocalRuleSet rss options
  elabAdditionalForwardRules rs additionalRules

def elabForwardRuleSet (rsNames? : Option (TSyntax ``usingRuleSets))
    (additionalRules? : Option (TSyntax ``additionalRules)) (options : Options') :
    ElabM LocalRuleSet := do
  let rsNames? ← rsNames?.mapM λ
    | `(usingRuleSets| using $rs:ident*) => pure rs
    | _ => throwUnsupportedSyntax
  let additionalRules? ← additionalRules?.mapM λ
    | `(additionalRules| [$rs:additionalRule,*]) => pure (rs : Array _)
    | _ => throwUnsupportedSyntax
  elabForwardRuleSetCore (rsNames?.getD #[]) (additionalRules?.getD #[]) options

open Lean.Elab.Tactic

def evalSaturate (depth? : Option (TSyntax `num))
    (rules? : Option (TSyntax ``additionalRules))
    (rs? : Option (TSyntax ``usingRuleSets)) (traceScript : Bool) :
    TacticM Unit := do
  let depth? := depth?.map (·.getNat)
  let options ← mkForwardOptions depth? traceScript
  let rs ← elabForwardRuleSet rs? rules? options
    |>.runForwardElab (← getMainGoal)
  liftMetaTactic1 (saturate rs · options)

elab "saturate " depth?:(num)? ppSpace rules?:(additionalRules)? ppSpace rs?:(usingRuleSets)? : tactic => do
  evalSaturate depth? rules? rs? (traceScript := false)

elab "saturate? " depth?:(num)? ppSpace rules?:(additionalRules)? ppSpace rs?:(usingRuleSets)? : tactic => do
  evalSaturate depth? rules? rs? (traceScript := true)

macro "forward " rules?:(additionalRules)? ppSpace rs?:(usingRuleSets)? : tactic =>
  `(tactic| saturate 1 $[$rules?]? $[$rs?]?)

macro "forward? " rules?:(additionalRules)? ppSpace rs?:(usingRuleSets)? : tactic =>
  `(tactic| saturate? 1 $[$rules?]? $[$rs?]?)

end Aesop.Frontend



=== LEAN SOURCE: Tactic.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Frontend.RuleExpr
import Aesop.Options
import Batteries.Linter.UnreachableTactic
import Aesop.Frontend.Extension

open Lean
open Lean.Meta
open Lean.Elab
open Lean.Elab.Term

namespace Aesop.Frontend.Parser

declare_syntax_cat Aesop.tactic_clause

syntax ruleSetSpec := "-"? ident

syntax " (" &"add " Aesop.rule_expr,+,? ")" : Aesop.tactic_clause
syntax " (" &"erase " Aesop.rule_expr,+,? ")" : Aesop.tactic_clause
syntax " (" &"rule_sets" " := " "[" ruleSetSpec,+,? "]" ")" : Aesop.tactic_clause
syntax " (" &"config" " := " term ")" : Aesop.tactic_clause
syntax " (" &"simp_config" " := " term ")" : Aesop.tactic_clause

/--
`aesop <clause>*` tries to solve the current goal by applying a set of rules
registered with the `@[aesop]` attribute. See [its
README](https://github.com/JLimperg/aesop#readme) for a tutorial and a
reference.

The variant `aesop?` prints the proof it found as a `Try this` suggestion.

Clauses can be used to customise the behaviour of an Aesop call. Available
clauses are:

- `(add <phase> <priority> <builder> <rule>)` adds a rule. `<phase>` is
  `unsafe`, `safe` or `norm`. `<priority>` is a percentage for unsafe rules and
  an integer for safe and norm rules. `<rule>` is the name of a declaration or
  local hypothesis. `<builder>` is the rule builder used to turn `<rule>` into
  an Aesop rule. Example: `(add unsafe 50% apply Or.inl)`.
- `(erase <rule>)` disables a globally registered Aesop rule. Example: `(erase
  Aesop.BuiltinRules.assumption)`.
- `(rule_sets := [<ruleset>,*])` enables or disables named sets of rules for
  this Aesop call. Example: `(rule_sets := [-builtin, MyRuleSet])`.
- `(config { <opt> := <value> })` adjusts Aesop's search options. See
  `Aesop.Options`.
- `(simp_config { <opt> := <value> })` adjusts options for Aesop's built-in
  `simp` rule. The given options are directly passed to `simp`. For example,
  `(simp_config := { zeta := false })` makes Aesop use
  `simp (config := { zeta := false })`.
-/
syntax (name := aesopTactic)  "aesop"  Aesop.tactic_clause* : tactic

@[inherit_doc aesopTactic]
syntax (name := aesopTactic?) "aesop?" Aesop.tactic_clause* : tactic

initialize do
  Batteries.Linter.UnreachableTactic.addIgnoreTacticKind ``aesopTactic
  Batteries.Linter.UnreachableTactic.addIgnoreTacticKind ``aesopTactic?

end Parser

-- Inspired by declare_config_elab
unsafe def elabConfigUnsafe (type : Name) (stx : Syntax) : TermElabM α :=
  withRef stx do
    let e ← withoutModifyingStateWithInfoAndMessages <| withLCtx {} {} <| withSaveInfoContext <| Term.withSynthesize <| withoutErrToSorry do
      let e ← Term.elabTermEnsuringType stx (Lean.mkConst type)
      Term.synthesizeSyntheticMVarsNoPostponing
      instantiateMVars e
    evalExpr' α type e

def elabOptions : Syntax → TermElabM Aesop.Options :=
  unsafe elabConfigUnsafe ``Aesop.Options

def elabSimpConfig : Syntax → TermElabM Simp.Config :=
  unsafe elabConfigUnsafe ``Simp.Config

def elabSimpConfigCtx : Syntax → TermElabM Simp.ConfigCtx :=
  unsafe elabConfigUnsafe ``Simp.ConfigCtx

structure TacticConfig where
  additionalRules : Array RuleExpr
  erasedRules : Array RuleExpr
  enabledRuleSets : Std.HashSet RuleSetName
  options : Aesop.Options
  simpConfig : Simp.Config
  simpConfigSyntax? : Option Term

namespace TacticConfig

def parse (stx : Syntax) (goal : MVarId) : TermElabM TacticConfig :=
  withRef stx do
    match stx with
    | `(tactic| aesop $clauses:Aesop.tactic_clause*) =>
      go (traceScript := false) clauses
    | `(tactic| aesop? $clauses:Aesop.tactic_clause*) =>
      go (traceScript := true) clauses
    | _ => throwUnsupportedSyntax
  where
    go (traceScript : Bool) (clauses : Array (TSyntax `Aesop.tactic_clause)) :
        TermElabM TacticConfig := do
      let init : TacticConfig := {
        additionalRules := #[]
        erasedRules := #[]
        enabledRuleSets := ← getDefaultRuleSetNames
        options := { traceScript }
        simpConfig := {}
        simpConfigSyntax? := none
      }
      let (_, config) ← clauses.forM (addClause traceScript) |>.run init
      let simpConfig ←
        if let some stx := config.simpConfigSyntax? then
          if config.options.useSimpAll then
            (·.toConfig) <$> elabSimpConfigCtx stx
          else
            elabSimpConfig stx
        else
          if config.options.useSimpAll then
            pure { : Simp.ConfigCtx}.toConfig
          else
            pure { : Simp.Config }
        return { config with simpConfig }

    addClause (traceScript : Bool) (stx : TSyntax `Aesop.tactic_clause) :
        StateRefT TacticConfig TermElabM Unit :=
      withRef stx do
        match stx with
        | `(tactic_clause| (add $es:Aesop.rule_expr,*)) => do
          let rs ← (es : Array Syntax).mapM λ e =>
            RuleExpr.elab e |>.run $ .forAdditionalRules goal
          modify λ c => { c with additionalRules := c.additionalRules ++ rs }
        | `(tactic_clause| (erase $es:Aesop.rule_expr,*)) => do
          let rs ← (es : Array Syntax).mapM λ e =>
            RuleExpr.elab e |>.run $ .forErasing goal
          modify λ c => { c with erasedRules := c.erasedRules ++ rs }
        | `(tactic_clause| (rule_sets := [ $specs:ruleSetSpec,* ])) => do
          let mut enabledRuleSets := (← get).enabledRuleSets
          for spec in (specs : Array Syntax) do
            match spec with
            | `(Parser.ruleSetSpec| - $rsName:ident) => do
              let rsName := RuleSetName.elab rsName
              unless enabledRuleSets.contains rsName do throwError
                "aesop: trying to deactivate rule set '{rsName}', but it is not active"
              enabledRuleSets := enabledRuleSets.erase rsName
            | `(Parser.ruleSetSpec| $rsName:ident) => do
              let rsName := RuleSetName.elab rsName
              if enabledRuleSets.contains rsName then throwError
                "aesop: rule set '{rsName}' is already active"
              enabledRuleSets := enabledRuleSets.insert rsName
            | _ => throwUnsupportedSyntax
          modify λ c => { c with enabledRuleSets }
        | `(tactic_clause| (config := $t:term)) =>
          let options ← elabOptions t
          let options :=
            { options with traceScript := options.traceScript || traceScript }
          modify λ c => { c with options }
        | `(tactic_clause| (simp_config := $t:term)) =>
          modify λ c => { c with simpConfigSyntax? := some t }
        | _ => throwUnsupportedSyntax

def updateRuleSet (rs : LocalRuleSet) (c : TacticConfig) (goal : MVarId):
    TermElabM LocalRuleSet := do
  let mut rs := rs
  for ruleExpr in c.additionalRules do
    let rules ← ruleExpr.buildAdditionalLocalRules goal
    for rule in rules do
      rs := rs.add rule

  -- Erase erased rules
  for ruleExpr in c.erasedRules do
    let filters ← ruleExpr.toLocalRuleFilters |>.run $ .forErasing goal
    for rFilter in filters do
      let (rs', anyErased) := rs.erase rFilter
      rs := rs'
      if ! anyErased then
        throwError "aesop: '{rFilter.name}' is not registered (with the given features) in any rule set."
  return rs

def getRuleSet (goal : MVarId) (c : TacticConfig) :
    TermElabM LocalRuleSet :=
  goal.withContext do
    let rss ← getGlobalRuleSets c.enabledRuleSets.toArray
    c.updateRuleSet (← mkLocalRuleSet rss (← c.options.toOptions')) goal

end Aesop.Frontend.TacticConfig



=== LEAN SOURCE: Init.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.RuleSet

open Lean

namespace Aesop

/--
An environment extension containing an Aesop rule set. Each rule set has its
own extension.
-/
abbrev RuleSetExtension :=
  SimpleScopedEnvExtension BaseRuleSetMember BaseRuleSet

/--
Structure containing information about all declared Aesop rule sets.
-/
structure DeclaredRuleSets where
  /--
  The collection of declared rule sets. Each rule set has an extension, the
  name of the associated `SimpExtension` and the name of the associated
  `SimprocExtension`. The two simp extensions are expected to be declared.
  -/
  ruleSets : Std.HashMap RuleSetName (RuleSetExtension × Name × Name)
  /--
  The set of Aesop rule sets that are enabled by default.
  -/
  defaultRuleSets : Std.HashSet RuleSetName
  deriving Inhabited

instance : EmptyCollection DeclaredRuleSets :=
  ⟨∅, ∅⟩

initialize declaredRuleSetsRef : IO.Ref DeclaredRuleSets ←
  IO.mkRef ∅

def getDeclaredRuleSets : IO (Std.HashMap RuleSetName (RuleSetExtension × Name × Name)) :=
  return (← declaredRuleSetsRef.get).ruleSets

def getDefaultRuleSetNames : IO (Std.HashSet Name) :=
  return (← declaredRuleSetsRef.get).defaultRuleSets

end Aesop



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Util.Basic
import Aesop.Rule.Name
import Aesop.RulePattern
import Aesop.Forward.Match.Types

open Lean Lean.Meta

namespace Aesop

inductive IndexingMode : Type
  | unindexed
  | target (keys : Array DiscrTree.Key)
  | hyps (keys : Array DiscrTree.Key)
  | or (imodes : Array IndexingMode)
  deriving Inhabited

namespace IndexingMode

protected partial def format : IndexingMode → Format
  | unindexed => "unindexed"
  | target keys => f!"target {keys}"
  | hyps keys => f!"hyps {keys}"
  | or imodes => f!"or {imodes.map IndexingMode.format}"

instance : ToFormat IndexingMode :=
  ⟨IndexingMode.format⟩

def targetMatchingConclusion (type : Expr) : MetaM IndexingMode := do
  let path ← getConclusionDiscrTreeKeys type
  return target path

def hypsMatchingConst (decl : Name) : MetaM IndexingMode := do
  let path ← getConstDiscrTreeKeys decl
  return hyps path

end IndexingMode


inductive IndexMatchLocation
  | none
  | target
  | hyp (ldecl : LocalDecl)
  deriving Inhabited

namespace IndexMatchLocation

instance : ToMessageData IndexMatchLocation where
  toMessageData
    | none => "none"
    | target => "target"
    | hyp ldecl => m!"hyp {ldecl.userName}"

instance : BEq IndexMatchLocation where
  beq
    | none, none => true
    | target, target => true
    | hyp ldecl₁, hyp ldecl₂ => ldecl₁.fvarId == ldecl₂.fvarId
    | _, _ => false

instance : Ord IndexMatchLocation where
  compare
    | target, target => .eq
    | target, none => .lt
    | target, hyp .. => .lt
    | none, target => .gt
    | none, none => .eq
    | none, hyp .. => .lt
    | hyp .., target => .gt
    | hyp .., none => .gt
    | hyp ldecl₁, hyp ldecl₂ => ldecl₁.fvarId.name.cmp ldecl₂.fvarId.name

instance : Hashable IndexMatchLocation where
  hash
    | none => 7
    | target => 13
    | hyp ldecl => mixHash 17 $ hash ldecl.fvarId

end IndexMatchLocation


/-- A rule that, according to the index, should be applied to the current goal.
In addition to the rule, this data structure contains information about how the
rule should be applied. For example, if the rule has rule patterns, we report
the substitutions obtained by matching the rule patterns against the current
goal. -/
structure IndexMatchResult (α : Type) where
  /-- The rule that should be applied. -/
  rule : α
  /-- Goal locations where the rule matched. The rule's `indexingMode`
  determines which locations can be contained in this set. -/
  locations : Std.HashSet IndexMatchLocation
  /-- Pattern substitutions for this rule that were found in the goal. `none`
  iff the rule doesn't have a pattern. -/
  patternSubsts? : Option (Std.HashSet Substitution)
  deriving Inhabited

namespace IndexMatchResult

instance [Ord α] : Ord (IndexMatchResult α) where
  compare r s := compare r.rule s.rule

instance [Ord α] : LT (IndexMatchResult α) :=
  ltOfOrd

instance [ToMessageData α] : ToMessageData (IndexMatchResult α) where
  toMessageData r := toMessageData r.rule

end Aesop.IndexMatchResult



=== LEAN SOURCE: DiscrKeyConfig.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Lean

open Lean Lean.Meta

namespace Aesop

/-- The configuration used by all Aesop indices. -/
-- I don't really know what I'm doing here. I'm just copying the config used
-- by `simp`; see `Meta/Simp/Types.lean:mkIndexConfig`.
def indexConfig : ConfigWithKey :=
  ({ proj := .no, transparency := .reducible : Config }).toConfigWithKey

def mkDiscrTreePath (e : Expr) : MetaM (Array DiscrTree.Key) :=
  withConfigWithKey indexConfig $ DiscrTree.mkPath e

def getUnify (t : DiscrTree α) (e : Expr) : MetaM (Array α) :=
  withConfigWithKey indexConfig $ t.getUnify e

def getMatch (t : DiscrTree α) (e : Expr) : MetaM (Array α) :=
  withConfigWithKey indexConfig $ t.getMatch e

end Aesop



=== LEAN SOURCE: DiscrTreeConfig.lean ===
/-
Copyright (c) 2021-2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Lean

namespace Aesop

open Lean Lean.Meta

/-- The configuration used by all Aesop indices. -/
-- I don't really know what I'm doing here. I'm just copying the config used
-- by `simp`; see `Meta/Simp/Types.lean:mkIndexConfig`.
def indexConfig : ConfigWithKey :=
  ({ proj := .no, transparency := .reducible : Config }).toConfigWithKey

def mkDiscrTreePath (e : Expr) : MetaM (Array DiscrTree.Key) :=
  withConfigWithKey indexConfig $ DiscrTree.mkPath e

def getUnify (t : DiscrTree α) (e : Expr) : MetaM (Array α) :=
  withConfigWithKey indexConfig $ t.getUnify e

def getMatch (t : DiscrTree α) (e : Expr) : MetaM (Array α) :=
  withConfigWithKey indexConfig $ t.getMatch e

end Aesop



=== LEAN SOURCE: Forward.lean ===
/-
Copyright (c) 2024 Xavier Généreux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Xavier Généreux, Jannis Limperg
-/

import Aesop.Forward.Match.Types
import Aesop.Rule.Forward
import Aesop.Index.Basic
import Batteries.Lean.Meta.DiscrTree

set_option linter.missingDocs true

open Lean Lean.Meta

namespace Aesop

/-- Index for forward rules. -/
structure ForwardIndex where
  /-- Maps expressions `T` to all tuples `(r, i)` where `r : ForwardRule`,
  `i : PremiseIndex` and the `i`-th argument of the type of `r.expr` (counting
  from zero) likely unifies with `T`. -/
  tree : DiscrTree (ForwardRule × PremiseIndex)
  /-- Indexes the forward rules contained in `tree` by name. -/
  nameToRule : PHashMap RuleName ForwardRule
  /-- Constant forward rules, i.e. forward rules that have no premises and no
  rule pattern. -/
  constRules : PHashSet ForwardRule
  deriving Inhabited

namespace ForwardIndex

instance : EmptyCollection ForwardIndex := by
  refine' ⟨{..}⟩ <;> exact {}

/-- Trace the rules contained in `idx` if `traceOpt` is enabled. -/
protected def trace (traceOpt : TraceOption) (idx : ForwardIndex) : CoreM Unit := do
  if ! (← traceOpt.isEnabled) then
    return
  else
    have : Ord (ForwardRule × PremiseIndex) := ⟨λ (r₁, _) (r₂, _) => compare r₁ r₂⟩
    have : BEq (ForwardRule × PremiseIndex) := ⟨λ (r₁, _) (r₂, _) => r₁ == r₂⟩
    let rs := idx.tree.values.qsortOrd.dedupSorted
    rs.forM λ (r, _) => do aesop_trace![traceOpt] r

/-- Merge two indices. -/
def merge (idx₁ idx₂ : ForwardIndex) : ForwardIndex where
  tree := idx₁.tree.mergePreservingDuplicates idx₂.tree
  nameToRule := idx₁.nameToRule.mergeWith idx₂.nameToRule λ _ r₁ _ => r₁
  constRules := idx₂.constRules.fold (init := idx₁.constRules) λ s r => s.insert r

/-- Insert a forward rule into the `ForwardIndex`. -/
def insert (r : ForwardRule) (idx : ForwardIndex) : ForwardIndex := Id.run do
  if r.isConstant then
    return {
      idx with
      constRules := idx.constRules.insert r
      nameToRule := idx.nameToRule.insert r.name r
    }
  else
    let mut tree := idx.tree
    for cluster in r.slotClusters do
      for slot in cluster do
        let some discrTreeKeys := slot.typeDiscrTreeKeys?
          | continue
        tree := tree.insertCore discrTreeKeys (r, slot.premiseIndex)
    let nameToRule := idx.nameToRule.insert r.name r
    return { idx with tree, nameToRule }

/-- Get the forward rules whose maximal premises likely unify with `e`.
Each returned pair `(r, i)` contains a rule `r` and the index `i` of the premise
of `r` that likely unifies with `e`. -/
def get (idx : ForwardIndex) (e : Expr) :
    MetaM (Array (ForwardRule × PremiseIndex)) :=
  getUnify idx.tree e

/-- Get the forward rule with the given rule name. -/
def getRuleWithName? (n : RuleName) (idx : ForwardIndex) : Option ForwardRule :=
  idx.nameToRule[n]

/-- Get forward rule matches for the constant forward rules (i.e., those with no
premises and no rule pattern). Accordingly, the returned matches contain no
hypotheses. -/
def getConstRuleMatches (idx : ForwardIndex) : Array ForwardRuleMatch :=
  idx.constRules.fold (init := #[]) λ ms r =>
    ms.push { rule := r, «match» := ∅ }

end Aesop.ForwardIndex



=== LEAN SOURCE: RulePattern.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Index.Basic
import Aesop.RuleTac.GoalDiff
import Batteries.Lean.Meta.DiscrTree

set_option linter.missingDocs true

open Lean Lean.Meta

namespace Aesop

/-- A map from rule names to rule pattern substitutions. When run on a goal,
the rule pattern index returns such a map. -/
abbrev RulePatternSubstMap := Std.HashMap RuleName (Std.HashSet Substitution)

namespace RulePatternSubstMap

/-- Insert an array of rule pattern substitutions into a rule pattern
substitution map. -/
def insertArray (xs : Array (RuleName × Substitution))
    (m : RulePatternSubstMap) : RulePatternSubstMap :=
  xs.foldl (init := m) λ m (r, inst) =>
    match m[r]? with
    | none => m.insert r $ (∅ : Std.HashSet _).insert inst
    | some insts => m.insert r $ insts.insert inst

/-- Build a rule pattern substitution map from an array of substitutions. -/
def ofArray (xs : Array (RuleName × Substitution)) : RulePatternSubstMap :=
  (∅ : RulePatternSubstMap).insertArray xs

/-- Convert a rule pattern substitution map to a flat array of substitutions. -/
def toFlatArray (m : RulePatternSubstMap) : Array (RuleName × Substitution) :=
  m.fold (init := #[]) λ acc r patInsts =>
    patInsts.fold (init := acc) λ acc patInst =>
      acc.push (r, patInst)

end RulePatternSubstMap


/-- An entry of the rule pattern index. -/
structure RulePatternIndex.Entry where
  /-- The name of the rule to which the pattern belongs. -/
  name : RuleName
  /-- The rule's pattern. We assume that there is at most one pattern per
  rule. -/
  pattern : RulePattern
  deriving Inhabited

instance : BEq RulePatternIndex.Entry where
  beq e₁ e₂ := e₁.name == e₂.name

set_option linter.missingDocs false in
/-- A rule pattern index. Maps expressions `e` to rule patterns that likely
unify with `e`. -/
structure RulePatternIndex where
  /-- The index. -/
  tree : DiscrTree RulePatternIndex.Entry
  /-- `true` iff the index contains no patterns. -/
  isEmpty : Bool
  deriving Inhabited

namespace RulePatternIndex

instance : EmptyCollection RulePatternIndex :=
  ⟨⟨{}, true⟩⟩

/-- Add a rule pattern to the index. -/
def add (name : RuleName) (pattern : RulePattern) (idx : RulePatternIndex) :
    RulePatternIndex :=
  ⟨idx.tree.insertCore pattern.discrTreeKeys { name, pattern }, false⟩

/-- Merge two rule pattern indices. Patterns that appear in both indices appear
twice in the result. -/
def merge (idx₁ idx₂ : RulePatternIndex) : RulePatternIndex :=
  if idx₁.isEmpty then
    idx₂
  else if idx₂.isEmpty then
    idx₁
  else
    ⟨idx₁.tree.mergePreservingDuplicates idx₂.tree, false⟩

section Get

/-- Get rule pattern substitutions for the patterns that match `e`. -/
def getSingle (e : Expr) (idx : RulePatternIndex) :
    BaseM (Array (RuleName × Substitution)) := do
  if idx.isEmpty then
    return #[]
  let ms ← getUnify idx.tree e
  ms.filterMapM λ { name := r, pattern } => do
    let some subst ← pattern.match e
      | return none
    return (r, subst)

/-- Get all substitutions of the rule patterns that match a subexpression of
`e`. Subexpressions containing bound variables are not considered. The returned
array may contain duplicates. -/
def getCore (e : Expr) (idx : RulePatternIndex) :
    BaseM (Array (RuleName × Substitution)) := do
  if idx.isEmpty then
    return #[]
  let e ← instantiateMVars e
  checkCache (β := RulePatternCache.Entry) e λ _ => do
    let (_, ms) ← e.forEach getSubexpr |>.run #[]
    return ms
where
  getSubexpr (e : Expr) :
      StateRefT (Array (RuleName × Substitution)) BaseM Unit := do
    if e.hasLooseBVars then
      -- We don't visit subexpressions with loose bvars. Substitutions
      -- derived from such subexpressions would not be valid in the goal's
      -- context. E.g. if a rule `(x : T) → P x` has pattern `x` and we
      -- have the expression `λ (y : T), y` in the goal, then it makes no
      -- sense to match `y` and generate `P y`.
      return
    let ms ← idx.getSingle e
    modifyThe (Array _) (· ++ ms)

@[inherit_doc getCore]
def get (e : Expr) (idx : RulePatternIndex) : BaseM RulePatternSubstMap :=
  .ofArray <$> idx.getCore e

/-- Get all substitutions of the rule patterns that match a subexpression of
the given local declaration. Subexpressions containing bound variables are not
considered. -/
def getInLocalDeclCore (acc : RulePatternSubstMap) (ldecl : LocalDecl)
    (idx : RulePatternIndex) : BaseM RulePatternSubstMap := do
  if idx.isEmpty then
    return acc
  let mut result := acc
  result := result.insertArray $ ← idx.getCore ldecl.toExpr
  result := result.insertArray $ ← idx.getCore ldecl.type
  if let some val := ldecl.value? then
    result := result.insertArray $ ← idx.getCore val
  return result

@[inherit_doc getInLocalDeclCore]
def getInLocalDecl (ldecl : LocalDecl) (idx : RulePatternIndex) :
    BaseM RulePatternSubstMap :=
  idx.getInLocalDeclCore ∅ ldecl

/-- Get all substitutions of the rule patterns that match a subexpression of
a hypothesis or the target. Subexpressions containing bound variables are not
considered. -/
def getInGoal (goal : MVarId) (idx : RulePatternIndex) :
    BaseM RulePatternSubstMap :=
  goal.withContext do
    if idx.isEmpty then
      return ∅
    let mut result := ∅
    for ldecl in (← goal.getDecl).lctx do
      unless ldecl.isImplementationDetail do
        result ← idx.getInLocalDeclCore result ldecl
    result := result.insertArray $ ← idx.getCore (← goal.getType)
    return result

end Get

end Aesop.RulePatternIndex



=== LEAN SOURCE: Internal.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Check
import Aesop.Options.Public

open Lean
open Lean.Meta

namespace Aesop

structure Options' extends Options where
  generateScript : Bool
  forwardMaxDepth? : Option Nat
  deriving Inhabited

def Options.toOptions' [Monad m] [MonadOptions m] (opts : Options)
    (forwardMaxDepth? : Option Nat := none) : m Options' := do
  let generateScript ←
    pure (aesop.dev.generateScript.get (← getOptions)) <||>
    pure opts.traceScript <||>
    Check.script.isEnabled <||>
    Check.script.steps.isEnabled
  return { opts with generateScript, forwardMaxDepth? }

end Aesop



=== LEAN SOURCE: Public.lean ===
import Lean

open Lean Lean.Meta

namespace Aesop

set_option linter.missingDocs true

/--
Search strategies which Aesop can use.
-/
inductive Strategy
  /--
  Best-first search. This is the default strategy.
  -/
  | bestFirst
  /--
  Depth-first search. Whenever a rule is applied, Aesop immediately tries to
  solve each of its subgoals (from left to right), up to the maximum rule
  application depth. Goal and rule priorities are ignored, except to decide
  which rule is applied first.
  -/
  | depthFirst
  /--
  Breadth-first search. Aesop always works on the oldest unsolved goal. Goal and
  rule priorities are ignored, except to decide which rule is applied first.
  -/
  | breadthFirst
  deriving Inhabited, BEq, Repr

/--
Options which modify the behaviour of the `aesop` tactic.
-/
structure Options where
  /--
  The search strategy used by Aesop.
  -/
  strategy := Strategy.bestFirst
  /--
  The maximum number of rule applications in any branch of the search tree
  (i.e., the maximum search depth). When a branch exceeds this limit, it is
  considered unprovable, but other branches may still be explored. 0 means no
  limit.
  -/
  maxRuleApplicationDepth := 30
  /--
  Maximum total number of rule applications in the search tree. When this limit
  is exceeded, the search ends. 0 means no limit.
  -/
  maxRuleApplications := 200
  /--
  Maximum total number of goals in the search tree. When this limit is exceeded,
  the search ends. 0 means no limit.
  -/
  maxGoals := 0
  /--
  Maximum number of norm rules applied to a single goal. When this limit is
  exceeded, normalisation is likely stuck in an infinite loop, so Aesop fails. 0
  means no limit.
  -/
  maxNormIterations := 100
  /--
  When Aesop fails to prove a goal, it reports the goals that remain after safe
  rules have been applied exhaustively to the root goal, the safe
  descendants of the root goal, and so on (i.e., after the "safe prefix" of the
  search tree has been unfolded). However, it is possible for the search to fail
  before the safe prefix has been completely generated. In this case, Aesop
  expands the safe prefix after the fact. This option limits the number of
  additional rule applications generated during this process. 0 means no limit.
  -/
  maxSafePrefixRuleApplications := 50
  /--
  Heartbeat limit for individual Aesop rules. If a rule goes over this limit, it
  fails, but Aesop itself continues until it reaches the limit set by the
  `maxHeartbeats` option. If `maxRuleHeartbeats = 0` or `maxRuleHeartbeats` is
  greater than `maxHeartbeats`, the `maxHeartbeats` limit is used for the
  individual rules as well.
  -/
  maxRuleHeartbeats := 0
  /--
  Heartbeat limit for Aesop's builtin `simp` rule. If `simp` goes over this
  limit, Aesop fails. If `maxSimpHeartbeats = 0`, there is no limit for `simp`
  (but the global heartbeat limit still applies).
  -/
  maxSimpHeartbeats := 0
  /--
  Heartbeat limit for Aesop's builtin `unfold` rule. If `unfold` goes over this
  limit, Aesop fails. If `maxUnfoldHeartbeats = 0`, there is no limit for
  `unfold` (but the global heartbeat limit still applies).
  -/
  maxUnfoldHeartbeats := 0
  /--
  The transparency used by the `applyHyps` builtin rule. The rule applies a
  hypothesis `h : T` if `T ≡ ∀ (x₁ : X₁) ... (xₙ : Xₙ), Y` at the given
  transparency and if additionally the goal's target is defeq to `Y` at the
  given transparency.
  -/
  applyHypsTransparency : TransparencyMode := .default
  /--
  The transparency used by the `assumption` builtin rule. The rule applies a
  hypothesis `h : T` if `T` is defeq to the goal's target at the given
  transparency.
  -/
  assumptionTransparency : TransparencyMode := .default
  /--
  The transparency used by the `destructProducts` builtin rule. The rule splits
  a hypothesis `h : T` if `T` is defeq to a product-like type (e.g. `T ≡ A ∧ B`
  or `T ≡ A × B`) at the given transparency.

  Note: we can index this rule only if the transparency is `.reducible`. With
  any other transparency, the rule becomes unindexed and is applied to every
  goal.
  -/
  destructProductsTransparency : TransparencyMode := .reducible
  /--
  If this option is not `none`, the builtin `intros` rule unfolds the goal's
  target with the given transparency to discover `∀` binders. For example, with
  `def T := ∀ x y : Nat, x = y`, `introsTransparency? := some .default` and goal
  `⊢ T`, the `intros` rule produces the goal `x, y : Nat ⊢ x = y`. With
  `introsTransparency? := some .reducible`, it produces `⊢ T`. With
  `introsTransparency? := none`, it only introduces arguments which are
  syntactically bound by `∀` binders, so it also produces `⊢ T`.
  -/
  introsTransparency? : Option TransparencyMode := none
  /--
  If `true`, Aesop succeeds only if it proves the goal. If `false`, Aesop always
  succeeds and reports the goals remaining after safe rules were applied.
  -/
  terminal := false
  /--
  If `true`, print a warning when Aesop does not prove the goal.
  -/
  warnOnNonterminal := true
  /--
  If Aesop proves a goal and this option is `true`, Aesop prints a tactic proof
  as a `Try this:` suggestion.
  -/
  traceScript := false
  /--
  Enable the builtin `simp` normalisation rule.
  -/
  enableSimp := true
  /--
  Use `simp_all`, rather than `simp at *`, for the builtin `simp` normalisation
  rule.
  -/
  useSimpAll := true
  /--
  Use simp theorems from the default `simp` set, i.e. those tagged with
  `@[simp]`. If this option is `false`, Aesop uses only Aesop-specific simp
  theorems, i.e. those tagged with `@[aesop simp]`. Note that the congruence
  lemmas from the default `simp` set are always used.
  -/
  useDefaultSimpSet := true
  /--
  Enable the builtin `unfold` normalisation rule.
  -/
  enableUnfold := true
  deriving Inhabited, BEq, Repr

/--
(aesop) Only for use by Aesop developers. Enables dynamic script structuring.
-/
register_option aesop.dev.dynamicStructuring : Bool := {
  descr := "(aesop) Only for use by Aesop developers. Enables dynamic script structuring."
  defValue := true
}

/--
(aesop) Only for use by Aesop developers. Uses static structuring instead of
dynamic structuring if no metavariables appear in the proof.
-/
register_option aesop.dev.optimizedDynamicStructuring : Bool := {
  descr := "(aesop) Only for use by Aesop developers. Uses static structuring instead of dynamic structuring if no metavariables appear in the proof."
  defValue := true
}

/--
(aesop) Only for use by Aesop developers. Generates a script even if none was requested.
-/
register_option aesop.dev.generateScript : Bool := {
  descr := "(aesop) Only for use by Aesop developers. Generates a script even if none was requested."
  defValue := false
}

/--
(aesop) Only for use by Aesop developers. Enables the new stateful forward reasoning engine.
-/
register_option aesop.dev.statefulForward : Bool := {
  descr := "(aesop) Only for use by Aesop developers. Enables the new stateful forward reasoning engine."
  defValue := true
}

/--
(aesop) Warn when apply builder is applied to a rule with conclusion of the form A ↔ B
-/
register_option aesop.warn.applyIff : Bool := {
  descr := "(aesop) Warn when apply builder is applied to a rule with conclusion of the form A ↔ B"
  defValue := true
}

end Aesop



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Lean

set_option linter.missingDocs true

open Lean Lean.Meta

namespace Aesop

/-- `MData` tag for expressions that are proofs. -/
def mdataPINFIsProofName : Name :=
  `Aesop.pinfIsProof

/-- Modify `d` to indicate that the enclosed expression is a proof. -/
def mdataSetIsProof (d : MData) : MData :=
  d.insert mdataPINFIsProofName true

/-- Check whether `d` indicates that the enclosed expression is a proof. -/
def mdataIsProof (d : MData) : Bool :=
  d.getBool mdataPINFIsProofName (defVal := false)

mutual
  /-- Check whether two expressions in PINF are equal. We assume that the two
  expressions are type-correct, in PINF and have defeq types. -/
  def pinfEqCore : (x y : Expr) → Bool
    | .bvar i₁, .bvar i₂ => i₁ == i₂
    | .fvar id₁, .fvar id₂ => id₁ == id₂
    | .mvar id₁, .mvar id₂ => id₁ == id₂
    | .sort u, .sort v => u == v
    | .const n₁ us, .const n₂ vs => n₁ == n₂ && us == vs
    | .app f₁ e₁, .app f₂ e₂ => pinfEq f₁ f₂ && pinfEq e₁ e₂
    | .lam _ t₁ e₁ bi₁, .lam _ t₂ e₂ bi₂ =>
      bi₁ == bi₂ && pinfEq t₁ t₂ && pinfEq e₁ e₂
    | .forallE _ t₁ e₁ bi₁, .forallE _ t₂ e₂ bi₂ =>
      bi₁ == bi₂ && pinfEq t₁ t₂ && pinfEq e₁ e₂
    | .letE _ t₁ v₁ e₁ _, .letE _ t₂ v₂ e₂ _ =>
      pinfEq v₁ v₂ && pinfEq t₁ t₂ && pinfEq e₁ e₂
    | .lit l₁, .lit l₂ => l₁ == l₂
    | .mdata d e₁, e₂ | e₁, .mdata d e₂ => mdataIsProof d || pinfEq e₁ e₂
    | _, _ => false

  @[inherit_doc pinfEqCore]
  def pinfEq (x y : Expr) : Bool :=
    (unsafe ptrEq x y) || pinfEqCore x y
end

/-- Compute the PINF hash of an expression in PINF. The hash ignores binder
names, binder info and proofs marked by `mdataPINFIsProofName`. -/
partial def pinfHashCore (e : Expr) :
    StateRefT (Std.HashMap UInt64 UInt64) (ST s) UInt64 :=
  have : MonadHashMapCacheAdapter UInt64 UInt64
           (StateRefT (Std.HashMap UInt64 UInt64) (ST s)) := {
    getCache := get
    modifyCache := modify
  }
  checkCache e.hash λ _ => do
    match e with
    | .app .. =>
      let h ← pinfHashCore e.getAppFn
      e.getAppArgs.foldlM (init := h) λ h arg =>
        return mixHash h (← pinfHashCore arg)
    | .lam _ t b _ | .forallE _ t b _ =>
      return mixHash (← pinfHashCore t) (← pinfHashCore b)
    | .letE _ t v b _ =>
      return mixHash (← pinfHashCore t) $
        mixHash (← pinfHashCore v) (← pinfHashCore b)
    | .proj t i e =>
      return mixHash (← pinfHashCore e) $ mixHash (hash t) (hash i)
    | .mdata d e => if mdataIsProof d then return 13 else pinfHashCore e
    | .sort .. | .mvar .. | .lit .. | .const .. | .fvar .. | .bvar .. =>
      return e.hash

@[inherit_doc pinfHashCore]
def pinfHash (e : Expr) : UInt64 :=
  runST λ _ => pinfHashCore e |>.run' ∅

set_option linter.missingDocs false in
/-- An expression in PINF at transparency `md`. -/
structure PINFRaw (md : TransparencyMode) where
  toExpr : Expr
  deriving Inhabited

instance : BEq (PINFRaw md) where
  beq x y := pinfEq x.toExpr y.toExpr

instance : Hashable (PINFRaw md) where
  hash x := pinfHash x.toExpr

instance : ToString (PINFRaw md) where
  toString x := toString x.toExpr

instance : ToFormat (PINFRaw md) where
  format x := format x.toExpr

instance : ToMessageData (PINFRaw md) where
  toMessageData x := toMessageData x.toExpr

/-- An expression in PINF at `reducible` transparency. -/
abbrev RPINFRaw := PINFRaw .reducible

set_option linter.missingDocs false in
/-- Cache for `rpinf`. -/
structure RPINFCache where
  map : Std.HashMap Expr RPINFRaw
  deriving Inhabited

instance : EmptyCollection RPINFCache :=
  ⟨⟨∅⟩⟩

set_option linter.missingDocs false in
/-- An expression in PINF at transparency `md`, together with its PINF hash as
computed by `pinfHash`. -/
structure PINF (md : TransparencyMode) where
  toExpr : Expr
  hash : UInt64
  deriving Inhabited

instance : BEq (PINF md) where
  beq x y := pinfEq x.toExpr y.toExpr

instance : Hashable (PINF md) where
  hash x := x.hash

instance : Ord (PINF md) where
  compare x y :=
    if x == y then .eq else if x.toExpr.lt y.toExpr then .lt else .gt

instance : ToString (PINF md) where
  toString x := toString x.toExpr

instance : ToFormat (PINF md) where
  format x := format x.toExpr

instance : ToMessageData (PINF md) where
  toMessageData x := toMessageData x.toExpr

/-- An expression in RPINF together with its RPINF hash. -/
abbrev RPINF := PINF .reducible

end Aesop



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Index.Basic
import Aesop.Rule.Name
import Aesop.RuleTac.Basic
import Aesop.RuleTac.Descr

open Lean

namespace Aesop

structure Rule (α : Type) where
  name : RuleName
  indexingMode : IndexingMode
  pattern? : Option RulePattern
  extra : α
  tac : RuleTacDescr
  deriving Inhabited

namespace Rule

instance : BEq (Rule α) where
  beq r s := r.name == s.name

instance : Ord (Rule α) where
  compare r s := compare r.name s.name

instance : Hashable (Rule α) where
  hash r := hash r.name

def compareByPriority [Ord α] (r s : Rule α) : Ordering :=
  compare r.extra s.extra

def compareByName (r s : Rule α) : Ordering :=
  r.name.compare s.name

def compareByPriorityThenName [Ord α] (r s : Rule α) : Ordering :=
  compareByPriority r s |>.then $ compareByName r s

@[inline]
protected def map (f : α → β) (r : Rule α) : Rule β :=
  { r with extra := f r.extra }

@[inline]
protected def mapM [Monad m] (f : α → m β) (r : Rule α) : m (Rule β) :=
  return { r with extra := ← f r.extra }

end Aesop.Rule



=== LEAN SOURCE: Forward.lean ===
/-
Copyright (c) 2024 Xavier Généreux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Xavier Généreux, Jannis Limperg
-/

import Aesop.Forward.RuleInfo
import Aesop.Percent
import Aesop.Rule.Name
import Aesop.RuleTac.RuleTerm

set_option linter.missingDocs true

open Lean Lean.Meta

namespace Aesop

/-- The priority of a forward rule. -/
inductive ForwardRulePriority : Type where
  /-- If the rule is a norm or safe rule, its priority is an integer. -/
  | normSafe (n : Int) : ForwardRulePriority
  /-- If the rule is an unsafe rule, its priority is a percentage representing
  the rule's success probability. -/
  | «unsafe» (p : Percent) : ForwardRulePriority
  deriving Inhabited, BEq

namespace ForwardRulePriority

/-- If a `ForwardRulePriority` contains a penalty, extract it. -/
def penalty? : ForwardRulePriority → Option Int
  | .normSafe n => some n
  | .unsafe .. => none

/-- If a `ForwardRulePriority` contains a success probability, extract it. -/
def successProbability? : ForwardRulePriority → Option Percent
  | .unsafe p => some p
  | .normSafe .. => none

/-- Compare two rule priorities. Less means higher priority ('better').
Norm/safe rules have higher priority than unsafe rules. Among norm/safe rules,
lower penalty is better. Among unsafe rules, higher percentage is better. -/
protected def compare : (p₁ p₂ : ForwardRulePriority) → Ordering
  | .normSafe .., .unsafe .. => .lt
  | .unsafe .., .normSafe .. => .gt
  | .normSafe n₁, .normSafe n₂ => compare n₁ n₂
  | .unsafe p₁, .unsafe p₂ => compare p₁ p₂ |>.swap

instance : Ord ForwardRulePriority :=
  ⟨ForwardRulePriority.compare⟩

instance : ToString ForwardRulePriority where
  toString
    | .normSafe n => toString n
    | .unsafe p => p.toHumanString

end ForwardRulePriority

/-- A forward rule. -/
structure ForwardRule extends ForwardRuleInfo where
  /-- The rule's name. Should be unique among all rules in a rule set. -/
  name : RuleName
  /-- The theorem from which this rule is derived. -/
  term : RuleTerm
  /-- The rule's priority. -/
  prio : ForwardRulePriority
  deriving Inhabited

namespace ForwardRule

instance : BEq ForwardRule :=
  ⟨λ r₁ r₂ => r₁.name == r₂.name⟩

instance : Hashable ForwardRule :=
  ⟨λ r => hash r.name⟩

instance : Ord ForwardRule :=
  ⟨λ r₁ r₂ => compare r₁.prio r₂.prio |>.then (compare r₁.name r₂.name)⟩

instance : ToString ForwardRule where
  toString r := s!"[{r.prio}] {r.name}"

/-- Is this rule a `destruct` rule (i.e., should we clear matched hyps)? -/
def destruct (r : ForwardRule) : Bool :=
  r.name.builder matches .destruct

end Aesop.ForwardRule



=== LEAN SOURCE: Name.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Lean.Meta.Basic

open Lean
open Lean.Meta

namespace Aesop

inductive PhaseName
  | norm
  | safe
  | «unsafe»
  deriving Inhabited, BEq, Hashable
  -- NOTE: Constructors should be listed in alphabetical order for the Ord
  -- instance.

namespace PhaseName

instance : Ord PhaseName where
  compare s₁ s₂ := compare s₁.toCtorIdx s₂.toCtorIdx

instance : ToString PhaseName where
  toString
    | norm => "norm"
    | safe => "safe"
    | «unsafe» => "unsafe"

end PhaseName


inductive ScopeName
  | global
  | «local»
  deriving Inhabited, BEq, Hashable
  -- NOTE: Constructors should be listed in alphabetical order for the Ord
  -- instance.

namespace ScopeName

instance : Ord ScopeName where
  compare s₁ s₂ := compare s₁.toCtorIdx s₂.toCtorIdx

instance : ToString ScopeName where
  toString
    | global => "global"
    | «local» => "local"

end ScopeName


inductive BuilderName
  | apply
  | cases
  | constructors
  | destruct
  | forward
  | simp
  | tactic
  | unfold
  deriving Inhabited, BEq, Hashable
  -- NOTE: Constructors should be listed in alphabetical order for the Ord
  -- instance.

namespace BuilderName

instance : Ord BuilderName where
  compare b₁ b₂ := compare b₁.toCtorIdx b₂.toCtorIdx

instance : ToString BuilderName where
  toString
    | apply => "apply"
    | cases => "cases"
    | constructors => "constructors"
    | destruct => "destruct"
    | forward => "forward"
    | simp => "simp"
    | tactic => "tactic"
    | unfold => "unfold"

end BuilderName


-- Rules are identified by a `RuleName` throughout Aesop. We assume that rule
-- names are unique within our 'universe', i.e. within the rule sets that we are
-- working with. All data structures should enforce this invariant.
structure RuleName where
  name : Name
  builder : BuilderName
  phase : PhaseName
  scope : ScopeName
  protected hash : UInt64 :=
    mixHash (hash name) $ mixHash (hash builder) $ mixHash (hash phase)
      (hash scope)
  deriving Inhabited

namespace RuleName

instance : Hashable RuleName where
  hash n := n.hash

instance : BEq RuleName where
  beq n₁ n₂ :=
    n₁.hash == n₂.hash && n₁.builder == n₂.builder && n₁.phase == n₂.phase &&
    n₁.scope == n₂.scope && n₁.name == n₂.name

protected def compare : (_ _ : RuleName) → Ordering :=
  compareLex (compareOn (·.builder)) $
  compareLex (compareOn (·.phase)) $
  compareLex (compareOn (·.scope)) $
  (λ n₁ n₂ => n₁.name.cmp n₂.name)

protected def quickCompare (n₁ n₂ : RuleName) : Ordering :=
  match compare n₁.hash n₂.hash with
  | Ordering.eq => n₁.compare n₂
  | ord => ord

instance : Ord RuleName :=
  ⟨RuleName.compare⟩

instance : ToString RuleName where
  toString n :=
    toString n.phase ++ "|" ++ toString n.builder ++ "|" ++ toString n.scope ++
    "|" ++ toString n.name

end RuleName

def getRuleNameForExpr : Expr → MetaM Name
  | .const decl _ => return decl
  | .fvar fvarId => return (← fvarId.getDecl).userName
  | _ => mkFreshId


inductive DisplayRuleName
  | ruleName (n : RuleName)
  | normSimp
  | normUnfold
  deriving Inhabited, BEq, Ord, Hashable

namespace DisplayRuleName

instance : Coe RuleName DisplayRuleName :=
  ⟨DisplayRuleName.ruleName⟩

instance : ToString DisplayRuleName where
  toString
    | ruleName n => toString n
    | normSimp => "<norm simp>"
    | normUnfold => "<norm unfold>"

end Aesop.DisplayRuleName



=== LEAN SOURCE: Cache.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Forward.Substitution
import Aesop.Rule.Name

open Lean

set_option linter.missingDocs true

namespace Aesop

/-- Entry of the rule pattern cache. -/
def RulePatternCache.Entry := Array (RuleName × Substitution)

set_option linter.missingDocs false in
/-- A cache for the rule pattern index. -/
structure RulePatternCache where
  map : Std.HashMap Expr RulePatternCache.Entry
  deriving Inhabited

instance : EmptyCollection RulePatternCache :=
  ⟨⟨∅⟩⟩

end Aesop



=== LEAN SOURCE: Filter.lean ===
/-
Copyright (c) 2021-2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.RuleSet.Name
import Aesop.Rule.Name

open Lean

namespace Aesop

structure RuleFilter where
  name : Name
  scope : ScopeName
  /--
  `#[]` means 'match any builder'
  -/
  builders : Array BuilderName
  /--
  `#[]` means 'match any phase'
  -/
  phases : Array PhaseName

namespace RuleFilter

def matchesPhase (f : RuleFilter) (p : PhaseName) : Bool :=
  f.phases.isEmpty || f.phases.contains p

def matchesBuilder (f : RuleFilter) (b : BuilderName) : Bool :=
  f.builders.isEmpty || f.builders.contains b

def «matches» (f : RuleFilter) (n : RuleName) : Bool :=
  f.name == n.name &&
  f.scope == n.scope &&
  f.matchesPhase n.phase &&
  f.matchesBuilder n.builder

def matchesSimpTheorem? (f : RuleFilter) : Option Name :=
  if f.scope == .global && f.matchesBuilder .simp then
    some f.name
  else
    none

/--
Returns the identifier of the local norm simp rule matched by `f`, if any.
-/
def matchesLocalNormSimpRule? (f : RuleFilter) : Option Name := Id.run do
  if f.scope == .local && f.matchesBuilder .simp then
    return some f.name
  return none

end RuleFilter


structure RuleSetNameFilter where
  ns : Array RuleSetName -- #[] means 'match any rule set'

namespace RuleSetNameFilter

protected def all : RuleSetNameFilter :=
  ⟨#[]⟩

def matchesAll (f : RuleSetNameFilter) : Bool :=
  f.ns.isEmpty

def «matches» (f : RuleSetNameFilter) (n : RuleSetName) : Bool :=
  f.matchesAll || f.ns.contains n

def matchedRuleSetNames (f : RuleSetNameFilter) : Option (Array RuleSetName) :=
  if f.matchesAll then none else some f.ns

end Aesop.RuleSetNameFilter



=== LEAN SOURCE: Member.lean ===
/-
Copyright (c) 2021-2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Rule
import Aesop.Rule.Forward

namespace Aesop

inductive BaseRuleSetMember
  | normRule (r : NormRule)
  | unsafeRule (r : UnsafeRule)
  | safeRule (r : SafeRule)
  | unfoldRule (r : UnfoldRule)
  | normForwardRule (r₁ : ForwardRule) (r₂ : NormRule)
  | unsafeForwardRule (r₁ : ForwardRule) (r₂ : UnsafeRule)
  | safeForwardRule (r₁ : ForwardRule) (r₂ : SafeRule)
  deriving Inhabited

def BaseRuleSetMember.name : BaseRuleSetMember → RuleName
  | normRule r => r.name
  | unsafeRule r => r.name
  | safeRule r => r.name
  | unfoldRule r => r.name
  | normForwardRule r _ => r.name
  | unsafeForwardRule r _ => r.name
  | safeForwardRule r _ => r.name

inductive GlobalRuleSetMember
  | base (m : BaseRuleSetMember)
  | normSimpRule (e : NormSimpRule)
  deriving Inhabited

def GlobalRuleSetMember.name : GlobalRuleSetMember → RuleName
  | base m => m.name
  | normSimpRule r => r.name

inductive LocalRuleSetMember
  | global (m : GlobalRuleSetMember)
  | localNormSimpRule (r : LocalNormSimpRule)
  deriving Inhabited

def LocalRuleSetMember.name : LocalRuleSetMember → RuleName
  | global m => m.name
  | localNormSimpRule r => r.name

def LocalRuleSetMember.toGlobalRuleSetMember? :
    LocalRuleSetMember → Option GlobalRuleSetMember
  | global m => some m
  | _ => none

end Aesop



=== LEAN SOURCE: Name.lean ===
/-
Copyright (c) 2021-2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Lean

open Lean

namespace Aesop

abbrev RuleSetName := Name -- Not really an abbreviation is it?

def defaultRuleSetName : RuleSetName := `default

def builtinRuleSetName : RuleSetName := `builtin

def localRuleSetName : RuleSetName := `local

def builtinRuleSetNames : Array RuleSetName :=
  #[defaultRuleSetName, builtinRuleSetName]

def RuleSetName.isReserved (n : RuleSetName) : Bool :=
  n == localRuleSetName || builtinRuleSetNames.contains n

end Aesop



=== LEAN SOURCE: Apply.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.RuleTac.Basic
import Aesop.RuleTac.ElabRuleTerm
import Aesop.Script.SpecificTactics

open Lean
open Lean.Meta
open Lean.PrettyPrinter (delab)

namespace Aesop.RuleTac

def applyExpr' (goal : MVarId) (e : Expr) (eStx : Term)
    (patSubst? : Option Substitution) (md : TransparencyMode) :
    BaseM RuleApplication :=
  withTransparency md do
    let e ←
      if let some patSubst := patSubst? then
        patSubst.specializeRule e
      else
        pure e
    let (goals, #[step]) ← applyS goal e eStx md |>.run
      | throwError "aesop: internal error in applyExpr': multiple steps"
    let goals := goals.map λ newGoal => { diff := .empty goal newGoal }
    return {
      goals
      postState := step.postState
      scriptSteps? := #[step]
      successProbability? := none
    }

def applyExpr (goal : MVarId) (e : Expr) (eStx : Term)
    (patSubsts? : Option (Std.HashSet Substitution)) (md : TransparencyMode) :
    BaseM RuleTacOutput := do
  if let some patSubsts := patSubsts? then
    let mut rapps := Array.mkEmpty patSubsts.size
    let initialState ← saveState
    for patSubst in patSubsts do
      try
        let rapp ← applyExpr' goal e eStx patSubst md
        rapps := rapps.push rapp
      catch _ =>
        continue
      finally
        restoreState initialState
    if rapps.isEmpty then
      throwError "failed to apply '{e}' with any of the matched instances of the rule pattern"
    return { applications := rapps }
  else
    let rapp ← applyExpr' goal e eStx none md
    return { applications := #[rapp] }

def applyConst (decl : Name) (md : TransparencyMode) :
    RuleTac := λ input => do
  applyExpr input.goal (← mkConstWithFreshMVarLevels decl) (mkIdent decl)
    input.patternSubsts? md

def applyTerm (stx : Term) (md : TransparencyMode) : RuleTac :=
  λ input => input.goal.withContext do
    applyExpr input.goal (← elabRuleTermForApplyLikeMetaM input.goal stx) stx
      input.patternSubsts? md

def apply (t : RuleTerm) (md : TransparencyMode) : RuleTac :=
  match t with
  | .const decl => applyConst decl md
  | .term tm => applyTerm tm md

-- Tries to apply each constant in `decls`. For each one that applies, a rule
-- application is returned. If none applies, the tactic fails.
def applyConsts (decls : Array Name) (md : TransparencyMode) :
    RuleTac := λ input => do
  let initialState ← saveState
  let apps ← decls.filterMapM λ decl => do
    try
      let e ← mkConstWithFreshMVarLevels decl
      some <$> applyExpr' input.goal e (mkIdent decl) none md
    catch _ =>
      return none
    finally
      restoreState initialState
  if apps.isEmpty then throwError
    "failed to apply any of these declarations: {decls}"
  return ⟨apps⟩

end RuleTac



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Forward.Match.Types
import Aesop.Index.Basic
import Aesop.Percent
import Aesop.Rule.Forward
import Aesop.RuleTac.GoalDiff
import Aesop.RuleTac.FVarIdSubst
import Aesop.Script.CtorNames
import Aesop.Script.Step
import Batteries.Lean.Meta.SavedState
import Aesop.Options.Internal

open Lean
open Lean.Elab.Tactic
open Lean.Meta

namespace Aesop

/-! # Rule Tactic Types -/

/-- Input for a rule tactic. -/
structure RuleTacInput where
  /-- The goal on which the rule is run. -/
  goal : MVarId
  /-- The set of mvars that `goal` depends on. -/
  mvars : UnorderedArraySet MVarId
  /-- If the rule is indexed, the locations (i.e. hyps or the target) matched by
  the rule's index entries. Otherwise an empty set. -/
  indexMatchLocations : Std.HashSet IndexMatchLocation
  /-- If the rule has a pattern, the pattern substitutions that were found in
  the goal. Each substitution is a list of expressions which were found by
  matching the pattern against expressions in the goal. For example, if `h : max
  a b = max a c` appears in the goal and the rule has pattern `max x y`, there
  will be two substitutions `{x ↦ a, y ↦ b}`) and `{x ↦ a, y ↦ c}`.

  If the rule does not have a pattern, this is `none`. Otherwise it is
  guaranteed to be `some xs` with `xs` non-empty. -/
  patternSubsts? : Option (Std.HashSet Substitution)
  /-- The options given to Aesop. -/
  options : Options'
  /-- Normalised types of all non-implementation detail hypotheses in the local
  context of `goal`. -/
  hypTypes : PHashSet RPINF
  deriving Inhabited

/-- A subgoal produced by a rule. -/
structure Subgoal where
  /--
  A diff between the goal the rule was run on and this goal. Many `MetaM`
  tactics report information that allows you to easily construct a `GoalDiff`.
  If you don't have access to such information, use `diffGoals`, but note that
  it may not give optimal results.
  -/
  diff : GoalDiff
  deriving Inhabited

namespace Subgoal

def mvarId (g : Subgoal) : MVarId :=
  g.diff.newGoal

end Subgoal

def mvarIdToSubgoal (parentMVarId mvarId : MVarId) : BaseM Subgoal :=
  return { diff := ← diffGoals parentMVarId mvarId }

/--
A single rule application, representing the application of a tactic to the input
goal. Must accurately report the following information:

- `goals`: the goals generated by the tactic.
- `postState`: the `MetaM` state after the tactic was run.
- `scriptSteps?`: script steps which produce the same effect as the rule tactic.
  If `input.options.generateScript = false` (where `input` is the
  `RuleTacInput`), this field is ignored. If the tactic does not support script
  generation, use `none`.
- `successProbability`: The success probability of this rule application. If
  `none`, we use the success probability of the applied rule.
-/
structure RuleApplication where
  goals : Array Subgoal
  postState : Meta.SavedState
  scriptSteps? : Option (Array Script.LazyStep)
  successProbability? : Option Percent

namespace RuleApplication

def check (r : RuleApplication) (input : RuleTacInput) :
    BaseM (Option MessageData) :=
  runInMetaState r.postState do
    for goal in r.goals do
      if ← goal.mvarId.isAssignedOrDelayedAssigned then
        return some m!"subgoal metavariable ?{goal.mvarId.name} is already assigned."
      if let some err ← goal.diff.check input.goal goal.mvarId then
        return some err
    return none

end RuleApplication

/--
The result of a rule tactic is a list of rule applications.
-/
structure RuleTacOutput where
  applications : Array RuleApplication
  deriving Inhabited

/--
A `RuleTac` is the tactic that is run when a rule is applied to a goal.
-/
def RuleTac := RuleTacInput → BaseM RuleTacOutput

instance : Inhabited RuleTac := by
  unfold RuleTac; exact inferInstance

/--
A `RuleTac` which generates only a single `RuleApplication`.
-/
def SingleRuleTac :=
  RuleTacInput →
  BaseM (Array Subgoal × Option (Array Script.LazyStep) × Option Percent)

@[inline]
def SingleRuleTac.toRuleTac (t : SingleRuleTac) : RuleTac := λ input => do
  let (goals, scriptSteps?, successProbability?) ← t input
  let postState ← saveState
  return ⟨#[{ postState, goals, scriptSteps?, successProbability? }]⟩

@[inline]
def RuleTac.ofSingleRuleTac := SingleRuleTac.toRuleTac

def RuleTac.ofTacticSyntax (t : RuleTacInput → MetaM Syntax.Tactic) : RuleTac :=
  RuleTac.ofSingleRuleTac λ input => do
    let stx ← t input
    let preState ← saveState
    let postGoals ← Lean.Elab.Tactic.run input.goal (evalTactic stx) |>.run'
    let postState ← saveState
    let postGoals := postGoals.toArray
    let step := {
      preGoal := input.goal
      tacticBuilders := #[return .unstructured stx]
      preState, postState, postGoals
    }
    let postGoals ← postGoals.mapM (mvarIdToSubgoal input.goal ·)
    return (postGoals, some #[step], none)

/--
A tactic generator is a special sort of rule tactic, intended for use with
generative machine learning methods. It generates zero or more tactics
(represented as strings) that could be applied to the goal, plus a success
probability for each tactic. When Aesop executes a tactic generator, it executes
each of the tactics and, if the tactic succeeds, adds a rule application for it.
The tactic's success probability (which must be between 0 and 1, inclusive)
becomes the success probability of the rule application. A `TacGen` rule
succeeds if at least one of its suggested tactics succeeds.
-/
abbrev TacGen := MVarId → MetaM (Array (String × Float))

/-! # Rule Tactic Descriptions -/

def CasesPattern := AbstractMVarsResult
  deriving Inhabited

inductive CasesTarget
  | decl (decl : Name)
  | patterns (patterns : Array CasesPattern)
  deriving Inhabited

end Aesop



=== LEAN SOURCE: Cases.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.RuleTac.Basic
import Aesop.Script.SpecificTactics

open Lean
open Lean.Meta

namespace Aesop

-- NOTE: introduces fresh metavariables for the 'holes' in `p`.
def CasesPattern.toExpr (p : CasesPattern) : MetaM Expr := do
  let (_, _, p) ← openAbstractMVarsResult p
  return p

inductive CasesTarget' where
  | decl (decl : Name)
  | patterns (ps : Array (Expr × Meta.SavedState))

def CasesTarget.toCasesTarget' : CasesTarget → MetaM CasesTarget'
  | decl d => return .decl d
  | patterns ps => withoutModifyingState do
    let initialState ← saveState
    .patterns <$> ps.mapM λ p => do
      initialState.restore
      let e ← p.toExpr
      let s ← saveState
      return (e, s)

namespace RuleTac

partial def cases (target : CasesTarget) (md : TransparencyMode)
    (isRecursiveType : Bool) (ctorNames : Array CtorNames) : RuleTac :=
  SingleRuleTac.toRuleTac λ input => do
    match ← go input.goal #[] #[] input.goal |>.run with
    | (none, _) => throwError "No matching hypothesis found."
    | (some goals, steps) => return (goals, steps, none)
  where
    findFirstApplicableHyp (excluded : Array FVarId) (goal : MVarId) :
        MetaM (Option FVarId) :=
      withTransparency md do goal.withContext do
        let target ← target.toCasesTarget'
        let «match» ldecl : MetaM Bool :=
          match target with
          | .decl d => do
            isAppOfUpToDefeq (← mkConstWithFreshMVarLevels d) ldecl.type
          | .patterns ps => withoutModifyingState do
            ps.anyM λ (e, state) => do state.restore; isDefEq e ldecl.type
        return ← (← getLCtx).findDeclM? λ ldecl => do
          if ldecl.isImplementationDetail || excluded.contains ldecl.fvarId then
            return none
          else if ← «match» ldecl then
            return some ldecl.fvarId
          else
            return none

    go (initialGoal : MVarId) (newGoals : Array Subgoal) (excluded : Array FVarId)
        (goal : MVarId) : ScriptM (Option (Array Subgoal)) := do
      let some hyp ← findFirstApplicableHyp excluded goal
        | return none
      let some goals ← tryCasesS goal hyp ctorNames
        | return none
      let mut newGoals := newGoals
      for h : i in [:goals.size] do
        let g := goals[i]
        let newDiff ← diffGoals goal g.mvarId
        let mut excluded := excluded
        if isRecursiveType then
          excluded := excluded.map λ fvarId =>
            if let .fvar fvarId' := g.subst.get fvarId then fvarId' else fvarId
          excluded := excluded ++ newDiff.addedFVars.toArray
        match ← go initialGoal newGoals excluded g.mvarId with
        | some newGoals' => newGoals := newGoals'
        | none =>
          -- TODO We used to use a method that produces a more clever goal diff,
          -- using the fvarSubst reported by `cases`. Restore this once
          -- ForwardState.applyGoalDiff can deal with nonempty fvarSubsts.
          let diff ← diffGoals initialGoal g.mvarId
          newGoals := newGoals.push { diff }
      return some newGoals

end Aesop.RuleTac



=== LEAN SOURCE: Descr.lean ===
import Aesop.RuleTac.Basic
import Aesop.Forward.Match.Types

open Lean Lean.Meta

namespace Aesop

inductive RuleTacDescr
  | apply (term : RuleTerm) (md : TransparencyMode)
  | constructors (constructorNames : Array Name) (md : TransparencyMode)
  | forward (term : RuleTerm) (immediate : UnorderedArraySet PremiseIndex)
      (isDestruct : Bool)
  | cases (target : CasesTarget) (md : TransparencyMode)
      (isRecursiveType : Bool) (ctorNames : Array CtorNames)
  | tacticM (decl : Name)
  | ruleTac (decl : Name)
  | tacGen (decl : Name)
  | singleRuleTac (decl : Name)
  | tacticStx (stx : Syntax)
  | preprocess
  | forwardMatches (ms : Array ForwardRuleMatch)
  deriving Inhabited

namespace RuleTacDescr

def forwardRuleMatches? : RuleTacDescr → Option (Array ForwardRuleMatch)
  | forwardMatches ms => ms
  | _ => none

end RuleTacDescr

end Aesop



=== LEAN SOURCE: ElabRuleTerm.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.ElabM

open Lean Lean.Meta Lean.Elab.Term Lean.Elab.Tactic

namespace Aesop

def elabGlobalRuleIdent? (stx : Term) : TermElabM (Option Name) :=
  try
    if ! stx.raw.isIdent then
      return none
    let some (.const n _) ← resolveId? stx
      | return none
    return some n
  catch _ =>
    return none

def elabInductiveRuleIdent? (stx : Term) : TermElabM (Option InductiveVal) := do
  let some decl ← elabGlobalRuleIdent? stx
    | return none
  try
    getConstInfoInduct decl
  catch _ =>
    return none

-- HACK: We ignore the output goals, so this is only likely to work for
-- functions that might as well be in `TermElabM`.
def runTacticMAsTermElabM (goal : MVarId) (x : TacticM α) : TermElabM α := do
  x.run { elaborator := .anonymous } |>.run' { goals := [goal] }

-- HACK: We ignore the output goals, so this is only likely to work for
-- functions that might as well be in `TermElabM`.
def runTacticMAsElabM (x : TacticM α) : ElabM α := do
  runTacticMAsTermElabM (← read).goal x

def withFullElaboration (x : TermElabM α) : TermElabM α :=
  withSynthesize $ withoutErrToSorry $ withoutAutoBoundImplicit x

def elabRuleTermForApplyLikeCore (goal : MVarId) (stx : Term): TermElabM Expr :=
  withFullElaboration $ runTacticMAsTermElabM goal do
    elabTermForApply stx (mayPostpone := false)

def elabRuleTermForApplyLikeMetaM (goal : MVarId) (stx : Term) : MetaM Expr :=
  elabRuleTermForApplyLikeCore goal stx |>.run'

def elabRuleTermForApplyLike (stx : Term) : ElabM Expr := do
  elabRuleTermForApplyLikeCore (← read).goal stx

-- `stx` is of the form `"[" simpTheorem,* "]"`
def elabSimpTheorems (stx : Syntax) (ctx : Simp.Context)
    (simprocs : Simp.SimprocsArray) (isSimpAll : Bool) :
    TacticM (Simp.Context × Simp.SimprocsArray) :=
  withoutRecover do
    let kind : SimpKind := if isSimpAll then .simpAll else .simp
    let result ←
      elabSimpArgs stx ctx simprocs (eraseLocal := true) (kind := kind)
    if result.simpArgs.any fun | (_, .star) => true | _ => false then
      throwError "aesop: simp builder currently does not support wildcard '*'"
    return (result.ctx, result.simprocs)

-- HACK: This produces the syntax "[" lemmas,* "]" which is parsed by
-- `elabSimpArgs`. This syntax doesn't have an associated parser, so I don't
-- know how to ensure that the produced syntax is valid.
def mkSimpArgs (simpTheorem : Term) : Syntax :=
  mkNullNode #[
    mkAtom "[",
    mkNullNode
      #[Unhygienic.run `(Lean.Parser.Tactic.simpLemma| $simpTheorem:term)],
    mkAtom "]"
  ]

def elabRuleTermForSimpCore (goal : MVarId) (term : Term) (ctx : Simp.Context)
    (simprocs : Simp.SimprocsArray) (isSimpAll : Bool) :
    TermElabM (Simp.Context × Simp.SimprocsArray) := do
  withFullElaboration $ runTacticMAsTermElabM goal do
    elabSimpTheorems (mkSimpArgs term) ctx simprocs isSimpAll

def checkElabRuleTermForSimp (term : Term) (isSimpAll : Bool) : ElabM Unit := do
  let ctx ← Simp.mkContext (simpTheorems := #[{}] )
  let simprocs := #[{}]
  discard $ elabRuleTermForSimpCore (← read).goal term ctx simprocs isSimpAll

def elabRuleTermForSimpMetaM (goal : MVarId) (term : Term) (ctx : Simp.Context)
    (simprocs : Simp.SimprocsArray) (isSimpAll : Bool) :
    MetaM (Simp.Context × Simp.SimprocsArray) :=
  elabRuleTermForSimpCore goal term ctx simprocs isSimpAll |>.run'

end Aesop



=== LEAN SOURCE: Forward.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Forward.Match
import Aesop.RuleTac.Basic
import Aesop.RuleTac.ElabRuleTerm
import Aesop.RuleTac.Forward.Basic
import Aesop.Script.SpecificTactics
import Batteries.Lean.Meta.UnusedNames

open Lean
open Lean.Meta

namespace Aesop.RuleTac

partial def makeForwardHyps (e : Expr) (patSubst? : Option Substitution)
    (immediate : UnorderedArraySet PremiseIndex) (maxDepth? : Option Nat)
    (forwardHypData : ForwardHypData) (existingHypTypes : PHashSet RPINF) :
    BaseM (Array (Expr × Nat) × Array FVarId) :=
  withNewMCtxDepth (allowLevelAssignments := true) do
    let type ← inferType e
    let (argMVars, binderInfos, _) ← openRuleType patSubst? e
    let app := mkAppN e (argMVars.map .mvar)
    let mut instMVars := Array.mkEmpty argMVars.size
    let mut immediateMVars := Array.mkEmpty argMVars.size
    for h : i in [:argMVars.size] do
      let mvarId := argMVars[i]
      if ← mvarId.isAssignedOrDelayedAssigned then
        continue
      if immediate.contains ⟨i⟩ then
        immediateMVars := immediateMVars.push mvarId
      else if binderInfos[i]!.isInstImplicit then
        instMVars := instMVars.push mvarId
    let (proofs, usedHyps, _) ←
      loop app instMVars immediateMVars 0 #[] 0 #[] #[] ∅
    return (proofs, usedHyps)
  where
    loop (app : Expr) (instMVars : Array MVarId) (immediateMVars : Array MVarId)
        (i : Nat) (proofsAcc : Array (Expr × Nat)) (currentMaxHypDepth : Nat)
        (currentUsedHyps : Array FVarId) (usedHypsAcc : Array FVarId)
        (proofTypesAcc : Std.HashSet RPINF) :
        BaseM (Array (Expr × Nat) × Array FVarId × Std.HashSet RPINF) := do
      if h : immediateMVars.size > 0 ∧ i < immediateMVars.size then
        -- We go through the immediate mvars back to front. This is more
        -- efficient because assigning later mvars may already determine the
        -- assignments of earlier mvars.
        let mvarId := immediateMVars[immediateMVars.size - 1 - i]
        if ← mvarId.isAssignedOrDelayedAssigned then
          -- If the mvar is already assigned, we still need to update and check
          -- the hyp depth.
          let mut currentMaxHypDepth := currentMaxHypDepth
          let (_, fvarIds) ← (← instantiateMVars (.mvar mvarId)).collectFVars |>.run {}
          for fvarId in fvarIds.fvarIds do
            let hypDepth := forwardHypData.depths.getD fvarId 0
            currentMaxHypDepth := max currentMaxHypDepth hypDepth
          if let some maxDepth := maxDepth? then
            if currentMaxHypDepth + 1 > maxDepth then
              return (proofsAcc, usedHypsAcc, proofTypesAcc)
          return ← loop app instMVars immediateMVars (i + 1) proofsAcc
            currentMaxHypDepth currentUsedHyps usedHypsAcc proofTypesAcc
        let type ← mvarId.getType
        (← getLCtx).foldlM (init := (proofsAcc, usedHypsAcc, proofTypesAcc)) λ s@(proofsAcc, usedHypsAcc, proofTypesAcc) ldecl => do
          if ldecl.isImplementationDetail then
            return s
          let hypDepth := forwardHypData.depths.getD ldecl.fvarId 0
          let currentMaxHypDepth := max currentMaxHypDepth hypDepth
          if let some maxDepth := maxDepth? then
            if currentMaxHypDepth + 1 > maxDepth then
              return s
          withoutModifyingState do
            if ← isDefEq ldecl.type type then
              mvarId.assign (mkFVar ldecl.fvarId)
              let currentUsedHyps := currentUsedHyps.push ldecl.fvarId
              loop app instMVars immediateMVars (i + 1) proofsAcc
                currentMaxHypDepth currentUsedHyps usedHypsAcc proofTypesAcc
            else
              return s
      else
        for instMVar in instMVars do
          instMVar.withContext do
            let inst ← synthInstance (← instMVar.getType)
            instMVar.assign inst
        let proof := (← abstractMVars app).expr
        let type ← rpinf (← inferType proof)
        let redundant :=
          proofTypesAcc.contains type || existingHypTypes.contains type
        if redundant then
          return (proofsAcc, usedHypsAcc, proofTypesAcc)
        else
          let depth := currentMaxHypDepth + 1
          let proofsAcc := proofsAcc.push (proof, depth)
          let proofTypesAcc := proofTypesAcc.insert type
          let usedHypsAcc := usedHypsAcc ++ currentUsedHyps
          return (proofsAcc, usedHypsAcc, proofTypesAcc)

def assertForwardHyp (goal : MVarId) (hyp : Hypothesis) (depth : Nat) :
    ScriptM (FVarId × MVarId) := do
  withScriptStep goal (λ (_, g) => #[g]) (λ _ => true) tacticBuilder do
  withReducible do
    let hyp := {
      hyp with
      binderInfo := .default
      kind := .default
    }
    let implDetailHyp := {
        hyp with
        userName := forwardImplDetailHypName hyp.userName depth
        binderInfo := .default
        kind := .implDetail
    }
    let (#[fvarId, _], goal) ← goal.assertHypotheses #[hyp, implDetailHyp]
      | throwError "aesop: internal error in assertForwardHyp: unexpected number of asserted fvars"
    return (fvarId, goal)
where
  tacticBuilder _ := Script.TacticBuilder.assertHypothesis goal hyp .reducible

def applyForwardRule (goal : MVarId) (e : Expr)
    (patSubsts? : Option (Std.HashSet Substitution))
    (immediate : UnorderedArraySet PremiseIndex) (clear : Bool)
    (maxDepth? : Option Nat) (existingHypTypes : PHashSet RPINF) :
    ScriptM Subgoal :=
  withReducible $ goal.withContext do
    let initialGoal := goal
    let forwardHypData ← getForwardHypData
    let mut newHypProofs := #[]
    let mut usedHyps := ∅
    if let some patSubsts := patSubsts? then
      for patSubst in patSubsts do
        let (newHypProofs', usedHyps') ←
          makeForwardHyps e patSubst immediate maxDepth? forwardHypData
            existingHypTypes
        newHypProofs := newHypProofs ++ newHypProofs'
        usedHyps := usedHyps ++ usedHyps'
    else
      let (newHypProofs', usedHyps') ←
        makeForwardHyps e none immediate maxDepth? forwardHypData
          existingHypTypes
      newHypProofs := newHypProofs'
      usedHyps := usedHyps'
    usedHyps :=
      usedHyps.sortDedup (ord := ⟨λ x y => x.name.quickCmp y.name⟩)
    if newHypProofs.isEmpty then
      err
    let newHypUserNames ← getUnusedUserNames newHypProofs.size forwardHypPrefix
    let mut newHyps := #[]
    for (proof, depth) in newHypProofs, userName in newHypUserNames do
      let type ← inferType proof
      newHyps := newHyps.push ({ value := proof, type, userName }, depth)
    let mut goal := goal
    let mut addedFVars := ∅
    for (newHyp, depth) in newHyps do
      let (fvarId, goal') ← assertForwardHyp goal newHyp depth
      goal := goal'
      addedFVars := addedFVars.insert fvarId
    let mut diff := {
      oldGoal := initialGoal
      newGoal := goal
      addedFVars
      removedFVars := ∅
      targetChanged := .false
    }
    if clear then
      let usedPropHyps ← goal.withContext do
        usedHyps.filterM λ fvarId => isProof (.fvar fvarId)
      let (goal', removedFVars) ← tryClearManyS goal usedPropHyps
      let removedFVars := removedFVars.foldl (init := ∅) λ set fvarId =>
        set.insert fvarId
      goal := goal'
      diff := { diff with newGoal := goal, removedFVars }
    return { diff }
  where
    err {α} : MetaM α := throwError
      "found no instances of {e} (other than possibly those which had been previously added by forward rules)"

@[inline]
def forwardExpr (e : Expr) (immediate : UnorderedArraySet PremiseIndex)
    (clear : Bool) : RuleTac :=
  SingleRuleTac.toRuleTac λ input => input.goal.withContext do
    let (goal, steps) ←
      applyForwardRule input.goal e input.patternSubsts? immediate
        (clear := clear) input.options.forwardMaxDepth? input.hypTypes
      |>.run
    return (#[goal], steps, none)

def forwardConst (decl : Name) (immediate : UnorderedArraySet PremiseIndex)
    (clear : Bool) : RuleTac := λ input => do
  let e ← mkConstWithFreshMVarLevels decl
  forwardExpr e immediate (clear := clear) input

def forwardTerm (stx : Term) (immediate : UnorderedArraySet PremiseIndex)
    (clear : Bool) : RuleTac := λ input =>
  input.goal.withContext do
    let e ← elabRuleTermForApplyLikeMetaM input.goal stx
    forwardExpr e immediate (clear := clear) input

def forward (t : RuleTerm) (immediate : UnorderedArraySet PremiseIndex)
    (clear : Bool) : RuleTac :=
  match t with
  | .const decl => forwardConst decl immediate clear
  | .term tm => forwardTerm tm immediate clear

def forwardMatches (ms : Array ForwardRuleMatch) : RuleTac :=
  SingleRuleTac.toRuleTac λ input => do
    let skip type := input.hypTypes.contains type
    let mut goal := input.goal
    let mut addedFVars := ∅
    let mut removedFVars := ∅
    let mut anySuccess := false
    let mut steps := #[]
    for m in ms do
      let (some (goal', hyp, removedFVars'), steps') ← m.apply goal (some skip) |>.run
        | continue
      anySuccess := true
      goal := goal'
      addedFVars := addedFVars.insert hyp
      removedFVars := removedFVars.insertMany removedFVars'
      steps := steps ++ steps'
    if ! anySuccess then
      throwError "failed to add hyps for any of the following forward rule matches:{indentD $ MessageData.joinSep (ms.map toMessageData |>.toList) "\n"}"
    let diff := {
      oldGoal := input.goal
      newGoal := goal
      targetChanged := .false
      addedFVars, removedFVars
    }
    return (#[{ diff }], some steps, none)

def forwardMatch (m : ForwardRuleMatch) : RuleTac :=
  .forwardMatches #[m]

end Aesop.RuleTac



=== LEAN SOURCE: FVarIdSubst.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Lean

open Lean Lean.Meta

namespace Aesop

structure FVarIdSubst where
  map : Std.HashMap FVarId FVarId
  deriving Inhabited

namespace FVarIdSubst

def isEmpty (s : FVarIdSubst) : Bool :=
  s.map.isEmpty

def contains (s : FVarIdSubst) (fvarId : FVarId) : Bool :=
  s.map.contains fvarId

def find? (s : FVarIdSubst) (fvarId : FVarId) : Option FVarId :=
  s.map[fvarId]?

def get (s : FVarIdSubst) (fvarId : FVarId) : FVarId :=
  s.find? fvarId |>.getD fvarId

def apply (s : FVarIdSubst) (e : Expr) : Expr :=
  if s.isEmpty || ! e.hasFVar then
    e
  else
    e.replace λ
      | .fvar fvarId => s.find? fvarId |>.map mkFVar
      | _ => none

def applyToLocalDecl (s : FVarIdSubst) : LocalDecl → LocalDecl
  | .cdecl i id n t bi k   => .cdecl i id n (s.apply t) bi k
  | .ldecl i id n t v nd k => .ldecl i id n (s.apply t) (s.apply v) nd k

def domain (s : FVarIdSubst) : Std.HashSet FVarId :=
  s.map.fold (init := ∅) λ r k _ => r.insert k

def codomain (s : FVarIdSubst) : Std.HashSet FVarId :=
  s.map.fold (init := ∅) λ r _ v => r.insert v

protected def empty : FVarIdSubst :=
  ⟨∅⟩

instance : EmptyCollection FVarIdSubst :=
  ⟨.empty⟩

def insert (s : FVarIdSubst) (old new : FVarId) : FVarIdSubst :=
  let map : Std.HashMap _ _ := s.map.fold (init := ∅) λ map k v =>
    map.insert k $ if v == old then new else v
  ⟨map.insert old new⟩

def erase (s : FVarIdSubst) (fvarId : FVarId) : FVarIdSubst :=
  ⟨s.map.erase fvarId⟩

def append (s t : FVarIdSubst) : FVarIdSubst :=
  let map : Std.HashMap _ _ := s.map.fold (init := ∅) λ map k v =>
    map.insert k $ t.get v
  ⟨t.map.fold (init := map) λ s k v => s.insert k v⟩

def ofFVarSubstIgnoringNonFVarIds (s : FVarSubst) : FVarIdSubst := .mk $
  s.map.foldl (init := ∅) λ map k v =>
    if let .fvar fvarId := v then map.insert k fvarId else map

def ofFVarSubst? (s : FVarSubst) : Option FVarIdSubst := Id.run do
  let mut result := ∅
  for (k, v) in s.map do
    if let .fvar fvarId := v then
      result := result.insert k fvarId
    else
      return none
  return some result

end Aesop.FVarIdSubst



=== LEAN SOURCE: GoalDiff.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.RPINF
import Aesop.RuleTac.FVarIdSubst
import Aesop.Util.Basic

open Lean Lean.Meta

namespace Aesop

/--
A representation of the differences between two goals. Each Aesop rule produces
a `GoalDiff` between the goal on which the rule was run (the 'old goal') and
each of the subgoals produced by the rule (the 'new goals').

We use the produced `GoalDiff`s to update stateful data structures which cache
information about Aesop goals and for which it is more efficient to update the
cached information than to recompute it for each goal.

Hypotheses are identified by their `FVarId` *and* the RPINF of their type and
value (if any). This means that when a hypothesis `h : T` with `FVarId` `i`
appears in the old goal and `h : T'` with `FVarId` `i` appears in the new goal,
but the RPINF of `T` is not equal to the RPINF of `T'`, then `h` is treated as
both added (with the new type) and removed (with the old type). This can happen
when the type of a hyp changes to another type that is definitionally equal at
`default`, but not at `reducible` transparency.

The target is identified by RPINF.
-/
-- TODO Lean theoretically has an invariant that the type of an fvar cannot
-- change without the `FVarId` also changing. However, this invariant is
-- currently sometimes violated, notably by `simp`:
--
--   https://github.com/leanprover/lean4/issues/6226
--
-- If we could rely on this invariant, we could greatly simplify the computation
-- of goal diffs because we could trust that if an fvar is present in the old
-- and new goal, it has the same type in both.
structure GoalDiff where
  /-- The old goal. -/
  oldGoal : MVarId
  /-- The new goal. -/
  newGoal : MVarId
  /-- `FVarId`s that appear in the new goal, but not (or with a different type)
  in the old goal. -/
  addedFVars : Std.HashSet FVarId
  /-- `FVarId`s that appear in the old goal, but not (or with a different type)
  in the new goal. -/
  removedFVars : Std.HashSet FVarId
  /-- Is the old goal's target RPINF equal to the new goal's target RPINF? -/
  targetChanged : LBool
  deriving Inhabited

protected def GoalDiff.empty (oldGoal newGoal : MVarId) : GoalDiff := {
  addedFVars := ∅
  removedFVars := ∅
  targetChanged := .undef
  oldGoal, newGoal
}

def isRPINFEqual (goal₁ goal₂ : MVarId) (e₁ e₂ : Expr) : BaseM Bool :=
  return (← goal₁.withContext $ rpinf e₁) == (← goal₂.withContext $ rpinf e₂)

def isRPINFEqualLDecl (goal₁ goal₂ : MVarId) (ldecl₁ ldecl₂ : LocalDecl) : BaseM Bool :=
  match ldecl₁.isLet, ldecl₂.isLet with
  | false, false =>
    isRPINFEqual goal₁ goal₂ ldecl₁.type ldecl₂.type
  | true, true =>
    isRPINFEqual goal₁ goal₂ ldecl₁.type ldecl₂.type <&&>
    isRPINFEqual goal₁ goal₂ ldecl₁.value ldecl₂.value
  | _, _ => return false

def getNewFVars (oldGoal newGoal : MVarId) (oldLCtx newLCtx : LocalContext) :
    BaseM (Std.HashSet FVarId) :=
  newLCtx.foldlM (init := ∅) λ newFVars ldecl => do
    if ldecl.isImplementationDetail then
      return newFVars
    if let some oldLDecl := oldLCtx.find? ldecl.fvarId then
      if ← isRPINFEqualLDecl oldGoal newGoal oldLDecl ldecl then
        return newFVars
      else
        return newFVars.insert ldecl.fvarId
    else
      return newFVars.insert ldecl.fvarId

/--
Diff two goals.
-/
def diffGoals (old new : MVarId) : BaseM GoalDiff := do
  let oldLCtx := (← old.getDecl).lctx
  let newLCtx := (← new.getDecl).lctx
  return {
    oldGoal := old
    newGoal := new
    addedFVars := ← getNewFVars old new oldLCtx newLCtx
    removedFVars := ← getNewFVars new old newLCtx oldLCtx
    targetChanged :=
      ! (← isRPINFEqual old new (← old.getType) (← new.getType)) |>.toLBool
  }

namespace GoalDiff

def targetChanged' (diff : GoalDiff) : BaseM Bool :=
  match diff.targetChanged with
  | .true => return true
  | .false => return false
  | .undef => do
    let eq ←
      isRPINFEqual diff.oldGoal diff.newGoal (← diff.oldGoal.getType)
        (← diff.newGoal.getType)
    return ! eq

/--
If `diff₁` is the difference between goals `g₁` and `g₂` and `diff₂` is the
difference between `g₂` and `g₃`, then `diff₁.comp diff₂` is the difference
between `g₁` and `g₃`.

We assume that a hypothesis whose RPINF changed between `g₁` and `g₂` does not
change back, i.e. the hypothesis' RPINF is still different between `g₁` and `g₃`.
-/
def comp (diff₁ diff₂ : GoalDiff) : GoalDiff where
  oldGoal := diff₁.oldGoal
  newGoal := diff₂.newGoal
  addedFVars :=
    diff₁.addedFVars.fold (init := diff₂.addedFVars) λ addedFVars fvarId =>
      if diff₂.removedFVars.contains fvarId then
        addedFVars
      else
        addedFVars.insert fvarId
  removedFVars :=
    diff₂.removedFVars.fold (init := diff₁.removedFVars) λ removedFVars fvarId =>
      if diff₁.addedFVars.contains fvarId then
        removedFVars
      else
        removedFVars.insert fvarId
  targetChanged := lBoolOr diff₁.targetChanged diff₂.targetChanged

def checkCore (diff : GoalDiff) (old new : MVarId) :
    BaseM (Option MessageData) := do
  if diff.oldGoal != old then
    return some m!"incorrect old goal: expected {old.name}, got {diff.oldGoal.name}"
  if diff.newGoal != new then
    return some m!"incorrect new goal: expected {new.name}, got {diff.newGoal.name}"

  let oldLCtx := (← old.getDecl).lctx
  let newLCtx := (← new.getDecl).lctx

  -- Check that the added hypotheses were indeed added
  for fvarId in diff.addedFVars do
    if let some oldLDecl := oldLCtx.find? fvarId then
      if ← isRPINFEqualLDecl old new oldLDecl (← fvarId.getDecl) then
        return some m!"addedFVars contains hypothesis {oldLDecl.userName} which was already present in the old goal"
    unless newLCtx.contains fvarId do
      return some m!"addedFVars contains hypothesis {fvarId.name} but this fvar does not exist in the new goal"

  -- Check that the removed hypotheses were indeed removed
  for fvarId in diff.removedFVars do
    if let some newLDecl := newLCtx.find? fvarId then
      if ← isRPINFEqualLDecl old new (← fvarId.getDecl) newLDecl then
        return some m!"removedFVars contains hypothesis {newLDecl.userName} but it is still present in the new goal"
    unless oldLCtx.contains fvarId do
      return some m!"removedFVars contains hypothesis {fvarId.name} but this fvar does not exist in the old goal"

  -- Check that all added hypotheses appear in addedFVars
  for newLDecl in newLCtx do
    if newLDecl.isImplementationDetail then
      continue
    let newFVarId := newLDecl.fvarId
    if ! oldLCtx.contains newFVarId &&
       ! diff.addedFVars.contains newFVarId then
      return some m!"hypothesis {newLDecl.userName} was added, but does not appear in addedFVars"

  -- Check that all removed hypotheses appear in removedFVars
  for oldLDecl in oldLCtx do
    if oldLDecl.isImplementationDetail then
      continue
    let oldFVarId := oldLDecl.fvarId
    if ! newLCtx.contains oldFVarId &&
       ! diff.removedFVars.contains oldFVarId then
      return some m!"hypothesis {oldLDecl.userName} was removed, but does not appear in removedFVars"

  -- Check that all common hypotheses have equal RPINFs
  for newLDecl in newLCtx do
    if newLDecl.isImplementationDetail then
      continue
    if let some oldLDecl := oldLCtx.find? newLDecl.fvarId then
      unless ← isRPINFEqualLDecl old new oldLDecl newLDecl do
        return some m!"hypotheses {oldLDecl.userName} and {newLDecl.userName} have the same FVarId but their types/values are not reducibly defeq"

  -- Check the target
  let oldTgt ← old.getType
  let newTgt ← new.getType
  if ← (pure $ diff.targetChanged == .true) <&&>
     isRPINFEqual old new oldTgt newTgt then
    let oldTgt ← old.withContext do addMessageContext m!"{oldTgt}"
    let newTgt ← new.withContext do addMessageContext m!"{newTgt}"
    return some m!"diff says target changed, but old target{indentD oldTgt}\nis reducibly defeq to new target{indentD newTgt}"
  if ← (pure $ diff.targetChanged == .false) <&&>
     notM (isRPINFEqual old new oldTgt newTgt) then
    let oldTgt ← old.withContext do addMessageContext m!"{oldTgt}"
    let newTgt ← new.withContext do addMessageContext m!"{newTgt}"
    return some m!"diff says target did not change, but old target{indentD oldTgt}\nis not reducibly defeq to new target{indentD newTgt}"

  return none

def check (diff : GoalDiff) (old new : MVarId) :
    BaseM (Option MessageData) := do
  if let some err ← diff.checkCore old new then
    addMessageContext m!"rule produced incorrect diff:{indentD err}\nold goal:{indentD old}\nnew goal:{indentD new}"
  else
    return none

end Aesop.GoalDiff



=== LEAN SOURCE: Preprocess.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.RuleTac.Basic
import Aesop.Script.SpecificTactics

open Lean Lean.Meta

namespace Aesop.RuleTac

/--
This `RuleTac` is applied once to the root goal, before any other rules are
tried.
-/
def preprocess : RuleTac := RuleTac.ofSingleRuleTac λ input => do
  let ((mvarId, _), steps) ← renameInaccessibleFVarsS input.goal |>.run
  return (#[{ diff := .empty input.goal mvarId }], steps, none)

end Aesop.RuleTac



=== LEAN SOURCE: RuleTerm.lean ===
import Aesop.Rule.Name

open Lean Lean.Meta

namespace Aesop

inductive RuleTerm
  | const (decl : Name)
  | term (term : Term)
  deriving Inhabited

instance : ToMessageData RuleTerm where
  toMessageData
    | .const decl => m!"{decl}"
    | .term tm => m!"{tm}"

inductive ElabRuleTerm
  | const (decl : Name)
  | term (term : Term) (expr : Expr)
  deriving Inhabited

namespace ElabRuleTerm

instance : ToMessageData ElabRuleTerm where
  toMessageData
    | .const decl => m!"{decl}"
    | .term tm _ => m!"{tm}"

def expr : ElabRuleTerm → MetaM Expr
  | const decl => mkConstWithFreshMVarLevels decl
  | term _ e => return e

def scope : ElabRuleTerm → ScopeName
  | const .. => .global
  | term .. => .local

def name : ElabRuleTerm → MetaM Name
  | const decl => return decl
  | term _ e => getRuleNameForExpr e

def toRuleTerm : ElabRuleTerm → RuleTerm
  | const decl => .const decl
  | term t _ => .term t

def ofElaboratedTerm (tm : Term) (expr : Expr) : ElabRuleTerm :=
  if let some decl := expr.constName? then
    .const decl
  else
    .term tm expr

end Aesop.ElabRuleTerm



=== LEAN SOURCE: Tactic.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg, Kaiyu Yang
-/

import Aesop.RuleTac.Basic
import Aesop.Script.Step

open Lean Lean.Meta Lean.Elab.Tactic
open Lean.Elab.Tactic (TacticM evalTactic withoutRecover)

namespace Aesop.RuleTac

-- Precondition: `decl` has type `TacticM Unit`.
unsafe def tacticMImpl (decl : Name) : RuleTac :=
  SingleRuleTac.toRuleTac λ input => do
    let tac ← evalConst (TacticM Unit) decl
    let goals ← run input.goal tac |>.run'
    let goals ← goals.mapM (mvarIdToSubgoal (parentMVarId := input.goal) ·)
    return (goals.toArray, none, none)

-- Precondition: `decl` has type `TacticM Unit`.
@[implemented_by tacticMImpl]
opaque tacticM (decl : Name) : RuleTac

-- Precondition: `decl` has type `RuleTac`.
unsafe def ruleTacImpl (decl : Name) : RuleTac := λ input => do
  let tac ← evalConst RuleTac decl
  tac input

-- Precondition: `decl` has type `RuleTac`.
@[implemented_by ruleTacImpl]
opaque ruleTac (decl : Name) : RuleTac

-- Precondition: `decl` has type `SimpleRuleTac`.
unsafe def singleRuleTacImpl (decl : Name) : RuleTac :=
  SingleRuleTac.toRuleTac λ input => do
    let tac ← evalConst SingleRuleTac decl
    tac input

-- Precondition: `decl` has type `SimpleRuleTac`.
@[implemented_by singleRuleTacImpl]
opaque singleRuleTac (decl : Name) : RuleTac

/--
Elaborates and runs the given tactic syntax `stx`. The syntax `stx` must be of
kind `tactic` or `tacticSeq`.
-/
def tacticStx (stx : Syntax) : RuleTac :=
  SingleRuleTac.toRuleTac λ input => do
    let preState ← saveState
    let tac := withoutRecover $ evalTactic stx
    let postGoals := (← Elab.Tactic.run input.goal tac |>.run').toArray
    let postState ← saveState
    let tacticBuilder : Script.TacticBuilder := do
      if stx.isOfKind `tactic then
        return .unstructured ⟨stx⟩
      else if stx.isOfKind ``Parser.Tactic.tacticSeq then
        let stx := ⟨stx⟩
        (.unstructured ·) <$> `(tactic| ($stx:tacticSeq))
      else
        throwError "expected either a single tactic or a sequence of tactics"
    let step := {
      preGoal := input.goal
      tacticBuilders := #[tacticBuilder]
      preState, postState, postGoals
    }
    let postGoals ←
      postGoals.mapM (mvarIdToSubgoal (parentMVarId := input.goal) ·)
    return (postGoals, some #[step], none)

-- Precondition: `decl` has type `TacGen`.
unsafe def tacGenImpl (decl : Name) : RuleTac := λ input => do
  let tacGen ← evalConst TacGen decl
  let initialState ← saveState
  let suggestions ← tacGen input.goal
  let mut apps := Array.mkEmpty suggestions.size
  let mut errors : Array (String × Exception) := Array.mkEmpty suggestions.size
  for (tacticStr, successProbability) in suggestions do
    initialState.restore
    let env ← getEnv
    try
      let some successProbability := Percent.ofFloat successProbability
        | throwError "invalid success probability '{successProbability}', must be between 0 and 1"
      let .ok stx :=
        Parser.runParserCategory env `tactic tacticStr (fileName := "<stdin>")
        | throwError "failed to parse tactic syntax{indentD tacticStr}"
      let postGoals := (← run input.goal (evalTactic stx) |>.run').toArray
      let postState ← saveState
      if let some proof ← getExprMVarAssignment? input.goal then
        if ← hasSorry proof then
          throwError "generated proof contains sorry"
      let step := {
        preState := initialState
        preGoal := input.goal
        tacticBuilders := #[return .unstructured ⟨stx⟩]
        postState, postGoals
      }
      let postGoals ←
        postGoals.mapM (mvarIdToSubgoal (parentMVarId := input.goal) ·)
      apps := apps.push {
        goals := postGoals
        scriptSteps? := some #[step]
        successProbability? := successProbability
        postState
      }
    catch e =>
      errors := errors.push (tacticStr, e)
  if apps.isEmpty then throwError
    "Failed to apply any tactics generated. Errors:{indentD $ MessageData.joinSep (errors.toList.map (λ (tac, e) => m!"{tac}: {e.toMessageData}")) "\n"}"
  return ⟨apps⟩

-- Precondition: `decl` has type `TacGen`.
@[implemented_by tacGenImpl]
opaque tacGen (decl : Name) : RuleTac

end Aesop.RuleTac



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Util.Basic
import Aesop.Util.EqualUpToIds

namespace Aesop

open Lean Lean.Meta

/-
Forward rules must only succeed once for each combination of immediate
hypotheses; otherwise any forward rule could be applied infinitely often (if
it can be applied at all). We use the following scheme to ensure this:

- Whenever we add a hypothesis `h : T` as an instance of a forward rule, we also
  add an `implDetail` hypothesis `h' : T`.
- Before we add a hypothesis `h : T`, we check whether there is already an
  `implDetail` `h' : T`. If so, `h` is not added.

This scheme ensures that forward rules never add more than one hypothesis of
any given type. `h'` is added as an `implDetail`, rather than as a regular
hypothesis, to ensure that future rule applications do not change its type.

We also encode two pieces of data in the name of `h`: the name `h` and the
*forward depth* of `h`. The forward depth of a hypothesis not generated by
forward reasoning is 0. The forward depth of a hypothesis `h` generated by
forward reasoning is one plus the maximal forward depth of any hypothesis used
in the proof of `h`. The `saturate` tactic uses this information to limit its
reasoning depth.
-/

/-- Prefix of the regular hyps added by `forward`. -/
def forwardHypPrefix := `fwd

/-- Prefix of the `implDetail` hyps added by `forward`. -/
def forwardImplDetailHypPrefix := `__aesop.fwd

/-- Name of the `implDetail` hyp corresponding to the forward `hyp` with name
`fwdHypName` and depth `depth`. -/
def forwardImplDetailHypName (fwdHypName : Name) (depth : Nat) : Name :=
  .num forwardImplDetailHypPrefix depth ++ fwdHypName

/--
Parse a name generated by `forwardImplDetailHypName`, obtaining the
`fwdHypName` and `depth`.
-/
def matchForwardImplDetailHypName (n : Name) : Option (Nat × Name) :=
  match n.components with
  | `__aesop :: `fwd :: .num .anonymous depth :: components =>
    let name := Name.ofComponents components
    some (depth, name)
  | _ => none

/--
Check whether the given name was generated by `forwardImplDetailHypName`.
We assume that nobody else adds hyps with the `forwardImplHypDetailPrefix`
prefix.
-/
def isForwardImplDetailHypName (n : Name) : Bool :=
  (`__aesop.fwd).isPrefixOf n

def isForwardImplDetailHyp (ldecl : LocalDecl) : Bool :=
  ldecl.isImplementationDetail && isForwardImplDetailHypName ldecl.userName

def getForwardImplDetailHyps : MetaM (Array LocalDecl) := do
 let mut result := #[]
 for ldecl in ← getLCtx do
    if isForwardImplDetailHyp ldecl then
      result := result.push ldecl
  return result

def _root_.Aesop.clearForwardImplDetailHyps (goal : MVarId) : MetaM MVarId :=
  goal.withContext do
    let hyps ← getForwardImplDetailHyps
    goal.tryClearMany $ hyps.map (·.fvarId)

structure ForwardHypData where
  /--
  Depths of the hypotheses that have already been added by forward reasoning.
  -/
  depths : Std.HashMap FVarId Nat

def getForwardHypData : MetaM ForwardHypData := do
  let ldecls ← getForwardImplDetailHyps
  let mut depths := ∅
  for ldecl in ldecls do
    if let some (depth, name) := matchForwardImplDetailHypName ldecl.userName then
      if let some ldecl := (← getLCtx).findFromUserName? name then
        depths := depths.insert ldecl.fvarId depth
  return { depths }

/--
Mark hypotheses that, according to their name, are forward implementation detail
hypotheses, as implementation details. This is a hack that works around the
fact that certain tactics (particularly anything based on the revert-intro
pattern) can turn implementation detail hyps into regular hyps.
-/
def hideForwardImplDetailHyps (goal : MVarId) : MetaM MVarId :=
  goal.withContext do
    let mut lctx ← getLCtx
    let mut localInsts ← getLocalInstances
    let mut anyChange := false
    for ldecl in ← getLCtx do
      if ! ldecl.isImplementationDetail &&
         isForwardImplDetailHypName ldecl.userName then
        lctx := lctx.setKind ldecl.fvarId .implDetail
        localInsts := localInsts.erase ldecl.fvarId
        anyChange := true
    if ! anyChange then
      return goal
    let goal' ← mkFreshExprMVarAt lctx localInsts (← goal.getType)
    goal.assign goal'
    return goal'.mvarId!

end Aesop



=== LEAN SOURCE: Check.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Check
import Aesop.Script.UScript

open Lean Lean.Elab.Tactic
open Lean.Parser.Tactic (tacticSeq)

namespace Aesop.Script

def UScript.checkIfEnabled (uscript : UScript) : MetaM Unit := do
  unless ← Check.script.steps.isEnabled do
    return
  try
    uscript.validate
  catch e =>
    throwError "{Check.script.steps.name}: {e.toMessageData}"

end Script

def checkRenderedScriptIfEnabled (script : TSyntax ``tacticSeq)
    (preState : Meta.SavedState) (goal : MVarId) (expectCompleteProof : Bool) :
    MetaM Unit := do
  if ! (← Check.script.isEnabled) then
    return
  let go : TacticM Unit := do
    setGoals [goal]
    evalTactic script
    if expectCompleteProof && ! (← getUnsolvedGoals).isEmpty then
      throwError "script executed successfully but did not solve the main goal"
  try
    show MetaM Unit from withoutModifyingState do
      preState.restore
      go.run { elaborator := .anonymous, recover := false }
        |>.run' { goals := [goal] }
        |>.run'
  catch e => throwError
    "{Check.script.name}: error while executing generated script:{indentD e.toMessageData}"

end Aesop



=== LEAN SOURCE: CtorNames.lean ===
import Aesop.Util.Basic

open Lean Lean.Meta

namespace Aesop

structure CtorNames where
  ctor : Name
  args : Array Name
  /-- Whether the constructor has at least one implicit argument. -/
  hasImplicitArg : Bool

namespace CtorNames

def toRCasesPat (cn : CtorNames) : TSyntax `rcasesPat := Unhygienic.run do
  let ns ← cn.args.mapM λ n =>
    `(Lean.Parser.Tactic.rcasesPatLo| $(mkIdent n):ident)
  if cn.hasImplicitArg then
    `(rcasesPat| @⟨ $ns,* ⟩)
  else
    `(rcasesPat| ⟨ $ns,* ⟩)

private def nameBase : Name → Name
  | .anonymous => .anonymous
  | .str _ s => .str .anonymous s
  | .num _ n => .num .anonymous n

open Lean.Parser.Tactic in
def toInductionAltLHS (cn : CtorNames) :
    TSyntax ``inductionAltLHS := Unhygienic.run do
  let ns := cn.args.map mkIdent
  let ctor := mkIdent $ nameBase cn.ctor
  if cn.hasImplicitArg then
    `(inductionAltLHS| | @$ctor $ns:ident*)
  else
    `(inductionAltLHS| | $ctor $ns:ident*)

open Lean.Parser.Tactic in
def toInductionAlt (cn : CtorNames) (tacticSeq : Array Syntax.Tactic) :
    TSyntax ``inductionAlt := Unhygienic.run do
  `(inductionAlt| $(cn.toInductionAltLHS):inductionAltLHS => $tacticSeq:tactic*)

def toAltVarNames (cn : CtorNames) : AltVarNames where
  explicit := true
  varNames := cn.args.toList

def mkFreshArgNames (lctx : LocalContext) (cn : CtorNames) :
    CtorNames × LocalContext :=
  let (args, lctx) := getUnusedNames lctx cn.args
  ({ cn with args }, lctx)

end CtorNames

open Lean.Parser.Tactic in
def ctorNamesToRCasesPats (cns : Array CtorNames) : TSyntax ``rcasesPatMed :=
  Unhygienic.run do `(rcasesPatMed| $(cns.map (·.toRCasesPat)):rcasesPat|*)

open Lean.Parser.Tactic in
def ctorNamesToInductionAlts (cns : Array (CtorNames × Array Syntax.Tactic)) :
    TSyntax ``inductionAlts := Unhygienic.run do
  let alts := cns.map λ (cn, tacticSeq) => cn.toInductionAlt tacticSeq
  `(inductionAlts| with $alts:inductionAlt*)

def mkCtorNames (iv : InductiveVal) : CoreM (Array CtorNames) := MetaM.run' do
  iv.ctors.toArray.mapM λ ctor => do
    let cv ← getConstInfoCtor ctor
    let arity := cv.numParams + cv.numFields
    forallBoundedTelescope cv.type arity λ args _ => do
      let mut result := Array.mkEmpty cv.numFields
      let mut hasImplicitArg := false
      for arg in args[cv.numParams:] do
        let ldecl ← arg.fvarId!.getDecl
        result := result.push ldecl.userName
        hasImplicitArg := hasImplicitArg || ! ldecl.binderInfo.isExplicit
      return { args := result, ctor, hasImplicitArg }

end Aesop



=== LEAN SOURCE: GoalWithMVars.lean ===
import Lean

open Lean Std Lean.Meta

namespace Aesop

structure GoalWithMVars where
  goal : MVarId
  mvars : Std.HashSet MVarId
  deriving Inhabited

instance : Repr GoalWithMVars where
  reprPrec
    | g, _ => s!"\{ goal := {repr g.goal}, mvars := {repr g.mvars.toArray} }"

instance : BEq GoalWithMVars :=
  ⟨λ g₁ g₂ => g₁.goal == g₂.goal⟩

namespace GoalWithMVars

def ofMVarId (goal : MVarId) : MetaM GoalWithMVars := do
  return { goal, mvars := ← goal.getMVarDependencies }

end Aesop.GoalWithMVars



=== LEAN SOURCE: Main.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Script.Check
import Aesop.Script.StructureDynamic
import Aesop.Script.StructureStatic
import Aesop.Script.OptimizeSyntax
import Aesop.Stats.Basic
import Aesop.Options.Internal

open Lean
open Lean.Parser.Tactic (tacticSeq)

namespace Aesop.Script

def UScript.optimize (uscript : UScript) (proofHasMVar : Bool)
    (preState : Meta.SavedState) (goal : MVarId) :
    MetaM (Option (TSyntax ``tacticSeq × ScriptGenerated)) := do
  let structureResult? ← do
    let opts ← getOptions
    if aesop.dev.dynamicStructuring.get opts &&
       ! (aesop.dev.optimizedDynamicStructuring.get opts && ! proofHasMVar) then
      structureDynamic
    else
      structureStatic
  let some (sscript, gen) := structureResult?
    | return none
  let tacticSeq ← `(tacticSeq| $(← sscript.render):tactic*)
  let tacticSeq ← optimizeSyntax tacticSeq
  return some (tacticSeq, gen)
where
  structureStatic : MetaM (Option (SScript × ScriptGenerated)) := do
    let tacticState ← preState.runMetaM' $ TacticState.mkInitial goal
    let (sscript, perfect) ← uscript.toSScriptStatic tacticState
    let gen :=
      .staticallyStructured (perfect := perfect) (hasMVar := proofHasMVar)
    pure $ some (sscript, gen)

  structureDynamic : MetaM (Option (SScript × ScriptGenerated)) := do
    let some (script, perfect) ← uscript.toSScriptDynamic preState goal
      | return none
    let gen :=
      .dynamicallyStructured (perfect := perfect) (hasMVar := proofHasMVar)
    return some (script, gen)

end Script

open Script

variable [Monad m] [MonadLog m] [MonadRef m] [MonadError m] [AddMessageContext m]
  [MonadStats m] [MonadLiftT MetaM m] in
def checkAndTraceScript (uscript : UScript)
    (sscript? : Option (TSyntax ``tacticSeq × ScriptGenerated)) (preState : Meta.SavedState)
    (goal : MVarId) (options : Aesop.Options') (expectCompleteProof : Bool)
    (tacticName : String) :
    m Unit := do
  if let some (script, scriptGenerated) := sscript? then
    recordScriptGenerated scriptGenerated
    if options.traceScript then
      addTryThisTacticSeqSuggestion (← getRef) script
    checkRenderedScriptIfEnabled script preState goal
      (expectCompleteProof := expectCompleteProof)
  else
    if options.traceScript then
      let tacticSeq ← uscript.renderTacticSeq preState goal
      addTryThisTacticSeqSuggestion (← getRef) tacticSeq
    if ← Check.script.isEnabled then
      throwError "{Check.script.name}: structuring the script failed"
    else if options.traceScript then
      logWarning m!"{tacticName}: structuring the script failed. Reporting unstructured script."

end Aesop



=== LEAN SOURCE: OptimizeSyntax.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Lean

namespace Aesop

open Lean Lean.Meta Lean.Parser.Tactic

variable [Monad m] [MonadQuotation m]

partial def optimizeFocusRenameI : Syntax → m Syntax
  | stx@.missing | stx@(.atom ..) | stx@(.ident ..) => return stx
  | .node info kind args => do
    let stx := .node info kind (← args.mapM optimizeFocusRenameI)
    match stx with
    | `(tactic| · $tacs:tactic*)
    | `(tactic| · { $tacs:tactic* }) => do
      let tacs := tacs.getElems
      let some (tac : TSyntax `tactic) := tacs[0]?
        | return stx
      match tac with
      | `(tactic| rename_i $[$ns:ident]*) =>
        `(tactic| next $[$ns:ident]* => $(tacs[1:]):tactic*)
      | _ => return stx
    | _ => return stx

private partial def addIdents (acc : Std.HashSet Name) : Syntax → Std.HashSet Name
  | .missing | .atom .. => acc
  | .ident (val := val) .. => acc.insert val
  | .node _ _ args =>
    args.foldl (init := acc) λ acc stx => addIdents acc stx

def optimizeInitialRenameI : Syntax → m Syntax
  | stx@`(tacticSeq| $tacs:tactic*) => do
    let tacs := tacs.getElems
    let some (tac : TSyntax `tactic) := tacs[0]?
      | return stx
    match tac with
    | `(tactic| rename_i $[$ns:ident]*) =>
      let usedNames := tacs[1:].foldl (init := ∅) λ usedNames stx =>
        addIdents usedNames stx.raw
      let mut dropUntil := 0
      for n in ns do
        if usedNames.contains n.getId then
          break
        else
          dropUntil := dropUntil + 1
      if dropUntil == 0 then
        return stx
      else if dropUntil == ns.size then
        tacsToTacticSeq tacs[1:]
      else
        let ns : TSyntaxArray `ident := ns[dropUntil:].toArray
        let tac ← `(tactic| rename_i $[$ns:ident]*)
        let mut result : Array (TSyntax `tactic) := Array.mkEmpty tacs.size
        result := result.push tac
        result := result ++ tacs[1:]
        tacsToTacticSeq result
    | _ => return stx
  | stx => return stx
where
  -- Inlining this helper function triggers a code gen issue:
  -- https://github.com/leanprover/lean4/issues/4548
  tacsToTacticSeq (tacs : Array (TSyntax `tactic)) : m (TSyntax ``tacticSeq) :=
    `(tacticSeq| $tacs:tactic*)

def optimizeSyntax (stx : TSyntax kind) : m (TSyntax kind) := do
  let mut stx := stx.raw
  stx ← optimizeFocusRenameI stx
  stx ← optimizeInitialRenameI stx
  return ⟨stx⟩

end Aesop



=== LEAN SOURCE: ScriptM.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.BaseM
import Aesop.Script.Step
import Aesop.Script.Tactic

open Lean Aesop.Script

namespace Aesop

abbrev ScriptT m := StateRefT' IO.RealWorld (Array LazyStep) m

namespace ScriptT

protected def run [Monad m] [MonadLiftT (ST IO.RealWorld) m] (x : ScriptT m α) :
    m (α × Array LazyStep) :=
  StateRefT'.run x #[]

end ScriptT

abbrev ScriptM := ScriptT BaseM

variable [MonadStateOf (Array LazyStep) m]

def recordScriptStep (step : LazyStep) : m Unit :=
  modify (·.push step)

def recordScriptSteps (steps : Array LazyStep) : m Unit :=
  modify (· ++ steps)

def withScriptStep (preGoal : MVarId) (postGoals : α → Array MVarId)
    (success : α → Bool) (tacticBuilder : α → TacticBuilder) (x : MetaM α) :
    ScriptM α := do
  let preState ← show MetaM _ from saveState
  let a ← x
  if success a then
    let postState ← show MetaM _ from saveState
    recordScriptStep {
      tacticBuilders := #[tacticBuilder a]
      postGoals := postGoals a
      preGoal, preState, postState
    }
  return a

def withOptScriptStep (preGoal : MVarId) (postGoals : α → Array MVarId)
    (tacticBuilder : α → TacticBuilder) (x : MetaM (Option α)) :
    ScriptM (Option α) := do
  let preState ← show MetaM _ from saveState
  let some a ← x
    | return none
  let postState ← show MetaM _ from saveState
  recordScriptStep {
    tacticBuilders := #[tacticBuilder a]
    postGoals := postGoals a
    preGoal, preState, postState
  }
  return some a

end Aesop



=== LEAN SOURCE: SpecificTactics.lean ===
/-
Copyright (c) 2022--2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Util.Tactic
import Aesop.Util.Tactic.Ext
import Aesop.Util.Tactic.Unfold
import Aesop.Script.CtorNames
import Aesop.Script.ScriptM
import Batteries.Lean.Meta.Inaccessible

open Lean
open Lean.Meta
open Lean.PrettyPrinter (delab)

namespace Aesop.Script

def Tactic.skip : Tactic :=
  .unstructured $ Unhygienic.run `(tactic| skip)

namespace TacticBuilder

def applyStx (e : Term) (md : TransparencyMode) : TacticBuilder := do
  let tac := withAllTransparencySyntax md (← `(tactic| apply $e))
  return .unstructured tac

def apply (mvarId : MVarId) (e : Expr) (md : TransparencyMode) :
    TacticBuilder := do
  let e ← mvarId.withContext $ delab e
  let tac := withAllTransparencySyntax md (← `(tactic| apply $e))
  return .unstructured tac

def exactFVar (goal : MVarId) (fvarId : FVarId) (md : TransparencyMode) :
    TacticBuilder := do
  let ident := mkIdent (← goal.withContext $ fvarId.getUserName)
  let tac := withAllTransparencySyntax md $ ← `(tactic| exact $ident)
  return .unstructured tac

def replace (preGoal postGoal : MVarId) (fvarId : FVarId) (type : Expr)
    (proof : Expr) : TacticBuilder := do
  let userName ← preGoal.withContext $ fvarId.getUserName
  let proof ← preGoal.withContext $ delab proof
  let type ← postGoal.withContext $ delab type
  let tac ← `(tactic| replace $(mkIdent userName) : $type := $proof)
  return .unstructured tac

def assertHypothesis (goal : MVarId) (h : Hypothesis) (md : TransparencyMode) :
    TacticBuilder :=
  goal.withContext do
    let tac ← `(tactic| have $(mkIdent h.userName) : $(← delab h.type) := $(← delab h.value))
    return .unstructured $ withAllTransparencySyntax md tac

def clear (goal : MVarId) (fvarIds : Array FVarId) : TacticBuilder :=
  goal.withContext do
    let userNames ← fvarIds.mapM (mkIdent <$> ·.getUserName)
    return .unstructured $ ← `(tactic| clear $userNames*)

def cases (goal : MVarId) (e : Expr) (ctorNames : Array CtorNames) :
    TacticBuilder := do
  goal.withContext do
    let rcasesPat := ctorNamesToRCasesPats ctorNames
    let e ← delab e
    let uTactic ← `(tactic| rcases $e:term with $rcasesPat)
    let sTactic := {
      numSubgoals := ctorNames.size
      run := λ conts =>
        Unhygienic.run do
          let alts := ctorNamesToInductionAlts (ctorNames.zip conts)
          `(tactic| cases $e:term $alts:inductionAlts)
    }
    return .structured uTactic sTactic

def obtain (goal : MVarId) (e : Expr) (ctorNames : CtorNames) : TacticBuilder :=
  goal.withContext do
    let tac ← `(tactic| obtain $(ctorNames.toRCasesPat) := $(← delab e))
    return .unstructured tac

def casesOrObtain (goal : MVarId) (e : Expr) (ctorNames : Array CtorNames) :
    TacticBuilder :=
  if h : ctorNames.size = 1 then
    obtain goal e ctorNames[0]
  else
    cases goal e ctorNames

def renameInaccessibleFVars (postGoal : MVarId) (renamedFVars : Array FVarId) :
    TacticBuilder :=
  if renamedFVars.isEmpty then
    return .skip
  else
    postGoal.withContext do
      let ids ← renamedFVars.mapM λ fvarId => do
        let userName := mkIdent (← fvarId.getDecl).userName
        `(binderIdent| $userName:ident)
      return .unstructured $ ← `(tactic| rename_i $ids:binderIdent*)

def unfold (usedDecls : Array Name) (aesopUnfold : Bool) : TacticBuilder := do
  let usedDecls := usedDecls.map mkIdent
  let tac ←
  if aesopUnfold then
    `(tactic | aesop_unfold $usedDecls:ident*)
  else
    `(tactic | unfold $usedDecls:ident*)
  return .unstructured tac

def unfoldAt (goal : MVarId) (fvarId : FVarId) (usedDecls : Array Name)
    (aesopUnfold : Bool) : TacticBuilder :=
  goal.withContext do
    let hypIdent := mkIdent (← goal.withContext $ fvarId.getUserName)
    let usedDecls := usedDecls.map mkIdent
    let tac ←
    if aesopUnfold then
      `(tactic| aesop_unfold $usedDecls:ident* at $hypIdent:ident)
    else
      `(tactic| unfold $usedDecls:ident* at $hypIdent:ident)
    return .unstructured tac

open Lean.Parser.Tactic in
def extN (r : ExtResult) : TacticBuilder := do
  if r.depth == 0 then
    return .skip
  let mut pats := #[]
  if h : 0 < r.goals.size then
    let pats' ← r.goals[0].1.withContext do r.commonFVarIds.mapM mkPat
    pats := pats ++ pats'
    for (g, fvarIds) in r.goals do
      let pats' ← g.withContext do fvarIds.mapM mkPat
      pats := pats ++ pats'
  let depthStx := Syntax.mkNumLit $ toString r.depth
  let tac ← `(tactic| ext $pats:rintroPat* : $depthStx)
  return .unstructured tac
where
  mkPat (fvarId : FVarId) : MetaM (TSyntax `rintroPat) := do
    `(rintroPat| $(mkIdent $ ← fvarId.getUserName):ident)

private def simpAllOrSimpAtStarStx [Monad m] [MonadQuotation m] (simpAll : Bool)
    (configStx? : Option Term) : m (Syntax.Tactic) :=
  if simpAll then
    match configStx? with
    | none => `(tactic| simp_all)
    | some cfg => `(tactic| simp_all ($(mkIdent `config):ident := $cfg))
  else
    match configStx? with
    | none => `(tactic| simp at *)
    | some cfg => `(tactic| simp ($(mkIdent `config):ident := $cfg) at *)

private def simpAllOrSimpAtStarOnlyStx (simpAll : Bool) (inGoal : MVarId)
    (configStx? : Option Term) (usedTheorems : Simp.UsedSimps) :
    MetaM Syntax.Tactic := do
  let originalStx ← simpAllOrSimpAtStarStx simpAll configStx?
  let stx ← inGoal.withContext do
    Elab.Tactic.mkSimpOnly originalStx usedTheorems
  return ⟨stx⟩

def simpAllOrSimpAtStarOnly (simpAll : Bool) (inGoal : MVarId)
    (configStx? : Option Term) (usedTheorems : Simp.UsedSimps) :
    TacticBuilder :=
  .unstructured <$>
    simpAllOrSimpAtStarOnlyStx simpAll inGoal configStx? usedTheorems

private def isGlobalSimpTheorem (thms : SimpTheorems) (simprocs : Simprocs) : Origin → Bool
  | origin@(.decl decl) =>
    simprocs.simprocNames.contains decl ||
    thms.lemmaNames.contains origin ||
    thms.toUnfold.contains decl ||
    thms.toUnfoldThms.contains decl
  | _ => false

def simpAllOrSimpAtStar (simpAll : Bool) (inGoal : MVarId)
    (configStx? : Option Term) (usedTheorems : Simp.UsedSimps) :
    TacticBuilder := do
  let simpTheorems ← getSimpTheorems
  let simprocs ← Simp.getSimprocs
  let (map, size) ←
    usedTheorems.map.foldlM (init := ({}, 0)) λ (map, size) origin thm => do
      if isGlobalSimpTheorem simpTheorems simprocs origin then
        return (map, size)
      else
        return (map.insert origin thm, size + 1)
  let stx ←
    match ← simpAllOrSimpAtStarOnlyStx simpAll inGoal configStx? { map, size } with
    | `(tactic| simp_all $cfg:optConfig only [$lems,*]) =>
      `(tactic| simp_all $cfg:optConfig [$lems,*])
    | `(tactic| simp $cfg:optConfig only [$lems,*] at *) =>
      `(tactic| simp $cfg:optConfig [$lems,*] at *)
    | `(tactic| simp_all $cfg:optConfig only) =>
      `(tactic| simp_all $cfg:optConfig)
    | `(tactic| simp $cfg:optConfig only at *) =>
      `(tactic| simp $cfg:optConfig at *)
    | stx => throwError "simp tactic builder: unexpected syntax:{indentD stx}"
  return .unstructured ⟨stx⟩

def intros (postGoal : MVarId) (newFVarIds : Array FVarId)
    (md : TransparencyMode) : TacticBuilder := do
  let newFVarUserNames ← postGoal.withContext $
    newFVarIds.mapM (mkIdent <$> ·.getUserName)
  let tac ← `(tactic| intro $newFVarUserNames:ident*)
  let tac := withAllTransparencySyntax md tac
  return .unstructured ⟨tac⟩

def splitTarget : TacticBuilder :=
  return .unstructured $ ← `(tactic| split)

def splitAt (goal : MVarId) (fvarId : FVarId) : TacticBuilder := do
  let name ← goal.withContext fvarId.getUserName
  let tac ← `(tactic| split at $(mkIdent name):ident)
  return .unstructured tac

def substFVars (goal : MVarId) (fvarIds : Array FVarId) : TacticBuilder := do
  let names ← goal.withContext $ fvarIds.mapM λ fvarId =>
    return mkIdent (← fvarId.getUserName)
  let tac ← `(tactic| subst $names:ident*)
  return .unstructured tac

def substFVars' (fvarUserNames : Array Name) : TacticBuilder := do
  let fvarUserNames := fvarUserNames.map mkIdent
  let tac ← `(tactic| subst $fvarUserNames:ident*)
  return .unstructured tac

end Script.TacticBuilder

open Script

def assertHypothesisS (goal : MVarId) (h : Hypothesis) (md : TransparencyMode) :
    ScriptM (MVarId × Array FVarId) :=
  withScriptStep goal (#[·.1]) (λ _ => true) tacticBuilder do
    let (fvarIds, goal) ← withTransparency md $ goal.assertHypotheses #[h]
    return (goal, fvarIds)
where
  tacticBuilder _ := TacticBuilder.assertHypothesis goal h md

def applyS (goal : MVarId) (e : Expr) (eStx? : Option Term)
    (md : TransparencyMode) : ScriptM (Array MVarId) :=
  withScriptStep goal id (λ _ => true) tacticBuilder do
    (·.toArray) <$> withTransparency md (goal.apply e)
where
  tacticBuilder _ :=
      match eStx? with
      | none => TacticBuilder.apply goal e md
      | some eStx => TacticBuilder.applyStx eStx md

def replaceFVarS (goal : MVarId) (fvarId : FVarId) (type : Expr) (proof : Expr) :
    ScriptM (MVarId × FVarId × Bool) :=
  withScriptStep goal (#[·.1]) (λ _ => true) tacticBuilder do
    replaceFVar goal fvarId type proof
where
  tacticBuilder := (TacticBuilder.replace goal ·.1 fvarId type proof)

def clearS (goal : MVarId) (fvarId : FVarId) : ScriptM MVarId :=
  withScriptStep goal (#[·]) (λ _ => true) tacticBuilder do
    goal.clear fvarId
where
  tacticBuilder _ := TacticBuilder.clear goal #[fvarId]

def tryClearS (goal : MVarId) (fvarId : FVarId) : ScriptM (Option MVarId) :=
  withOptScriptStep goal (#[·]) tacticBuilder do
    goal.tryClear fvarId
where
  tacticBuilder _ := TacticBuilder.clear goal #[fvarId]

def tryClearManyS (goal : MVarId) (fvarIds : Array FVarId) :
    ScriptM (MVarId × Array FVarId) :=
  withScriptStep goal (#[·.fst]) (! ·.2.isEmpty) tacticBuilder do
    goal.tryClearMany' fvarIds
where
  tacticBuilder := λ (_, fvarIds) => TacticBuilder.clear goal fvarIds

def tryCasesS (goal : MVarId) (fvarId : FVarId) (ctorNames : Array CtorNames) :
    ScriptM (Option (Array CasesSubgoal)) := do
  let ctorNames := getUnusedCtorNames (← goal.getDecl).lctx
  let tacticBuilder _ :=
    TacticBuilder.casesOrObtain goal (.fvar fvarId) ctorNames
  withOptScriptStep goal (·.map (·.mvarId)) tacticBuilder do
    observing? $ goal.cases fvarId (ctorNames.map (·.toAltVarNames))
      (useNatCasesAuxOn := true)
where
  getUnusedCtorNames (lctx : LocalContext) : Array CtorNames :=
    Prod.fst $ ctorNames.foldl (init := (Array.mkEmpty ctorNames.size, lctx))
      λ (ctorNames, lctx) cn =>
        let (cn, lctx) := cn.mkFreshArgNames lctx
        (ctorNames.push cn, lctx)

def renameInaccessibleFVarsS (goal : MVarId) :
    ScriptM (MVarId × Array FVarId) :=
  withScriptStep goal (#[·.1]) (! ·.snd.isEmpty) tacticBuilder do
    goal.renameInaccessibleFVars
where
  tacticBuilder := λ (goal, renamedFVars) =>
    TacticBuilder.renameInaccessibleFVars goal renamedFVars

def unfoldManyTargetS (unfold? : Name → Option (Option Name)) (goal : MVarId) :
    ScriptM (Option (MVarId × Array Name)) := do
  let preState ← show MetaM _ from saveState
  let some (postGoal, usedDecls) ← unfoldManyTarget unfold? goal
    | return none
  let postState ← show MetaM _ from saveState
  recordScriptStep {
    preGoal := goal
    tacticBuilders :=
      #[TacticBuilder.unfold usedDecls (aesopUnfold := false),
        TacticBuilder.unfold usedDecls (aesopUnfold := true)]
    postGoals := #[postGoal]
    preState, postState
  }
  return some (postGoal, usedDecls)

def unfoldManyAtS (unfold? : Name → Option (Option Name)) (goal : MVarId)
    (fvarId : FVarId) : ScriptM (Option (MVarId × Array Name)) := do
  let preState ← show MetaM _ from saveState
  let some (postGoal, usedDecls) ← unfoldManyAt unfold? goal fvarId
    | return none
  let postState ← show MetaM _ from saveState
  recordScriptStep {
    preGoal := goal
    tacticBuilders :=
      #[TacticBuilder.unfoldAt goal fvarId usedDecls (aesopUnfold := false),
        TacticBuilder.unfoldAt goal fvarId usedDecls (aesopUnfold := true)]
    postGoals := #[postGoal]
    preState, postState
  }
  return some (postGoal, usedDecls)

def unfoldManyStarS (goal : MVarId) (unfold? : Name → Option (Option Name))  :
    ScriptM (Option MVarId) :=
  goal.withContext do
    let initialGoal := goal
    let mut goal := goal
    if let some (goal', _) ← unfoldManyTargetS unfold? goal then
      goal := goal'
    for ldecl in (← goal.getDecl).lctx do
      if ldecl.isImplementationDetail then
        continue
      if let some (goal', _) ← unfoldManyAtS unfold? goal ldecl.fvarId then
        goal := goal'
    if goal == initialGoal then
      return none
    else
      return some goal

def introsS (goal : MVarId) : ScriptM (MVarId × Array FVarId) :=
  withScriptStep goal (#[·.fst]) (! ·.2.isEmpty) tacticBuilder do
    let (newFVarIds, mvarId) ← unhygienic $ goal.intros
    return (mvarId, newFVarIds)
where
  tacticBuilder := λ (postGoal, newFVarIds) =>
      TacticBuilder.intros postGoal newFVarIds .default

def introsUnfoldingS (goal : MVarId) (md : TransparencyMode) :
    ScriptM (MVarId × Array FVarId) :=
  withScriptStep goal (#[·.fst]) (! ·.2.isEmpty) tacticBuilder do
    let (newFVarIds, mvarId) ← withTransparency md $ unhygienic $
      introsUnfolding goal
    return (mvarId, newFVarIds)
where
  tacticBuilder := λ (postGoal, newFVarIds) =>
      TacticBuilder.intros postGoal newFVarIds md

def straightLineExtS (goal : MVarId) : ScriptM ExtResult :=
  withScriptStep goal (·.goals.map (·.1)) (·.depth != 0) tacticBuilder do
    unhygienic $ straightLineExt goal
where
  tacticBuilder := TacticBuilder.extN

def tryExactFVarS (goal : MVarId) (fvarId : FVarId) (md : TransparencyMode) :
    ScriptM Bool := do
  let preState ← show MetaM _ from saveState
  let ldecl ← fvarId.getDecl
  let tgt ← goal.getType
  if ! (← withTransparency md $ isDefEq ldecl.type tgt) then
    show MetaM _ from restoreState preState
    return false
  goal.assign ldecl.toExpr
  let postState ← show MetaM _ from saveState
  let step := {
    preGoal := goal
    postGoals := #[]
    tacticBuilders := #[TacticBuilder.exactFVar goal fvarId md]
    preState, postState
  }
  recordScriptStep step
  return true

private def renameInaccessibleFVarsS' (goals : Array MVarId) :
    ScriptM (Array MVarId) :=
  goals.mapM ((·.fst) <$> renameInaccessibleFVarsS ·)

def splitTargetS? (goal : MVarId) :
    ScriptM (Option (Array MVarId)) := do
  let some subgoals ← withOptScriptStep goal id tacticBuilder do
    (·.map (·.toArray)) <$> splitTarget? goal
    | return none
  some <$> renameInaccessibleFVarsS' subgoals
where
  tacticBuilder _ := TacticBuilder.splitTarget

def splitFirstHypothesisS? (goal : MVarId) :
    ScriptM (Option (Array MVarId)) := do
  let some (subgoals, _) ← withOptScriptStep goal (·.1) tacticBuilder do
    for ldecl in (← goal.getDecl).lctx do
      if ldecl.isImplementationDetail then
        continue
      if let some goals ← splitLocalDecl? goal ldecl.fvarId then
        return some (goals.toArray, ldecl.fvarId)
    return none
    | return none
  some <$> renameInaccessibleFVarsS' subgoals
where
  tacticBuilder := λ (_, fvarId) => TacticBuilder.splitAt goal fvarId

end Aesop



=== LEAN SOURCE: SScript.lean ===
import Aesop.Script.Step

open Lean Lean.Meta

variable [Monad m] [MonadError m] [MonadQuotation m]

namespace Aesop.Script

inductive SScript
  | empty
  | onGoal (goalPos : Nat) (step : Step) (tail : SScript)
  | focusAndSolve (goalPos : Nat) (here tail : SScript)
  deriving Inhabited

namespace SScript

def takeNConsecutiveFocusAndSolve? (acc : Array SScript) :
    Nat → SScript → Option (Array SScript × SScript)
  | 0, tail => some (acc, tail)
  | _ + 1, empty => none
  | _ + 1, onGoal .. => none
  | n + 1, focusAndSolve 0 here tail =>
    takeNConsecutiveFocusAndSolve? (acc.push here) n tail
  | _ + 1, focusAndSolve (_ + 1) .. => none

partial def render (script : SScript) : m (Array Syntax.Tactic) := do
  go #[] script
where
  go (acc : Array Syntax.Tactic) :
      SScript → m (Array Syntax.Tactic)
    | empty => return acc
    | onGoal goalPos step tail => do
      if let some (tactic, tail) ← renderSTactic? goalPos step tail then
        let script := acc.push tactic
        go script tail
      else
        let script := acc.push $ mkOnGoal goalPos step.uTactic
        go script tail
    | focusAndSolve goalPos here tail => do
      let nestedScript ← go #[] here
      let t ←
        if goalPos == 0 then
          `(tactic| · $[$nestedScript:tactic]*)
        else
          let posLit := mkOneBasedNumLit goalPos
          `(tactic| on_goal $posLit:num => { $nestedScript:tactic* })
      go (acc.push t) tail

  renderSTactic? (goalPos : Nat) (step : Step) (tail : SScript) :
      m (Option (Syntax.Tactic × SScript)) := do
    let some sTactic := step.sTactic?
      | return none
    let some (nested, tail) :=
      takeNConsecutiveFocusAndSolve? #[] sTactic.numSubgoals tail
      | return none
    let nestedScripts ← nested.mapM (go #[])
    let tactic := mkOnGoal goalPos $ sTactic.run nestedScripts
    return (tactic, tail)

end Aesop.Script.SScript



=== LEAN SOURCE: Step.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Util.EqualUpToIds
import Aesop.Script.Tactic
import Aesop.Script.TacticState
import Aesop.Script.Util
import Aesop.Tracing
import Batteries.Tactic.PermuteGoals

open Lean Lean.Meta

variable [Monad m] [MonadError m] [MonadQuotation m]

namespace Aesop.Script

@[inline]
def mkOneBasedNumLit (n : Nat) : NumLit :=
  Syntax.mkNumLit $ toString $ n + 1

def mkOnGoal (goalPos : Nat) (tac : Syntax.Tactic) : Syntax.Tactic :=
  if goalPos == 0 then
    tac
  else
    let posLit := mkOneBasedNumLit goalPos
    Unhygienic.run `(tactic| on_goal $posLit:num => $tac:tactic)

structure Step where
  preState : Meta.SavedState
  preGoal : MVarId
  tactic : Tactic
  postState : Meta.SavedState
  postGoals : Array GoalWithMVars

def TacticState.applyStep (tacticState : TacticState) (step : Step) :
    m TacticState :=
  tacticState.applyTactic step.preGoal step.postGoals step.preState.meta.mctx
    step.postState.meta.mctx

namespace Step

def uTactic (s : Step) : UTactic :=
  s.tactic.uTactic

def sTactic? (s : Step) : Option STactic :=
  s.tactic.sTactic?

instance : ToMessageData Step where
  toMessageData step :=
    m!"{step.preGoal.name} → {step.postGoals.map (·.goal.name)}:{indentD $ toMessageData step.tactic}"

def mkSorry (preGoal : MVarId) (preState : Meta.SavedState) : MetaM Step := do
  let (_, postState) ← preState.runMetaM do
    preGoal.admit (synthetic := false)
  let tactic ← .unstructured <$> `(tactic| sorry)
  return {
    postGoals := #[]
    preState, postState, preGoal, tactic
  }

def render (acc : Array Syntax.Tactic) (step : Step)
    (tacticState : TacticState) : m (Array Syntax.Tactic × TacticState) := do
  let pos ← tacticState.getVisibleGoalIndex step.preGoal
  let tacticState ← tacticState.applyStep step
  let acc := acc.push $ mkOnGoal pos step.tactic.uTactic
  return (acc, tacticState)

open Lean.Elab.Tactic (evalTactic) in
def validate (step : Step) : MetaM Unit := do
  let preMCtx := step.preState.meta.mctx
  let expectedPostMCtx := step.postState.meta.mctx
  let expectedPostGoals := step.postGoals |>.map (·.goal)
  let tac := step.uTactic
  let (actualPostState, actualPostGoals) ←
    try
      runTacticMCapturingPostState (evalTactic tac) step.preState [step.preGoal]
    catch e =>
      throwError "tactic{indentD step.uTactic}\nfailed with error{indentD e.toMessageData}"
  let actualPostGoals := actualPostGoals.toArray
  unless ← tacticStatesEqualUpToIds preMCtx expectedPostMCtx
      actualPostState.meta.mctx expectedPostGoals actualPostGoals do
    throwError "tactic{indentD tac}\nsucceeded but did not generate expected state. Initial goal:{indentD $ ← fmtGoals step.preState #[step.preGoal]}\nExpected goals:{indentD $ ← fmtGoals step.postState $ step.postGoals.map (·.goal)}\nActual goals:{indentD $ ← fmtGoals actualPostState actualPostGoals}"
where
  fmtGoals (state : Meta.SavedState) (goals : Array MVarId) :
      MetaM MessageData :=
    state.runMetaM' do
      addMessageContext $
        MessageData.joinSep (← goals.mapM (λ g => return m!"{g}")).toList "\n"

end Step

structure LazyStep where
  preState : Meta.SavedState
  preGoal : MVarId
  /--
  A nonempty list of tactic builders. During script generation, Aesop tries to
  execute the builders from left to right. It then uses the first builder that
  succceds (in the sense that when run in `preState` on `preGoal` it produces
  the `postState` and `postGoals`). The last builder must succeed and is used
  unconditionally.
  -/
  tacticBuilders : Array TacticBuilder
  tacticBuilders_ne : 0 < tacticBuilders.size := by simp
  postState : Meta.SavedState
  postGoals : Array MVarId

namespace LazyStep

def runFirstSuccessfulTacticBuilder (s : LazyStep) : MetaM Tactic :=
  withConstAesopTraceNode .script (return m!"converting lazy step to step") do
  withPPAnalyze do
    let initialState ← saveState
    for b in s.tacticBuilders[:s.tacticBuilders.size - 1] do
      if let some tactic ← tryTacticBuilder b then
        return tactic
      initialState.restore
    have := s.tacticBuilders_ne
    let fallback ← s.tacticBuilders[s.tacticBuilders.size - 1]
    aesop_trace[script] "fallback: {fallback}"
    return fallback
where
  tryTacticBuilder (b : TacticBuilder) : MetaM (Option Tactic) := do
    let tactic ← b
    withAesopTraceNode .script (λ res => return m!"{exceptOptionEmoji res} {tactic}") do
      let tacticResult ← observing? do
        runTacticCapturingPostState tactic.uTactic s.preState [s.preGoal]
      let some (actualPostState, actualPostGoals) := tacticResult
        | return none
      let actualPostGoals := actualPostGoals.toArray
      let some _ ← matchGoals s.postState actualPostState s.postGoals actualPostGoals
        | return none
      return tactic

def toStep (s : LazyStep) : MetaM Step :=
  s.postState.runMetaM' do
    return {
      s with
      tactic := ← runFirstSuccessfulTacticBuilder s
      postGoals := ← s.postGoals.mapM GoalWithMVars.ofMVarId
    }

structure BuildInput (α) where
  tac : MetaM α
  postGoals : α → Array MVarId
  tacticBuilder : α → TacticBuilder

@[inline, always_inline]
def build (preGoal : MVarId) (i : BuildInput α) : MetaM (LazyStep × α) := do
  let preState ← saveState
  let a ← i.tac
  let postState ← saveState
  let step := {
    tacticBuilders := #[i.tacticBuilder a]
    postGoals := i.postGoals a
    preGoal, preState, postState
  }
  return (step, a)

def erasePostStateAssignments (s : LazyStep) (gs : Array MVarId) : LazyStep :=
  { s with
    postState.meta.mctx :=
      gs.foldl (init := s.postState.meta.mctx) λ mctx g =>
        mctx.eraseExprMVarAssignment g }

end Aesop.Script.LazyStep



=== LEAN SOURCE: StructureDynamic.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Script.UScript
import Aesop.Script.UScriptToSScript
import Aesop.Script.Util
import Aesop.Script.SScript
import Aesop.Tracing

open Lean Lean.Meta

namespace Aesop.Script

private def goalsToMessageData (state : Meta.SavedState) (goals : Array MVarId) :
    MetaM MessageData :=
  state.runMetaM' do
    addMessageContext $
    MessageData.joinSep
      (goals.map λ g => m!"?{g.name}:{indentD $ toMessageData g}").toList
      "\n"

namespace DynStructureM

structure Context where
  /-- The tactic invocation steps corresponding to the original unstructured
  script, but with `MVarId` keys adjusted to fit the current `MetaM` state. This
  state evolves during dynamic structuring and we continually update the `steps`
  so that this map's keys refer to metavariables which exist in the current
  `MetaM` state. -/
  steps : PHashMap MVarId (Nat × Step)
  deriving Inhabited

structure State where
  perfect : Bool := true

/--
Given a bijective map `map` from new `MVarId`s to old `MVarId`s, update the
`steps` of the context `c` such that each entry whose key is an old `MVarId` `m`
is replaced with an entry whose key is the corresponding new `MVarId`
`map⁻¹ m`.
-/
def Context.updateMVarIds (c : Context) (map : Std.HashMap MVarId MVarId) :
    Context :=
  let steps := map.fold (init := c.steps) λ steps newMVarId oldMVarId =>
    if let (some step) := steps.find? oldMVarId then
      steps.erase oldMVarId |>.insert newMVarId step
    else
      steps
  { c with steps }

end DynStructureM

abbrev DynStructureM :=
  ReaderT DynStructureM.Context $ StateRefT DynStructureM.State MetaM

def DynStructureM.run (x : DynStructureM α) (script : UScript) :
    MetaM (α × Bool) := do
  let mut steps : PHashMap MVarId (Nat × Step) := {}
  for h : i in [:script.size] do
    let step := script[i]
    steps := steps.insert step.preGoal (i, step)
  let (a, s) ← ReaderT.run x { steps } |>.run {}
  return (a, s.perfect)

def withUpdatedMVarIds
    (oldPostState newPostState : Meta.SavedState)
    (oldPostGoals newPostGoals : Array MVarId) (onFailure : DynStructureM α)
    (onSuccess : DynStructureM α) : DynStructureM α := do
  match ← matchGoals newPostState oldPostState newPostGoals oldPostGoals with
  | some m => withReader (·.updateMVarIds m) onSuccess
  | none => onFailure

structure DynStructureResult where
  script : List Step
  postState : Meta.SavedState

partial def structureDynamicCore (preState : Meta.SavedState) (preGoal : MVarId)
    (uscript : UScript) : MetaM (Option (UScript × Bool)) :=
  withAesopTraceNode .script (λ r => return m!"{exceptOptionEmoji r} Dynamically structuring the script") do
    aesop_trace[script] "unstructured script:{indentD $ MessageData.joinSep (uscript.map toMessageData |>.toList) "\n"}"
    let (result?, perfect) ← go preState #[preGoal] |>.run uscript
    let some result := result?
      | return none
    return some (result.script.toArray, perfect)
where
  go (preState : Meta.SavedState) (preGoals : Array MVarId) :
      DynStructureM (Option DynStructureResult) :=
    withIncRecDepth do
    if h : 0 < preGoals.size then
      -- Try to apply the step for the main goal, then solve the remaining goals.
      let firstGoal := preGoals[0]
      let result? ← withAesopTraceNode .script (λ r => return m!"{exceptOptionEmoji r} Focusing main goal {firstGoal.name}") do
        aesop_trace[script] "goal: {firstGoal.name}{← preState.runMetaM' $ addMessageContext $ indentD firstGoal}"
        goStructured preState preGoals preGoals[0]
      match result? with
      | some result => return result
      | none =>
        -- If this fails, apply the chronologically next step and solve the remaining goals.
        modify ({ · with perfect := false })
        withAesopTraceNode .script (λ r => return m!"{exceptOptionEmoji r} Applying step to chronologically first goal") do
          goUnstructured preState preGoals
    else
      return some { script := [], postState := preState }

  goStructured (preState : Meta.SavedState) (preGoals : Array MVarId)
      (firstPreGoal : MVarId) : DynStructureM (Option DynStructureResult) := do
    let (some (_, step)) := (← read).steps[firstPreGoal]
      | throwError "aesop: internal error while structuring the script: no step for goal {preGoal.name}:{indentD $ ← preState.runMetaM' $ addMessageContext $ toMessageData preGoal}"
    applyStepAndSolveRemaining preState preGoals firstPreGoal 0 step

  goUnstructured (preState : Meta.SavedState) (preGoals : Array MVarId) :
      DynStructureM (Option DynStructureResult) := do
    let steps := (← read).steps
    let firstStep? := findFirstStep? preGoals (steps[·]) (·.fst)
    let some (goalPos, goal, _, step) := firstStep?
      | throwError "aesop: internal error while structuring the script: no step for any of the visible goals{indentD $ ← goalsToMessageData preState preGoals}"
    aesop_trace[script] "goal: {goal.name}{← preState.runMetaM' $ addMessageContext $ indentD goal}"
    applyStepAndSolveRemaining preState preGoals goal goalPos step

  applyStepAndSolveRemaining (preState : Meta.SavedState)
      (preGoals : Array MVarId) (preGoal : MVarId) (goalPos : Nat)
      (step : Step) : DynStructureM (Option DynStructureResult) := do
    aesop_trace[script] "applying step:{indentD $ toMessageData step}"
    aesop_trace[script] "expected post goals:{indentD $ ← goalsToMessageData step.postState (step.postGoals.map (·.goal))}"
    let (postState, postGoals) ←
      try
        runTacticCapturingPostState step.uTactic preState [preGoal]
      catch e =>
        aesop_trace[script] "tactic failed with error:{indentD e.toMessageData}"
        return none
    let postGoals := postGoals.toArray
    withUpdatedMVarIds step.postState postState (step.postGoals.map (·.goal)) postGoals
      (onFailure := do
        aesop_trace[script] "post goals don't match; actual post goals:{indentD $ ← goalsToMessageData postState postGoals}"
        return none) do
      aesop_trace[script] "post goals match"
      let postGoalsWithMVars ← postState.runMetaM' do
        postGoals.mapM λ goal =>
          return { goal, mvars := ← goal.getMVarDependencies }
      -- We need to construct a new step here because the old step's postState
      -- is equivalent to the new postState *only up to mvar assignments*.
      let step := {
        tactic := step.tactic
        postGoals := postGoalsWithMVars
        preState, preGoal, postState
      }
      let postGoals := preGoals[:goalPos] ++ postGoals ++ preGoals[goalPos+1:]
      let postGoals ← postState.runMetaM' do
        postGoals.filterM λ mvarId =>
          return ! (← mvarId.isAssignedOrDelayedAssigned)
      let some { script := tailScript, postState } ← go postState postGoals
        | return none
      let script := step :: tailScript
      return some { script, postState }

def UScript.toSScriptDynamic (preState : Meta.SavedState) (preGoal : MVarId)
    (uscript : UScript) : MetaM (Option (SScript × Bool)) := do
  let some (uscript, perfect) ← structureDynamicCore preState preGoal uscript
    | return none
  let preGoalMVars ← preState.runMetaM' preGoal.getMVarDependencies
  let tacticState := {
    visibleGoals := #[⟨preGoal, preGoalMVars⟩]
    invisibleGoals := ∅
  }
  return some (← orderedUScriptToSScript uscript tacticState, perfect)

end Aesop.Script



=== LEAN SOURCE: StructureStatic.lean ===
import Aesop.Script.UScriptToSScript
import Aesop.Script.Util

open Lean Lean.Meta

namespace Aesop.Script

namespace StaticStructureM

structure State where
  perfect : Bool := true

structure Context where
  steps : Std.HashMap MVarId (Nat × Step)

end StaticStructureM

abbrev StaticStructureM :=
  ReaderT StaticStructureM.Context $ StateRefT StaticStructureM.State CoreM

protected def StaticStructureM.run (script : UScript) (x : StaticStructureM α) :
    CoreM (α × Bool) := do
  let mut steps : Std.HashMap MVarId (Nat × Step) := Std.HashMap.emptyWithCapacity script.size
  for h : i in [:script.size] do
    let step := script[i]
    if h : step.postGoals.size = 1 then
      if step.postGoals[0].goal == step.preGoal then
        continue
    steps := steps.insert step.preGoal (i, step)
  let (a, s) ← ReaderT.run x { steps } |>.run {}
  return (a, s.perfect)

partial def structureStaticCore (tacticState : TacticState) (script : UScript) :
    CoreM (UScript × Bool) :=
  withConstAesopTraceNode .script (return m!"statically structuring the tactic script") do
  aesop_trace[script] "unstructured script:{indentD $ MessageData.joinSep (script.toList.map λ step => m!"{step}") "\n"}"
  let ((script, _), perfect) ← go tacticState |>.run script
  return (script.toArray, perfect)
where
  go (tacticState : TacticState) : StaticStructureM (List Step × TacticState) :=
    withIncRecDepth do
    if let some goal := tacticState.visibleGoals[0]? then
      let step ← nextStep tacticState goal
      aesop_trace[script] "rendering step:{indentD $ toMessageData step}"
      let tacticState ← tacticState.applyStep step
      let (tailScript, tacticState) ← go tacticState
      return (step :: tailScript, tacticState)
    else
      return ([], tacticState)

  nextStep (tacticState : TacticState) (mainGoal : GoalWithMVars) :
      StaticStructureM Step := do
    let steps := (← read).steps
    if mainGoal.mvars.isEmpty then
      let some (_, step) := steps[mainGoal.goal]?
        | throwError "aesop: internal error while structuring script: no script step for main goal {mainGoal.goal.name}"
      return step
    let firstStep? :=
      findFirstStep? tacticState.visibleGoals (steps[·.goal]?) (·.fst)
    let some (_, _, _, firstStep) := firstStep?
      | throwError "aesop: internal error while structuring script: no script step found for any of the goals {tacticState.visibleGoals.map (·.goal.name)}"
    if firstStep.preGoal != mainGoal.goal then
      modify ({ · with perfect := false })
    return firstStep

def UScript.toSScriptStatic (tacticState : TacticState) (uscript : UScript) :
    CoreM (SScript × Bool) := do
  let (script, perfect) ← structureStaticCore tacticState uscript
  return (← orderedUScriptToSScript script tacticState, perfect)

end Aesop.Script



=== LEAN SOURCE: Tactic.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Lean

open Lean

namespace Aesop.Script

abbrev UTactic := Syntax.Tactic

structure STactic where
  numSubgoals : Nat
  run : Array (Array Syntax.Tactic) → Syntax.Tactic

structure Tactic where
  uTactic : UTactic
  sTactic? : Option STactic

namespace Tactic

instance : ToMessageData Tactic where
  toMessageData t := toMessageData t.uTactic

def unstructured (uTactic : UTactic) : Tactic where
  uTactic := uTactic
  sTactic? := none

def structured (uTactic : UTactic) (sTactic : STactic) : Tactic where
  uTactic := uTactic
  sTactic? := some sTactic

end Tactic

abbrev TacticBuilder := MetaM Tactic

end Aesop.Script



=== LEAN SOURCE: TacticState.lean ===
/-
Copyright (c) 2022--2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/
import Batteries.Lean.Meta.Basic
import Aesop.Script.GoalWithMVars

open Lean

namespace Aesop.Script

variable [Monad m] [MonadError m]

structure TacticState where
  visibleGoals : Array GoalWithMVars
  invisibleGoals : Std.HashSet MVarId
  deriving Inhabited

namespace TacticState

def mkInitial (goal : MVarId) : MetaM TacticState :=
  return {
    visibleGoals := #[⟨goal, ← goal.getMVarDependencies⟩]
    invisibleGoals := ∅
  }

private def throwUnknownGoalError (goal : MVarId) (pre : MessageData) : m α :=
  throwError "internal error: {pre}: unknown goal '?{goal.name}'"

def getVisibleGoalIndex? (ts : TacticState) (goal : MVarId) : Option Nat :=
  ts.visibleGoals.findIdx? (·.goal == goal)

def getVisibleGoalIndex (ts : TacticState) (goal : MVarId) : m Nat := do
  if let (some idx) := ts.getVisibleGoalIndex? goal then
    return idx
  else
    throwUnknownGoalError goal "getVisibleGoalIndex"

def getMainGoal? (ts : TacticState) : Option MVarId :=
  ts.visibleGoals[0]?.map (·.goal)

def visibleGoalsHaveMVars (ts : TacticState) : Bool :=
  ts.visibleGoals.any λ g => ! g.mvars.isEmpty

def solveVisibleGoals (ts : TacticState) : TacticState :=
  { ts with visibleGoals := #[] }

private def replaceWithArray [BEq α] (xs : Array α) (x : α) (r : Array α) :
    Option (Array α) := Id.run do
  let mut found := false
  let mut ys := Array.mkEmpty (xs.size - 1 + r.size)
  for x' in xs do
    if x' == x then
      ys := ys ++ r
      found := true
    else
      ys := ys.push x'
  return if found then some ys else none

def eraseSolvedGoals (ts : TacticState) (preMCtx postMCtx : MetavarContext) :
    TacticState := {
  ts with
  visibleGoals := ts.visibleGoals.filter (! mvarWasSolved ·.goal)
  invisibleGoals := ts.invisibleGoals.filter (! mvarWasSolved ·)
}
where
  mvarWasSolved (mvarId : MVarId) : Bool :=
    postMCtx.isExprMVarAssignedOrDelayedAssigned mvarId &&
    ! preMCtx.isExprMVarAssignedOrDelayedAssigned mvarId

def applyTactic (ts : TacticState) (inGoal : MVarId)
    (outGoals : Array GoalWithMVars) (preMCtx postMCtx : MetavarContext) :
    m TacticState := do
  let (some visibleGoals) :=
        replaceWithArray ts.visibleGoals ⟨inGoal, {}⟩ outGoals
    | throwUnknownGoalError inGoal "applyTactic"
  let ts := { ts with visibleGoals }
  return eraseSolvedGoals ts preMCtx postMCtx

-- Focus the visible goal `goal` and move all other previously visible goals
-- to `invisibleGoals`.
def focus (ts : TacticState) (goal : MVarId) : m TacticState := do
  let (some goalWithMVars) := ts.visibleGoals.find? (·.goal == goal)
    | throwUnknownGoalError goal "focus"
  let mut invisibleGoals := ts.invisibleGoals
  for g in ts.visibleGoals do
    if g.goal != goal then
      invisibleGoals := invisibleGoals.insert g.goal
  return { visibleGoals := #[goalWithMVars], invisibleGoals }

@[inline, always_inline]
def onGoalM (ts : TacticState) (g : MVarId)
    (f : TacticState → m (α × TacticState)) : m (α × TacticState) := do
  let (a, postTs) ← f (← ts.focus g)
  let mut visibleGoals := #[]
  for preGoal in ts.visibleGoals do
    if preGoal.goal == g then
      visibleGoals := visibleGoals ++ postTs.visibleGoals
    else if postTs.invisibleGoals.contains preGoal.goal then
      visibleGoals := visibleGoals.push preGoal
  let mut invisibleGoals := ∅
  for g in ts.invisibleGoals do
    if postTs.invisibleGoals.contains g then
      invisibleGoals := invisibleGoals.insert g
  return (a, { visibleGoals, invisibleGoals })

end Aesop.Script.TacticState



=== LEAN SOURCE: UScript.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Script.Step

open Lean Lean.Meta
open Lean.Parser.Tactic (tacticSeq)

namespace Aesop.Script

abbrev UScript := Array Step

namespace UScript

variable [Monad m] [MonadError m] [MonadQuotation m] in
def render (tacticState : TacticState) (s : UScript) :
    m (Array Syntax.Tactic) := do
  let mut script := Array.mkEmpty s.size
  let mut tacticState := tacticState
  for step in s do
    let (script', tacticState') ← step.render script tacticState
    script := script'
    tacticState := tacticState'
  return script

def renderTacticSeq (uscript : UScript) (preState : Meta.SavedState)
    (goal : MVarId) : MetaM (TSyntax ``tacticSeq) := do
  let tacticState ← preState.runMetaM' $ Script.TacticState.mkInitial goal
  `(tacticSeq| $(← uscript.render tacticState):tactic*)

def validate (s : UScript) : MetaM Unit :=
  s.forM (·.validate)

end Aesop.Script.UScript



=== LEAN SOURCE: UScriptToSScript.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Script.UScript
import Aesop.Script.SScript
import Aesop.Tracing

open Lean Lean.Meta

namespace Aesop.Script

inductive StepTree where
  | empty
  | node (step : Step) (index : Nat) (children : Array StepTree)
  deriving Nonempty

namespace StepTree

protected partial def toMessageData? : StepTree → Option MessageData
  | empty => none
  | node step index children =>
    m!"- {index}: {step}{if children.isEmpty then m!"" else indentD $ MessageData.joinSep (children.filterMap (·.toMessageData?) |>.toList) "\n"}"

protected def toMessageData (t : StepTree) : MessageData :=
  t.toMessageData?.getD "empty"

end StepTree

instance : ToMessageData StepTree :=
  ⟨StepTree.toMessageData⟩

partial def UScript.toStepTree (s : UScript) : StepTree := Id.run do
  let mut preGoalMap : Std.HashMap MVarId (Nat × Step) := ∅
  for h : i in [:s.size] do
    preGoalMap := preGoalMap.insert s[i].preGoal (i, s[i])
  if h : 0 < s.size then
    go preGoalMap s[0].preGoal
  else
    return .empty
where
  go (m : Std.HashMap MVarId (Nat × Step)) (goal : MVarId) : StepTree :=
    if let some (i, step) := m[goal]? then
      .node step i (step.postGoals.map (go m ·.goal))
    else
      .empty

def sortDedupArrays [Ord α] (as : Array (Array α)) : Array α :=
  let sz := as.foldl (init := 0) (· + ·.size)
  let as := as.foldl (init := Array.mkEmpty sz) (· ++ ·)
  as.sortDedup

def isConsecutiveSequence (ns : Array Nat) : Bool := Id.run do
  if let some hd := ns[0]? then
    let mut prev := hd
    for n in ns[1:] do
      if n != prev + 1 then
        return false
      prev := n
  return true

namespace StepTree

partial def focusableGoals (t : StepTree) : Std.HashMap MVarId Nat :=
  runST (λ _ => go t |>.run ∅) |>.2
where
  go {σ} : StepTree → StateRefT (Std.HashMap MVarId Nat) (ST σ) (Array Nat)
    | .empty => return #[]
    | .node step i children => do
      let childIndexes := sortDedupArrays $ ← children.mapM go
      let indexes :=
        (Array.mkEmpty $ childIndexes.size + 1).push i ++ childIndexes
      if isConsecutiveSequence indexes then
        let lastIndex := childIndexes[childIndexes.size - 1]?.getD i
        modify (·.insert step.preGoal lastIndex)
      return indexes

partial def numSiblings (t : StepTree) : Std.HashMap MVarId Nat :=
  runST (λ _ => go 0 t |>.run ∅) |>.2
where
  go {σ} (parentNumGoals : Nat) :
      StepTree → StateRefT (Std.HashMap MVarId Nat) (ST σ) Unit
    | .empty => return
    | .node step _ children => do
      modify (·.insert step.preGoal (parentNumGoals - 1))
      children.forM (go children.size)

end StepTree

partial def orderedUScriptToSScript (uscript : UScript) (tacticState : TacticState) : CoreM SScript :=
  withAesopTraceNode .script (λ e => return m!"{exceptEmoji e} Converting ordered unstructured script to structured script") do
  aesop_trace[script] "unstructured script:{indentD $ MessageData.joinSep (uscript.map toMessageData |>.toList) "\n"}"
  let stepTree := uscript.toStepTree
  aesop_trace[script] "step tree:{indentD $ toMessageData stepTree}"
  let focusable := stepTree.focusableGoals
  let numSiblings := stepTree.numSiblings
  aesop_trace[script] "focusable goals: {focusable.toArray.map λ (mvarId, n) => (mvarId.name, n)}"
  (·.fst) <$> go focusable numSiblings 0 (uscript.size - 1) tacticState
where
  go (focusable : Std.HashMap MVarId Nat) (numSiblings : Std.HashMap MVarId Nat)
      (start stop : Nat) (tacticState : TacticState) :
      CoreM (SScript × TacticState) := do
    if start > stop then
      return (.empty, tacticState)
    if let some step := uscript[start]? then
      aesop_trace[script] "applying step:{indentD $ toMessageData step}"
      let some siblings := numSiblings[step.preGoal]?
        | throwError "aesop: internal error while structuring script: unknown sibling count for goal {step.preGoal.name}"
      aesop_trace[script] "siblings: {siblings}"
      let innerStop? := focusable[step.preGoal]?
      aesop_trace[script] "focusable: {innerStop?.isSome}"
      aesop_trace[script] "visible goals: {tacticState.visibleGoals.map (·.goal.name)}"
      let some goalPos := tacticState.getVisibleGoalIndex? step.preGoal
        -- I think his can be `none` if the step is for an mvar that was already
        -- assigned by some other step.
        | return (.empty, tacticState)
      aesop_trace[script] "goal position: {goalPos}"
      if innerStop?.isNone || siblings == 0 then
        let tacticState ← tacticState.applyStep step
        let (tailScript, tacticState) ← go focusable numSiblings (start + 1) stop tacticState
        return (.onGoal goalPos step tailScript, tacticState)
      else
        let innerStop := innerStop?.get!
        let (nestedScript, tacticState) ←
          tacticState.onGoalM step.preGoal λ tacticState => do
            let tacticState ← tacticState.applyStep step
            let (tailScript, tacticState) ←
              go focusable numSiblings (start + 1) innerStop tacticState
            return (.onGoal 0 step tailScript, tacticState)
        let (tailScript, tacticState) ←
          go focusable numSiblings (innerStop + 1) stop tacticState
        let script := .focusAndSolve goalPos nestedScript tailScript
        return (script, tacticState)
    else
      return (.empty, tacticState)

end Aesop.Script



=== LEAN SOURCE: Util.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Util.Basic
import Aesop.Util.EqualUpToIds
import Batteries.Lean.Meta.SavedState

open Lean Std Lean.Meta

namespace Aesop.Script

-- Without {α β : Type} universe inference goes haywire.
@[specialize]
def findFirstStep? {α β : Type} (goals : Array α) (step? : α → Option β)
     (stepOrder : β → Nat) : Option (Nat × α × β) := Id.run do
  let mut firstStep? := none
  for h : pos in [:goals.size] do
    let g := goals[pos]
    if let some step := step? g then
      if let some (_, _, currentFirstStep) := firstStep? then
        if stepOrder step < stepOrder currentFirstStep then
          firstStep? := some (pos, g, step)
      else
        firstStep? := some (pos, g, step)
    else
      continue
  return firstStep?

def matchGoals (postState₁ postState₂ : Meta.SavedState)
    (goals₁ goals₂ : Array MVarId) : MetaM (Option (Std.HashMap MVarId MVarId)) := do
  let goals₁ ← getProperGoals postState₁ goals₁
  let goals₂ ← getProperGoals postState₂ goals₂
  let (equal, s) ←
    tacticStatesEqualUpToIds' none postState₁.meta.mctx
      postState₂.meta.mctx goals₁ goals₂ (allowAssignmentDiff := true)
  if ! equal then
    return none
  else
    return s.equalMVarIds
where
  getProperGoals (state : Meta.SavedState) (goals : Array MVarId) :
      MetaM (Array MVarId) :=
    state.runMetaM' do
      let (properGoals, _) ← partitionGoalsAndMVars id goals
      return properGoals.map (·.fst)

end Aesop.Script



=== LEAN SOURCE: ExpandSafePrefix.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/
import Aesop.Exception
import Aesop.Search.Expansion

open Lean Lean.Meta

namespace Aesop

declare_aesop_exception
  safeExpansionFailedException safeExpansionFailedExceptionId
  isSafeExpansionFailedException

structure SafeExpansionM.State where
  numRapps : Nat := 0

abbrev SafeExpansionM Q [Queue Q] := StateRefT SafeExpansionM.State (SearchM Q)

variable [Queue Q]

private def Goal.isSafeExpanded (g : Goal) : BaseIO Bool :=
  (pure g.unsafeRulesSelected) <||> g.hasSafeRapp

-- Typeclass inference struggles with inferring Q, so we have to lift
-- explicitly.
private def liftSearchM (x : SearchM Q α) : SafeExpansionM Q α :=
  x

mutual
  private partial def expandSafePrefixGoal (gref : GoalRef) :
      SafeExpansionM Q Unit := do
    let g ← gref.get
    if g.state.isProven then
      aesop_trace[steps] "Skipping safe rule expansion of goal {g.id} since it is already proven."
      return
    if ! (← g.isSafeExpanded) then
      aesop_trace[steps] "Applying safe rules to goal {g.id}."
      if ← liftSearchM $ normalizeGoalIfNecessary gref then
          -- Goal was already proved by normalisation.
          return
      let maxRapps := (← read).options.maxSafePrefixRuleApplications
      if maxRapps > 0 && (← getThe SafeExpansionM.State).numRapps > maxRapps then
        throw safeExpansionFailedException
      discard $ liftSearchM $ runFirstSafeRule gref
      modifyThe SafeExpansionM.State λ s =>
        { s with numRapps := s.numRapps + 1 }
    else
      aesop_trace[steps] "Skipping safe rule expansion of goal {g.id} since safe rules have already been applied."
    let g ← gref.get
    if g.state.isProven then
      return
    let safeRapps ← g.safeRapps
    if h₁ : 0 < safeRapps.size then
      if safeRapps.size > 1 then
        throwError "aesop: internal error: goal {g.id} has multiple safe rapps"
      expandFirstPrefixRapp safeRapps[0]

  private partial def expandFirstPrefixRapp (rref : RappRef) :
      SafeExpansionM Q Unit := do
    (← rref.get).children.forM expandSafePrefixMVarCluster

  private partial def expandSafePrefixMVarCluster (cref : MVarClusterRef) :
      SafeExpansionM Q Unit := do
    (← cref.get).goals.forM expandSafePrefixGoal
end

def expandSafePrefix : SearchM Q Bool := do
  aesop_trace[steps] "Expanding safe subtree of the root goal."
  try
    expandSafePrefixGoal (← getRootGoal) |>.run' {}
    return true
  catch e =>
    if isSafeExpansionFailedException e then
      return false
    else
      throw e

end Aesop



=== LEAN SOURCE: Expansion.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Search.Expansion.Norm
import Aesop.Tree.AddRapp

open Lean
open Lean.Meta

namespace Aesop

variable [Aesop.Queue Q]

inductive RuleResult
  | proved (newRapps : Array RappRef)
  | succeeded (newRapps : Array RappRef)
  | failed

namespace RuleResult

def toEmoji : RuleResult → String
  | proved .. => ruleProvedEmoji
  | succeeded .. => ruleSuccessEmoji
  | failed => ruleFailureEmoji

def isSuccessful
  | proved .. | succeeded .. => true
  | failed => false

end RuleResult

inductive SafeRuleResult
  | regular (result : RuleResult)
  | postponed (result : PostponedSafeRule)

namespace SafeRuleResult

def toEmoji : SafeRuleResult → String
  | regular r => r.toEmoji
  | postponed .. => rulePostponedEmoji

def isSuccessfulOrPostponed
  | regular r => r.isSuccessful
  | postponed .. => true

end SafeRuleResult

def runRegularRuleTac (goal : Goal) (tac : RuleTac) (ruleName : RuleName)
    (indexMatchLocations : Std.HashSet IndexMatchLocation)
    (patternSubsts? : Option (Std.HashSet Substitution))
    (options : Options') (hypTypes : PHashSet RPINF) :
    BaseM (Except Exception RuleTacOutput) := do
  let some (postNormGoal, postNormState) := goal.postNormGoalAndMetaState? | throwError
    "aesop: internal error during expansion: expected goal {goal.id} to be normalised (but not proven by normalisation)."
  let input := {
    goal := postNormGoal
    mvars := goal.mvars
    hypTypes, indexMatchLocations, patternSubsts?, options
  }
  runRuleTac tac ruleName postNormState input

def addRapps (parentRef : GoalRef) (rule : RegularRule)
    (rapps : Array RuleApplication) : SearchM Q RuleResult := do
  let parent ← parentRef.get

  let mut rrefs := Array.mkEmpty rapps.size
  let mut subgoals := Array.mkEmpty $ rapps.size * 3
  for h : i in [:rapps.size] do
    let rapp := rapps[i]
    let successProbability :=
      parent.successProbability *
      (rapp.successProbability?.getD rule.successProbability)
    let rref ← addRapp {
      rapp with
      parent := parentRef
      appliedRule := rule
      successProbability }
    rrefs := rrefs.push rref
    for cref in (← rref.get).children do
      for gref in (← cref.get).goals do
        subgoals := subgoals.push gref

  enqueueGoals subgoals
  rrefs.forM (·.markProven)
    -- `markProven` is a no-op if the rapp is not, in fact, proven. We must
    -- perform this computation after all rapps have been added to ensure
    -- that if one is proven, the others are all marked as irrelevant.

  let provenRref? ← rrefs.findM? λ rref => return (← rref.get).state.isProven
  if let (some _) := provenRref? then
    return .proved rrefs
  else
    return .succeeded rrefs

private def addRuleFailure (rule : RegularRule) (parentRef : GoalRef) :
    SearchM Q Unit := do
  parentRef.modify λ g => g.setFailedRapps $ g.failedRapps.push rule

@[inline, always_inline]
def withRuleTraceNode (ruleName : RuleName)
    (toEmoji : α → String) (suffix : String) (k : SearchM Q α) : SearchM Q α :=
  withAesopTraceNode .steps fmt k
  where
    fmt (result : Except Exception α) : SearchM Q MessageData := do
      let emoji := exceptRuleResultToEmoji toEmoji result
      return m!"{emoji} {ruleName}{suffix}"

def runRegularRuleCore (parentRef : GoalRef) (rule : RegularRule)
    (indexMatchLocations : Std.HashSet IndexMatchLocation)
    (patternSubsts? : Option (Std.HashSet Substitution)) :
    SearchM Q (Option RuleTacOutput) := do
  let parent ← parentRef.get
  let ruleOutput? ←
    runRegularRuleTac parent rule.tac.run rule.name indexMatchLocations
      patternSubsts? (← read).options parent.forwardState.hypTypes
  match ruleOutput? with
  | .error exc =>
    aesop_trace[steps] exc.toMessageData
    return none
  | .ok { applications := #[], .. } =>
    aesop_trace[steps] "Rule returned no rule applications"
    return none
  | .ok output =>
    return some output

def runSafeRule (parentRef : GoalRef) (matchResult : IndexMatchResult SafeRule) :
    SearchM Q SafeRuleResult := do
  profilingRule (.ruleName matchResult.rule.name) (·.isSuccessfulOrPostponed) do
    let rule := matchResult.rule
    withRuleTraceNode rule.name (·.toEmoji) "" do
      let some output ←
          runRegularRuleCore parentRef (.safe matchResult.rule)
            matchResult.locations matchResult.patternSubsts?
        | do addRuleFailure (.safe rule) parentRef; return .regular .failed
      let parentMVars := (← parentRef.get).mvars
      let rapps := output.applications
      if rapps.size != 1 then
        aesop_trace[steps] "Safe rule did not produce exactly one rule application"
        addRuleFailure (.safe rule) parentRef
        return .regular .failed
      let anyParentMVarAssigned ← rapps.anyM λ rapp => do
        rapp.postState.runMetaM' do
          parentMVars.anyM (·.isAssignedOrDelayedAssigned)
      if anyParentMVarAssigned then
        aesop_trace[steps] "Safe rule assigned metavariables, so we postpone it"
        return .postponed ⟨rule, output⟩
      else
        return .regular (← addRapps parentRef (.safe rule) rapps)

def runUnsafeRule (parentRef : GoalRef)
    (matchResult : IndexMatchResult UnsafeRule) : SearchM Q RuleResult := do
  let rule := matchResult.rule
  profilingRule (.ruleName rule.name) (·.isSuccessful) do
    withRuleTraceNode rule.name (·.toEmoji) "" do
      let some output ←
          runRegularRuleCore parentRef (.unsafe rule) matchResult.locations
            matchResult.patternSubsts?
        | do addRuleFailure (.unsafe rule) parentRef; return .failed
      addRapps parentRef (.unsafe rule) output.applications

inductive SafeRulesResult
  | proved (newRapps : Array RappRef)
  | succeeded (newRapps : Array RappRef)
  | failed (postponed : Array PostponedSafeRule)
  | skipped

def SafeRulesResult.toEmoji : SafeRulesResult → String
  | proved .. => ruleProvedEmoji
  | succeeded .. => ruleSuccessEmoji
  | failed .. => ruleFailureEmoji
  | skipped => ruleSkippedEmoji

def runFirstSafeRule (gref : GoalRef) : SearchM Q SafeRulesResult := do
  let g ← gref.get
  if g.unsafeRulesSelected then
    return .skipped
    -- If the unsafe rules have been selected, we have already tried all the
    -- safe rules.
  let rules ← selectSafeRules g
  let mut postponedRules := {}
  for r in rules do
    let result ← runSafeRule gref r
    match result with
    | .regular .failed => continue
    | .regular (.proved newRapps) => return .proved newRapps
    | .regular (.succeeded newRapps) => return .succeeded newRapps
    | .postponed r =>
      postponedRules := postponedRules.push r
  return .failed postponedRules

def applyPostponedSafeRule (r : PostponedSafeRule) (parentRef : GoalRef) :
    SearchM Q RuleResult := do
  withRuleTraceNode r.rule.name (·.toEmoji) " (postponed)" do
    addRapps parentRef (.unsafe r.toUnsafeRule) r.output.applications

partial def runFirstUnsafeRule (postponedSafeRules : Array PostponedSafeRule)
    (parentRef : GoalRef) : SearchM Q RuleResult := do
  let queue ← selectUnsafeRules postponedSafeRules parentRef
  let (remainingQueue, result) ← loop queue
  parentRef.modify λ g => g.setUnsafeQueue remainingQueue
  if remainingQueue.isEmpty then
    let parent ← parentRef.get
    if ← pure (! parent.state.isProven) <&&> parent.isUnprovableNoCache then
      parentRef.markUnprovable
  return result
  where
    loop (queue : UnsafeQueue) : SearchM Q (UnsafeQueue × RuleResult) := do
      let (some (r, queue)) := Subarray.popHead? queue
        | return (queue, RuleResult.failed)
      match r with
      | .unsafeRule r =>
        let result ← runUnsafeRule parentRef r
        match result with
        | .proved .. => return (queue, result)
        | .succeeded .. => return (queue, result)
        | .failed => loop queue
      | .postponedSafeRule r =>
        return (queue, ← applyPostponedSafeRule r parentRef)

def expandGoal (gref : GoalRef) : SearchM Q RuleResult := do
  let provedByNorm ←
    withAesopTraceNode .steps fmtNorm (normalizeGoalIfNecessary gref)
  aesop_trace[steps] do
    unless provedByNorm do
      let (goal, metaState) ←
        (← gref.get).currentGoalAndMetaState (← getRootMetaState)
      metaState.runMetaM' do
        aesop_trace![steps] "Goal after normalisation:{indentD goal}"
  if provedByNorm then
    return .proved #[]
  let safeResult ←
    withAesopTraceNode .steps fmtSafe (runFirstSafeRule gref)
  match safeResult with
  | .succeeded newRapps => return .succeeded newRapps
  | .proved newRapps => return .proved newRapps
  | .failed postponedSafeRules => doUnsafe postponedSafeRules
  | .skipped => doUnsafe #[]
  where
    doUnsafe (postponedSafeRules : Array PostponedSafeRule) :
        SearchM Q RuleResult := do
      withAesopTraceNode .steps fmtUnsafe do
        runFirstUnsafeRule postponedSafeRules gref

    fmtNorm (result : Except Exception Bool) : SearchM Q MessageData :=
      let emoji :=
        match result with
        | .error _ => ruleErrorEmoji
        | .ok true => ruleProvedEmoji
        | .ok false => ruleSuccessEmoji
      return m!"{emoji} Normalisation"

    fmtSafe (result : Except Exception SafeRulesResult) :
        SearchM Q MessageData :=
      return m!"{exceptRuleResultToEmoji (·.toEmoji) result} Safe rules"

    fmtUnsafe (result : Except Exception RuleResult) : SearchM Q MessageData :=
      return m!"{exceptRuleResultToEmoji (·.toEmoji) result} Unsafe rules"

end Aesop



=== LEAN SOURCE: Main.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Check
import Aesop.Options
import Aesop.RuleSet
import Aesop.Script.Check
import Aesop.Script.Main
import Aesop.Search.Expansion
import Aesop.Search.ExpandSafePrefix
import Aesop.Search.Queue
import Aesop.Tree
import Aesop.Frontend.Extension

open Lean
open Lean.Elab.Tactic (liftMetaTacticAux TacticM)
open Lean.Parser.Tactic (tacticSeq)
open Lean.Meta

namespace Aesop

variable [Aesop.Queue Q]

partial def nextActiveGoal : SearchM Q GoalRef := do
  let some gref ← popGoal?
    | throwError "aesop/expandNextGoal: internal error: no active goals left"
  if ! (← (← gref.get).isActive) then
    nextActiveGoal
  else
    return gref

def expandNextGoal : SearchM Q Unit := do
  let gref ← nextActiveGoal
  let g ← gref.get
  let (initialGoal, initialMetaState) ←
    g.currentGoalAndMetaState (← getRootMetaState)
  let result ← withAesopTraceNode .steps
    (fmt g.id g.priority initialGoal initialMetaState) do
    initialMetaState.runMetaM' do
      aesop_trace[steps] "Initial goal:{indentD initialGoal}"
    let maxRappDepth := (← read).options.maxRuleApplicationDepth
    if maxRappDepth != 0 && (← gref.get).depth >= maxRappDepth then
      aesop_trace[steps] "Treating the goal as unprovable since it is beyond the maximum rule application depth ({maxRappDepth})."
      gref.markForcedUnprovable
      setMaxRuleApplicationDepthReached
      return .failed
    let result ← expandGoal gref
    let currentIteration ← getIteration
    gref.modify λ g => g.setLastExpandedInIteration currentIteration
    if ← (← gref.get).isActive then
      enqueueGoals #[gref]
    return result
  match result with
  | .proved newRapps | .succeeded newRapps => traceNewRapps newRapps
  | .failed => return
  where
    fmt (id : GoalId) (priority : Percent) (initialGoal : MVarId)
        (initialMetaState : Meta.SavedState)
        (result : Except Exception RuleResult) : SearchM Q MessageData := do
      let tgt ← initialMetaState.runMetaM' do
        initialGoal.withContext do
          addMessageContext $ toMessageData (← initialGoal.getType)
      return m!"{exceptRuleResultToEmoji (·.toEmoji) result} (G{id}) [{priority.toHumanString}] ⋯ ⊢ {tgt}"

    traceNewRapps (newRapps : Array RappRef) : SearchM Q Unit := do
      aesop_trace[steps] do
        for rref in newRapps do
          let r ← rref.get
          r.withHeadlineTraceNode .steps
            (transform := λ msg => return m!"{newNodeEmoji} " ++ msg) do
            withAesopTraceNode .steps (λ _ => return "Metadata") do
              r.traceMetadata .steps
          r.metaState.runMetaM' do
            r.forSubgoalsM λ gref => do
              let g ← gref.get
              g.withHeadlineTraceNode .steps
                (transform := λ msg => return m!"{newNodeEmoji} " ++ msg) do
                aesop_trace![steps] g.preNormGoal
                withAesopTraceNode .steps (λ _ => return "Metadata") do
                  g.traceMetadata .steps

def checkGoalLimit : SearchM Q (Option MessageData) := do
  let maxGoals := (← read).options.maxGoals
  let currentGoals := (← getTree).numGoals
  if maxGoals != 0 && currentGoals >= maxGoals then
    return m!"maximum number of goals ({maxGoals}) reached. Set the 'maxGoals' option to increase the limit."
  return none

def checkRappLimit : SearchM Q (Option MessageData) := do
  let maxRapps := (← read).options.maxRuleApplications
  let currentRapps := (← getTree).numRapps
  if maxRapps != 0 && currentRapps >= maxRapps then
    return m!"maximum number of rule applications ({maxRapps}) reached. Set the 'maxRuleApplications' option to increase the limit."
  return none

def checkRootUnprovable : SearchM Q (Option MessageData) := do
  let root := (← getTree).root
  if (← root.get).state.isUnprovable then
    let msg ←
      if ← wasMaxRuleApplicationDepthReached then
        pure m!"failed to prove the goal. Some goals were not explored because the maximum rule application depth ({(← read).options.maxRuleApplicationDepth}) was reached. Set option 'maxRuleApplicationDepth' to increase the limit."
      else
        pure m!"failed to prove the goal after exhaustive search."
    return msg
  return none

def getProof? : SearchM Q (Option Expr) := do
  getExprMVarAssignment? (← getRootMVarId)

def finalizeProof : SearchM Q Unit := do
  (← getRootMVarId).withContext do
    extractProof
    let (some proof) ← getProof? | throwError
      "aesop: internal error: root goal is proven but its metavariable is not assigned"
    if (← instantiateMVars proof).hasExprMVar then
      let inner :=
        m!"Proof: {proof}\nUnassigned metavariables: {(← getMVarsNoDelayed proof).map (·.name)}"
      throwError "aesop: internal error: extracted proof has metavariables.{indentD inner}"
    withPPAnalyze do
      aesop_trace[proof] "Final proof:{indentExpr proof}"

def traceScript (completeProof : Bool) : SearchM Q Unit :=
  profiling (λ stats _ elapsed => { stats with script := elapsed }) do
  let options := (← read).options
  if ! options.generateScript then
    return
  let (uscript, proofHasMVars) ←
    if completeProof then extractScript else extractSafePrefixScript
  uscript.checkIfEnabled
  let rootGoal ← getRootMVarId
  let rootState ← getRootMetaState
  aesop_trace[script] "Unstructured script:{indentD $ toMessageData $ ← uscript.renderTacticSeq rootState rootGoal}"
  let sscript? ← uscript.optimize proofHasMVars rootState rootGoal
  checkAndTraceScript uscript sscript? rootState rootGoal options
    (expectCompleteProof := completeProof) "aesop"

def traceTree : SearchM Q Unit := do
  (← (← getRootGoal).get).traceTree .tree

def finishIfProven : SearchM Q Bool := do
  unless (← (← getRootMVarCluster).get).state.isProven do
    return false
  finalizeProof
  traceScript (completeProof := true)
  traceTree
  return true

-- TODO move to Tree directory
/--
This function detects whether the search has made progress, meaning that the
remaining goals after safe prefix expansion are different from the initial goal.
We approximate this by checking whether, after safe prefix expansion, either
of the following statements is true.

- There is a safe rapp.
- A subgoal of the preprocessing rule has been modified during normalisation.

This is an approximation because a safe rule could, in principle, leave the
initial goal unchanged.
-/
def treeHasProgress : TreeM Bool := do
  let resultRef ← IO.mkRef false
  preTraverseDown
    (λ gref => do
      let g ← gref.get
      if let some postGoal := g.normalizationState.normalizedGoal? then
        if postGoal != g.preNormGoal then
          resultRef.set true
          return false
      return true)
    (λ rref => do
      let rule := (← rref.get).appliedRule
      if rule.name == preprocessRule.name then
        return true
      else if rule.isUnsafe then
        return false
      else
        resultRef.set true
        return false)
    (λ _ => return true)
    (.mvarCluster (← getThe Tree).root)
  resultRef.get

def throwAesopEx (mvarId : MVarId) (remainingSafeGoals : Array MVarId)
    (safePrefixExpansionSuccess : Bool) (msg? : Option MessageData) :
    SearchM Q α := do
  if aesop.smallErrorMessages.get (← getOptions) then
    match msg? with
    | none => throwError "tactic 'aesop' failed"
    | some msg => throwError "tactic 'aesop' failed, {msg}"
  else
    let maxRapps := (← read).options.maxSafePrefixRuleApplications
    let suffix :=
      if remainingSafeGoals.isEmpty then
        m!""
      else
        let gs := .joinSep (remainingSafeGoals.toList.map toMessageData) "\n\n"
        let suffix' :=
          if safePrefixExpansionSuccess then
            m!""
          else
            m!"\nThe safe prefix was not fully expanded because the maximum number of rule applications ({maxRapps}) was reached."
        m!"\nRemaining goals after safe rules:{indentD gs}{suffix'}"
    -- Copy-pasta from `Lean.Meta.throwTacticEx`
    match msg? with
    | none => throwError "tactic 'aesop' failed\nInitial goal:{indentD mvarId}{suffix}"
    | some msg => throwError "tactic 'aesop' failed, {msg}\nInitial goal:{indentD mvarId}{suffix}"


-- When we hit a non-fatal error (i.e. the search terminates without a proof
-- because the root goal is unprovable or because we hit a search limit), we
-- usually:
--
-- - Expand all safe rules as much as possible, starting from the root node,
--   until we hit an unsafe rule. We call this the safe prefix.
-- - Extract the proof term for the safe prefix and report the remaining goals.
--
-- The first step is necessary because a goal can become unprovable due to a
-- sibling being unprovable, without the goal ever being expanded. So if we did
-- not expand the safe rules after the fact, the tactic's output would be
-- sensitive to minor changes in, e.g., rule priority.
def handleNonfatalError (err : MessageData) : SearchM Q (Array MVarId) := do
  let safeExpansionSuccess ← expandSafePrefix
  let safeGoals ← extractSafePrefix
  aesop_trace[proof] do
    match ← getProof? with
    | some proof =>
      (← getRootMVarId).withContext do
        aesop_trace![proof] "{proof}"
    | none => aesop_trace![proof] "<no proof>"
  traceTree
  traceScript (completeProof := false)
  let opts := (← read).options
  if opts.terminal then
    throwAesopEx (← getRootMVarId) safeGoals safeExpansionSuccess err
  if ! (← treeHasProgress) then
    throwAesopEx (← getRootMVarId) #[] safeExpansionSuccess "made no progress"
  if opts.warnOnNonterminal then
    logWarning m!"aesop: {err}"
  if ! safeExpansionSuccess then
    logWarning m!"aesop: safe prefix was not fully expanded because the maximum number of rule applications ({(← read).options.maxSafePrefixRuleApplications}) was reached."
  safeGoals.mapM (clearForwardImplDetailHyps ·)

partial def searchLoop : SearchM Q (Array MVarId) :=
  withIncRecDepth do
    checkSystem "aesop"
    if let (some err) ← checkRootUnprovable then
      handleNonfatalError err
    else if ← finishIfProven then
      return #[]
    else if let (some err) ← checkGoalLimit then
      handleNonfatalError err
    else if let (some err) ← checkRappLimit then
      handleNonfatalError err
    else
      expandNextGoal
      checkInvariantsIfEnabled
      incrementIteration
      searchLoop

def search (goal : MVarId) (ruleSet? : Option LocalRuleSet := none)
     (options : Aesop.Options := {}) (simpConfig : Simp.Config := {})
     (simpConfigSyntax? : Option Term := none) (stats : Stats := {}) :
     MetaM (Array MVarId × Stats) := do
  goal.checkNotAssigned `aesop
  let options ← options.toOptions'
  let ruleSet ←
    match ruleSet? with
    | none =>
        let rss ← Frontend.getDefaultGlobalRuleSets
        mkLocalRuleSet rss options
    | some ruleSet => pure ruleSet
  let ⟨Q, _⟩ := options.queue
  let go : SearchM _ _ := do
    show SearchM Q _ from
    try searchLoop
    finally freeTree
  let ((goals, _, _), stats) ←
    go.run ruleSet options simpConfig simpConfigSyntax? goal |>.run stats
  return (goals, stats)

end Aesop



=== LEAN SOURCE: Queue.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Options
import Aesop.Tracing
import Aesop.Tree
import Aesop.Search.Queue.Class
import Batteries.Data.BinomialHeap.Basic

open Lean
open Batteries (BinomialHeap)

namespace Aesop.BestFirstQueue

structure ActiveGoal where
  goal : GoalRef
  priority : Percent
  lastExpandedInIteration : Iteration
    -- Iteration of the search loop when this goal was last expanded (counting
    -- from 1), or 0 if the goal was never expanded.
  addedInIteration : Iteration
    -- Iteration of the search loop when this goal was added. 0 for the root
    -- goal.

namespace ActiveGoal

-- We prioritise active goals lexicographically by the following criteria:
--
--  1. Goals with higher priority have priority.
--  2. Goals which were last expanded in an earlier iteration have priority.
--  3. Goals which were added in an earlier iteration have priority.
--
-- The last two criteria ensure a very weak form of fairness: if a search
-- produces infinitely many goals with the same success probability, each of
-- them will be expanded infinitely often.
--
-- Note that since we use a min-queue, `le x y` means `x` has priority over `y`.
protected def le (g h : ActiveGoal) : Bool :=
  g.priority > h.priority ||
    (g.priority == h.priority &&
      (g.lastExpandedInIteration ≤ h.lastExpandedInIteration ||
        (g.lastExpandedInIteration == h.lastExpandedInIteration &&
          g.addedInIteration ≤ h.addedInIteration)))

protected def ofGoalRef (gref : GoalRef) : BaseIO ActiveGoal := do
  let g ← gref.get
  return {
    goal := gref
    priority := g.priority
    lastExpandedInIteration := g.lastExpandedInIteration
    addedInIteration := g.addedInIteration
  }

end BestFirstQueue.ActiveGoal

def BestFirstQueue :=
  BinomialHeap BestFirstQueue.ActiveGoal BestFirstQueue.ActiveGoal.le

namespace BestFirstQueue

protected def init : BestFirstQueue :=
  BinomialHeap.empty

protected def addGoals (q : BestFirstQueue) (grefs : Array GoalRef) :
    BaseIO BestFirstQueue :=
  grefs.foldlM (init := q) λ q gref =>
    return q.insert (← ActiveGoal.ofGoalRef gref)

protected def popGoal (q : BestFirstQueue) : Option GoalRef × BestFirstQueue :=
  match q.deleteMin with
  | none => (none, q)
  | some (ag, q) => (some ag.goal, q)

end BestFirstQueue

instance : Queue BestFirstQueue where
  init := return BestFirstQueue.init
  addGoals := BestFirstQueue.addGoals
  popGoal q := return BestFirstQueue.popGoal q


structure LIFOQueue where
  goals : Array GoalRef

namespace LIFOQueue

protected def init : LIFOQueue :=
  ⟨#[]⟩

protected def addGoals (q : LIFOQueue) (grefs : Array GoalRef) : LIFOQueue :=
  ⟨q.goals ++ grefs.reverse⟩

protected def popGoal (q : LIFOQueue) : Option GoalRef × LIFOQueue :=
  match q.goals.back? with
  | some g => (some g, ⟨q.goals.pop⟩)
  | none => (none, q)

instance : Queue LIFOQueue where
  init := return .init
  addGoals q grefs := return q.addGoals grefs
  popGoal q := return q.popGoal

end LIFOQueue


structure FIFOQueue where
  goals : Array GoalRef
  pos : Nat

namespace FIFOQueue

protected def init : FIFOQueue :=
  ⟨#[], 0⟩

protected def addGoals (q : FIFOQueue) (grefs : Array GoalRef) : FIFOQueue :=
  { q with goals := q.goals ++ grefs }

protected def popGoal (q : FIFOQueue) : Option GoalRef × FIFOQueue :=
  if h : q.pos < q.goals.size then
    (some q.goals[q.pos], { q with pos := q.pos + 1 })
  else
    (none, q)

instance : Queue FIFOQueue where
  init := return .init
  addGoals q grefs := return q.addGoals grefs
  popGoal q := return q.popGoal

end FIFOQueue

def Options.queue (opts : Aesop.Options) : Σ Q, Queue Q :=
  match opts.strategy with
  | .bestFirst => ⟨BestFirstQueue, inferInstance⟩
  | .depthFirst => ⟨LIFOQueue, inferInstance⟩
  | .breadthFirst => ⟨FIFOQueue, inferInstance⟩

end Aesop



=== LEAN SOURCE: RuleSelection.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/
import Aesop.Tree.RunMetaM
import Aesop.Search.SearchM

open Lean

namespace Aesop

variable [Aesop.Queue Q]

def selectNormRules (rs : LocalRuleSet) (fms : ForwardRuleMatches)
    (goal : MVarId) : BaseM (Array (IndexMatchResult NormRule)) :=
  profilingRuleSelection do rs.applicableNormalizationRules fms goal

def preprocessRule : SafeRule where
  name := {
    name := `Aesop.BuiltinRule.preprocess
    builder := .tactic
    phase := .safe
    scope := .global
  }
  indexingMode := .unindexed
  pattern? := none
  extra := { penalty := 0, safety := .safe }
  tac := .preprocess

def selectSafeRules (g : Goal) :
    SearchM Q (Array (IndexMatchResult SafeRule)) := do
  profilingRuleSelection do
    if ← g.isRoot then
      return #[{
        rule := preprocessRule
        locations := ∅
        patternSubsts? := none
      }]
    let ruleSet := (← read).ruleSet
    g.runMetaMInPostNormState' λ postNormGoal =>
      ruleSet.applicableSafeRules g.forwardRuleMatches postNormGoal

def selectUnsafeRules (postponedSafeRules : Array PostponedSafeRule)
    (gref : GoalRef) : SearchM Q UnsafeQueue := do
  profilingRuleSelection do
    let g ← gref.get
    match g.unsafeQueue? with
    | some rules => return rules
    | none => do
      let ruleSet := (← read).ruleSet
      let unsafeRules ←
        g.runMetaMInPostNormState' λ postNormGoal =>
          ruleSet.applicableUnsafeRules g.forwardRuleMatches postNormGoal
      let unsafeQueue := UnsafeQueue.initial postponedSafeRules unsafeRules
      gref.set $ g.setUnsafeRulesSelected true |>.setUnsafeQueue unsafeQueue
      return unsafeQueue

end Aesop



=== LEAN SOURCE: SearchM.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Options
import Aesop.Search.Queue.Class
import Aesop.Stats.Basic
import Aesop.RuleSet
import Aesop.Tree.TreeM

open Lean
open Lean.Meta

namespace Aesop

structure NormSimpContext where
  toContext : Simp.Context
  enabled : Bool
  useHyps : Bool
  configStx? : Option Term
  simprocs : Simp.SimprocsArray
  deriving Inhabited

namespace SearchM

structure Context where
  ruleSet : LocalRuleSet
  normSimpContext : NormSimpContext
  options : Aesop.Options'
  deriving Nonempty

structure State (Q) [Aesop.Queue Q] where
  iteration : Iteration
  queue : Q
  maxRuleApplicationDepthReached : Bool
  deriving Inhabited

end SearchM

abbrev SearchM Q [Aesop.Queue Q] :=
  ReaderT SearchM.Context $ StateRefT (SearchM.State Q) $
    StateRefT TreeM.State BaseM

variable [Aesop.Queue Q]

namespace SearchM

-- Generate specialized pure/bind implementations so we don't need to optimise
-- them on the fly at each use site.
instance : Monad (SearchM Q) :=
  { inferInstanceAs (Monad (SearchM Q)) with }

instance : MonadRef (SearchM Q) :=
  { inferInstanceAs (MonadRef (SearchM Q)) with }

instance : Inhabited (SearchM Q α) where
  default := failure

instance : MonadState (State Q) (SearchM Q) :=
  { inferInstanceAs (MonadStateOf (State Q) (SearchM Q)) with }

instance : MonadReader Context (SearchM Q) :=
  { inferInstanceAs (MonadReaderOf Context (SearchM Q)) with }

instance : MonadLift TreeM (SearchM Q) where
  monadLift x := do
    let ctx := {
      currentIteration := (← get).iteration
      ruleSet := (← read).ruleSet
    }
    liftM $ ReaderT.run x ctx

protected def run' (ctx : SearchM.Context) (σ : SearchM.State Q) (tree : Tree)
    (x : SearchM Q α) : BaseM (α × SearchM.State Q × Tree) := do
  let ((a, σ), t) ←
    x.run ctx |>.run σ |>.run { tree }
  return (a, σ, t.tree)

protected def run (ruleSet : LocalRuleSet) (options : Aesop.Options')
    (simpConfig : Simp.Config) (simpConfigStx? : Option Term)
    (goal : MVarId) (x : SearchM Q α) : BaseM (α × State Q × Tree) := do
  let t ← mkInitialTree goal ruleSet
  let normSimpContext := {
    toContext := ← Simp.mkContext simpConfig (simpTheorems := ruleSet.simpTheoremsArray.map (·.snd))
      (congrTheorems := ← getSimpCongrTheorems)
    simprocs := ruleSet.simprocsArray.map (·.snd)
    configStx? := simpConfigStx?
    enabled := options.enableSimp
    useHyps := options.useSimpAll
  }
  let ctx := { ruleSet, options, normSimpContext }
  let #[rootGoal] := (← t.root.get).goals
    | throwError "aesop: internal error: root mvar cluster does not contain exactly one goal."
  let state := {
    queue := ← Queue.init' #[rootGoal]
    iteration := Iteration.one
    maxRuleApplicationDepthReached := false
  }
  x.run' ctx state t

end SearchM

def getTree : SearchM Q Tree :=
  getThe Tree

def setTree : Tree → SearchM Q Unit :=
  setThe Tree

def modifyTree : (Tree → Tree) → SearchM Q Unit :=
  modifyThe Tree

def getIteration : SearchM Q Iteration :=
  return (← get).iteration

def incrementIteration : SearchM Q Unit :=
  modify λ s => { s with iteration := s.iteration.succ }

def popGoal? : SearchM Q (Option GoalRef) := do
  let s ← get
  let (goal?, queue) ← Queue.popGoal s.queue
  set { s with queue }
  return goal?

def enqueueGoals (gs : Array GoalRef) : SearchM Q Unit := do
  let s ← get
  let queue ← Queue.addGoals s.queue gs
  set { s with queue }

def setMaxRuleApplicationDepthReached : SearchM Q Unit :=
  modify λ s => { s with maxRuleApplicationDepthReached := true }

def wasMaxRuleApplicationDepthReached : SearchM Q Bool :=
  return (← get).maxRuleApplicationDepthReached

end Aesop



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.RuleTac.Basic

open Lean
open Lean.Meta

namespace Aesop

def runRuleTac (tac : RuleTac) (ruleName : RuleName)
    (preState : Meta.SavedState) (input : RuleTacInput) :
    BaseM (Except Exception RuleTacOutput) := do
  let result ←
    tryCatchRuntimeEx
      (Except.ok <$> runInMetaState preState do
        withAtMostMaxHeartbeats input.options.maxRuleHeartbeats do
          tac input)
      (λ e => return .error e)
  if ← Check.rules.isEnabled then
    if let .ok ruleOutput := result then
      ruleOutput.applications.forM λ rapp => do
        if let (some err) ← rapp.check input then
          throwError "{Check.rules.name}: while applying rule {ruleName}: {err}"
  return result

end Aesop



=== LEAN SOURCE: Norm.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Forward.State.ApplyGoalDiff
import Aesop.RuleTac
import Aesop.RuleTac.ElabRuleTerm
import Aesop.Script.SpecificTactics
import Aesop.Search.Expansion.Basic
import Aesop.Search.Expansion.Simp
import Aesop.Search.RuleSelection
import Aesop.Search.SearchM
import Aesop.Tree.State
import Batteries.Lean.HashSet

open Lean Lean.Meta Aesop.Script

namespace Aesop

namespace NormM

structure Context where
  options : Options'
  ruleSet : LocalRuleSet
  normSimpContext : NormSimpContext

structure State where
  forwardState : ForwardState
  forwardRuleMatches : ForwardRuleMatches
  deriving Inhabited

end NormM

abbrev NormM := ReaderT NormM.Context $ StateRefT NormM.State BaseM

def getForwardState : NormM ForwardState :=
  return (← getThe NormM.State).forwardState

def getResetForwardState : NormM ForwardState := do
  modifyGetThe NormM.State λ s => (s.forwardState, { s with forwardState := ∅ })

def updateForwardState (fs : ForwardState) (newMatches : Array ForwardRuleMatch)
    (erasedHyps : Std.HashSet FVarId) : NormM Unit :=
  modifyThe NormM.State λ s => { s with
    forwardState := fs
    forwardRuleMatches :=
      s.forwardRuleMatches.update newMatches erasedHyps
        (consumedForwardRuleMatches := #[]) -- We erase the consumed matches separately.
  }

def eraseForwardRuleMatch (m : ForwardRuleMatch) : NormM Unit := do
  modifyThe NormM.State λ s => { s with forwardRuleMatches := s.forwardRuleMatches.erase m }

def applyDiffToForwardState (diff : GoalDiff) : NormM Unit := do
  let fs ← getResetForwardState
  let (fs, ms) ← fs.applyGoalDiff (← read).ruleSet diff
  updateForwardState fs ms diff.removedFVars

inductive NormRuleResult
  | succeeded (goal : MVarId) (steps? : Option (Array Script.LazyStep))
  | proved (steps? : Option (Array Script.LazyStep))

namespace NormRuleResult

def newGoal? : NormRuleResult → Option MVarId
  | succeeded goal .. => goal
  | proved .. => none

def steps? : NormRuleResult → Option (Array Script.LazyStep)
  | .succeeded (steps? := steps?) .. | .proved (steps? := steps?) .. => steps?

end NormRuleResult

def optNormRuleResultEmoji : Option NormRuleResult → String
  | some (.succeeded ..) => ruleSuccessEmoji
  | some (.proved ..) => ruleProvedEmoji
  | none => ruleFailureEmoji

@[inline, always_inline]
def withNormTraceNode (ruleName : DisplayRuleName)
    (k : NormM (Option NormRuleResult)) : NormM (Option NormRuleResult) :=
  withAesopTraceNode .steps fmt do
    let result? ← k
    if let some newGoal := result?.bind (·.newGoal?) then
      aesop_trace[steps] newGoal
    return result?
  where
    fmt (r : Except Exception (Option NormRuleResult)) : NormM MessageData := do
      let emoji := exceptRuleResultToEmoji (optNormRuleResultEmoji ·) r
      return m!"{emoji} {ruleName}"

/-- On success, returns the rule tactic's result, the new forward state and the
new forward rule matches. If `rule` corresponds to some forward rule matches,
returns the matches as well. -/
def runNormRuleTac (rule : NormRule) (input : RuleTacInput) (fs : ForwardState)
    (rs : LocalRuleSet) :
    NormM $
      Option (NormRuleResult × ForwardState × Array ForwardRuleMatch × Std.HashSet FVarId) ×
      Array ForwardRuleMatch := do
  let preMetaState ← show MetaM _ from saveState
  let result? ← runRuleTac rule.tac.run rule.name preMetaState input
  let forwardRuleMatches := rule.tac.forwardRuleMatches? |>.getD #[]
  match result? with
  | .error e =>
    aesop_trace[steps] e.toMessageData
    return (none, forwardRuleMatches)
  | .ok result =>
    let #[rapp] := result.applications
      | err m!"rule did not produce exactly one rule application."
    show MetaM _ from restoreState rapp.postState
    if rapp.goals.isEmpty then
      return (some (.proved rapp.scriptSteps?, fs, #[], ∅), forwardRuleMatches)
    let (#[{ diff }]) := rapp.goals
      | err m!"rule produced more than one subgoal."
    let (fs, ms) ← fs.applyGoalDiff rs diff
    let g := diff.newGoal
    if ← Check.rules.isEnabled then
      let mvars := .ofArray input.mvars.toArray
      let actualMVars ← rapp.postState.runMetaM' g.getMVarDependencies
      if ! actualMVars == mvars then
         err "the goal produced by the rule depends on different metavariables than the original goal."
    let result := .succeeded g rapp.scriptSteps?
    return (some (result, fs, ms, diff.removedFVars), forwardRuleMatches)
  where
    err {α} (msg : MessageData) : MetaM α := throwError
      "aesop: error while running norm rule {rule.name}: {msg}\nThe rule was run on this goal:{indentD $ MessageData.ofGoal input.goal}"

def runNormRule (goal : MVarId) (mvars : UnorderedArraySet MVarId)
    (rule : IndexMatchResult NormRule) : NormM (Option NormRuleResult) := do
  profilingRule (.ruleName rule.rule.name) (λ result => result.isSome) do
    let ruleInput := {
      indexMatchLocations := rule.locations
      patternSubsts? := rule.patternSubsts?
      options := (← read).options
      hypTypes := (← get).forwardState.hypTypes
      goal, mvars
    }
    withNormTraceNode (.ruleName rule.rule.name) do
      let fs ← getForwardState
      let (result?, consumedForwardRuleMatches) ←
        runNormRuleTac rule.rule ruleInput fs (← read).ruleSet
      for m in consumedForwardRuleMatches do
        eraseForwardRuleMatch m
      let (some (result, fs, ms, removedFVars)) := result?
        | return none
      updateForwardState fs ms removedFVars
      return result

def runFirstNormRule (goal : MVarId) (mvars : UnorderedArraySet MVarId)
    (rules : Array (IndexMatchResult NormRule)) :
    NormM (Option (DisplayRuleName × NormRuleResult)) := do
  for rule in rules do
    let result? ← runNormRule goal mvars rule
    if let some result := result? then
      return some (rule.rule.name, result)
  return none

def mkNormSimpScriptStep
    (preGoal : MVarId) (postGoal? : Option MVarId)
    (preState postState : Meta.SavedState) (usedTheorems : Simp.UsedSimps) :
    NormM Script.LazyStep := do
  let ctx := (← read).normSimpContext
  let simpBuilder :=
    TacticBuilder.simpAllOrSimpAtStar (simpAll := ctx.useHyps) preGoal
      ctx.configStx? usedTheorems
  let simpOnlyBuilder :=
    TacticBuilder.simpAllOrSimpAtStarOnly (simpAll := ctx.useHyps) preGoal
      ctx.configStx? usedTheorems
  let tacticBuilders :=
    if (← read).options.useDefaultSimpSet then
      #[simpOnlyBuilder, simpBuilder]
    else
      #[simpOnlyBuilder]
  return {
    postGoals := postGoal?.toArray
    tacticBuilders
    tacticBuilders_ne := by simp only [tacticBuilders]; split <;> simp
    preGoal, preState, postState
  }

def normSimpCore (goal : MVarId) (goalMVars : Std.HashSet MVarId) :
    NormM (Option NormRuleResult) := do
  let ctx := (← read).normSimpContext
  goal.withContext do
    let preState ← show MetaM _ from saveState
    let localRules := (← read).ruleSet.localNormSimpRules
    let result ←
      if ctx.useHyps then
        let (ctx, simprocs) ←
          addLocalRules localRules ctx.toContext ctx.simprocs
            (isSimpAll := true)
        Aesop.simpAll goal ctx simprocs
      else
        let (ctx, simprocs) ←
          addLocalRules localRules ctx.toContext ctx.simprocs
            (isSimpAll := false)
        Aesop.simpGoalWithAllHypotheses goal ctx simprocs

    -- It can happen that simp 'solves' the goal but leaves some mvars
    -- unassigned. In this case, we treat the goal as unchanged.
    let result ←
      match result with
      | .solved .. =>
        let anyMVarDropped ← goalMVars.anyM (notM ·.isAssignedOrDelayedAssigned)
        if anyMVarDropped then
          aesop_trace[steps] "Normalisation simp solved the goal but dropped some metavariables. Skipping normalisation simp."
          show MetaM _ from restoreState preState
          pure .unchanged
        else
          pure result
      | .unchanged .. =>
        aesop_trace[steps] "norm simp left the goal unchanged"
        pure result
      | .simplified .. =>
        pure result

    let postState ← show MetaM _ from saveState
    match result with
    | .unchanged => return none
    | .solved usedTheorems => do
      let step ←
        mkNormSimpScriptStep goal none preState postState usedTheorems
      return some $ .proved #[step]
    | .simplified newGoal usedTheorems => do
      let step ←
        mkNormSimpScriptStep goal newGoal preState postState usedTheorems
      applyDiffToForwardState (← diffGoals goal newGoal)
      return some $ .succeeded newGoal #[step]
where
  addLocalRules (localRules : Array LocalNormSimpRule) (ctx : Simp.Context)
      (simprocs : Simp.SimprocsArray) (isSimpAll : Bool) :
      NormM (Simp.Context × Simp.SimprocsArray) :=
    localRules.foldlM (init := (ctx, simprocs)) λ (ctx, simprocs) r =>
      try
        elabRuleTermForSimpMetaM goal r.simpTheorem ctx simprocs isSimpAll
      catch _ =>
        return (ctx, simprocs)

@[inline, always_inline]
def checkSimp (name : String) (mayCloseGoal : Bool) (goal : MVarId)
    (x : NormM (Option NormRuleResult)) : NormM (Option NormRuleResult) := do
  if ! (← Check.rules.isEnabled) then
    x
  else
    let preMetaState ← show MetaM _ from saveState
    let result? ← x
    let newGoal? := result?.bind (·.newGoal?)
    let postMetaState ← show MetaM _ from saveState
    let introduced :=
        (← getIntroducedExprMVars preMetaState postMetaState).filter
        (some · != newGoal?)
    unless introduced.isEmpty do throwError
        "{Check.rules.name}: {name} introduced mvars:{introduced.map (·.name)}"
    let assigned :=
        (← getAssignedExprMVars preMetaState postMetaState).filter (· != goal)
    unless assigned.isEmpty do throwError
        "{Check.rules.name}: {name} assigned mvars:{introduced.map (·.name)}"
    if ← pure (! mayCloseGoal && newGoal?.isNone) <&&> goal.isAssigned then
        throwError "{Check.rules.name}: {name} solved the goal"
    return result?

def normSimp (goal : MVarId) (goalMVars : Std.HashSet MVarId) :
    NormM (Option NormRuleResult) := do
  profilingRule .normSimp (wasSuccessful := λ _ => true) do
    checkSimp "norm simp" (mayCloseGoal := true) goal do
      tryCatchRuntimeEx
        (withNormTraceNode .normSimp do
          withMaxHeartbeats (← read).options.maxSimpHeartbeats do
            normSimpCore goal goalMVars)
        (λ e => throwError "aesop: error in norm simp: {e.toMessageData}")

def normUnfoldCore (goal : MVarId) : NormM (Option NormRuleResult) := do
  let unfoldRules := (← read).ruleSet.unfoldRules
  let (result, steps) ← unfoldManyStarS goal (unfoldRules.find? ·) |>.run
  match result with
  | none =>
    aesop_trace[steps] "nothing to unfold"
    return none
  | some newGoal =>
    applyDiffToForwardState (← diffGoals goal newGoal)
    return some $ .succeeded newGoal steps

def normUnfold (goal : MVarId) : NormM (Option NormRuleResult) := do
  profilingRule .normUnfold (wasSuccessful := λ _ => true) do
    checkSimp "unfold simp" (mayCloseGoal := false) goal do
      tryCatchRuntimeEx
        (withNormTraceNode .normUnfold do
          withMaxHeartbeats (← read).options.maxUnfoldHeartbeats do
            normUnfoldCore goal)
        (λ e => throwError "aesop: error in norm unfold: {e.toMessageData}")

inductive NormSeqResult where
  | proved (script : Array (DisplayRuleName × Option (Array Script.LazyStep)))
  | changed (goal : MVarId)
      (script : Array (DisplayRuleName × Option (Array Script.LazyStep)))
  | unchanged

def NormRuleResult.toNormSeqResult (ruleName : DisplayRuleName) :
    NormRuleResult → NormSeqResult
  | .proved steps? => .proved #[(ruleName, steps?)]
  | .succeeded goal steps? => .changed goal #[(ruleName, steps?)]

def optNormRuleResultToNormSeqResult :
    Option (DisplayRuleName × NormRuleResult) → NormSeqResult
  | some (ruleName, r) => r.toNormSeqResult ruleName
  | none => .unchanged

abbrev NormStep :=
  MVarId → Array (IndexMatchResult NormRule) →
  Array (IndexMatchResult NormRule) → NormM NormSeqResult

def runNormSteps (goal : MVarId) (steps : Array NormStep)
    (stepsNe : 0 < steps.size) : NormM NormSeqResult := do
  let ctx ← readThe NormM.Context
  let maxIterations := ctx.options.maxNormIterations
  let mut iteration := 0
  let mut step : Fin steps.size := ⟨0, stepsNe⟩
  let mut goal := goal
  let mut scriptSteps := #[]
  let mut preSimpRules := ∅
  let mut postSimpRules := ∅
  let mut anySuccess := false
  while iteration < maxIterations do
    if step.val == 0 then
      let rules ←
        selectNormRules ctx.ruleSet (← getThe NormM.State).forwardRuleMatches
          goal
      let (preSimpRules', postSimpRules') :=
        rules.partition λ r => r.rule.extra.penalty < (0 : Int)
      preSimpRules := preSimpRules'
      postSimpRules := postSimpRules'
    match ← steps[step] goal preSimpRules postSimpRules with
    | .changed newGoal scriptSteps' =>
      anySuccess := true
      goal := newGoal
      scriptSteps := scriptSteps ++ scriptSteps'
      iteration := iteration + 1
      step := ⟨0, stepsNe⟩
    | .proved scriptSteps' =>
      scriptSteps := scriptSteps ++ scriptSteps'
      return .proved scriptSteps
    | .unchanged =>
      if h : step.val + 1 < steps.size then
        step := ⟨step.val + 1, h⟩
      else
        if anySuccess then
          return .changed goal scriptSteps
        else
          return .unchanged
  throwError "aesop: exceeded maximum number of normalisation iterations ({maxIterations}). This means normalisation probably got stuck in an infinite loop."

namespace NormStep

def runPreSimpRules (mvars : UnorderedArraySet MVarId) : NormStep
  | goal, preSimpRules, _ => do
    optNormRuleResultToNormSeqResult <$>
      runFirstNormRule goal mvars preSimpRules

def runPostSimpRules (mvars : UnorderedArraySet MVarId) : NormStep
  | goal, _, postSimpRules =>
    optNormRuleResultToNormSeqResult <$>
      runFirstNormRule goal mvars postSimpRules

def unfold : NormStep
  | goal, _, _ => do
    if ! (← readThe NormM.Context).options.enableUnfold then
      aesop_trace[steps] "norm unfold is disabled (options := \{ ..., enableUnfold := false })"
      return .unchanged
    let r := (← normUnfold goal).map (.normUnfold, ·)
    return optNormRuleResultToNormSeqResult r

def simp (mvars : Std.HashSet MVarId) : NormStep
  | goal, _, _ => do
    if ! (← readThe NormM.Context).normSimpContext.enabled then
      aesop_trace[steps] "norm simp is disabled (simp_options := \{ ..., enabled := false })"
      return .unchanged
    let r := (← normSimp goal mvars).map (.normSimp, ·)
    return optNormRuleResultToNormSeqResult r

end NormStep

partial def normalizeGoalMVar (goal : MVarId)
    (mvars : UnorderedArraySet MVarId) : NormM NormSeqResult := do
  let mvarsHashSet := .ofArray mvars.toArray
  let mut normSteps := #[
    NormStep.runPreSimpRules mvars,
    NormStep.unfold,
    NormStep.simp mvarsHashSet,
    NormStep.runPostSimpRules mvars
  ]
  runNormSteps goal normSteps
    (by simp (config := { decide := true }) [normSteps])

-- Returns true if the goal was solved by normalisation.
def normalizeGoalIfNecessary (gref : GoalRef) [Aesop.Queue Q] :
    SearchM Q Bool := do
  let g ← gref.get
  let preGoal := g.preNormGoal
  if ← g.isRoot then
    -- For the root goal, we skip normalization.
    let rootState ← getRootMetaState
    gref.modify (·.setNormalizationState (.normal preGoal rootState #[]))
    return false
  match g.normalizationState with
  | .provenByNormalization .. => return true
  | .normal .. => return false
  | .notNormal => pure ()
  let normCtx := { (← read) with }
  let normState := {
    forwardState := g.forwardState
    forwardRuleMatches := g.forwardRuleMatches
  }
  let ((normResult, { forwardState, forwardRuleMatches }), postState) ←
    g.runMetaMInParentState do
      normalizeGoalMVar preGoal g.mvars |>.run normCtx |>.run normState
  match normResult with
  | .changed postGoal script? =>
    gref.modify λ g =>
      g.setNormalizationState (.normal postGoal postState script?)
        |>.setForwardState forwardState
        |>.setForwardRuleMatches forwardRuleMatches
    return false
  | .unchanged =>
    gref.modify (·.setNormalizationState (.normal preGoal postState #[]))
    return false
  | .proved script? =>
    gref.modify
      (·.setNormalizationState (.provenByNormalization postState script?))
    gref.markProvenByNormalization
    return true

end Aesop



=== LEAN SOURCE: Simp.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/
import Lean.Meta.Tactic.Simp.SimpAll

open Lean Lean.Meta
open Simp (UsedSimps)

namespace Aesop

inductive SimpResult
  | solved (usedTheorems : Simp.UsedSimps)
  | unchanged
  | simplified (newGoal : MVarId) (usedTheorems : UsedSimps)

namespace SimpResult

def newGoal? : SimpResult → Option MVarId
  | solved .. => none
  | unchanged => none
  | simplified g .. => some g

end SimpResult

/--
Add all `let` hypotheses in the local context as `simp` theorems.

Background: by default, in the goal `x : _ := v ⊢ P[x]`, `simp` does not
substitute `x` by `v` in the target. The `simp` option `zetaDelta` can be used
to make `simp` perform this substitution, but we don't want to set it because
then Aesop `simp` would diverge from default `simp`, so we would have to adjust
the `aesop?` output as well. Instead, we add `let` hypotheses explicitly. This
way, `simp?` picks them up as well.

See lean4#3520.
-/
def addLetDeclsToSimpTheorems (ctx : Simp.Context) : MetaM Simp.Context := do
  let mut simpTheoremsArray := ctx.simpTheorems
  if simpTheoremsArray.isEmpty then
    simpTheoremsArray := #[{}]
  for ldecl in ← getLCtx do
    if ldecl.hasValue && ! ldecl.isImplementationDetail then
      simpTheoremsArray := simpTheoremsArray.modify 0 λ simpTheorems =>
        simpTheorems.addLetDeclToUnfold ldecl.fvarId
  return ctx.setSimpTheorems simpTheoremsArray

def addLetDeclsToSimpTheoremsUnlessZetaDelta (ctx : Simp.Context) :
    MetaM Simp.Context := do
  if ctx.config.zetaDelta then
    return ctx
  else
    addLetDeclsToSimpTheorems ctx

def simpGoal (mvarId : MVarId) (ctx : Simp.Context)
    (simprocs : Simp.SimprocsArray) (discharge? : Option Simp.Discharge := none)
    (simplifyTarget : Bool := true) (fvarIdsToSimp : Array FVarId := #[])
    (stats : Simp.Stats := {}) : MetaM SimpResult := do
  let mvarIdOld := mvarId
  let ctx := ctx.setFailIfUnchanged false
  let (result, { usedTheorems := usedSimps, .. }) ←
    Meta.simpGoal mvarId ctx simprocs discharge? simplifyTarget fvarIdsToSimp
      stats
  if let some (_, mvarId) := result then
    if mvarId == mvarIdOld then
      return .unchanged
    else
      return .simplified mvarId usedSimps
  else
    return .solved usedSimps

def simpGoalWithAllHypotheses (mvarId : MVarId) (ctx : Simp.Context)
    (simprocs : Simp.SimprocsArray) (discharge? : Option Simp.Discharge := none)
    (simplifyTarget : Bool := true) (stats : Simp.Stats := {}) :
    MetaM SimpResult :=
  mvarId.withContext do
    let lctx ← getLCtx
    let mut fvarIdsToSimp := Array.mkEmpty lctx.decls.size
    for ldecl in lctx do
      if ldecl.isImplementationDetail then
        continue
      fvarIdsToSimp := fvarIdsToSimp.push ldecl.fvarId
    let ctx ← addLetDeclsToSimpTheoremsUnlessZetaDelta ctx
    Aesop.simpGoal mvarId ctx simprocs discharge? simplifyTarget fvarIdsToSimp
      stats

def simpAll (mvarId : MVarId) (ctx : Simp.Context)
    (simprocs : Simp.SimprocsArray) (stats : Simp.Stats := {}) :
    MetaM SimpResult :=
  mvarId.withContext do
    let ctx := ctx.setFailIfUnchanged false
    let ctx ← addLetDeclsToSimpTheoremsUnlessZetaDelta ctx
    match ← Lean.Meta.simpAll mvarId ctx simprocs stats with
    | (none, stats) => return .solved stats.usedTheorems
    | (some mvarIdNew, stats) =>
      if mvarIdNew == mvarId then
        return .unchanged
      else
        return .simplified mvarIdNew stats.usedTheorems

end Aesop



=== LEAN SOURCE: Class.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Tree.Data

open Lean

namespace Aesop

class Queue (Q : Type) where
  init : BaseIO Q
  addGoals : Q → Array GoalRef → BaseIO Q
  popGoal : Q → BaseIO (Option GoalRef × Q)

namespace Queue

def init' [Queue Q] (grefs : Array GoalRef) : BaseIO Q := do
  addGoals (← init) grefs

end Aesop.Queue



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2022-2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Nanos
import Aesop.Rule.Name
import Aesop.Tracing

open Lean

namespace Aesop

initialize collectStatsOption : Lean.Option Bool ←
  Lean.Option.register `aesop.collectStats {
    defValue := false
    group := "aesop"
    descr := "(aesop) collect statistics about Aesop invocations. Use #aesop_stats to display the collected statistics."
  }

-- All times are in nanoseconds.
structure RuleStats where
  rule : DisplayRuleName
  elapsed : Nanos
  successful : Bool
  deriving Inhabited

namespace RuleStats

instance : ToString RuleStats where
  toString rp :=
    let success := if rp.successful then "successful" else "failed"
    s!"[{rp.elapsed.printAsMillis}] apply rule {rp.rule} ({success})"

end RuleStats


inductive ScriptGenerated
  | none
  | staticallyStructured (perfect : Bool) (hasMVar : Bool)
  | dynamicallyStructured (perfect : Bool) (hasMVar : Bool)
  deriving Inhabited

namespace ScriptGenerated

protected def toString : ScriptGenerated → String
  | none => "no"
  | staticallyStructured perfect _ => s!"with {go perfect} static structuring"
  | dynamicallyStructured perfect _ => s!"with {go perfect} dynamic structuring"
where
  go b := if b then "perfect" else "imperfect"

def isNontrivial : ScriptGenerated → Bool
  | none => false
  | staticallyStructured  (hasMVar := hasMVar) ..
  | dynamicallyStructured (hasMVar := hasMVar) .. => hasMVar

end ScriptGenerated

structure Stats where
  total : Nanos
  configParsing : Nanos
  ruleSetConstruction : Nanos
  search : Nanos
  ruleSelection : Nanos
  script : Nanos
  scriptGenerated : ScriptGenerated
  ruleStats : Array RuleStats
  deriving Inhabited

namespace Stats

protected def empty : Stats where
  total := 0
  configParsing := 0
  ruleSetConstruction := 0
  search := 0
  ruleSelection := 0
  script := 0
  scriptGenerated := .none
  ruleStats := #[]

instance : EmptyCollection Stats :=
  ⟨Stats.empty⟩

end Stats


structure RuleStatsTotals where
  /--
  Number of successful applications of a rule.
  -/
  numSuccessful : Nat
  /--
  Number of failed applications of a rule.
  -/
  numFailed : Nat
  /--
  Total elapsed time of successful applications of a rule.
  -/
  elapsedSuccessful : Nanos
  /--
  Total elapsed time of failed applications of a rule.
  -/
  elapsedFailed : Nanos

namespace RuleStatsTotals

protected def empty : RuleStatsTotals where
  numSuccessful := 0
  numFailed := 0
  elapsedSuccessful := 0
  elapsedFailed := 0

instance : EmptyCollection RuleStatsTotals :=
  ⟨.empty⟩

def compareByTotalElapsed : (x y : RuleStatsTotals) → Ordering :=
  compareOn λ totals => totals.elapsedSuccessful + totals.elapsedFailed

end RuleStatsTotals


namespace Stats

def ruleStatsTotals (p : Stats)
    (init : Std.HashMap DisplayRuleName RuleStatsTotals := ∅) :
    Std.HashMap DisplayRuleName RuleStatsTotals :=
  p.ruleStats.foldl (init := init) λ m rp => Id.run do
    let mut stats := m.getD rp.rule ∅
    if rp.successful then
      stats := { stats with
        numSuccessful := stats.numSuccessful + 1
        elapsedSuccessful := stats.elapsedSuccessful + rp.elapsed
      }
    else
      stats := { stats with
        numFailed := stats.numFailed + 1
        elapsedFailed := stats.elapsedFailed + rp.elapsed
      }
    m.insert rp.rule stats

def _root_.Aesop.sortRuleStatsTotals
    (ts : Array (DisplayRuleName × RuleStatsTotals)) :
    Array (DisplayRuleName × RuleStatsTotals) :=
  let lt := λ (n₁, t₁) (n₂, t₂) =>
    RuleStatsTotals.compareByTotalElapsed t₁ t₂ |>.swap.then
    (compare n₁ n₂)
    |>.isLT
  ts.qsort lt

def trace (p : Stats) (opt : TraceOption) : CoreM Unit := do
  if ! (← opt.isEnabled) then
    return
  let totalRuleApplications :=
    p.ruleStats.foldl (init := 0) λ total rp =>
      total + rp.elapsed
  aesop_trace![opt] "Total: {p.total.printAsMillis}"
  aesop_trace![opt] "Configuration parsing: {p.configParsing.printAsMillis}"
  aesop_trace![opt] "Rule set construction: {p.ruleSetConstruction.printAsMillis}"
  aesop_trace![opt] "Script generation: {p.script.printAsMillis}"
  aesop_trace![opt] "Script generated: {p.scriptGenerated.toString}"
  withConstAesopTraceNode opt (collapsed := false)
      (return m!"Search: {p.search.printAsMillis}") do
    aesop_trace![opt] "Rule selection: {p.ruleSelection.printAsMillis}"
    withConstAesopTraceNode opt (collapsed := false)
        (return m!"Rule applications: {totalRuleApplications.printAsMillis}") do
      let timings := sortRuleStatsTotals p.ruleStatsTotals.toArray
      for (n, t) in timings do
        aesop_trace![opt] "[{(t.elapsedSuccessful + t.elapsedFailed).printAsMillis} / {t.elapsedSuccessful.printAsMillis} / {t.elapsedFailed.printAsMillis}] {n}"

end Stats


abbrev StatsRef := IO.Ref Stats

class MonadStats (m) extends MonadOptions m where
  modifyGetStats : (Stats → α × Stats) → m α
  getStats : m Stats :=
    modifyGetStats λ s => (s, s)
  modifyStats : (Stats → Stats) → m Unit :=
    λ f => modifyGetStats λ s => ((), f s)

export MonadStats (modifyGetStats getStats modifyStats)

instance [MonadStats m] : MonadStats (StateRefT' ω σ m) where
  modifyGetStats f := (modifyGetStats f : m _)
  getStats := (getStats : m _)
  modifyStats f := (modifyStats f : m _)

instance [MonadStats m] : MonadStats (ReaderT α m) where
  modifyGetStats f := (modifyGetStats f : m _)
  getStats := (getStats : m _)
  modifyStats f := (modifyStats f : m _)

instance [MonadOptions m] [MonadStateOf Stats m] : MonadStats m where
  modifyGetStats f := modifyGetThe Stats f
  getStats := getThe Stats
  modifyStats := modifyThe Stats

variable [Monad m]

@[inline, always_inline]
def isStatsCollectionEnabled [MonadOptions m] : m Bool :=
  collectStatsOption.get <$> getOptions

@[inline, always_inline]
def isStatsTracingEnabled [MonadOptions m] : m Bool :=
  TraceOption.stats.isEnabled

@[inline, always_inline]
def isStatsCollectionOrTracingEnabled [MonadOptions m] : m Bool :=
  isStatsCollectionEnabled <||> isStatsTracingEnabled

variable [MonadStats m] [MonadLiftT BaseIO m]

@[inline, always_inline]
def profiling (recordStats : Stats → α → Nanos → Stats) (x : m α) : m α := do
  if ← isStatsCollectionOrTracingEnabled then
    let (result, elapsed) ← time x
    modifyStats (recordStats · result elapsed)
    return result
  else
    x

@[inline, always_inline]
def profilingRuleSelection : m α → m α :=
  profiling λ stats _ elapsed =>
    { stats with ruleSelection := stats.ruleSelection + elapsed }

@[inline, always_inline]
def profilingRule (rule : DisplayRuleName) (wasSuccessful : α → Bool) :
    m α → m α :=
  profiling λ stats a elapsed =>
    let rp := { successful := wasSuccessful a, rule, elapsed }
    { stats with ruleStats := stats.ruleStats.push rp }

def modifyCurrentStats (f : Stats → Stats) : m Unit := do
  if ← isStatsCollectionEnabled then
    modifyStats f

def recordScriptGenerated (x : ScriptGenerated) : m Unit := do
  modifyCurrentStats ({ · with scriptGenerated := x })

end Aesop



=== LEAN SOURCE: Extension.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Stats.Basic

open Lean

namespace Aesop

structure StatsExtensionEntry where
  /--
  The Aesop call for which stats were collected.
  -/
  aesopStx : Syntax
  /-
  The file in which Aesop was called.
  -/
  fileName : String
  /-
  The position in the file where Aesop was called.
  -/
  position? : Option Position
  /--
  The collected stats.
  -/
  stats : Stats

namespace StatsExtensionEntry

def forCurrentFile [Monad m] [MonadLog m] (stx : Syntax) (stats : Stats) :
    m StatsExtensionEntry := do
  let fileName ← getFileName
  let fileMap ← getFileMap
  let position? := stx.getPos?.map fileMap.toPosition
  return { aesopStx := stx, stats, fileName, position? }

end StatsExtensionEntry

abbrev StatsExtension := SimplePersistentEnvExtension StatsExtensionEntry Unit

def StatsExtension.importedEntries (env : Environment) (ext : StatsExtension) :
    Array (Array StatsExtensionEntry) :=
  ext.toEnvExtension.getState env |>.importedEntries

initialize statsExtension : StatsExtension ←
  registerSimplePersistentEnvExtension {
    addEntryFn := λ _ _ => ()
    addImportedFn := λ _ => ()
    asyncMode := .sync -- Maybe we could use a less restrictive mode, but (a) it's not clear to me and (b) this extension is unused by default.
  }

def recordStatsIfEnabled [Monad m] [MonadEnv m] [MonadOptions m]
    (s : StatsExtensionEntry) : m Unit := do
  if ← isStatsCollectionEnabled then
    modifyEnv λ env => statsExtension.addEntry env s

def recordStatsForCurrentFileIfEnabled [Monad m] [MonadEnv m] [MonadOptions m]
    [MonadLog m] (aesopStx : Syntax) (stats : Stats) : m Unit := do
  if ← isStatsCollectionEnabled then
    let entry ← StatsExtensionEntry.forCurrentFile aesopStx stats
    modifyEnv λ env => statsExtension.addEntry env entry

abbrev StatsArray := Array StatsExtensionEntry

def mkStatsArray (localEntries : List StatsExtensionEntry)
    (importedEntries : Array (Array StatsExtensionEntry)) :
    StatsArray := Id.run do
  let mut result := #[]
  for entry in localEntries do
    result := result.push entry
  for entries in importedEntries do
    result := result ++ entries
  return result

def getStatsArray [Monad m] [MonadEnv m] : m StatsArray := do
  let env ← getEnv
  let current := statsExtension.getEntries env
  let imported := statsExtension.importedEntries env
  return mkStatsArray current imported

end Aesop



=== LEAN SOURCE: Report.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Percent
import Aesop.Stats.Extension

open Lean

namespace Aesop

/-- Assumes that `xs` is ascending. We use a simple nearest-rank definition of
percentiles. -/
def sortedPercentileD (p : Percent) (dflt : α) (xs : Array α) : α :=
  if xs.size == 0 then
    dflt
  else
    let rank := xs.size.toFloat * p.toFloat |>.ceil.toUInt64.toNat |>.min (xs.size - 1)
    xs[rank]?.getD dflt

def sortedMedianD (dflt : α) (xs : Array α) : α :=
  sortedPercentileD ⟨0.5⟩ dflt xs

abbrev StatsReport := StatsArray → Format

namespace StatsReport

local instance : ToString Nanos :=
  ⟨Nanos.printAsMillis⟩

def default : StatsReport := λ statsArray => Id.run do
  let mut total := 0
  let mut configParsing := 0
  let mut ruleSetConstruction := 0
  let mut search := 0
  let mut ruleSelection := 0
  let mut script := 0
  let mut ruleStats : Std.HashMap DisplayRuleName RuleStatsTotals := ∅
  for stats in statsArray do
    let stats := stats.stats
    total := total + stats.total
    configParsing := configParsing + stats.configParsing
    ruleSetConstruction := ruleSetConstruction + stats.ruleSetConstruction
    search := search + stats.search
    ruleSelection := ruleSelection + stats.ruleSelection
    script := script + stats.script
    ruleStats := stats.ruleStatsTotals (init := ruleStats)
  let samples := statsArray.size
  f!"Statistics for {statsArray.size} Aesop calls in current and imported modules\n\
     Displaying totals and [averages]\n\
     Total Aesop time:      {fmtTime total samples}\n\
     Config parsing:        {fmtTime configParsing samples}\n\
     Rule set construction: {fmtTime ruleSetConstruction samples}\n\
     Rule selection:        {fmtTime ruleSelection samples}\n\
     Script generation:     {fmtTime script samples}\n\
     Search:                {fmtTime search samples}\n\
     Rules:{Std.Format.indentD $ fmtRuleStats $ sortRuleStatsTotals $ ruleStats.toArray}"
where
  fmtTime (n : Nanos) (samples : Nat) : Format :=
    f!"{n} [{if samples == 0 then 0 else n / samples}]"

  fmtRuleStats (stats : Array (DisplayRuleName × RuleStatsTotals)) :
      Format := Id.run do
    let fmtSection (n : Nanos) (samples : Nat) : Format :=
      f!"{samples} in {fmtTime n samples}"
    let mut fmt := f!""
    for (name, totals) in stats do
      fmt := fmt ++
        f!"{name}:\n\
          {"  "}total:      {fmtSection (totals.elapsedSuccessful + totals.elapsedFailed) (totals.numSuccessful + totals.numFailed)}\n\
          {"  "}successful: {fmtSection totals.elapsedSuccessful totals.numSuccessful}\n\
          {"  "}failed:     {fmtSection totals.elapsedFailed totals.numFailed}\n"
    return fmt

def scriptsCore (nSlowest := 30) (nontrivialOnly := false) :
    StatsReport := λ statsArray => Id.run do
  let statsArray :=
    if nontrivialOnly then
      statsArray.filter (·.stats.scriptGenerated.isNontrivial)
    else
      statsArray
  let mut staticallyStructured := 0
  let mut perfectlyStaticallyStructured := 0
  let mut dynamicallyStructured := 0
  let mut perfectlyDynamicallyStructured := 0
  let mut totalTimes := Array.mkEmpty statsArray.size
  let mut scriptTimes := Array.mkEmpty statsArray.size
  for stats in statsArray do
    let stats := stats.stats
    totalTimes := totalTimes.push stats.total
    match stats.scriptGenerated with
    | .none => pure ()
    | .staticallyStructured perfect .. =>
      scriptTimes := scriptTimes.push stats.script
      staticallyStructured := staticallyStructured + 1
      if perfect then
        perfectlyStaticallyStructured := perfectlyStaticallyStructured + 1
    | .dynamicallyStructured perfect .. =>
      scriptTimes := scriptTimes.push stats.script
      dynamicallyStructured := dynamicallyStructured + 1
      if perfect then
        perfectlyDynamicallyStructured := perfectlyDynamicallyStructured + 1

  let slowest := statsArray.qsort (λ s₁ s₂ => s₁.stats.script > s₂.stats.script)
  let slowest := slowest[:nSlowest].toArray
  let nSlowest := min slowest.size nSlowest
  let slowestFmt := slowest.map λ e =>
    let pos :=
      match e.position? with
      | some pos => f!"{pos.line}:{pos.column}"
      | none => f!"?:?"
    f!"{e.fileName}:{pos}: script {e.stats.script}, total {e.stats.total}, type {fmtScriptGenerated e.stats.scriptGenerated}"

  f!"Statistics for {statsArray.size} Aesop calls{if nontrivialOnly then f!" with nontrivial script generation" else ""} in current and imported modules\n\
     Total Aesop time:         {fmtTimes totalTimes}\n\
     Script generation time:   {fmtTimes scriptTimes}\n\
     Scripts generated:        {scriptTimes.size}\n\
     - Statically  structured: {staticallyStructured}\n" ++
  f!"  - perfectly:            {perfectlyStaticallyStructured}\n\
     - Dynamically structured: {dynamicallyStructured}\n" ++
  f!"  - perfectly:            {perfectlyDynamicallyStructured}\n\
     \n\
     {nSlowest} Aesop calls with slowest script generation:\n\
     {Format.joinSep slowestFmt.toList "\n"}"
where
  fmtScriptGenerated : ScriptGenerated → Format
    | .none => "<none>"
    | .staticallyStructured perfect _ => f!"static (perfect: {perfect})"
    | .dynamicallyStructured perfect _ => f!"dynamic (perfect: {perfect})"

  fmtTimes (ns : Array Nanos) : Format :=
    let ns := ns.qsortOrd
    let total : Nanos := ns.foldl (init := 0) (· + ·)
    let average := if ns.size == 0 then 0 else total / ns.size
    let min := ns[0]?.getD 0
    let max := ns[ns.size - 1]?.getD 0
    let median := sortedMedianD 0 ns
    let pct80 := sortedPercentileD ⟨0.80⟩ 0 ns
    let pct95 := sortedPercentileD ⟨0.95⟩ 0 ns
    let pct99 := sortedPercentileD ⟨0.99⟩ 0 ns
    f!"{total} (min = {min}, avg = {average}, median = {median}, 80pct = {pct80}, 95pct = {pct95}, 99pct = {pct99}, max = {max})"

def scripts := scriptsCore
def scriptsNontrivial := scriptsCore (nontrivialOnly := true)

end Aesop.StatsReport



=== LEAN SOURCE: AddRapp.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Check
import Aesop.Forward.State.ApplyGoalDiff
import Aesop.Tree.Traversal
import Aesop.Tree.TreeM
import Aesop.Util.UnionFind

open Lean
open Lean.Meta

namespace Aesop

structure AddRapp extends RuleApplication where
  parent : GoalRef
  appliedRule : RegularRule
  successProbability : Percent

namespace AddRapp

def consumedForwardRuleMatches (r : AddRapp) : Array ForwardRuleMatch :=
  r.appliedRule.tac.forwardRuleMatches? |>.getD #[]

end AddRapp

def findPathForAssignedMVars (assignedMVars : UnorderedArraySet MVarId)
    (start : GoalRef) : TreeM (Array RappRef × Std.HashSet GoalId) := do
  if assignedMVars.isEmpty then
    return (#[], {})
  let unseen : IO.Ref (UnorderedArraySet MVarId) ← IO.mkRef assignedMVars
  let pathRapps : IO.Ref (Array RappRef) ← IO.mkRef #[]
  let pathGoals : IO.Ref (Std.HashSet GoalId) ← IO.mkRef {}
  preTraverseUp
    (λ gref => do
      let id := (← gref.get).originalGoalId
      pathGoals.modify (·.insert id)
      return true)
    (λ rref => do
      pathRapps.modify (·.push rref)
      for introducedMVar in (← rref.get).introducedMVars do
        unseen.modify (·.erase introducedMVar)
      if (← unseen.get).isEmpty then
        return false
      else
        return true)
    (λ _ =>
      return true)
    (TreeRef.goal start)
  let unseen ← unseen.get
  if ! unseen.isEmpty then
    let rootGoalMVars := (← (← getRootGoal).get).mvars
    if unseen.any (! rootGoalMVars.contains ·) then
      let reallyUnseen :=
        unseen.toArray.filter (! rootGoalMVars.contains ·) |>.map (·.name)
      throwError "aesop: internal error: introducing rapps not found for these mvars: {reallyUnseen}"
  return (← pathRapps.get, ← pathGoals.get)

def getGoalsToCopy (assignedMVars : UnorderedArraySet MVarId)
    (start : GoalRef) : TreeM (Array GoalRef) := do
  let (pathRapps, pathGoals) ← findPathForAssignedMVars assignedMVars start
  let mut toCopy := #[]
  let mut toCopyIds := (∅ : Std.HashSet GoalId)
  for rref in pathRapps do
    for cref in (← rref.get).children do
      for gref in (← cref.get).goals do
        let g ← gref.get
        let id := g.originalGoalId
        -- We copy goals which
        -- - aren't on the path;
        -- - haven't been copied already;
        -- - contain at least one of the assigned metavariables.
        -- For the first two checks, we identify goals by their
        -- `originalGoalId`, i.e. 'up to copying'.
        if ! pathGoals.contains id && ! toCopyIds.contains id &&
           g.mvars.any (assignedMVars.contains ·) then
          toCopy := toCopy.push gref
          toCopyIds := toCopyIds.insert id
  return toCopy

unsafe def copyGoals (assignedMVars : UnorderedArraySet MVarId)
    (start : GoalRef) (parentMetaState : Meta.SavedState)
    (parentSuccessProbability : Percent) (depth : Nat) :
    TreeM (Array Goal) := do
  let toCopy ← getGoalsToCopy assignedMVars start
  toCopy.mapM λ gref => do
    let g ← gref.get
    let rs := (← read).ruleSet
    let (forwardState, forwardRuleMatches, mvars) ←
      runInMetaState parentMetaState do
        let start ← start.get
        let diff ← diffGoals start.currentGoal g.preNormGoal
        let (forwardState, ms) ← start.forwardState.applyGoalDiff rs diff
        let forwardRuleMatches :=
          start.forwardRuleMatches.update ms diff.removedFVars
            (consumedForwardRuleMatches := #[]) -- TODO unsure whether this is correct
        let mvars ← .ofHashSet <$> g.preNormGoal.getMVarDependencies
        pure (forwardState, forwardRuleMatches, mvars)
    return Goal.mk {
      id := ← getAndIncrementNextGoalId
      parent := unsafeCast () -- will be filled in later
      children := #[]
      origin := .copied g.id g.originalGoalId
      depth
      state := GoalState.unknown
      isIrrelevant := false
      isForcedUnprovable := false
      preNormGoal := g.preNormGoal
      normalizationState := NormalizationState.notNormal
      mvars
      forwardState
      forwardRuleMatches
      successProbability := parentSuccessProbability
      addedInIteration := (← read).currentIteration
      lastExpandedInIteration := Iteration.none
      unsafeRulesSelected := false
      unsafeQueue := {}
      failedRapps := #[]
    }

def makeInitialGoal (goal : Subgoal) (mvars : UnorderedArraySet MVarId)
    (parent : MVarClusterRef) (parentMetaState : Meta.SavedState)
    (parentForwardState : ForwardState)
    (parentForwardMatches : ForwardRuleMatches)
    (consumedForwardRuleMatches : Array ForwardRuleMatch) (depth : Nat)
    (successProbability : Percent) (origin : GoalOrigin) : TreeM Goal := do
  let rs := (← read).ruleSet
  let (forwardState, forwardRuleMatches) ← runInMetaState parentMetaState do
    let (fs, newMatches) ← parentForwardState.applyGoalDiff rs goal.diff
    let ms :=
      parentForwardMatches.update newMatches goal.diff.removedFVars
        consumedForwardRuleMatches
    pure (fs, ms)
  return Goal.mk {
    id := ← getAndIncrementNextGoalId
    children := #[]
    state := GoalState.unknown
    isIrrelevant := false
    isForcedUnprovable := false
    preNormGoal := goal.mvarId
    normalizationState := NormalizationState.notNormal
    forwardState
    forwardRuleMatches
    addedInIteration := (← read).currentIteration
    lastExpandedInIteration := Iteration.none
    unsafeRulesSelected := false
    unsafeQueue := {}
    failedRapps := #[]
    parent, origin, depth, mvars, successProbability
  }

unsafe def addRappUnsafe (r : AddRapp) : TreeM RappRef := do
  let originalSubgoals := r.goals

  -- We update the rapp's `auxDeclNGen` to ensure that tactics on different
  -- branches of the search tree generate different names for auxiliary
  -- declarations.
  let auxDeclNGen ←
    match ← (← r.parent.get).parentRapp? with
    | none =>
      let (child, parent) := (← getDeclNGen).mkChild
      setDeclNGen parent
      pure child
    | some parentRapp => parentRapp.getChildAuxDeclNameGenerator
  let metaState := { r.postState with core.auxDeclNGen := auxDeclNGen }

  let rref : RappRef ← IO.mkRef $ Rapp.mk {
    id := ← getAndIncrementNextRappId
    parent := r.parent
    children := #[] -- will be filled in later
    state := NodeState.unknown
    isIrrelevant := false
    appliedRule := r.appliedRule
    scriptSteps? := r.scriptSteps?
    originalSubgoals := originalSubgoals.map (·.mvarId)
    successProbability := r.successProbability
    metaState
    introducedMVars := {} -- will be filled in later
    assignedMVars   := {} -- will be filled in later
  }

  let parentGoal ← r.parent.get
  let goalDepth := parentGoal.depth + 1

  let (originalSubgoalMVars, assignedMVars, assignedOrDroppedMVars) ←
    r.postState.runMetaM' do
      -- Get mvars which the original subgoals depend on.
      let originalSubgoalMVars : Std.HashSet MVarId ←
        originalSubgoals.foldlM (init := ∅) λ acc subgoal =>
          return acc.insertMany (← subgoal.mvarId.getMVarDependencies)

      -- Get mvars which were either assigned or dropped by the rapp. We assume
      -- that rules only assign mvars which appear in the rapp's parent goal. A
      -- dropped mvar is one that appears in the parent of the rapp but is
      -- neither assigned by the rapp nor does it appear in any of its subgoals.
      -- A dropped mvar is treated like an assigned mvar for the purposes of
      -- copying.
      let mut assignedMVars : UnorderedArraySet MVarId := ∅
      let mut assignedOrDroppedMVars : UnorderedArraySet MVarId := ∅
      for mvarId in parentGoal.mvars do
        if ← mvarId.isAssignedOrDelayedAssigned then
          -- mvar was assigned
          assignedMVars := assignedMVars.insert mvarId
          assignedOrDroppedMVars := assignedOrDroppedMVars.insert mvarId
        else if ! originalSubgoalMVars.contains mvarId then
          -- mvar was dropped
          assignedOrDroppedMVars := assignedOrDroppedMVars.insert mvarId
      pure (originalSubgoalMVars, assignedMVars, assignedOrDroppedMVars)

  -- If the rapp assigned or dropped any mvars, copy the related goals.
  let copiedGoals : Array Goal ←
    copyGoals assignedOrDroppedMVars r.parent r.postState
      r.successProbability goalDepth
  let copiedSubgoals : Array Subgoal :=
    copiedGoals.map λ g =>
      { diff := { (default : GoalDiff) with newGoal := g.preNormGoal } }
    -- The diff is irrelevant because we later add `g` to the tree (and the
    -- forward state of `g` is already up to date).

  -- Collect the mvars which occur in the original subgoals and copied goals.
  let originalSubgoalAndCopiedGoalMVars :=
    copiedGoals.foldl (init := originalSubgoalMVars)
       λ copiedGoalMVars g => copiedGoalMVars.insertMany g.mvars

  -- Turn the dropped mvars into subgoals. Note: an mvar that was dropped by the
  -- rapp may occur in the copied goals, in which case we don't count it as
  -- dropped any more.
  let droppedSubgoals : Array Subgoal ← runInMetaState r.postState do
    let mut droppedMVars := #[]
    for mvarId in parentGoal.mvars do
      unless ← (pure $ originalSubgoalAndCopiedGoalMVars.contains mvarId) <||>
               mvarId.isAssignedOrDelayedAssigned do
        let diff ← diffGoals parentGoal.currentGoal mvarId
        droppedMVars := droppedMVars.push { diff }
    pure droppedMVars

  -- Partition the subgoals into 'proper goals' and 'proper mvars'. A proper
  -- mvar is an mvar that occurs in any of the other subgoal mvars. Any other
  -- mvar is a proper goal.
  let (properGoals, _) ← r.postState.runMetaM' do
    partitionGoalsAndMVars (·.mvarId) $
      originalSubgoals ++ copiedSubgoals ++ droppedSubgoals

  -- Construct the subgoals
  let subgoals ← properGoals.mapM λ (goal, mvars) =>
    if let some copiedGoal := copiedGoals.find? (·.preNormGoal == goal.mvarId) then
      pure copiedGoal
    else
      let origin :=
        if droppedSubgoals.find? (·.mvarId == goal.mvarId) |>.isSome then
          .droppedMVar
        else
          .subgoal
      try
        makeInitialGoal goal mvars (unsafeCast ()) r.postState
          parentGoal.forwardState parentGoal.forwardRuleMatches
          r.consumedForwardRuleMatches goalDepth r.successProbability origin
          -- The parent (`unsafeCast ()`) will be patched up later.
      catch e =>
        throwError "in rapp for rule {r.appliedRule.name}:{indentD e.toMessageData}"

  -- Construct the new mvar clusters.
  let crefs : Array MVarClusterRef ←
    cluster (·.mvars.toArray) subgoals |>.mapM λ gs => do
      let grefs ← gs.mapM (IO.mkRef ·)
      let cref ← IO.mkRef $ MVarCluster.mk {
        parent? := some rref
        goals := grefs
        isIrrelevant := false
        state := NodeState.unknown
      }
      -- Patch up information we left out earlier (to break cyclic
      -- dependencies).
      grefs.forM λ gref => gref.modify λ g => g.setParent cref
      return cref

  -- Get the introduced mvars. An mvar counts as introduced by this rapp if it
  -- appears in a subgoal, but not in the parent goal.
  let mut introducedMVars : UnorderedArraySet MVarId := ∅
  let mut allIntroducedMVars ← modifyGetThe Tree λ t =>
    (t.allIntroducedMVars, { t with allIntroducedMVars := ∅ })
    -- We set `allIntroducedMVars := ∅` to make sure that the hash set is used
    -- linearly.
  for g in subgoals do
    for mvarId in g.mvars do
      if ! parentGoal.mvars.contains mvarId &&
         ! allIntroducedMVars.contains mvarId then
        introducedMVars := introducedMVars.insert mvarId
        allIntroducedMVars := allIntroducedMVars.insert mvarId
  modifyThe Tree λ t => { t with allIntroducedMVars }

  -- Patch up more information we left out earlier.
  rref.modify λ r =>
    r.setChildren crefs
    |>.setIntroducedMVars introducedMVars
    |>.setAssignedMVars assignedMVars
  r.parent.modify λ g => g.setChildren $ g.children.push rref

  -- Increment goal and rapp counters.
  incrementNumGoals subgoals.size
  incrementNumRapps
  return rref

/--
Adds a new rapp and its subgoals. If the rapp assigns mvars, all relevant
goals containing these mvars are copied as children of the rapp as well. If
the rapp drops mvars, these are treated as assigned mvars, in the sense that
the same goals are copied as if the dropped mvar had been assigned.

Note that adding a rapp may prove the parent goal, but this function does not
make the necessary changes. So after calling it, you should check whether the
rapp's parent goal is proven and mark it accordingly.
-/
@[implemented_by addRappUnsafe]
opaque addRapp : AddRapp → TreeM RappRef

end Aesop



=== LEAN SOURCE: Check.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Check
import Aesop.Tree.State
import Aesop.Tree.Traversal
import Aesop.Tree.TreeM
import Batteries.Lean.HashSet
import Aesop.Tree.RunMetaM

open Lean
open Lean.Meta

namespace Aesop.MVarClusterRef

def checkIds (root : MVarClusterRef) : CoreM Unit := do
  let visitedGoalIds : IO.Ref (Std.HashSet GoalId) ← IO.mkRef {}
  let visitedRappIds : IO.Ref (Std.HashSet RappId) ← IO.mkRef {}
  preTraverseDown
    (λ gref => do
      let id := (← gref.get).id
      if (← visitedGoalIds.get).contains id then
        throwError "{Check.tree.name}: duplicate goal id: {id}"
      visitedGoalIds.modify λ s => s.insert id
      return true)
    (λ rref => do
      let id := (← rref.get).id
      if (← visitedRappIds.get).contains id then
        throwError "{Check.tree.name}: duplicate rapp id: {id}"
      visitedRappIds.modify λ s => s.insert id
      return true)
    (λ _ => return true)
    (TreeRef.mvarCluster root)

def checkAcyclic (root : MVarClusterRef) : CoreM Unit := do
  -- We use arrays to store the visited nodes (rather than some data structure
  -- with asymptotically faster lookup) because STRefs only have pointer
  -- equality, not pointer comparison. Besides, this is probably faster anyway
  -- for small to medium trees.
  let visitedGoalRefs        : IO.Ref (Array GoalRef)        ← ST.mkRef #[]
  let visitedRappRefs        : IO.Ref (Array RappRef)        ← ST.mkRef #[]
  let visitedMVarClusterRefs : IO.Ref (Array MVarClusterRef) ← ST.mkRef #[]
  preTraverseDown
    (λ gref => go visitedGoalRefs gref)
    (λ rref => go visitedRappRefs rref)
    (λ cref => go visitedMVarClusterRefs cref)
    (TreeRef.mvarCluster root)
  where
    go {α} (visited : IO.Ref (Array (IO.Ref α))) (current : IO.Ref α) :
        CoreM Bool := do
      if ← (← visited.get).anyM (current.ptrEq ·) then throwError
        "{Check.tree.name}: search tree contains a cycle."
      visited.modify (·.push current)
      return true

def checkConsistentParentChildLinks (root : MVarClusterRef) : CoreM Unit :=
  preTraverseDown
    (λ gref => do
      for c in (← gref.get).children do
        if ← notM $ (← c.get).parent.ptrEq gref then err
      return true)
    (λ rref => do
      for c in (← rref.get).children do
        match (← c.get).parent? with
        | some parent =>
          if ← notM $ parent.ptrEq rref then err
        | none =>
          err
      return true)
    (λ cref => do
      for c in (← cref.get).goals do
        if ← notM $ (← c.get).parent.ptrEq cref then err
      return true)
    (TreeRef.mvarCluster root)
  where
    err := throwError "{Check.tree.name}: search tree is not properly linked."

private def mvarClusterId (c : MVarCluster) : BaseIO String :=
  match c.parent? with
  | some parentRef => return s!"mvar cluster of rapp {(← parentRef.get).id}"
  | none => return s!"root mvar cluster"

def checkState (root : MVarClusterRef) : CoreM Unit :=
  postTraverseDown
    (λ gref => do
      let g ← gref.get
      go s!"goal {g.id}" (← g.stateNoCache) g.state)
    (λ rref => do
      let r ← rref.get
      go s!"rapp {r.id}" (← r.stateNoCache) r.state)
    (λ cref => do
      let c ← cref.get
      go (← mvarClusterId c) (← c.stateNoCache) c.state)
    (TreeRef.mvarCluster root)
  where
    @[inline]
    go {σ} [BEq σ] [ToString σ] (id : String) (expected actual : σ) :
        CoreM Unit := do
      if expected != actual then throwError
        "{Check.tree.name}: {id} has wrong state: marked as '{actual}' but should be '{expected}'."

def checkIrrelevance (root : MVarClusterRef) : CoreM Unit :=
  preTraverseDown
    (λ gref => do
      let g ← gref.get
      go s!"goal {g.id}" (← g.isIrrelevantNoCache) g.isIrrelevant)
    (λ rref => do
      let r ← rref.get
      go s!"rapp {r.id}" (← r.isIrrelevantNoCache) r.isIrrelevant)
    (λ cref => do
      let c ← cref.get
      go (← mvarClusterId c) (← c.isIrrelevantNoCache) c.isIrrelevant)
    (TreeRef.mvarCluster root)
  where
    @[inline]
    go (id : String) (expected actual : Bool) : CoreM Bool := do
      match actual, expected with
      | true, false => throwError
        "{Check.tree.name}: {id} is marked as irrelevant, but is not irrelevant."
      | false, true => throwError
        "{Check.tree.name}: {id} is marked as not irrelevant, but is irrelevant."
      | _, _ => return true

def checkMVars (root : MVarClusterRef) (rootMetaState : Meta.SavedState) :
    MetaM Unit :=
  preTraverseDown
    (λ gref => do
      let g ← gref.get
      checkGoalMVars g
      return true)
    (λ rref => do
      let r ← rref.get
      checkAssignedMVars r
      checkDroppedMVars r
      return true)
    (λ _ => return true)
    (TreeRef.mvarCluster root)
  where
    getParentInfo (r : Rapp) : CoreM (MVarId × Meta.SavedState) := do
      let some res := (← r.parent.get).postNormGoalAndMetaState? | throwError
        "{Check.tree.name}: expected parent goal of rapp {r.id} to be normalised (but not proven by normalisation)."
      return res

    checkAssignedMVars (r : Rapp) : MetaM Unit := do
      let (parentPostNormGoal, parentPostNormState) ← getParentInfo r
      let actualAssigned :=
        (← getAssignedExprMVars parentPostNormState r.metaState).erase
          parentPostNormGoal
      unless actualAssigned.equalSet r.assignedMVars.toArray do throwError
        "{Check.tree.name}: rapp {r.id} reports incorrect assigned mvars.\n  reported: {r.assignedMVars.toArray.map (·.name)}\n  actual: {actualAssigned.map (·.name)}"

    checkDroppedMVars (r : Rapp) : MetaM Unit := do
      let droppableMVars :=
        (← r.parent.get).mvars ++ r.introducedMVars |>.toArray
      let mut nonDroppedMVars := Std.HashSet.ofArray r.assignedMVars.toArray
      for cref in r.children do
        for gref in (← cref.get).goals do
          let g ← gref.get
          nonDroppedMVars := nonDroppedMVars.insert g.preNormGoal
          nonDroppedMVars := nonDroppedMVars.insertMany g.mvars
      if droppableMVars.any (! nonDroppedMVars.contains ·) then throwError
        "{Check.tree.name}: rapp {r.id} dropped mvars.\n  mvars introduced or present in parent: {droppableMVars.map (·.name)}\n  mvars assigned or present in subgoals:\n  {nonDroppedMVars.toArray.map (·.name)}"

    checkGoalMVars (g : Goal) : MetaM Unit := do
      checkNormMVars g
      let actualPreNormMVars ← g.runMetaMInParentState'
        g.preNormGoal.getMVarDependencies
      let expectedMVars := Std.HashSet.ofArray g.mvars.toArray
      unless actualPreNormMVars == expectedMVars do throwError
        "{Check.tree.name}: goal {g.id} reports incorrect unassigned mvars.\n  reported: {g.mvars.toArray.map (·.name)}\n  actual: {actualPreNormMVars.toArray.map (·.name)}"

    checkNormMVars (g : Goal) : MetaM Unit := do
      let go (parentMetaState postMetaState : Meta.SavedState)
          (introduced : Array MVarId) : MetaM Unit := do
        unless introduced.isEmpty do throwError
          "{Check.tree.name}: normalisation of goal {g.id} introduced additional metavariables:{indentD $ toMessageData $ introduced.map (·.name)}"
        let assigned :=
          (← getAssignedExprMVars parentMetaState postMetaState).erase
            g.preNormGoal
        unless assigned.isEmpty do throwError
          "{Check.tree.name}: normalisation of goal {g.id} assigned metavariables:{indentD $ toMessageData $ assigned.map (·.name)}"
      match g.normalizationState with
      | .notNormal => return
      | .provenByNormalization postMetaState .. =>
        let parentMetaState ← g.parentMetaState rootMetaState
        let introduced ← getIntroducedExprMVars parentMetaState postMetaState
        go parentMetaState postMetaState introduced
      | .normal postGoal postMetaState .. =>
        let parentMetaState ← g.parentMetaState rootMetaState
        let introduced :=
          (← getIntroducedExprMVars parentMetaState postMetaState).erase
            postGoal
        go parentMetaState postMetaState introduced

-- Check that each mvar ocurring in a goal is either present in the root meta
-- state or has an introducing rapp.
def checkIntroducedMVars (root : MVarClusterRef)
    (rootMetaState : Meta.SavedState) : MetaM Unit := do
  let declaredAtRoot : Std.HashSet MVarId :=
    rootMetaState.meta.mctx.decls.foldl (init := ∅) λ acc mvarId _ =>
      acc.insert mvarId
  let introducedMVarsRef ← IO.mkRef declaredAtRoot
  preTraverseDown
    (λ gref => do
      for mvarId in (← gref.get).mvars do
        unless (← introducedMVarsRef.get).contains mvarId do
          throwError "{Check.tree.name}: at goal {(← gref.get).id}: no introducing rapp found for mvarId {mvarId.name}"
      return true)
    (λ rref => do
      let introduced := (← rref.get).introducedMVars
      introducedMVarsRef.modify λ mvars => mvars.insertMany introduced
      return true)
    (λ _ => return true)
    (.mvarCluster root)

def checkInvariants (root : MVarClusterRef) (rootMetaState : Meta.SavedState) :
    MetaM Unit := do
  root.checkAcyclic
  root.checkConsistentParentChildLinks
  root.checkIds
  root.checkState
  root.checkIrrelevance
  root.checkMVars rootMetaState
  root.checkIntroducedMVars rootMetaState

def checkInvariantsIfEnabled (root : MVarClusterRef)
    (rootMetaState : Meta.SavedState) : MetaM Unit := do
  if ← Check.tree.isEnabled then
    root.checkInvariants rootMetaState

end MVarClusterRef

def checkInvariantsIfEnabled : TreeM Unit := do
  (← getRootMVarCluster).checkInvariantsIfEnabled (← getRootMetaState)

end Aesop



=== LEAN SOURCE: Data.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg, Asta Halkjær From
-/

import Aesop.Constants
import Aesop.Script.Step
import Aesop.Tracing
import Aesop.Tree.Data.ForwardRuleMatches
import Aesop.Tree.UnsafeQueue
import Aesop.Forward.State

open Lean
open Lean.Meta
open Std

private def Bool.toYesNo : Bool → Format
  | true => "yes"
  | false => "no "

namespace Aesop

/-! ## Node IDs -/

-- TODO Change to USize?
structure GoalId where
  toNat : Nat
  deriving Inhabited, DecidableEq

namespace GoalId

protected def zero : GoalId :=
  ⟨0⟩

protected def one : GoalId :=
  ⟨1⟩

protected def succ : GoalId → GoalId
  | ⟨n⟩ => ⟨n + 1⟩

def dummy : GoalId :=
  ⟨1000000000000000⟩

instance : LT GoalId where
  lt n m := n.toNat < m.toNat

instance : DecidableRel (α := GoalId) (· < ·) :=
  λ n m => inferInstanceAs (Decidable (n.toNat < m.toNat))

instance : ToString GoalId where
  toString n := toString n.toNat

instance : Hashable GoalId where
  hash n := hash n.toNat

end GoalId


/-! ## Rule Application IDs -/

structure RappId where
  toNat : Nat
  deriving Inhabited, DecidableEq

namespace RappId

protected def zero : RappId :=
  ⟨0⟩

protected def succ : RappId → RappId
  | ⟨n⟩ => ⟨n + 1⟩

protected def one : RappId :=
  ⟨1⟩

def dummy : RappId :=
  ⟨1000000000000000⟩

instance : LT RappId where
  lt n m := n.toNat < m.toNat

instance : DecidableRel (α := RappId) (· < ·) :=
  λ n m => inferInstanceAs $ Decidable (n.toNat < m.toNat)

instance : ToString RappId where
  toString n := toString n.toNat

instance : Hashable RappId where
  hash n := hash n.toNat

end RappId


/-! ## Iterations -/

def Iteration := Nat
  deriving Inhabited

namespace Iteration

@[inline]
private def toNat : Iteration → Nat :=
  id

@[inline]
private def ofNat : Nat → Iteration :=
  id

@[inline]
protected def one : Iteration :=
  ofNat 1

@[inline]
protected def succ (i : Iteration) : Iteration :=
  ofNat $ i.toNat + 1

protected def none : Iteration :=
  ofNat 0

instance : DecidableEq Iteration :=
  inferInstanceAs $ DecidableEq Nat

instance : ToString Iteration :=
  inferInstanceAs $ ToString Nat

instance : LT Iteration :=
  inferInstanceAs $ LT Nat

instance : LE Iteration :=
  inferInstanceAs $ LE Nat

instance : DecidableRel (α := Iteration) (· < ·) :=
  inferInstanceAs $ DecidableRel (α := Nat) (· < ·)

instance : DecidableRel (α := Iteration) (· ≤ ·) :=
  inferInstanceAs $ DecidableRel (α := Nat) (· ≤ ·)

end Iteration


/-! ## The Tree -/

/--
At each point during the search, every node of the tree (goal, rapp or mvar
cluster) is in one of these states:

- `proven`: the node is proven.
- `unprovable`: the node is unprovable, i.e. it will never be proven regardless
  of any future expansions that might be performed.
- `unknown`: neither of the above.

Every node starts in the `unknown` state and may later become either `proven` or
`unprovable`. After this, the state does not change any more.
-/
inductive NodeState
  | unknown
  | proven
  | unprovable
  deriving Inhabited, BEq

namespace NodeState

instance : ToString NodeState where
  toString
    | unknown => "unknown"
    | proven => "proven"
    | unprovable => "unprovable"

def isUnknown : NodeState → Bool
  | unknown => true
  | _ => false

def isProven : NodeState → Bool
  | proven => true
  | _ => false

def isUnprovable : NodeState → Bool
  | unprovable => true
  | _ => false

def isIrrelevant : NodeState → Bool
  | proven => true
  | unprovable => true
  | unknown => false

def toEmoji : NodeState → String
  | proven => nodeProvedEmoji
  | unprovable => nodeUnprovableEmoji
  | unknown => nodeUnknownEmoji

end NodeState


/--
A refinement of the `NodeState`, distinguishing between goals proven during
normalisation and goals proven by a child rule application.
-/
inductive GoalState
  | unknown
  | provenByRuleApplication
  | provenByNormalization
  | unprovable
  deriving Inhabited, BEq

namespace GoalState

instance : ToString GoalState where
  toString
    | unknown => "unknown"
    | provenByRuleApplication => "provenByRuleApplication"
    | provenByNormalization =>  "provenByNormalization"
    | unprovable => "unprovable"

def isProvenByRuleApplication : GoalState → Bool
  | provenByRuleApplication => true
  | _ => false

def isProvenByNormalization : GoalState → Bool
  | provenByNormalization => true
  | _ => false

def isProven : GoalState → Bool
  | provenByRuleApplication => true
  | provenByNormalization => true
  | _ => false

def isUnprovable : GoalState → Bool
  | unprovable => true
  | _ => false

def isUnknown : GoalState → Bool
  | unknown => true
  | _ => false

def toNodeState : GoalState → NodeState
  | unknown => NodeState.unknown
  | provenByRuleApplication => NodeState.proven
  | provenByNormalization => NodeState.proven
  | unprovable => NodeState.unprovable

def isIrrelevant (s : GoalState) : Bool :=
  s.toNodeState.isIrrelevant

def toEmoji : GoalState → String
  | unknown => nodeUnknownEmoji
  | provenByRuleApplication | provenByNormalization => nodeProvedEmoji
  | unprovable => nodeUnprovableEmoji

end GoalState


inductive NormalizationState
  | notNormal
  | normal (postGoal : MVarId) (postState : Meta.SavedState)
      (script : Array (DisplayRuleName × Option (Array Script.LazyStep)))
  | provenByNormalization (postState : Meta.SavedState)
      (script : Array (DisplayRuleName × Option (Array Script.LazyStep)))
  deriving Inhabited

namespace NormalizationState

def isNormal : NormalizationState → Bool
  | notNormal => false
  | normal .. => true
  | provenByNormalization .. => true

def isProvenByNormalization : NormalizationState → Bool
  | notNormal .. => false
  | normal .. => false
  | provenByNormalization .. => true

def normalizedGoal? : NormalizationState → Option MVarId
  | notNormal .. | provenByNormalization .. => none
  | normal (postGoal := g) .. => g

end NormalizationState


/--
A goal `G` can be added to the tree for three reasons:

1. `G` was produced by its parent rule as a subgoal. This is the most common
   reason.
2. `G` was copied because it contains some metavariables which were assigned by
   its parent rule. In this case, we record goal of which `G` is a copy. We also
   record the representative of the equivalence class of goals which are copies
   of each other. E.g. if goal `1` is copied to goal `2` and goal `2` is copied
   to goal `3`, they are all part of the equivalence class with representative
   `1`.
-/
inductive GoalOrigin
  | subgoal
  | copied («from» : GoalId) (rep : GoalId)
  | droppedMVar
  deriving Inhabited

namespace GoalOrigin

def originalGoalId? : GoalOrigin → Option GoalId
  | copied _ rep => some rep
  | _ => none

protected def toString : GoalOrigin → String
  | subgoal => "subgoal"
  | copied «from» rep => s!"copy of {«from»}, originally {«rep»}"
  | droppedMVar => "dropped mvar"

end GoalOrigin

-- TODO docs

structure GoalData (Rapp MVarCluster : Type) : Type where
  id : GoalId
  parent : IO.Ref MVarCluster
  children : Array (IO.Ref Rapp)
  origin : GoalOrigin
  depth : Nat
  state : GoalState
  isIrrelevant : Bool
  isForcedUnprovable : Bool
    -- True if the goal was designated unprovable 'by force'. This happens when
    -- we reach the search depth limit. Any goal beyond this limit becomes
    -- irrelevant and therefore unprovable.
  preNormGoal : MVarId
    -- The goal before normalisation. The goal after normalisation (if any) is
    -- contained in the `normalizationState`.
  normalizationState : NormalizationState
  mvars : UnorderedArraySet MVarId
    -- Unassigned expression metavariables that appear in the goal, i.e. that
    -- appear in the target or hypotheses of `goal` when interpreted in the
    -- metavar context of `parent?` (or in the global metavar context if
    -- `parent? = none`).
  /-- The forward state reflects the local context of the current goal. Before
  normalisation, this is the local context of `preNormGoal`; after normalisation,
  it is the local context of the post-normalisation goal (unless normalisation
  solved the goal, in which case the forward state is undetermined). -/
  forwardState : ForwardState
  /-- Complete matches of forward rules for the current goal (in the same sense
  as above). -/
  forwardRuleMatches : ForwardRuleMatches
  successProbability : Percent
  addedInIteration : Iteration
  lastExpandedInIteration : Iteration
    -- Iteration 0 means the node has never been expanded.
  unsafeRulesSelected : Bool
  unsafeQueue : UnsafeQueue
  failedRapps : Array RegularRule
  deriving Nonempty

structure MVarClusterData (Goal Rapp : Type) : Type where
  parent? : Option (IO.Ref Rapp)
  goals : Array (IO.Ref Goal)
  isIrrelevant : Bool
  state : NodeState
  deriving Inhabited


structure RappData (Goal MVarCluster : Type) : Type where
  id : RappId
  parent : IO.Ref Goal
  children : Array (IO.Ref MVarCluster)
  state : NodeState
  isIrrelevant : Bool
  appliedRule : RegularRule
  scriptSteps? : Option (Array Script.LazyStep)
  originalSubgoals : Array MVarId
  successProbability : Percent
  metaState : Meta.SavedState
    -- This is the state *after* the rule was successfully applied, so the goal
    -- mvar is assigned in this state.
  introducedMVars : UnorderedArraySet MVarId
    -- Unassigned expression mvars introduced by this rapp. These are exactly
    -- the unassigned expr mvars that are declared in `metaState`, but not in
    -- the meta state of the parent rapp of `parent`.
  assignedMVars : UnorderedArraySet MVarId
    -- Expression mvars that were previously unassigned but were assigned by
    -- this rapp. These are exactly the expr mvars that (a) are declared and
    -- unassigned in the meta state of the parent rapp of `parent` and (b) are
    -- assigned in `metaState`.
  deriving Nonempty

mutual
  unsafe inductive GoalUnsafe
    | mk (d : GoalData RappUnsafe MVarClusterUnsafe)

  unsafe inductive MVarClusterUnsafe
    | mk (d : MVarClusterData GoalUnsafe RappUnsafe)

  unsafe inductive RappUnsafe
    | mk (d : RappData GoalUnsafe MVarClusterUnsafe)
end

structure TreeSpec where
  Goal : Type
  Rapp : Type
  MVarCluster : Type
  introGoal : GoalData Rapp MVarCluster → Goal
  elimGoal : Goal → GoalData Rapp MVarCluster
  introRapp : RappData Goal MVarCluster → Rapp
  elimRapp : Rapp → RappData Goal MVarCluster
  introMVarCluster : MVarClusterData Goal Rapp → MVarCluster
  elimMVarCluster : MVarCluster → MVarClusterData Goal Rapp

instance : Nonempty TreeSpec := by
  refine' ⟨{ Goal := Unit, Rapp := Unit, MVarCluster := Unit, .. }⟩
    <;> exact Classical.ofNonempty

unsafe def treeImpl : TreeSpec where
  Goal := GoalUnsafe
  Rapp := RappUnsafe
  MVarCluster := MVarClusterUnsafe
  introGoal := GoalUnsafe.mk
  elimGoal | GoalUnsafe.mk x => x
  introRapp := RappUnsafe.mk
  elimRapp | RappUnsafe.mk x => x
  introMVarCluster := MVarClusterUnsafe.mk
  elimMVarCluster | MVarClusterUnsafe.mk x => x

@[implemented_by treeImpl]
opaque tree : TreeSpec

def Goal        := tree.Goal
def Rapp        := tree.Rapp
def MVarCluster := tree.MVarCluster

abbrev GoalRef        := IO.Ref Goal
abbrev RappRef        := IO.Ref Rapp
abbrev MVarClusterRef := IO.Ref MVarCluster


namespace MVarCluster

@[inline]
protected def mk : MVarClusterData Goal Rapp → MVarCluster :=
  tree.introMVarCluster

instance : Nonempty MVarCluster :=
  ⟨MVarCluster.mk Classical.ofNonempty⟩

@[inline]
protected def elim : MVarCluster → MVarClusterData Goal Rapp :=
  tree.elimMVarCluster

@[inline]
protected def modify (f : MVarClusterData Goal Rapp → MVarClusterData Goal Rapp)
    (c : MVarCluster) : MVarCluster :=
  MVarCluster.mk $ f $ c.elim

@[inline]
def parent? (c : MVarCluster) : Option RappRef :=
  c.elim.parent?

@[inline]
def setParent (parent? : Option RappRef) (c : MVarCluster) : MVarCluster :=
  c.modify λ c => { c with parent? }

@[inline]
def goals (c : MVarCluster) : Array GoalRef :=
  c.elim.goals

@[inline]
def setGoals (goals : Array GoalRef) (c : MVarCluster) : MVarCluster :=
  c.modify λ c => { c with goals }

@[inline]
def isIrrelevant (c : MVarCluster) : Bool :=
  c.elim.isIrrelevant

@[inline]
def setIsIrrelevant (isIrrelevant : Bool) (c : MVarCluster) : MVarCluster :=
  c.modify λ c => { c with isIrrelevant }

@[inline]
def state (c : MVarCluster) : NodeState :=
  c.elim.state

@[inline]
def setState (state : NodeState) (c : MVarCluster) : MVarCluster :=
  c.modify λ c => { c with state }

end MVarCluster


namespace Goal

@[inline]
protected def mk : GoalData Rapp MVarCluster → Goal :=
  tree.introGoal

@[inline]
protected def elim : Goal → GoalData Rapp MVarCluster :=
  tree.elimGoal

@[inline]
protected def modify (f : GoalData Rapp MVarCluster → GoalData Rapp MVarCluster)
    (g : Goal) : Goal :=
  Goal.mk $ f $ g.elim

@[inline]
def id (g : Goal) : GoalId :=
  g.elim.id

@[inline]
def parent (g : Goal) : MVarClusterRef :=
  g.elim.parent

@[inline]
def children (g : Goal) : Array RappRef :=
  g.elim.children

@[inline]
def origin (g : Goal) : GoalOrigin :=
  g.elim.origin

@[inline]
def depth (g : Goal) : Nat :=
  g.elim.depth

@[inline]
def state (g : Goal) : GoalState :=
  g.elim.state

@[inline]
def isIrrelevant (g : Goal) : Bool :=
  g.elim.isIrrelevant

@[inline]
def isForcedUnprovable (g : Goal) : Bool :=
  g.elim.isForcedUnprovable

@[inline]
def preNormGoal (g : Goal) : MVarId :=
  g.elim.preNormGoal

@[inline]
def normalizationState (g : Goal) : NormalizationState :=
  g.elim.normalizationState

@[inline]
def mvars (g : Goal) : UnorderedArraySet MVarId :=
  g.elim.mvars

@[inline]
def forwardState (g : Goal) : ForwardState :=
  g.elim.forwardState

@[inline]
def forwardRuleMatches (g : Goal) : ForwardRuleMatches :=
  g.elim.forwardRuleMatches

@[inline]
def successProbability (g : Goal) : Percent :=
  g.elim.successProbability

@[inline]
def addedInIteration (g : Goal) : Iteration :=
  g.elim.addedInIteration

@[inline]
def lastExpandedInIteration (g : Goal) : Iteration :=
  g.elim.lastExpandedInIteration

@[inline]
def failedRapps (g : Goal) : Array RegularRule :=
  g.elim.failedRapps

@[inline]
def unsafeRulesSelected (g : Goal) : Bool :=
  g.elim.unsafeRulesSelected

@[inline]
def unsafeQueue (g : Goal) : UnsafeQueue :=
  g.elim.unsafeQueue

@[inline]
def unsafeQueue? (g : Goal) : Option UnsafeQueue :=
  if g.unsafeRulesSelected then some g.unsafeQueue else none

@[inline]
def setId (id : GoalId) (g : Goal) : Goal :=
  g.modify λ g => { g with id }

@[inline]
def setParent (parent : MVarClusterRef) (g : Goal) : Goal :=
  g.modify λ g => { g with parent }

@[inline]
def setChildren (children : Array RappRef) (g : Goal) : Goal :=
  g.modify λ g => { g with children }

@[inline]
def setOrigin (origin : GoalOrigin) (g : Goal) : Goal :=
  g.modify λ g => { g with origin }

@[inline]
def setDepth (depth : Nat) (g : Goal) : Goal :=
  g.modify λ g => { g with depth }

@[inline]
def setIsIrrelevant (isIrrelevant : Bool) (g : Goal) : Goal :=
  g.modify λ g => { g with isIrrelevant }

@[inline]
def setIsForcedUnprovable (isForcedUnprovable : Bool) (g : Goal) : Goal :=
  g.modify λ g => { g with isForcedUnprovable }

@[inline]
def setPreNormGoal (preNormGoal : MVarId) (g : Goal) : Goal :=
  g.modify λ g => { g with preNormGoal }

@[inline]
def setNormalizationState (normalizationState : NormalizationState) (g : Goal) :
    Goal :=
  g.modify λ g => { g with normalizationState }

@[inline]
def setMVars (mvars : UnorderedArraySet MVarId) (g : Goal) : Goal :=
  g.modify λ g => { g with mvars }

@[inline]
def setForwardState (forwardState : ForwardState) (g : Goal) : Goal :=
  g.modify λ g => { g with forwardState }

@[inline]
def setForwardRuleMatches (forwardRuleMatches : ForwardRuleMatches) (g : Goal) :
    Goal :=
  g.modify λ g => { g with forwardRuleMatches }

@[inline]
def setSuccessProbability (successProbability : Percent) (g : Goal) : Goal :=
  g.modify λ g => { g with successProbability }

@[inline]
def setAddedInIteration (addedInIteration : Iteration) (g : Goal) : Goal :=
  g.modify λ g => { g with addedInIteration }

@[inline]
def setLastExpandedInIteration (lastExpandedInIteration : Iteration) (g : Goal) :
    Goal :=
  g.modify λ g => { g with lastExpandedInIteration }

@[inline]
def setUnsafeRulesSelected (unsafeRulesSelected : Bool) (g : Goal) : Goal :=
  g.modify λ g => { g with unsafeRulesSelected }

@[inline]
def setUnsafeQueue (unsafeQueue : UnsafeQueue) (g : Goal) : Goal :=
  g.modify λ g => { g with unsafeQueue }

@[inline]
def setState (state : GoalState) (g : Goal) : Goal :=
  g.modify λ g => { g with state }

@[inline]
def setFailedRapps (failedRapps : Array RegularRule) (g : Goal) : Goal :=
  g.modify λ g => { g with failedRapps }

instance : Nonempty Goal :=
  ⟨Goal.mk Classical.ofNonempty⟩

instance : BEq Goal where
  beq g₁ g₂ := g₁.id == g₂.id

instance : Hashable Goal where
  hash g := hash g.id

end Goal


namespace Rapp

@[inline]
protected def mk : RappData Goal MVarCluster → Rapp :=
  tree.introRapp

@[inline]
protected def elim : Rapp → RappData Goal MVarCluster :=
  tree.elimRapp

@[inline]
protected def modify (f : RappData Goal MVarCluster → RappData Goal MVarCluster)
    (r : Rapp) : Rapp :=
  Rapp.mk $ f $ r.elim

@[inline]
def id (r : Rapp) : RappId :=
  r.elim.id

@[inline]
def parent (r : Rapp) : GoalRef :=
  r.elim.parent

@[inline]
def children (r : Rapp) : Array MVarClusterRef :=
  r.elim.children

@[inline]
def state (r : Rapp) : NodeState :=
  r.elim.state

@[inline]
def isIrrelevant (r : Rapp) : Bool :=
  r.elim.isIrrelevant

@[inline]
def appliedRule (r : Rapp) : RegularRule :=
  r.elim.appliedRule

@[inline]
def scriptSteps? (r : Rapp) : Option (Array Script.LazyStep) :=
  r.elim.scriptSteps?

@[inline]
def originalSubgoals (r : Rapp) : Array MVarId :=
  r.elim.originalSubgoals

@[inline]
def successProbability (r : Rapp) : Percent :=
  r.elim.successProbability

@[inline]
def metaState (r : Rapp) : Meta.SavedState :=
  r.elim.metaState

@[inline]
def introducedMVars (r : Rapp) : UnorderedArraySet MVarId :=
  r.elim.introducedMVars

@[inline]
def assignedMVars (r : Rapp) : UnorderedArraySet MVarId :=
  r.elim.assignedMVars

@[inline]
def setId (id : RappId) (r : Rapp) : Rapp :=
  r.modify λ r => { r with id }

@[inline]
def setParent (parent : GoalRef) (r : Rapp) : Rapp :=
  r.modify λ r => { r with parent }

@[inline]
def setChildren (children : Array MVarClusterRef) (r : Rapp) : Rapp :=
  r.modify λ r => { r with children }

@[inline]
def setState (state : NodeState) (r : Rapp) : Rapp :=
  r.modify λ r => { r with state }

@[inline]
def setIsIrrelevant (isIrrelevant : Bool) (r : Rapp) : Rapp :=
  r.modify λ r => { r with isIrrelevant }

@[inline]
def setAppliedRule (appliedRule : RegularRule) (r : Rapp) : Rapp :=
  r.modify λ r => { r with appliedRule }

@[inline]
def setScriptSteps? (scriptSteps? : Option (Array Script.LazyStep)) (r : Rapp) :
    Rapp :=
  r.modify λ r => { r with scriptSteps? }

@[inline]
def setOriginalSubgoals (originalSubgoals : Array MVarId)
    (r : Rapp) : Rapp :=
  r.modify λ r => { r with originalSubgoals }

@[inline]
def setSuccessProbability (successProbability : Percent) (r : Rapp) : Rapp :=
  r.modify λ r => { r with successProbability }

@[inline]
def setMetaState (metaState : Meta.SavedState) (r : Rapp) : Rapp :=
  r.modify λ r => { r with metaState }

@[inline]
def setIntroducedMVars (introducedMVars : UnorderedArraySet MVarId)
    (r : Rapp) : Rapp :=
  r.modify λ r => { r with introducedMVars }

@[inline]
def setAssignedMVars (assignedMVars : UnorderedArraySet MVarId) (r : Rapp) :
    Rapp :=
  r.modify λ r => { r with assignedMVars }

instance : Nonempty Rapp :=
  ⟨Rapp.mk Classical.ofNonempty⟩

instance : BEq Rapp where
  beq r₁ r₂ := r₁.id == r₂.id

instance : Hashable Rapp where
  hash r := hash r.id

end Rapp


/-! ## Miscellaneous Queries -/

def Rapp.isSafe (r : Rapp) : Bool :=
  r.appliedRule.isSafe && r.assignedMVars.isEmpty
  -- During expansion, we postpone safe rules that assign metavariables and
  -- treat them as unsafe.


namespace Goal

@[inline]
def postNormGoalAndMetaState? (g : Goal) : Option (MVarId × Meta.SavedState) :=
  match g.normalizationState with
  | .normal postGoal postState _ => some (postGoal, postState)
  | _ => none

def postNormGoal? (g : Goal) : Option MVarId :=
  g.postNormGoalAndMetaState?.map (·.fst)

def currentGoal (g : Goal) : MVarId :=
  g.postNormGoal?.getD g.preNormGoal

def parentRapp? (g : Goal) : BaseIO (Option RappRef) :=
  return (← g.parent.get).parent?

def parentMetaState (g : Goal) (rootMetaState : Meta.SavedState) :
    BaseIO Meta.SavedState := do
  match ← g.parentRapp? with
  | none => return rootMetaState
  | some parent => return (← parent.get).metaState

def currentGoalAndMetaState (g : Goal) (rootMetaState : Meta.SavedState) :
    MetaM (MVarId × Meta.SavedState) :=
  match g.postNormGoalAndMetaState? with
  | some x => return x
  | none => return (g.preNormGoal, ← g.parentMetaState rootMetaState)

def safeRapps (g : Goal) : BaseIO (Array RappRef) :=
  g.children.filterM λ rref => return (← rref.get).isSafe

def hasSafeRapp (g : Goal) : BaseIO Bool :=
  g.children.anyM λ rref => return (← rref.get).isSafe

def isUnsafeExhausted (g : Goal) : Bool :=
  g.unsafeRulesSelected && g.unsafeQueue.isEmpty

def isExhausted (g : Goal) : BaseIO Bool :=
  pure g.isUnsafeExhausted <||> g.hasSafeRapp

def isActive (g : Goal) : BaseIO Bool :=
  return ! (← pure g.isIrrelevant <||> g.isExhausted)

def hasProvableRapp (g : Goal) : BaseIO Bool :=
  g.children.anyM λ r => return ! (← r.get).state.isUnprovable

def firstProvenRapp? (g : Goal) : BaseIO (Option RappRef) :=
  g.children.findSomeM? λ rref =>
    return if (← rref.get).state.isProven then some rref else none

def hasMVar (g : Goal) : Bool :=
  ! g.mvars.isEmpty

def priority (g : Goal) : Percent :=
  g.successProbability * unificationGoalPenalty ^ g.mvars.size

def isNormal (g : Goal) : Bool :=
  g.normalizationState.isNormal

def originalGoalId (g : Goal) : GoalId :=
  g.origin.originalGoalId?.getD g.id

def isRoot (g : Goal) : BaseIO Bool :=
  return (← g.parentRapp?).isNone

end Goal


namespace Rapp

def introducesMVar (r : Rapp) : Bool :=
  ! r.introducedMVars.isEmpty

def parentPostNormMetaState (r : Rapp) (rootMetaState : Meta.SavedState) :
    BaseIO Meta.SavedState := do
  (← r.parent.get).parentMetaState rootMetaState

def foldSubgoalsM [Monad m] [MonadLiftT (ST IO.RealWorld) m] (init : σ)
    (f : σ → GoalRef → m σ) (r : Rapp) : m σ :=
  r.children.foldlM (init := init) λ s cref => do
    (← cref.get).goals.foldlM (init := s) f

def forSubgoalsM [Monad m] [MonadLiftT (ST IO.RealWorld) m]
    (f : GoalRef → m Unit) (r : Rapp) : m Unit :=
  r.children.forM λ cref => do (← cref.get).goals.forM f

def subgoals [Monad m] [MonadLiftT (ST IO.RealWorld) m] (r : Rapp) :
    m (Array GoalRef) :=
  r.foldSubgoalsM (init := #[]) λ subgoals gref => return subgoals.push gref

def depth (r : Rapp) : BaseIO Nat :=
  return (← r.parent.get).depth

end Rapp


namespace MVarCluster

def provenGoal? (c : MVarCluster) : BaseIO (Option GoalRef) :=
  c.goals.findM? λ gref => return (← gref.get).state.isProven

end MVarCluster


namespace RappRef

/-- Get a `DeclNameGenerator` for auxiliary declarations that can be used by
children of this rapp. Successive calls to this function return
`DeclNameGenerators` that are guaranteed to generate distinct names. -/
def getChildAuxDeclNameGenerator (r : RappRef) : BaseIO DeclNameGenerator := do
  r.modifyGet λ r =>
    let (child, parent) := r.metaState.core.auxDeclNGen.mkChild
    let r := r.setMetaState $ { r.metaState with core.auxDeclNGen := parent }
    (child, r)

end RappRef



=== LEAN SOURCE: ExtractProof.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/
import Lean.Replay
import Aesop.Tracing
import Aesop.Tree.TreeM
import Batteries.Lean.Meta.InstantiateMVars

open Lean
open Lean.Meta

/-
To extract a proof, we start in the `MetaM` state in which Aesop was called.
Then we iterate through the proven part of the tree, top to bottom, 'replaying'
the mvar assignments that were performed during the search. This means:

- For each goal `g`, we assign `g`'s pre-norm mvar to the term generated by
  normalisation. If `g` was proved by normalisation, we are done. Otherwise,
  we find the proving child rapp of `g` and descend into it.
- For each rapp `r`, we assign the post-norm mvar of `r`'s parent goal to the
  term generated by `r`. Additionally, we assign each mvar assigned by `r`.
  Then we descend into `r`'s children.
- For each mvar cluster `c`, we find the proven goal of `c` and descend into it.

When we assign a metavariable `m`, we must take some care:

- We must first declare `m` if it is not already declared.
- We must assign (and declare) any metavariables on which the assignment of `m`
  depends. We cannot assume that these assignments are meta-free, since they may
  contain metavariables that were only assigned later during the search. We
  also cannot assume that these are the *only* metavariables occurring in the
  assignments, since they may additionally contain delayed-assigned
  metavariables which depend on the unassigned metavariables.

We also replay environment modifications -- e.g., auxiliary declarations added
by a tactic -- in a similar fashion. To do this, we use
`Environment.replayConsts`, so newly added constants are sent to the kernel
again and environment extensions get a chance to replay their changes with
`replay?`.

If the root goal is not proven, we extract the goals after safe rule
applications. This means we proceed as above, but stop as soon as we reach the
first non-safe rule application. If a goal has multiple safe rule applications,
we arbitrarily choose the first one. (This should happen rarely in practice.)
-/

namespace Aesop

local macro "throwPRError " s:interpolatedStr(term) : term =>
  `(throwError m!"aesop: internal error during proof reconstruction: " ++ m!$s)


-- ## Copying Declarations

private def copyEnvModifications (oldEnv newEnv : Environment) : CoreM Unit := do
  setEnv $ ← (← getEnv).replayConsts oldEnv newEnv (skipExisting := true)

-- ## Copying Metavariables

private partial def copyExprMVar (s : Meta.SavedState) (mvarId : MVarId) :
    MetaM Unit := do
  if ← mvarId.isAssignedOrDelayedAssigned then
    return
  unless ← mvarId.isDeclared do
    let (decl, depMVarIds) ← s.runMetaM' $ do
      mvarId.instantiateMVars
      let decl ← mvarId.getDecl
      let depMVarIds ← mvarId.getMVarDependencies (includeDelayed := true)
      aesop_trace[extraction] "declare ?{mvarId.name}:{indentD $ toMessageData mvarId}"
      pure (decl, depMVarIds)
    modifyMCtx λ mctx => { mctx with decls := mctx.decls.insert mvarId decl }
    for depMVarId in depMVarIds do
      copyExprMVar s depMVarId
  let assignment? ← s.runMetaM' do
    if let (some e) ← getExprMVarAssignment? mvarId then
      return some $ Sum.inl $ ← instantiateMVars e
    else if let (some d) ← getDelayedMVarAssignment? mvarId then
      return some $ Sum.inr d
    else
      return none
  match assignment? with
  | some (Sum.inl e) =>
    for mvarId in ← getMVars e do
      copyExprMVar s mvarId
    aesop_trace[extraction] "assign  ?{mvarId.name} := {toString e}"
    mvarId.assign e
  | some (Sum.inr d) =>
    for mvarId in ← getMVars (mkMVar d.mvarIdPending) do
      copyExprMVar s mvarId
    aesop_trace[extraction] "dassign ?{mvarId.name} := {d.fvars} => {d.mvarIdPending.name}"
    assignDelayedMVar mvarId d.fvars d.mvarIdPending
  | none => return

-- ## Main Functions

private def visitGoal (parentEnv : Environment) (g : Goal) :
    MetaM (Option (MVarId × Array RappRef × Environment)) := do
  aesop_trace[extraction] "visiting G{g.id}"
  match g.normalizationState with
  | NormalizationState.notNormal => throwPRError
    "goal {g.id} was not normalised."
  | NormalizationState.normal postNormGoal postState _ =>
    copyEnvModifications parentEnv postState.core.env
    copyExprMVar postState g.preNormGoal
    return (postNormGoal, g.children, postState.core.env)
  | NormalizationState.provenByNormalization postState _ =>
    copyEnvModifications parentEnv postState.core.env
    copyExprMVar postState g.preNormGoal
    return none

private def visitRapp (parentEnv : Environment) (parentGoal : MVarId) (r : Rapp) :
    MetaM (Array MVarClusterRef × Environment) := do
  aesop_trace[extraction] "visiting R{r.id}"
  let newEnv := r.metaState.core.env
  copyEnvModifications parentEnv newEnv
  copyExprMVar r.metaState parentGoal
  for m in r.assignedMVars do
    copyExprMVar r.metaState m
  return (r.children, newEnv)

mutual
  private partial def extractProofGoal (parentEnv : Environment) (g : Goal) :
      MetaM Unit := do
    let (some (postNormGoal, children, postNormEnv)) ← visitGoal parentEnv g
      | return
    let rref? ← children.findM? λ rref => return (← rref.get).state.isProven
    let (some rref) := rref? | throwPRError
      "goal {g.id} does not have a proven rapp."
    extractProofRapp postNormEnv postNormGoal (← rref.get)

  private partial def extractProofRapp (parentEnv : Environment)
      (parentGoal : MVarId) (r : Rapp) : MetaM Unit := do
    let (children, newEnv) ← visitRapp parentEnv parentGoal r
    children.forM λ cref => do extractProofMVarCluster newEnv (← cref.get)

  private partial def extractProofMVarCluster (parentEnv : Environment)
      (c : MVarCluster) : MetaM Unit := do
    let gref? ← c.goals.findM? λ gref => return (← gref.get).state.isProven
    let (some gref) := gref? | throwPRError
      "an mvar cluster does not contain a proven goal (candidate goals: {← c.goals.mapM λ gref => return (← gref.get).id})."
    extractProofGoal parentEnv (← gref.get)
end

private structure SafePrefixState where
  goals : Array MVarId := #[]

private abbrev SafePrefixM := StateRefT SafePrefixState MetaM

mutual
  private partial def extractSafePrefixGoal (parentEnv : Environment)
      (g : Goal) : SafePrefixM Unit := do
    let (some (postNormGoal, _, parentEnv)) ← visitGoal parentEnv g
      | return
    let safeRapps ← g.safeRapps
    if safeRapps.size > 1 then
      throwError "aesop: internal error: goal {g.id} has multiple safe rapps"
    if h : 0 < safeRapps.size then
      extractSafePrefixRapp parentEnv postNormGoal (← safeRapps[0].get)
    else
      modify λ s => { s with goals := s.goals.push postNormGoal }

  private partial def extractSafePrefixRapp (parentEnv : Environment)
      (parentGoal : MVarId) (r : Rapp) : SafePrefixM Unit := do
    let (children, newEnv) ← visitRapp parentEnv parentGoal r
    children.forM λ cref => do extractSafePrefixMVarCluster newEnv (← cref.get)

  private partial def extractSafePrefixMVarCluster (parentEnv : Environment)
      (c : MVarCluster) : SafePrefixM Unit :=
    c.goals.forM λ gref => do extractSafePrefixGoal parentEnv (← gref.get)
end

def Goal.extractProof (root : Goal) : MetaM Unit := do
  extractProofGoal (← getEnv) root

def extractProof : TreeM Unit := do
  (← (← getRootGoal).get).extractProof

def Goal.extractSafePrefix (root : Goal) : MetaM (Array MVarId) := do
  let (_, state) ← extractSafePrefixGoal (← getEnv) root |>.run {}
  return state.goals

def extractSafePrefix : TreeM (Array MVarId) := do
  (← (← getRootGoal).get).extractSafePrefix

end Aesop



=== LEAN SOURCE: ExtractScript.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Script.UScript
import Aesop.Tracing
import Aesop.Tree.TreeM

open Lean
open Lean.Meta
open Lean.Parser.Tactic (tacticSeq)

namespace Aesop

open Script

structure ExtractScriptM.State where
  script : UScript := #[]
  proofHasMVar : Bool := false

abbrev ExtractScriptM := StateRefT ExtractScriptM.State TreeM

def ExtractScriptM.run (x : ExtractScriptM α) : TreeM (UScript × Bool) := do
  let (_, r) ← StateRefT'.run x {}
  return (r.script, r.proofHasMVar)

namespace ExtractScript

def lazyStepToStep (ruleName : DisplayRuleName) (lstep : LazyStep) :
    MetaM Step :=
  try
    lstep.toStep
  catch e =>
    throwError "tactic script generation failed for rule {ruleName}:{indentD e.toMessageData}"

def lazyStepsToSteps (ruleName : DisplayRuleName) :
    Option (Array LazyStep) → MetaM (Array Step)
  | none => throwError "tactic script generation is not supported by rule {ruleName}"
  | some lsteps => lsteps.mapM (lazyStepToStep ruleName)

def recordStep (step : Script.Step) : ExtractScriptM Unit := do
  modify λ s => { s with script := s.script.push step }

def recordLazySteps (ruleName : DisplayRuleName)
    (steps? : Option (Array Script.LazyStep)) : ExtractScriptM Unit := do
  let steps ← lazyStepsToSteps ruleName steps?
  modify λ s => { s with script := s.script ++ steps }

def visitGoal (g : Goal) : ExtractScriptM Unit := do
  withConstAesopTraceNode .script (return m!"goal {g.id}") do
  if ! g.mvars.isEmpty then
    modify λ s => { s with proofHasMVar := true }
  match g.normalizationState with
  | .notNormal => throwError "expected goal {g.id} to be normalised"
  | .normal (script := script) ..
  | .provenByNormalization (script := script) .. =>
    for (ruleName, script?) in script do
      recordLazySteps ruleName script?

def visitRapp (r : Rapp) : ExtractScriptM Unit := do
  withConstAesopTraceNode .script (return m!"rapp {r.id}") do
  recordLazySteps r.appliedRule.name r.scriptSteps?

end ExtractScript

open ExtractScript

mutual
  partial def MVarClusterRef.extractScriptCore (cref : MVarClusterRef) :
      ExtractScriptM Unit := do
    let c ← cref.get
    let (some gref) ← c.provenGoal? | throwError
      m!"the mvar cluster with goals {(← c.goals.mapM (·.get)).map (·.id)} does not contain a proven goal"
    gref.extractScriptCore

  partial def GoalRef.extractScriptCore (gref : GoalRef) : ExtractScriptM Unit := do
    let g ← gref.get
    visitGoal g
    if ! g.normalizationState.isProvenByNormalization then
      let (some rref) ← g.firstProvenRapp? | throwError
        m!"goal {g.id} does not have a proven rapp"
      rref.extractScriptCore

  partial def RappRef.extractScriptCore (rref : RappRef) :
      ExtractScriptM Unit := do
    let r ← rref.get
    visitRapp r
    r.children.forM (·.extractScriptCore)
end

@[inline]
def extractScript : TreeM (UScript × Bool) :=
  withAesopTraceNode .script (λ r => return m!"{exceptEmoji r} Extract script") do
    (← getRootGoal).extractScriptCore.run

mutual
  partial def MVarClusterRef.extractSafePrefixScriptCore
      (mref : MVarClusterRef) : ExtractScriptM Unit := do
    (← mref.get).goals.forM (·.extractSafePrefixScriptCore)

  partial def GoalRef.extractSafePrefixScriptCore (gref : GoalRef) :
      ExtractScriptM Unit := do
    let g ← gref.get
    visitGoal g
    if ! g.normalizationState.isProvenByNormalization then
      let safeRapps ← g.safeRapps
      if safeRapps.size > 1 then
        throwError "aesop: internal error: goal {g.id} has {safeRapps.size} safe rapps"
      if let some rref := safeRapps[0]? then
        rref.extractSafePrefixScriptCore
      else
        let some (postNormGoal, postNormState) := g.postNormGoalAndMetaState?
          | throwError "aesop: internal error at extractSafePrefixScript: goal {g.id} is not normalised"
        recordStep $ ← Step.mkSorry postNormGoal postNormState

  partial def RappRef.extractSafePrefixScriptCore (rref : RappRef) :
      ExtractScriptM Unit := do
    let r ← rref.get
    visitRapp r
    -- The safe prefix can't assign mvars because any safe rule that assigns
    -- mvars is downgraded to an unsafe rule. So we add `sorry` steps for all
    -- introduced mvars.
    for mvarId in r.introducedMVars do
      recordStep $ ← Step.mkSorry mvarId r.metaState
    r.forSubgoalsM (·.extractSafePrefixScriptCore)
end

def extractSafePrefixScript : TreeM (UScript × Bool) := do
  withAesopTraceNode .script (λ r => return m!"{exceptEmoji r} Extract safe prefix script") do
    (← getRootGoal).extractSafePrefixScriptCore.run

end Aesop



=== LEAN SOURCE: Free.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Tree.TreeM

namespace Aesop

-- In Lean 4, cylic structures -- such as our trees with their parent pointers
-- -- are not freed automatically. This is because the runtime uses reference
-- counting and a parent node and its child, holding references to each other,
-- will always have a reference count ≥ 1. So in order to free a tree, we must
-- break the cycles by removing the parent pointers.

mutual
  variable
    (dummyGoalRef : GoalRef)
    (dummyMVarClusterRef : MVarClusterRef)

  private partial def freeGoalRef (gref : GoalRef) : BaseIO Unit := do
    gref.modify λ g => g.setParent dummyMVarClusterRef
    (← gref.get).children.forM freeRappRef

  private partial def freeRappRef (rref : RappRef) : BaseIO Unit := do
    rref.modify λ r => r.setParent dummyGoalRef
    (← rref.get).children.forM freeMVarClusterRef

  private partial def freeMVarClusterRef (cref : MVarClusterRef) :
      BaseIO Unit := do
    cref.modify λ c => c.setParent none
    (← cref.get).goals.forM freeGoalRef
end

private def mkDummyRefs : BaseIO (GoalRef × MVarClusterRef) := do
  let cref ← IO.mkRef $ by refine' MVarCluster.mk {..} <;> exact default
  let gref ← IO.mkRef $ by refine' Goal.mk { parent := cref, .. } <;> exact default
  return (gref, cref)

def GoalRef.free (gref : GoalRef) : BaseIO Unit := do
  let (dgref, dcref) ← mkDummyRefs
  freeGoalRef dgref dcref gref

def RappRef.free (rref : RappRef) : BaseIO Unit := do
  let (dgref, dcref) ← mkDummyRefs
  freeRappRef dgref dcref rref

def MVarClusterRef.free (cref : MVarClusterRef) : BaseIO Unit := do
  let (dgref, dcref) ← mkDummyRefs
  freeMVarClusterRef dgref dcref cref

def freeTree : TreeM Unit := do
  (← getThe Tree).root.free

end Aesop



=== LEAN SOURCE: RunMetaM.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Tree.Data

open Lean
open Lean.Meta

namespace Aesop

/-!
The following functions let us run MetaM actions in the context of a rapp or
goal. Rapps save the metavariable context in which they were run by storing a
`Meta.SavedState`. When we, for example, apply a rule to a goal, we run the
rule's action in the metavariable context of the goal (which is the
metavariable context of the goal's parent rapp). The resulting metavariable
context, in which the goal mvar is assigned to an expression generated by the
rule, then becomes the metavariable context of the rule's rapp.

To save and restore metavariable contexts, we use the `MonadBacktrack MetaM`
instance. This means that some elements of the state are persistent, notably
caches and trace messages. These become part of the global state.

The environment is not persistent. This means that modifications of the
environment made by a rule are not visible in the global state and are reset
once the tactic exits. As a result, rules which modify the environment are
likely to fail.
-/

variable [Monad m] [MonadLiftT MetaM m] [MonadFinally m]

local instance : MonadLiftT (ST IO.RealWorld) m where
  monadLift x := (x : MetaM _)

@[inline, always_inline]
private def withSaveState (x : m α) : m (α × Meta.SavedState) := do
  let r ← x
  let s ← Meta.saveState
  return (r, s)

def Rapp.runMetaM' (x : m α) (r : Rapp) : m α :=
  runInMetaState r.metaState x

def Rapp.runMetaM (x : m α) (r : Rapp) : m (α × Meta.SavedState) :=
  r.runMetaM' do withSaveState x

def Rapp.runMetaMModifying (x : m α) (r : Rapp) : m (α × Rapp) := do
  let (result, finalState) ← r.runMetaM x
  return (result, r |>.setMetaState finalState)

def RappRef.runMetaMModifying (x : m α) (rref : RappRef) : m α := do
  let (result, r) ← (← rref.get).runMetaMModifying x
  rref.set r
  return result

def Goal.runMetaMInPostNormState' [MonadError m] (x : MVarId → m α) (g : Goal) :
    m α := do
  let some (postGoal, postState) := g.postNormGoalAndMetaState? | throwError
    "aesop: internal error: expected goal {g.id} to be normalised (but not proven by normalisation)."
  runInMetaState postState $ x postGoal

def Goal.runMetaMInPostNormState [MonadError m] (x : MVarId → m α) (g : Goal) :
    m (α × Meta.SavedState) :=
  g.runMetaMInPostNormState' λ g => withSaveState (x g)

def Goal.runMetaMInParentState' (x : m α) (g : Goal) : m α := do
  match ← show MetaM _ from g.parentRapp? with
  | none =>
    let initialState ← Meta.saveState
    try
      x
    finally
      initialState.restore
  | some rref => (← rref.get).runMetaM' x

def Goal.runMetaMInParentState (x : m α) (g : Goal) : m (α × Meta.SavedState) :=
  g.runMetaMInParentState' do withSaveState x

def Goal.runMetaMModifyingParentState (x : m α) (g : Goal) : m α := do
  match ← show MetaM _ from g.parentRapp? with
  | none => x
  | some rref => rref.runMetaMModifying x

def Rapp.runMetaMInParentState (x : m α) (r : Rapp) :
    m (α × Meta.SavedState) := do
  (← r.parent.get).runMetaMInParentState x

def Rapp.runMetaMInParentState' (x : m α) (r : Rapp) : m α := do
  (← r.parent.get).runMetaMInParentState' x

def Rapp.runMetaMModifyingParentState (x : m α) (r : Rapp) : m α := do
  (← r.parent.get).runMetaMModifyingParentState x

end Aesop



=== LEAN SOURCE: State.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Tree.Traversal

namespace Aesop

/-! ## Marking Nodes As Proven/Unprovable/Irrelevant -/

/-! ### Irrelevant -/

/-
Each of our node types (goal, rapp, mvar cluster) is irrelevant under the
same conditions:

1. the node is proven or unprovable *or*
2. the node's parent is irrelevant. (If the node has no parent, this condition
   does not apply.)
-/

def Goal.isIrrelevantNoCache (g : Goal) : BaseIO Bool :=
  (return g.state.isIrrelevant) <||>
  (return (← g.parent.get).isIrrelevant)

def Rapp.isIrrelevantNoCache (r : Rapp) : BaseIO Bool :=
  (return r.state.isIrrelevant) <||>
  (return (← r.parent.get).isIrrelevant)

def MVarCluster.isIrrelevantNoCache (c : MVarCluster) : BaseIO Bool := do
  (return c.state.isIrrelevant) <||> do
    match c.parent? with
    | none => return false
    | some parentRef => return (← parentRef.get).isIrrelevant

def TreeRef.markSubtreeIrrelevant : TreeRef → BaseIO Unit :=
  preTraverseDown
    (λ gref => do
      if (← gref.get).isIrrelevant then
        return false -- Subtree is already irrelevant.
      gref.modify λ g => g.setIsIrrelevant true
      return true)
    (λ rref => do
      if (← rref.get).isIrrelevant then
        return false -- Subtree is already irrelevant.
      rref.modify λ r => r.setIsIrrelevant true
      return true)
    (λ cref => do
      if (← cref.get).isIrrelevant then
        return false -- Subtree is already irrelevant.
      cref.modify λ c => c.setIsIrrelevant true
      return true)

def GoalRef.markSubtreeIrrelevant (gref : GoalRef) : BaseIO Unit :=
  (TreeRef.goal gref).markSubtreeIrrelevant

def RappRef.markSubtreeIrrelevant (rref : RappRef) : BaseIO Unit :=
  (TreeRef.rapp rref).markSubtreeIrrelevant

def MVarClusterRef.markSubtreeIrrelevant (cref : MVarClusterRef) : BaseIO Unit :=
  (TreeRef.mvarCluster cref).markSubtreeIrrelevant


/-! ### Proven -/

-- A goal is proven if any of its child rapps are proven, or if the goal was
-- proven by normalisation.
def Goal.isProvenByNormalizationNoCache (g : Goal) : Bool :=
  g.normalizationState.isProvenByNormalization

def Goal.isProvenByRuleApplicationNoCache (g : Goal) : BaseIO Bool :=
  g.children.anyM λ rref => return (← rref.get).state.isProven

def Goal.isProvenNoCache (g : Goal) : BaseIO Bool :=
  (return g.isProvenByNormalizationNoCache) <||>
  g.isProvenByRuleApplicationNoCache

-- A rapp is proven if each of its child mvar clusters is proven.
def Rapp.isProvenNoCache (r : Rapp) : BaseIO Bool :=
  r.children.allM λ cref => return (← cref.get).state.isProven

-- An mvar cluster is proven if any of its goals is proven.
def MVarCluster.isProvenNoCache (c : MVarCluster) : BaseIO Bool :=
  c.goals.anyM λ cref => return (← cref.get).state.isProven

private def markProvenCore (root : TreeRef) : BaseIO Unit := do
  /-
  We iterate up the tree, marking nodes as proven according to the rules
  of provenness:
  - A goal is proven if any of its child rapps is proven. Since we're
    iterating up from a proven child rapp, we mark goals as proven
    unconditionally. As a result, all child rapps of the goal become
    irrelevant.
  - A rapp is proven if all its child mvar clusters are proven. We must check
    whether this is the case. If so, the rapp is marked as proven and
    irrelevant. (Its children, being proven, are already marked as
    irrelevant.)
  - An mvar cluster is proven if any of its goals is proven. Since we're
    iterating up from a proven goal, we mark mvar clusters as proven
    unconditionally. As a result, all goals in the mvar cluster become
    irrelevant.
  -/
  preTraverseUp
    (λ gref => do
      let g ← gref.get
      gref.set $
        g.setState GoalState.provenByRuleApplication |>.setIsIrrelevant true
      g.children.forM λ rref => rref.markSubtreeIrrelevant
      return true)
    (λ rref => do
      let r ← rref.get
      if ! (← r.isProvenNoCache) then
        return false
      rref.set $ r.setState NodeState.proven |>.setIsIrrelevant true
      return true)
    (λ cref => do
      let c ← cref.get
      cref.set $ c.setState NodeState.proven |>.setIsIrrelevant true
      c.goals.forM λ gref => gref.markSubtreeIrrelevant
      return true)
    root

def GoalRef.markProvenByNormalization (gref : GoalRef) : BaseIO Unit := do
  let g ← gref.get
  gref.set $ g.setState GoalState.provenByNormalization |>.setIsIrrelevant true
  g.children.forM λ rref => rref.markSubtreeIrrelevant
    -- `g` should not have any children, but better safe than sorry.
  markProvenCore (TreeRef.mvarCluster g.parent)

def RappRef.markProven (rref : RappRef) : BaseIO Unit :=
  markProvenCore (TreeRef.rapp rref)

/-! ### Unprovable -/

-- A goal is unrovable if it is exhausted (i.e. we've applied all applicable
-- rules) and all resulting rule applications are unprovable.
def Goal.isUnprovableNoCache (g : Goal) : BaseIO Bool :=
  pure g.isForcedUnprovable <||> (
    g.isExhausted <&&>
    g.children.allM λ rref => return (← rref.get).state.isUnprovable)

-- A rapp is unprovable if any of its child mvar clusters are unprovable.
def Rapp.isUnprovableNoCache (r : Rapp) : BaseIO Bool :=
  r.children.anyM λ cref => return (← cref.get).state.isUnprovable

-- An mvar cluster is unprovable if all its goals are unprovable.
def MVarCluster.isUnprovableNoCache (c : MVarCluster) : BaseIO Bool := do
  c.goals.allM λ cref => return (← cref.get).state.isUnprovable

private def markUnprovableCore : TreeRef → BaseIO Unit :=
  /-
  We iterate up the tree, marking nodes as unprovable according to the rules
  of unprovability:
  - A goal is unprovable if it is exhausted and all its child rapps are
    unprovable. We must check whether this is the case. If so, the goal
    is marked as unprovable and irrelevant. (Its children, being unprovable,
    are already marked as irrelevant.)
  - A rapp is unprovable if any of its child mvar clusters is unprovable.
    Since we iterate up from an unprovable mvar cluster, we mark rapps as
    unprovable unconditionally. As a result, all mvar clusters of the rapp
    become irrelevant.
  - An mvar cluster is unprovable if all its goals are unprovable. We must
    check whether this is the case. If so, the cluster is marked as unprovable
    and irrelevant. (Its children, being unprovable, are already marked as
    irrelevant.)
  -/
  preTraverseUp
    (λ gref => do
      let g ← gref.get
      if ! (← g.isUnprovableNoCache) then
        return false
      gref.set $ g.setState GoalState.unprovable |>.setIsIrrelevant true
      return true)
    (λ rref => do
      let r ← rref.get
      rref.set $ r.setState NodeState.unprovable |>.setIsIrrelevant true
      r.children.forM λ cref => cref.markSubtreeIrrelevant
      return true)
    (λ cref => do
      let c ← cref.get
      if ! (← c.isUnprovableNoCache) then
        return false
      cref.set $ c.setState NodeState.unprovable |>.setIsIrrelevant true
      return true)

def GoalRef.markUnprovable (gref : GoalRef) : BaseIO Unit := do
  let g ← gref.get
  gref.set $ g.setState GoalState.unprovable |>.setIsIrrelevant true
  g.children.forM λ rref => rref.markSubtreeIrrelevant
  markUnprovableCore (TreeRef.mvarCluster g.parent)

def GoalRef.markForcedUnprovable (gref : GoalRef) : BaseIO Unit := do
  gref.modify (·.setIsForcedUnprovable true)
  gref.markUnprovable

def GoalRef.checkAndMarkUnprovable (gref : GoalRef) : BaseIO Unit :=
  markUnprovableCore (TreeRef.goal gref)


/-! ### Uncached Node States -/

/-
The following functions determine the state of a node (goal/rapp/mvar cluster),
assuming only that the state of the node's children is correct. So they can be
used to verify a tree 'bottom-up'.
-/

def Goal.stateNoCache (g : Goal) : BaseIO GoalState := do
  if g.isProvenByNormalizationNoCache then
    return GoalState.provenByNormalization
  else if ← g.isProvenByRuleApplicationNoCache then
    return GoalState.provenByRuleApplication
  else if ← g.isUnprovableNoCache then
    return GoalState.unprovable
  else
    return GoalState.unknown

def Rapp.stateNoCache (r : Rapp) : BaseIO NodeState := do
  if ← r.isProvenNoCache then
    return NodeState.proven
  else if ← r.isUnprovableNoCache then
    return NodeState.unprovable
  else
    return NodeState.unknown

def MVarCluster.stateNoCache (c : MVarCluster) : BaseIO NodeState := do
  if ← c.isProvenNoCache then
    return NodeState.proven
  else if ← c.isUnprovableNoCache then
    return NodeState.unprovable
  else
    return NodeState.unknown

end Aesop



=== LEAN SOURCE: Tracing.lean ===
import Aesop.Tree.RunMetaM
import Aesop.Tracing

open Lean
open MessageData

namespace Aesop

private def toYesNo : Bool → String
  | true => "yes"
  | false => "no"

def Goal.withHeadlineTraceNode (g : Goal) (traceOpt : TraceOption) (k : MetaM α)
    (collapsed := true) (transform : MessageData → MetaM MessageData := pure) :
    MetaM α := do
  withConstAesopTraceNode traceOpt fmt k collapsed
  where
    fmt : MetaM MessageData := do
      g.runMetaMInParentState' do
        g.preNormGoal.withContext do
          addMessageContext $ ← transform
            m!"{g.state.toEmoji} G{g.id} [{g.priority.toHumanString}] ⋯ ⊢ {← g.preNormGoal.getType}"

def Goal.traceMetadata (g : Goal) (traceOpt : TraceOption) : MetaM Unit := do
  if ! (← traceOpt.isEnabled) then
    return
  trc m!"ID: {g.id}"
  trcNode m!"Pre-normalisation goal ({g.preNormGoal.name}):" do
    g.runMetaMInParentState' do
      trc m!"{g.preNormGoal}"
  match g.postNormGoalAndMetaState? with
  | none =>
    trc m!"Post-normalisation goal: <goal not normalised>"
  | some (goal, state) =>
    state.runMetaM' do
      trcNode m!"Post-normalisation goal ({goal.name}):" do
        trc m!"{goal}"
  trc m!"Metavariables: {g.mvars.toArray.map (·.name)}"
  trc m!"Parent rapp:  {← (← g.parentRapp?).mapM λ rref => (·.id) <$> rref.get}"
  trc m!"Child rapps:  {← g.children.mapM λ rref => (·.id) <$> rref.get}"
  trc m!"Origin: {g.origin.toString}"
  trc m!"Depth: {g.depth}"
  trc m!"State: {g.state.toEmoji} {g.state}"
  trc m!"Forward rule matches: {g.forwardRuleMatches.size}"
  trc m!"Irrelevant: {toYesNo g.isIrrelevant}"
  trc m!"Forced unprovable: {toYesNo g.isForcedUnprovable}"
  trc m!"Added in iteration: {g.addedInIteration}"
  trc m!"Last expanded in iteration: {if g.lastExpandedInIteration == .none then "never" else toString $ g.lastExpandedInIteration}"
  trcNode m!"Forward state" do
    match g.postNormGoalAndMetaState? with
    | some (mvarId, metaState) =>
      metaState.runMetaM' do mvarId.withContext do
        trc $ toMessageData g.forwardState
    | none =>
      g.runMetaMInParentState' do g.preNormGoal.withContext do
        trc $ toMessageData g.forwardState
  if g.unsafeRulesSelected then
    if g.unsafeQueue.isEmpty then
      trc m!"Unsafe rule queue: <empty>"
    else
      trcNode m!"Unsafe rule queue:" do
        for r in g.unsafeQueue.toArray do
          trc m!"[{r.successProbability.toHumanString}] {r.name}"
  else
    trc m!"Unsafe rule queue: <not selected>"
  if g.failedRapps.isEmpty then
    trc m!"Failed rules: <none>"
  else
    trcNode m!"Failed rules:" do
      for r in g.failedRapps do
        trc m!"[{r.successProbability.toHumanString}] {r.name}"
  where
    trc msg : MetaM Unit := do aesop_trace![traceOpt] msg

    trcNode msg (k : MetaM Unit) : MetaM Unit :=
      withConstAesopTraceNode traceOpt (return msg) k

def Rapp.withHeadlineTraceNode (r : Rapp) (traceOpt : TraceOption) (k : MetaM α)
    (collapsed := true) (transform : MessageData → MetaM MessageData := pure) :
    MetaM α :=
  withConstAesopTraceNode traceOpt
    (transform m!"{r.state.toEmoji} R{r.id} [{r.successProbability.toHumanString}] {r.appliedRule.name}")
    k collapsed

def Rapp.traceMetadata (r : Rapp) (traceOpt : TraceOption) : MetaM Unit := do
  if ! (← traceOpt.isEnabled) then
    return
  trc m!"ID: {r.id}"
  trc m!"Rule: {r.appliedRule}"
  trc m!"Success probability: {r.successProbability.toHumanString}"
  trc m!"Parent goal: {(← r.parent.get).id}"
  trc m!"Child goals: {← (← r.subgoals).mapM λ gref => (·.id) <$> gref.get}"
  trc m!"State: {r.state}"
  trc m!"Irrelevant: {r.isIrrelevant}"
  trc m!"Introduced metavariables: {r.introducedMVars.toArray.map (·.name)}"
  trc m!"Assigned   metavariables: {r.assignedMVars.toArray.map (·.name)}"
  where
    trc m : MetaM Unit := do aesop_trace![traceOpt] m

mutual
  partial def Goal.traceTreeCore (g : Goal) (traceOpt : TraceOption) :
      MetaM Unit :=
    g.withHeadlineTraceNode traceOpt (collapsed := false) do
      g.runMetaMInParentState' do
        aesop_trace![traceOpt] g.preNormGoal
      withConstAesopTraceNode traceOpt (return "Metadata") do
        g.traceMetadata traceOpt
      for rref in g.children do
        (← rref.get).traceTreeCore traceOpt

  partial def Rapp.traceTreeCore (r : Rapp) (traceOpt : TraceOption) :
      MetaM Unit := do
    r.withHeadlineTraceNode traceOpt (collapsed := false) do
      withConstAesopTraceNode traceOpt (return "Metadata") do
        r.traceMetadata traceOpt
      r.forSubgoalsM λ gref => do
        (← gref.get).traceTreeCore traceOpt
end

def Goal.traceTree (g : Goal) (traceOpt : TraceOption) : MetaM Unit := do
  if ← traceOpt.isEnabled then
    g.traceTreeCore traceOpt

def Rapp.traceTree (r : Rapp) (traceOpt : TraceOption) : MetaM Unit := do
  if ← traceOpt.isEnabled then
    r.traceTreeCore traceOpt

end Aesop



=== LEAN SOURCE: Traversal.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Tree.Data

namespace Aesop

inductive TreeRef
  | goal (gref : GoalRef)
  | rapp (rref : RappRef)
  | mvarCluster (cref : MVarClusterRef)

section

open TreeRef

variable
  {m} [Monad m] [MonadLiftT (ST IO.RealWorld) m]
  (visitGoalPre : GoalRef → m Bool)
  (visitGoalPost : GoalRef → m Unit)
  (visitRappPre : RappRef → m Bool)
  (visitRappPost : RappRef → m Unit)
  (visitMVarClusterPre : MVarClusterRef → m Bool)
  (visitMVarClusterPost : MVarClusterRef → m Unit)

@[specialize]
partial def traverseDown : TreeRef → m Unit
  | goal gref => do
    if ← visitGoalPre gref then
      (← gref.get).children.forM (traverseDown ∘ rapp)
      visitGoalPost gref
  | rapp rref => do
    if ← visitRappPre rref then
      (← rref.get).children.forM (traverseDown ∘ mvarCluster)
      visitRappPost rref
  | mvarCluster cref => do
    if ← visitMVarClusterPre cref then
      (← cref.get).goals.forM (traverseDown ∘ goal)
      visitMVarClusterPost cref

@[specialize]
partial def traverseUp : TreeRef → m Unit
  | goal gref => do
    if ← visitGoalPre gref then
      traverseUp $ mvarCluster (← gref.get).parent
      visitGoalPost gref
  | rapp rref => do
    if ← visitRappPre rref then
      traverseUp $ goal (← rref.get).parent
      visitRappPost rref
  | mvarCluster cref => do
    if ← visitMVarClusterPre cref then
      if let (some parent) := (← cref.get).parent? then
        traverseUp $ rapp parent
      visitMVarClusterPost cref

end

variable [Monad m] [MonadLiftT (ST IO.RealWorld) m]

@[inline]
def preTraverseDown (visitGoal : GoalRef → m Bool)
    (visitRapp : RappRef → m Bool) (visitMVarCluster : MVarClusterRef → m Bool) :
    TreeRef → m Unit :=
  traverseDown
    visitGoal
    (λ _ => pure ())
    visitRapp
    (λ _ => pure ())
    visitMVarCluster
    (λ _ => pure ())

@[inline]
def preTraverseUp (visitGoal : GoalRef → m Bool) (visitRapp : RappRef → m Bool)
    (visitMVarCluster : MVarClusterRef → m Bool) : TreeRef → m Unit :=
  traverseUp
    visitGoal
    (λ _ => pure ())
    visitRapp
    (λ _ => pure ())
    visitMVarCluster
    (λ _ => pure ())

@[inline]
def postTraverseDown (visitGoal : GoalRef → m Unit)
    (visitRapp : RappRef → m Unit) (visitMVarCluster : MVarClusterRef → m Unit) :
    TreeRef → m Unit :=
  traverseDown
    (λ _ => pure true)
    visitGoal
    (λ _ => pure true)
    visitRapp
    (λ _ => pure true)
    visitMVarCluster

@[inline]
def postTraverseUp (visitGoal : GoalRef → m Unit) (visitRapp : RappRef → m Unit)
    (visitMVarCluster : MVarClusterRef → m Unit) : TreeRef → m Unit :=
  traverseUp
    (λ _ => pure true)
    visitGoal
    (λ _ => pure true)
    visitRapp
    (λ _ => pure true)
    visitMVarCluster

end Aesop



=== LEAN SOURCE: TreeM.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Forward.State.Initial
import Aesop.RuleSet
import Aesop.Tree.Data

open Lean
open Lean.Meta

namespace Aesop

structure Tree where
  root : MVarClusterRef
  rootMetaState : Meta.SavedState
  numGoals : Nat
  numRapps : Nat
  nextGoalId : GoalId
  nextRappId : RappId
  /--
  Union of the mvars introduced by all rapps.
  -/
  allIntroducedMVars : Std.HashSet MVarId

def mkInitialTree (goal : MVarId) (rs : LocalRuleSet) : BaseM Tree := do
  let rootClusterRef ← IO.mkRef $ MVarCluster.mk {
    parent? := none
    goals := #[] -- patched up below
    isIrrelevant := false
    state := NodeState.unknown
  }
  let (forwardState, ms) ← withConstAesopTraceNode .forward (return m!"building initial forward state") do
    rs.mkInitialForwardState goal
  let rootGoalRef ← IO.mkRef $ Goal.mk {
    id := GoalId.zero
    parent := rootClusterRef
    children := #[]
    origin := .subgoal
    depth := 0
    state := GoalState.unknown
    isIrrelevant := false
    isForcedUnprovable := false
    preNormGoal := goal
    normalizationState := NormalizationState.notNormal
    mvars := .ofHashSet (← goal.getMVarDependencies)
    forwardState
    forwardRuleMatches := .ofArray ms
    successProbability := Percent.hundred
    addedInIteration := Iteration.one
    lastExpandedInIteration := Iteration.none
    unsafeRulesSelected := false
    unsafeQueue := {}
    failedRapps := #[]
  }
  rootClusterRef.modify λ c => c.setGoals #[rootGoalRef]
  return {
    root := rootClusterRef
    rootMetaState := ← saveState
    numGoals := 1
    numRapps := 0
    nextGoalId := .one
    nextRappId := .zero
    allIntroducedMVars := ∅
  }

structure TreeM.Context where
  currentIteration : Iteration
  ruleSet : LocalRuleSet

structure TreeM.State where
  tree : Tree

abbrev TreeM := ReaderT TreeM.Context $ StateRefT TreeM.State BaseM

namespace TreeM

-- Generate specialized pure/bind implementations so we don't need to optimise
-- them on the fly at each use site.
instance : Monad TreeM :=
  { inferInstanceAs (Monad TreeM) with }

instance (priority := low) : MonadStateOf Tree TreeM where
  get := return (← getThe State).tree
  set tree := modifyThe State ({ · with tree })
  modifyGet f := modifyGetThe State λ s =>
    let (a, tree) := f s.tree
    (a, { s with tree })

instance : Inhabited (TreeM α) where
  default := failure

def run' (ctx : TreeM.Context) (tree : Tree) (x : TreeM α) :
    BaseM (α × TreeM.State) :=
  ReaderT.run x ctx |>.run { tree }

end TreeM

def getRootMVarCluster : TreeM MVarClusterRef :=
  return (← getThe Tree).root

def getRootMetaState : TreeM Meta.SavedState :=
  return (← getThe Tree).rootMetaState

def getRootGoal : TreeM GoalRef := do
  let cref ← getRootMVarCluster
  let grefs := (← cref.get).goals
  if h : grefs.size = 1 then
    return grefs[0]
  else
    throwError "aesop: internal error: unexpected number of goals in root mvar cluster: {grefs.size}"

def getRootMVarId : TreeM MVarId := do
  let gref ← getRootGoal
  return (← gref.get).preNormGoal

def incrementNumGoals (increment := 1) : TreeM Unit := do
  modifyThe Tree λ s => { s with numGoals := s.numGoals + increment }

def incrementNumRapps (increment := 1) : TreeM Unit := do
  modifyThe Tree λ s => { s with numRapps := s.numRapps + increment }

def getAllIntroducedMVars : TreeM (Std.HashSet MVarId) :=
  return (← getThe Tree).allIntroducedMVars

def getAndIncrementNextGoalId : TreeM GoalId := do
  modifyGetThe Tree λ t =>
    let curr := t.nextGoalId
    (curr, { t with nextGoalId := curr.succ })

def getAndIncrementNextRappId : TreeM RappId := do
  modifyGetThe Tree λ t =>
    let curr := t.nextRappId
    (curr, { t with nextRappId := curr.succ })

end Aesop



=== LEAN SOURCE: UnsafeQueue.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Constants
import Aesop.Rule

open Lean

namespace Aesop

structure PostponedSafeRule where
  rule : SafeRule
  output : RuleTacOutput
  deriving Inhabited

namespace PostponedSafeRule

def toUnsafeRule (r : PostponedSafeRule) : UnsafeRule :=
  { r.rule with extra := ⟨postponedSafeRuleSuccessProbability⟩ }

end PostponedSafeRule


inductive UnsafeQueueEntry
  | unsafeRule (r : IndexMatchResult UnsafeRule)
  | postponedSafeRule (r : PostponedSafeRule)
  deriving Inhabited

namespace UnsafeQueueEntry

instance : ToString UnsafeQueueEntry where
  toString
    | unsafeRule        r => toString r.rule.name
    | postponedSafeRule r => toString r.rule.name

def successProbability : UnsafeQueueEntry → Percent
  | unsafeRule r => r.rule.extra.successProbability
  | postponedSafeRule .. => postponedSafeRuleSuccessProbability

def name : UnsafeQueueEntry → RuleName
  | unsafeRule r => r.rule.name
  | postponedSafeRule r => r.rule.name

instance : Ord UnsafeQueueEntry :=
  ⟨ compareLex
      (λ x y => compareOn successProbability x y |>.swap)
      (compareOn name) ⟩

end UnsafeQueueEntry


def UnsafeQueue := Subarray UnsafeQueueEntry

namespace UnsafeQueue

instance : EmptyCollection UnsafeQueue :=
  inferInstanceAs $ EmptyCollection (Subarray _)

instance : Inhabited UnsafeQueue :=
  inferInstanceAs $ Inhabited (Subarray _)

-- Precondition: `unsafeRules` is ordered lexicographically by descending
-- success probability, then by rule name.
def initial (postponedSafeRules : Array PostponedSafeRule)
    (unsafeRules : Array (IndexMatchResult UnsafeRule)) : UnsafeQueue :=
  let unsafeRules := unsafeRules.map .unsafeRule
  let postponedSafeRules :=
    postponedSafeRules.map .postponedSafeRule
      |>.qsort (λ x y => compare x y |>.isLT)
  postponedSafeRules.mergeDedup unsafeRules |>.toSubarray

def entriesToMessageData (q : UnsafeQueue) : Array MessageData :=
  q.toArray.map toMessageData

end UnsafeQueue

end Aesop



=== LEAN SOURCE: ForwardRuleMatches.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Forward.Match
import Aesop.Rule

set_option linter.missingDocs true

open Lean Lean.Meta

namespace Aesop

/-- Sets of complete matches for norm/safe/unsafe rules. -/
structure ForwardRuleMatches where
  /-- Complete matches of norm rules. -/
  normMatches   : PHashSet ForwardRuleMatch
  /-- Complete matches of safe rules. -/
  safeMatches   : PHashSet ForwardRuleMatch
  /-- Complete matches of unsafe rules. -/
  unsafeMatches : PHashSet ForwardRuleMatch
  deriving Inhabited

namespace ForwardRuleMatches

/-- Empty `ForwardRuleMatches`. -/
protected def empty : ForwardRuleMatches where
  normMatches := ∅
  safeMatches := ∅
  unsafeMatches := ∅

instance : EmptyCollection ForwardRuleMatches :=
  ⟨.empty⟩

/-- Add a complete match. -/
def insert (m : ForwardRuleMatch) (ms : ForwardRuleMatches) :
    ForwardRuleMatches :=
  match m.rule.name.phase with
  | .norm =>   { ms with normMatches   := ms.normMatches.insert   m }
  | .safe =>   { ms with safeMatches   := ms.safeMatches.insert   m }
  | .unsafe => { ms with unsafeMatches := ms.unsafeMatches.insert m }

/-- Add several complete matches. -/
def insertMany (ms : Array ForwardRuleMatch) (ms' : ForwardRuleMatches) :
    ForwardRuleMatches :=
  ms.foldl (init := ms') λ ms' m => ms'.insert m

/-- Erase a complete match. -/
def erase (m : ForwardRuleMatch) (ms : ForwardRuleMatches) :
    ForwardRuleMatches :=
  match m.rule.name.phase with
  | .norm =>   { ms with normMatches   := ms.normMatches.erase m }
  | .safe =>   { ms with safeMatches   := ms.safeMatches.erase m }
  | .unsafe => { ms with unsafeMatches := ms.unsafeMatches.erase m }

/-- Erase several complete matches. -/
def eraseMany (ms : Array ForwardRuleMatch) (ms' : ForwardRuleMatches) :
    ForwardRuleMatches :=
  ms.foldl (init := ms') λ ms' m => ms'.erase m

/-- Build a `ForwardRuleMatches` structure containing the matches from `ms`. -/
def ofArray (ms : Array ForwardRuleMatch) : ForwardRuleMatches :=
  (∅ : ForwardRuleMatches).insertMany ms

/-- Erase matches containing any of the hypotheses `hs` from `ms`. -/
def eraseHyps (hs : Std.HashSet FVarId) (ms : ForwardRuleMatches) :
    ForwardRuleMatches where
  normMatches   := go ms.normMatches
  safeMatches   := go ms.safeMatches
  unsafeMatches := go ms.unsafeMatches
where
  go (ms : PHashSet ForwardRuleMatch) : PHashSet ForwardRuleMatch :=
    let toErase := ms.fold (init := #[]) λ toErase m =>
      if m.anyHyp hs.contains then toErase.push m else toErase
    toErase.foldl (init := ms) λ ms m => ms.erase m

/-- Erase matches containing the hypothesis `h` from `ms`. -/
def eraseHyp (h : FVarId) (ms : ForwardRuleMatches) : ForwardRuleMatches :=
  ms.eraseHyps {h}

/-- Update the `ForwardRuleMatches` of a goal so that they are suitable for a
child goal. `newMatches` are new forward rule matches obtained by updating the
old goal's `ForwardState` with new hypotheses from the new goal. `erasedHyps`
are the hypotheses from the old goal that no longer appear in the new goal.
`consumedForwardRuleMatches` contains forward rule matches that were applied as
rules to transform the old goal into the new goal. -/
def update (newMatches : Array ForwardRuleMatch)
    (erasedHyps : Std.HashSet FVarId)
    (consumedForwardRuleMatches : Array ForwardRuleMatch)
    (forwardRuleMatches : ForwardRuleMatches) : ForwardRuleMatches := Id.run do
  let mut ms := forwardRuleMatches
  for m in consumedForwardRuleMatches do
    ms := ms.erase m
  return forwardRuleMatches.eraseHyps erasedHyps |>.insertMany newMatches

private def pHashSetToArray [BEq α] [Hashable α] (s : PHashSet α) : Array α :=
  s.fold (init := #[]) λ acc x => acc.push x

/-- Get the norm rules corresponding to the norm rule matches. -/
def normRules (ms : ForwardRuleMatches) : Array NormRule :=
  forwardRuleMatchesToNormRules? (pHashSetToArray ms.normMatches) |>.get!

/-- Get the safe rules corresponding to the safe rule matches. -/
def safeRules (ms : ForwardRuleMatches) : Array SafeRule :=
  forwardRuleMatchesToSafeRules? (pHashSetToArray ms.safeMatches) |>.get!

/-- Get the unsafe rules corresponding to the unsafe rule matches. -/
def unsafeRules (ms : ForwardRuleMatches) : Array UnsafeRule :=
  forwardRuleMatchesToUnsafeRules? (pHashSetToArray ms.unsafeMatches) |>.get!

/-- `O(n)` Number of matches in `ms`. -/
def size (ms : ForwardRuleMatches) : Nat :=
  ms.normMatches.fold   (init := 0) (λ n _ => n + 1) +
  ms.safeMatches.fold   (init := 0) (λ n _ => n + 1) +
  ms.unsafeMatches.fold (init := 0) (λ n _ => n + 1)

end ForwardRuleMatches

end Aesop



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg, Asta Halkjær From
-/

import Aesop.Index.DiscrTreeConfig
import Aesop.Nanos
import Aesop.Util.UnorderedArraySet
import Batteries.Lean.Expr
import Batteries.Data.String.Basic
import Lean
import Std.Data.HashSet.Basic

open Lean
open Lean.Meta Lean.Elab.Tactic

namespace Aesop

@[inline]
def time [Monad m] [MonadLiftT BaseIO m] (x : m α) : m (α × Aesop.Nanos) := do
  let start ← IO.monoNanosNow
  let a ← x
  let stop ← IO.monoNanosNow
  return (a, ⟨stop - start⟩)

@[inline]
def time' [Monad m] [MonadLiftT BaseIO m] (x : m Unit) : m Aesop.Nanos := do
  let start ← IO.monoNanosNow
  x
  let stop ← IO.monoNanosNow
  return ⟨stop - start⟩

namespace PersistentHashSet

variable [BEq α] [Hashable α]

-- Elements are returned in unspecified order.
@[inline]
def toList (s : PersistentHashSet α) : List α :=
  s.fold (init := []) λ as a => a :: as

-- Elements are returned in unspecified order. (In fact, they are currently
-- returned in reverse order of `toList`.)
@[inline]
def toArray (s : PersistentHashSet α) : Array α :=
  s.fold (init := #[]) λ as a => as.push a

def toHashSet (s : PHashSet α) : Std.HashSet α :=
  s.fold (init := ∅) fun result a ↦ result.insert a

def filter (p : α → Bool) (s : PHashSet α) : PHashSet α :=
  s.fold (init := s) λ s a => if p a then s else s.erase a

end PersistentHashSet

-- TODO upstream; generalise to {m : Type u → Type v}.
-- Need to generalise `HashMap.forM` first.
scoped instance {m : Type u → Type u} [BEq α] [Hashable α] :
    ForM m (Std.HashMap α β) (α × β) where
  forM | m, f => m.forM λ a b => f (a, b)

-- TODO upstream; generalise to {m : Type u → Type v}.
scoped instance {m : Type u → Type u} [BEq α] [Hashable α] :
    ForIn m (Std.HashMap α β) (α × β) where
  forIn := ForM.forIn

section DiscrTree

open DiscrTree

-- For `type = ∀ (x₁, ..., xₙ), T`, returns keys that match `T * ... *` (with
-- `n` stars).

def getConclusionDiscrTreeKeys (type : Expr) : MetaM (Array Key) :=
  withoutModifyingState do
    let (_, _, conclusion) ← forallMetaTelescope type
    mkDiscrTreePath conclusion
    -- We use a meta telescope because `DiscrTree.mkPath` ignores metas (they
    -- turn into `Key.star`) but not fvars.

-- For a constant `d` with type `∀ (x₁, ..., xₙ), T`, returns keys that
-- match `d * ... *` (with `n` stars).
def getConstDiscrTreeKeys (decl : Name) : MetaM (Array Key) := do
  let arity := (← getConstInfo decl).type.getNumHeadForalls
  let mut keys := Array.mkEmpty (arity + 1)
  keys := keys.push $ .const decl arity
  for _ in [0:arity] do
    keys := keys.push $ .star
  return keys

def isEmptyTrie : Trie α → Bool
  | .node vs children => vs.isEmpty && children.isEmpty

@[specialize]
private partial def filterTrieM [Monad m] [Inhabited σ] (f : σ → α → m σ)
    (p : α → m (ULift Bool)) (init : σ) : Trie α → m (Trie α × σ)
  | .node vs children => do
    let (vs, acc) ← vs.foldlM (init := (#[], init)) λ (vs, acc) v => do
      if (← p v).down then
        return (vs.push v, acc)
      else
        return (vs, ← f acc v)
    let (children, acc) ← go acc 0 children
    let children := children.filter λ (_, c) => ! isEmptyTrie c
    return (.node vs children, acc)
  where
    go (acc : σ) (i : Nat) (children : Array (Key × Trie α)) :
        m (Array (Key × Trie α) × σ) := do
      if h : i < children.size then
        let (key, t) := children[i]'h
        let (t, acc) ← filterTrieM f p acc t
        go acc (i + 1) (children.set i (key, t))
      else
        return (children, acc)

/--
Remove elements for which `p` returns `false` from the given `DiscrTree`.
The removed elements are monadically folded over using `f` and `init`, so `f`
is called once for each removed element and the final state of type `σ` is
returned.
-/
@[specialize]
def filterDiscrTreeM [Monad m] [Inhabited σ] (p : α → m (ULift Bool))
    (f : σ → α → m σ) (init : σ) (t : DiscrTree α) :
    m (DiscrTree α × σ) := do
  let (root, acc) ←
    t.root.foldlM (init := (.empty, init)) λ (root, acc) key t => do
      let (t, acc) ← filterTrieM f p acc t
      let root := if isEmptyTrie t then root else root.insert key t
      return (root, acc)
  return (⟨root⟩, acc)

/--
Remove elements for which `p` returns `false` from the given `DiscrTree`.
The removed elements are folded over using `f` and `init`, so `f` is called
once for each removed element and the final state of type `σ` is returned.
-/
def filterDiscrTree [Inhabited σ] (p : α → Bool) (f : σ → α → σ) (init : σ)
    (t : DiscrTree α) : DiscrTree α × σ := Id.run $
  filterDiscrTreeM (λ a => pure ⟨p a⟩) (λ s a => pure (f s a)) init t

end DiscrTree

namespace SimpTheorems

def addSimpEntry (s : SimpTheorems) : SimpEntry → SimpTheorems
  | SimpEntry.thm l =>
    { s.addSimpTheorem l with erased := s.erased.erase l.origin }
  | SimpEntry.toUnfold d =>
    { s with toUnfold := s.toUnfold.insert d }
  | SimpEntry.toUnfoldThms n thms => s.registerDeclToUnfoldThms n thms

def foldSimpEntriesM [Monad m] (f : σ → SimpEntry → m σ) (init : σ)
    (thms : SimpTheorems) : m σ := do
  let s ← thms.pre.foldValuesM  (init := init) processTheorem
  let s ← thms.post.foldValuesM (init := s)    processTheorem
  let s ← thms.toUnfold.foldM (init := s) λ s n => f s (SimpEntry.toUnfold n)
  thms.toUnfoldThms.foldlM (init := s) λ s n thms =>
    f s (SimpEntry.toUnfoldThms n thms)
  where
    @[inline]
    processTheorem (s : σ) (thm : SimpTheorem) : m σ :=
      if thms.erased.contains thm.origin then
        return s
      else
        f s (SimpEntry.thm thm)

def foldSimpEntries (f : σ → SimpEntry → σ) (init : σ) (thms : SimpTheorems) :
    σ :=
  Id.run $ foldSimpEntriesM f init thms

def simpEntries (thms : SimpTheorems) : Array SimpEntry :=
  foldSimpEntries (thms := thms) (init := #[]) λ s thm => s.push thm

def containsDecl (thms : SimpTheorems) (decl : Name) : Bool :=
  thms.isLemma (.decl decl) ||
  thms.isDeclToUnfold decl ||
  thms.toUnfoldThms.contains decl

end SimpTheorems


section ForEachExpr

variable {ω : Type} {m : Type → Type} [STWorld ω m] [MonadLiftT (ST ω) m]
    [Monad m] [MonadControlT MetaM m] [MonadLiftT MetaM m]

def forEachExprInLDeclCore (ldecl : LocalDecl) (g : Expr → m Bool) :
    MonadCacheT Expr Unit m Unit := do
  if ! ldecl.isImplementationDetail then
    ForEachExpr.visit g ldecl.toExpr
    ForEachExpr.visit g ldecl.type
    if let some value := ldecl.value? then
      ForEachExpr.visit g value

@[inline, always_inline]
def forEachExprInLDecl' (ldecl : LocalDecl) (g : Expr → m Bool) :
    m Unit :=
  forEachExprInLDeclCore ldecl g |>.run

@[inline, always_inline]
def forEachExprInLDecl (ldecl : LocalDecl) (g : Expr → m Unit) :
    m Unit :=
  forEachExprInLDeclCore ldecl (λ e => do g e; return true) |>.run

@[inline, always_inline]
def forEachExprInLCtxCore (lctx : LocalContext) (g : Expr → m Bool) :
    MonadCacheT Expr Unit m Unit :=
  for ldecl in lctx do
    forEachExprInLDeclCore ldecl g

@[inline, always_inline]
def forEachExprInLCtx' (mvarId : MVarId) (g : Expr → m Bool) : m Unit :=
  mvarId.withContext do
    forEachExprInLCtxCore (← mvarId.getDecl).lctx g |>.run

@[inline, always_inline]
def forEachExprInLCtx (mvarId : MVarId) (g : Expr → m Unit) : m Unit :=
  forEachExprInLCtx' mvarId (λ e => do g e; return true)

@[inline, always_inline]
def forEachExprInGoalCore (mvarId : MVarId) (g : Expr → m Bool) :
    MonadCacheT Expr Unit m Unit :=
  mvarId.withContext do
    forEachExprInLCtxCore (← mvarId.getDecl).lctx g
    ForEachExpr.visit g (← mvarId.getType)

@[inline, always_inline]
def forEachExprInGoal' (mvarId : MVarId) (g : Expr → m Bool) : m Unit :=
  forEachExprInGoalCore mvarId g |>.run

@[inline, always_inline]
def forEachExprInGoal (mvarId : MVarId) (g : Expr → m Unit) : m Unit :=
  forEachExprInGoal' mvarId λ e => do g e; return true

end ForEachExpr


@[inline]
def setThe (σ) {m} [MonadStateOf σ m] (s : σ) : m PUnit :=
  MonadStateOf.set s

@[inline]
def runMetaMAsCoreM (x : MetaM α) : CoreM α :=
  Prod.fst <$> x.run {} {}

@[inline]
def runTermElabMAsCoreM (x : Elab.TermElabM α) : CoreM α :=
  runMetaMAsCoreM x.run'

def runTacticMAsMetaM (x : TacticM α) (goals : List MVarId) :
    MetaM (α × List MVarId) := do
  let (a, s) ← x |>.run { elaborator := .anonymous } |>.run { goals } |>.run'
  return (a, s.goals)

def runTacticSyntaxAsMetaM (stx : Syntax) (goals : List MVarId) :
    MetaM (List MVarId) :=
  return (← runTacticMAsMetaM (evalTactic stx) goals).snd


def updateSimpEntryPriority (priority : Nat) (e : SimpEntry) : SimpEntry :=
  match e with
  | .thm t => .thm { t with priority }
  | .toUnfoldThms .. | .toUnfold .. => e

def getMVarDependencies (e : Expr) : MetaM (Std.HashSet MVarId) := do
  let (_, deps) ←
    Lean.MVarId.getMVarDependencies.addMVars (includeDelayed := true) e
    |>.run {}
  return deps

partial def hasSorry [Monad m] [MonadMCtx m] (e : Expr) : m Bool :=
  return go (← getMCtx) e
where
  go (mctx : MetavarContext) (e : Expr) : Bool :=
    Option.isSome $ e.find? λ e =>
      if e.isSorry then
        true
      else if let .mvar mvarId := e then
        if let some ass := mctx.getExprAssignmentCore? mvarId then
          go mctx ass
        else if let some ass := mctx.dAssignment.find? mvarId then
          go mctx $ .mvar ass.mvarIdPending
        else
          false
      else
        false

def isAppOfUpToDefeq (f : Expr) (e : Expr) : MetaM Bool :=
  withoutModifyingState do
    let type ← inferType f
    let (mvars, _, _) ← forallMetaTelescope type
    let app := mkAppN f mvars
    if ← isDefEq app e then
      return true
    else
      return false

/--
If the input expression `e` reduces to `f x₁ ... xₙ` via repeated `whnf`, this
function returns `f` and `[x₁, ⋯, xₙ]`. Otherwise it returns `e` (unchanged, not
in WHNF!) and `[]`.
-/
partial def getAppUpToDefeq (e : Expr) : MetaM (Expr × Array Expr) :=
  go #[] e
where
  go (args : Array Expr) (e : Expr) : MetaM (Expr × Array Expr) := do
    match ← whnf e with
    | .app f e => go (args.push e) f
    | _ => return (e, args.reverse)

/--
Partition an array of structures containing `MVarId`s into 'goals' and
'proper mvars'. An `MVarId` from the input array `goals` is classified as a
proper mvar if any of the `MVarId`s depend on it, and as a goal otherwise.
Additionally, for each goal, we report the set of mvars that the goal depends
on.
-/
def partitionGoalsAndMVars (mvarId : α → MVarId) (goals : Array α) :
    MetaM (Array (α × UnorderedArraySet MVarId) × UnorderedArraySet MVarId) := do
  let mut goalsAndMVars := #[]
  let mut mvars : UnorderedArraySet MVarId := {}
  for g in goals do
    let gMVars ← .ofHashSet <$> (mvarId g).getMVarDependencies
    mvars := mvars.merge gMVars
    goalsAndMVars := goalsAndMVars.push (g, gMVars)
  let goals :=
    if mvars.isEmpty then
      goalsAndMVars
    else
      goalsAndMVars.filter λ (g, _) => ! mvars.contains (mvarId g)
  return (goals, mvars)

section RunTactic

open Lean.Elab.Tactic

def runTacticMCapturingPostState (t : TacticM Unit) (preState : Meta.SavedState)
    (preGoals : List MVarId) : MetaM (Meta.SavedState × List MVarId) :=
  withoutModifyingState do
    let go : TacticM (Meta.SavedState × List MVarId) := do
      preState.restore
      t
      pruneSolvedGoals
      let postState ← show MetaM _ from saveState
      let postGoals ← getGoals
      pure (postState, postGoals)
    go |>.run { elaborator := .anonymous, recover := false }
       |>.run' { goals := preGoals }
       |>.run'

def runTacticCapturingPostState (t : Syntax.Tactic) (preState : Meta.SavedState)
    (preGoals : List MVarId) : MetaM (Meta.SavedState × List MVarId) := do
  runTacticMCapturingPostState (evalTactic t) preState preGoals

def runTacticSeqCapturingPostState (t : TSyntax ``Lean.Parser.Tactic.tacticSeq)
    (preState : Meta.SavedState) (preGoals : List MVarId) :
    MetaM (Meta.SavedState × List MVarId) := do
  runTacticMCapturingPostState (evalTactic t) preState preGoals

def runTacticsCapturingPostState (ts : Array Syntax.Tactic)
    (preState : Meta.SavedState) (preGoals : List MVarId) :
    MetaM (Meta.SavedState × List MVarId) := do
  let t ← `(Lean.Parser.Tactic.tacticSeq| $ts*)
  runTacticSeqCapturingPostState t preState preGoals

end RunTactic

section TransparencySyntax

variable [Monad m] [MonadQuotation m]

open Parser.Tactic

def withTransparencySeqSyntax (md : TransparencyMode)
    (k : TSyntax ``tacticSeq) : TSyntax ``tacticSeq := Unhygienic.run do
  match md with
  | .default => return k
  | .all => `(tacticSeq| with_unfolding_all $k)
  | .reducible => `(tacticSeq| with_reducible $k)
  | .instances => `(tacticSeq| with_reducible_and_instances $k)

def withAllTransparencySeqSyntax (md : TransparencyMode)
    (k : TSyntax ``tacticSeq) : TSyntax ``tacticSeq :=
  match md with
  | .all => Unhygienic.run `(tacticSeq| with_unfolding_all $k)
  | _ => k

def withTransparencySyntax (md : TransparencyMode) (k : TSyntax `tactic) :
    TSyntax `tactic := Unhygienic.run do
  match md with
  | .default   => return k
  | .all       => `(tactic| with_unfolding_all $k:tactic)
  | .reducible => `(tactic| with_reducible $k:tactic)
  | .instances => `(tactic| with_reducible_and_instances $k:tactic)

def withAllTransparencySyntax (md : TransparencyMode) (k : TSyntax `tactic) :
    TSyntax `tactic :=
  match md with
  | .all  => Unhygienic.run `(tactic| with_unfolding_all $k:tactic)
  | _     => k

end TransparencySyntax

/--
Register a "Try this" suggestion for a tactic sequence.

It works when the tactic to replace appears on its own line:

```lean
by
  aesop?
```

It doesn't work (i.e., the suggestion will appear but in the wrong place) when
the tactic to replace is preceded by other text on the same line:

```lean
have x := by aesop?
```

The `Try this:` suggestion in the infoview is not correctly formatted, but
there's nothing we can do about this at the moment.
-/
def addTryThisTacticSeqSuggestion (ref : Syntax)
    (suggestion : TSyntax ``Lean.Parser.Tactic.tacticSeq)
    (origSpan? : Option Syntax := none) : MetaM Unit := do
  let fmt ← PrettyPrinter.ppCategory ``Lean.Parser.Tactic.tacticSeq suggestion
  let msgText := fmt.pretty (indent := 0) (column := 0)
  if let some range := (origSpan?.getD ref).getRange? then
    let map ← getFileMap
    let (indent, column) := Lean.Meta.Tactic.TryThis.getIndentAndColumn map range
    let text := fmt.pretty (indent := indent) (column := column)
    let suggestion := {
      -- HACK: The `tacticSeq` syntax category is pretty-printed with each line
      -- indented by two spaces (for some reason), so we remove this
      -- indentation.
      suggestion := .string $ dedent text
      toCodeActionTitle? := some λ _ => "Replace aesop with the proof it found"
      messageData? := some msgText
      preInfo? := "  "
    }
    Lean.Meta.Tactic.TryThis.addSuggestion ref suggestion (origSpan? := origSpan?)
      (header := "Try this:\n")
where
  dedent (s : String) : String :=
    s.splitOn "\n"
    |>.map (λ line => line.dropPrefix? "  " |>.map (·.toString) |>.getD line)
    |> String.intercalate "\n"

/--
Runs a computation for at most the given number of heartbeats times 1000,
ignoring the global heartbeat limit. Note that heartbeats spent on the
computation still count towards the global heartbeat count.
-/
def withMaxHeartbeats [Monad m] [MonadLiftT BaseIO m]
    [MonadWithReaderOf Core.Context m] (n : Nat) (x : m α) : m α := do
  let numHeartbeats ← IO.getNumHeartbeats
  let f s := {
    s with
    initHeartbeats := numHeartbeats
    maxHeartbeats := n * 1000
  }
  withReader f x

/--
Runs a computation for at most the given number of heartbeats times 1000 or the
global heartbeat limit, whichever is lower. Note that heartbeats spent on the
computation still count towards the global heartbeat count. If 0 is given, the
global heartbeat limit is used.
-/
def withAtMostMaxHeartbeats [Monad m] [MonadLiftT BaseIO m] [MonadLiftT CoreM m]
    [MonadWithReaderOf Core.Context m] (n : Nat) (x : m α) : m α := do
  let globalMaxHeartbeats ← getMaxHeartbeats
  let maxHeartbeats :=
    if n == 0 then globalMaxHeartbeats else min n globalMaxHeartbeats
  withMaxHeartbeats maxHeartbeats x

open Lean.Elab Lean.Elab.Term in
def elabPattern (stx : Syntax) : TermElabM Expr :=
  withRef stx $ withReader adjustCtx $ withSynthesize $ elabTerm stx none
  where
    adjustCtx (old : Term.Context) : Term.Context := {
      old with
      mayPostpone := false
      errToSorry := false
      autoBoundImplicit := false
      sectionVars := {}
      sectionFVars := {}
      isNoncomputableSection := false
      ignoreTCFailures := true
      inPattern := true
      saveRecAppSyntax := false
      holesAsSyntheticOpaque := false
    }

register_option aesop.smallErrorMessages : Bool := {
    defValue := false
    group := "aesop"
    descr := "(aesop) Print smaller error messages. Used for testing."
  }

def tacticsToMessageData (ts : Array Syntax.Tactic) : MessageData :=
  MessageData.joinSep (ts.map toMessageData |>.toList) "\n"

/--
Note: the returned local context contains invalid `LocalDecl`s.
-/
def getUnusedNames (lctx : LocalContext) (suggestions : Array Name) : Array Name × LocalContext :=
  go 0 (Array.mkEmpty suggestions.size) lctx
where
  go (i : Nat) (acc : Array Name) (lctx : LocalContext) : Array Name × LocalContext :=
    if h : i < suggestions.size then
      let name := lctx.getUnusedName suggestions[i]
      let lctx := lctx.addDecl $ dummyLDecl name
      go (i + 1) (acc.push name) lctx
    else
      (acc, lctx)

  dummyLDecl (name : Name) : LocalDecl :=
    .cdecl 0 ⟨`_⟩ name (.sort levelZero) .default .default

def Name.ofComponents (cs : List Name) : Name :=
  cs.foldl (init := .anonymous) λ
    | result, .str _ s => .str result s
    | result, .num _ n => .num result n
    | result, .anonymous => result

@[macro_inline]
def withExceptionTransform [Monad m] [MonadError m]
    (f : MessageData → MessageData) (x : m α) : m α := do
  try
    x
  catch e =>
    match e with
    | .internal _ _ => throw e
    | .error ref msg => throw $ .error ref (f msg)

@[macro_inline]
def withExceptionPrefix [Monad m] [MonadError m] (pre : MessageData) :
    m α → m α :=
  withExceptionTransform (λ msg => pre ++ msg)

def withPPAnalyze [Monad m] [MonadWithOptions m] (x : m α) : m α :=
  withOptions (·.setBool `pp.analyze true |>.setBool `pp.proofs true) x
  -- `pp.proofs` works around lean4#6216

-- TODO upstream
scoped instance [MonadCache α β m] : MonadCache α β (StateRefT' ω σ m) where
  findCached? a := MonadCache.findCached? (m := m) a
  cache a b := MonadCache.cache (m := m) a b

/-- A generalized variant of `Meta.SavedState.runMetaM` -/
def runInMetaState [Monad m] [MonadLiftT MetaM m] [MonadFinally m]
    (s : Meta.SavedState) (x : m α) : m α := do
  let initialState ← show MetaM _ from saveState
  try
    s.restore
    x
  finally
    initialState.restore

def lBoolOr : (x y : LBool) → LBool
  | .true, _ => .true
  | .false, y => y
  | .undef, .true => .true
  | .undef, _ => .undef

-- Core's `arrayOrd` goes through lists. -.-
def compareArrayLex (cmp : α → α → Ordering) (xs ys : Array α) :
    Ordering := Id.run do
  let s := max xs.size ys.size
  for i in [:s] do
    if let some x := xs[i]? then
      if let some y := ys[i]? then
        let c := cmp x y
        if c.isNe then
          return c
      else
        return .gt
    else
      return .lt
  return .eq

def compareArraySizeThenLex (cmp : α → α → Ordering) (xs ys : Array α) :
    Ordering :=
  compare xs.size ys.size |>.then $
  compareArrayLex cmp xs ys

end Aesop



=== LEAN SOURCE: EqualUpToIds.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/
import Batteries.Lean.Meta.Basic

open Lean Std Lean.Meta

namespace Aesop

initialize registerTraceClass `Aesop.Util.EqualUpToIds

namespace EqualUpToIdsM

structure Context where
  commonMCtx? : Option MetavarContext
  mctx₁ : MetavarContext
  mctx₂ : MetavarContext
  /-- Allow metavariables to be unassigned on one side of the comparison and
  assigned on the other. So when we compare two expressions and we encounter
  a metavariable `?x` in one of them and a subexpression `e` in the other (at
  the same position), we consider `?x` equal to `e`. -/
  -- TODO we should also allow ?P x₁ ... xₙ = e
  allowAssignmentDiff : Bool

structure State where
  equalMVarIds : Std.HashMap MVarId MVarId := {}
  equalLMVarIds : Std.HashMap LMVarId LMVarId := {}
  /-- A map from metavariables which are unassigned in the left goal
  to their corresponding expression in the right goal. Only used when
  `allowAssignmentDiff = true`. -/
  leftUnassignedMVarValues : Std.HashMap MVarId Expr := {}
  /-- A map from metavariables which are unassigned in the right goal
  to their corresponding expression in the left goal. Only used when
  `allowAssignmentDiff = true`. -/
  rightUnassignedMVarValues : Std.HashMap MVarId Expr := {}

end EqualUpToIdsM


abbrev EqualUpToIdsM :=
  ReaderT EqualUpToIdsM.Context $ StateRefT EqualUpToIdsM.State MetaM

-- Make the compiler generate specialized `pure`/`bind` so we do not have to optimize through the
-- whole monad stack at every use site. May eventually be covered by `deriving`.
@[inline, always_inline]
instance : Monad EqualUpToIdsM :=
  { inferInstanceAs (Monad EqualUpToIdsM) with }

protected def EqualUpToIdsM.run' (x : EqualUpToIdsM α)
    (commonMCtx? : Option MetavarContext) (mctx₁ mctx₂ : MetavarContext)
    (allowAssignmentDiff : Bool) :
    MetaM (α × EqualUpToIdsM.State) :=
  x { commonMCtx?, mctx₁, mctx₂, allowAssignmentDiff, } |>.run {}

protected def EqualUpToIdsM.run (x : EqualUpToIdsM α)
    (commonMCtx? : Option MetavarContext) (mctx₁ mctx₂ : MetavarContext)
    (allowAssignmentDiff : Bool) : MetaM α :=
  (·.fst) <$> x.run' commonMCtx? mctx₁ mctx₂ allowAssignmentDiff

namespace EqualUpToIds

@[inline]
def readCommonMCtx? : EqualUpToIdsM (Option MetavarContext) :=
  return (← read).commonMCtx?

@[inline]
def readMCtx₁ : EqualUpToIdsM MetavarContext :=
  return (← read).mctx₁

@[inline]
def readMCtx₂ : EqualUpToIdsM MetavarContext :=
  return (← read).mctx₂

@[inline]
def readAllowAssignmentDiff : EqualUpToIdsM Bool :=
  return (← read).allowAssignmentDiff

@[specialize]
def equalCommonLMVars? (lmvarId₁ lmvarId₂ : LMVarId) :
    EqualUpToIdsM (Option Bool) := do
  match ← readCommonMCtx? with
  | none => return none
  | some mctx =>
    if mctx.lDepth.contains lmvarId₁ || mctx.lDepth.contains lmvarId₂ then
      return some $ lmvarId₁ == lmvarId₂
    else
      return none

@[specialize]
def equalCommonMVars? (mvarId₁ mvarId₂ : MVarId) :
    EqualUpToIdsM (Option Bool) := do
  match ← readCommonMCtx? with
  | none => return none
  | some mctx =>
    if mctx.isExprMVarDeclared mvarId₁ || mctx.isExprMVarDeclared mvarId₂ then
      return some $ mvarId₁ == mvarId₂
    else
      return none

structure GoalContext where
  lctx₁ : LocalContext
  localInstances₁ : LocalInstances
  lctx₂ : LocalContext
  localInstances₂ : LocalInstances
  equalFVarIds : Std.HashMap FVarId FVarId := {}

inductive MVarValue where
  | mvarId (mvarId : MVarId)
  | expr (e : Expr)
  | delayedAssignment (da : DelayedMetavarAssignment)

namespace Unsafe

@[inline]
private def namesEqualUpToMacroScopes (n₁ n₂ : Name) : Bool :=
  n₁.hasMacroScopes == n₂.hasMacroScopes &&
  n₁.eraseMacroScopes == n₂.eraseMacroScopes

mutual
  @[specialize]
  unsafe def levelsEqualUpToIdsCore (l₁ l₂ : Level) : EqualUpToIdsM Bool :=
    if ptrEq l₁ l₂ then
      return true
    else
      levelsEqualUpToIdsCore' l₁ l₂

  @[specialize]
  unsafe def levelsEqualUpToIdsCore' : Level → Level → EqualUpToIdsM Bool
    | .zero, .zero => return true
    | .succ l₁, .succ l₂ => levelsEqualUpToIdsCore l₁ l₂
    | .max l₁ m₁, .max l₂ m₂ =>
      levelsEqualUpToIdsCore l₁ l₂ <&&> levelsEqualUpToIdsCore m₁ m₂
    | .imax l₁ m₁, .imax l₂ m₂ =>
      levelsEqualUpToIdsCore l₁ l₂ <&&> levelsEqualUpToIdsCore m₁ m₂
    | .param n₁, .param n₂ =>
      return n₁ == n₂
    | .mvar m₁, .mvar m₂ => do
      if let some result ← equalCommonLMVars? m₁ m₂ then
        return result
      else if let some m₂' := (← get).equalLMVarIds[m₁]? then
        return m₂' == m₂
      else
        modify λ s => { s with equalLMVarIds := s.equalLMVarIds.insert m₁ m₂ }
        return true
    | _, _ => return false
end

end Unsafe

@[implemented_by Unsafe.levelsEqualUpToIdsCore]
opaque levelsEqualUpToIdsCore (l₁ l₂ : Level) : EqualUpToIdsM Bool

@[inline]
private def lctxDecls (lctx : LocalContext) : EqualUpToIdsM (Array LocalDecl) := do
  return lctx.foldl (init := Array.mkEmpty lctx.numIndices) λ decls d =>
    if d.isImplementationDetail then decls else decls.push d

abbrev ExprsEqualUpToIdsM :=
  MonadCacheT (ExprStructEq × ExprStructEq) Bool $
  ReaderT GoalContext EqualUpToIdsM

namespace Unsafe

mutual
  @[specialize]
  unsafe def exprsEqualUpToIdsCore₁ (e₁ e₂ : Expr) :
      ReaderT GoalContext EqualUpToIdsM Bool := do
    let e₁ ← withMCtx (← readMCtx₁) (instantiateMVars e₁)
    let e₂ ← withMCtx (← readMCtx₂) (instantiateMVars e₂)
    exprsEqualUpToIdsCore₂ e₁ e₂ |>.run

  @[specialize]
  unsafe def exprsEqualUpToIdsCore₂ (e₁ e₂ : Expr) : ExprsEqualUpToIdsM Bool :=
    withIncRecDepth do
    withTraceNodeBefore `Aesop.Util.EqualUpToIds (return m!"{← printExpr (← readMCtx₁) (← read).lctx₁ (← read).localInstances₁ e₁} ≟ {← printExpr (← readMCtx₂) (← read).lctx₂ (← read).localInstances₂ e₂}") do
      if ptrEq e₁ e₂ then
        trace[Aesop.Util.EqualUpToIds] "pointer-equal"
        return true
      else if ! e₁.hasMVar && ! e₂.hasMVar && e₁.equal e₂ then
        trace[Aesop.Util.EqualUpToIds] "structurally equal"
        return true
        -- If e₁ and e₂ don't contain mvars and are not structurally equal, they
        -- may still be equal up to IDs because we ignore macro scopes on names.
      else
        checkCache ((e₁ : ExprStructEq), (e₂ : ExprStructEq)) λ _ => do
          exprsEqualUpToIdsCore₃ e₁ e₂
  where
    printExpr (mctx : MetavarContext) (lctx : LocalContext)
        (localInstances : LocalInstances) (e : Expr) : MetaM MessageData :=
      withMCtx mctx do
      withLCtx lctx localInstances do
        addMessageContext m!"{e}"

  @[specialize]
  unsafe def exprsEqualUpToIdsCore₃ : Expr → Expr → ExprsEqualUpToIdsM Bool
    | .bvar i, .bvar j => return i == j
    | .fvar fvarId₁, .fvar fvarId₂ =>
      return fvarId₁ == fvarId₂ ||
             (← read).equalFVarIds[fvarId₁]? == some fvarId₂
    | .sort u, .sort v => levelsEqualUpToIdsCore u v
    | .const decl₁ lvls₁, .const decl₂ lvls₂ => do
      if decl₁ == decl₂ && lvls₁.length == lvls₂.length then
        for l₁ in lvls₁, l₂ in lvls₂ do
          if ! (← levelsEqualUpToIdsCore l₁ l₂) then
            return false
        return true
      else
        return false
    | .app f₁ x₁, .app f₂ x₂ =>
      exprsEqualUpToIdsCore₂ f₁ f₂ <&&> exprsEqualUpToIdsCore₂ x₁ x₂
    | .lam n₁ t₁ e₁ bi₁, .lam n₂ t₂ e₂ bi₂ =>
      pure (namesEqualUpToMacroScopes n₁ n₂ && bi₁ == bi₂) <&&>
      exprsEqualUpToIdsCore₂ t₁ t₂ <&&>
      exprsEqualUpToIdsCore₂ e₁ e₂
    | .forallE n₁ t₁ e₁ bi₁, .forallE n₂ t₂ e₂ bi₂ =>
      pure (namesEqualUpToMacroScopes n₁ n₂ && bi₁ == bi₂) <&&>
      exprsEqualUpToIdsCore₂ t₁ t₂ <&&>
      exprsEqualUpToIdsCore₂ e₁ e₂
    | .letE n₁ t₁ v₁ e₁ _, .letE n₂ t₂ v₂ e₂ _ =>
      pure (namesEqualUpToMacroScopes n₁ n₂) <&&>
      exprsEqualUpToIdsCore₂ t₁ t₂ <&&>
      exprsEqualUpToIdsCore₂ v₁ v₂ <&&>
      exprsEqualUpToIdsCore₂ e₁ e₂
    | .lit l₁, .lit l₂ => return l₁ == l₂
    | .mdata _ e₁, e₂ => exprsEqualUpToIdsCore₂ e₁ e₂
    | e₁, .mdata _ e₂ => exprsEqualUpToIdsCore₂ e₁ e₂
    | .proj n₁ i₁ e₁, .proj n₂ i₂ e₂ =>
      pure (n₁ == n₂ && i₁ == i₂) <&&> exprsEqualUpToIdsCore₂ e₁ e₂
    | .mvar m₁, .mvar m₂ => do
      let v₁ ← normalizeMVar (← readMCtx₁) m₁
      let v₂ ← normalizeMVar (← readMCtx₂) m₂
      compareMVarValues v₁ v₂
    | .mvar m₁, e₂ => do
      let v₁ ← normalizeMVar (← readMCtx₁) m₁
      compareMVarValues v₁ (.expr e₂)
    | e₁, .mvar m₂ => do
      let v₂ ← normalizeMVar (← readMCtx₂) m₂
      compareMVarValues (.expr e₁) v₂
    | _, _ => return false
  where
    normalizeMVar (mctx : MetavarContext) (m : MVarId) : MetaM MVarValue :=
      withMCtx mctx do
        if let some dAss ← getDelayedMVarAssignment? m then
          return .delayedAssignment dAss
        else
          return .mvarId m

    compareMVarValues : MVarValue → MVarValue → ExprsEqualUpToIdsM Bool
      | .expr _, .expr _ => unreachable!
      | .mvarId m₁, .mvarId m₂ => unassignedMVarsEqualUpToIdsCore m₁ m₂
      | .delayedAssignment dAss₁, .delayedAssignment dAss₂ =>
        unassignedMVarsEqualUpToIdsCore dAss₁.mvarIdPending dAss₂.mvarIdPending
        -- TODO I'm not sure whether this suffices -- do we also need to check
        -- that the `fvars` in `dAss₁` correspond to the `fvars` in `dAss₂`?
      | .mvarId m₁, .expr e₂ => do
        if ! (← readAllowAssignmentDiff) then
          return false
        let map := (← get).leftUnassignedMVarValues
        if let some e₁ := map[m₁]? then
          exprsEqualUpToIdsCore₂ e₁ e₂
        else
          modify λ s => {
            s with
            leftUnassignedMVarValues := s.leftUnassignedMVarValues.insert m₁ e₂
          }
          return true
      | .expr e₁, .mvarId m₂ => do
        if ! (← readAllowAssignmentDiff) then
          return false
        let map := (← get).rightUnassignedMVarValues
        if let some e₂ := map[m₂]? then
          exprsEqualUpToIdsCore₂ e₁ e₂
        else
          modify λ s => {
            s with
            rightUnassignedMVarValues := s.rightUnassignedMVarValues.insert m₂ e₁
          }
          return true
      | _, _ => return false

  @[specialize]
  unsafe def localDeclsEqualUpToIdsCore (ldecl₁ ldecl₂ : LocalDecl) :
      ReaderT GoalContext EqualUpToIdsM Bool :=
    match ldecl₁.isLet, ldecl₂.isLet with
    | false, false =>
      pure (namesEqualUpToMacroScopes ldecl₁.userName ldecl₂.userName && ldecl₁.binderInfo == ldecl₂.binderInfo &&
        ldecl₁.kind == ldecl₂.kind) <&&>
      exprsEqualUpToIdsCore₁ ldecl₁.type ldecl₂.type
    | true, true =>
      pure (namesEqualUpToMacroScopes ldecl₁.userName ldecl₂.userName &&
            ldecl₁.kind == ldecl₂.kind) <&&>
      exprsEqualUpToIdsCore₁ ldecl₁.type ldecl₂.type <&&>
      exprsEqualUpToIdsCore₁ ldecl₁.value ldecl₂.value
    | _, _ => return false

  @[specialize]
  unsafe def localContextsEqualUpToIdsCore (lctx₁ lctx₂ : LocalContext)
      (localInstances₁ localInstances₂ : LocalInstances) :
      EqualUpToIdsM (Option GoalContext) := do
    let decls₁ ← lctxDecls lctx₁
    let decls₂ ← lctxDecls lctx₂
    if h : decls₁.size = decls₂.size then
      go decls₁ decls₂ h 0 { lctx₁, lctx₂, localInstances₁, localInstances₂ }
    else
      trace[Aesop.Util.EqualUpToIds] "number of hyps differs"
      return none
  where
    go (decls₁ decls₂ : Array LocalDecl) (h : decls₁.size = decls₂.size)
        (i : Nat) (gctx : GoalContext) : EqualUpToIdsM (Option GoalContext) := do
      if h' : i < decls₁.size then
        let ldecl₁ := decls₁[i]
        let ldecl₂ := decls₂[i]'(by simp [← h, h'])
        let eq ← withTraceNodeBefore `Aesop.Util.EqualUpToIds (return m!"comparing hyps {ldecl₁.userName}, {ldecl₂.userName}") do
          localDeclsEqualUpToIdsCore ldecl₁ ldecl₂ |>.run gctx
        if ! eq then
          return none
        let equalFVarIds :=
          gctx.equalFVarIds.insert ldecl₁.fvarId ldecl₂.fvarId
        go decls₁ decls₂ h (i + 1) { gctx with equalFVarIds }
      else
        return some gctx

  @[specialize]
  unsafe def unassignedMVarsEqualUpToIdsCore (mvarId₁ mvarId₂ : MVarId) :
      EqualUpToIdsM Bool :=
    withTraceNodeBefore `Aesop.Util.EqualUpToIds (return m!"comparing mvars {mvarId₁.name}, {mvarId₂.name}") do
      if let some result ← equalCommonMVars? mvarId₁ mvarId₂ then
        trace[Aesop.Util.EqualUpToIds] "common mvars are {if result then "identical" else "different"}"
        return result
      else if let some m₂ := (← get).equalMVarIds[mvarId₁]? then
        if mvarId₂ == m₂ then
          trace[Aesop.Util.EqualUpToIds] "mvars already known to be equal"
          return true
        else
          trace[Aesop.Util.EqualUpToIds] "mvar {mvarId₁.name} known to be equal to different mvar {m₂.name}"
          return false
      else
        let ctx ← read
        let (some mdecl₁) := ctx.mctx₁.decls.find? mvarId₁ | throwError
          "unknown metavariable '?{mvarId₁.name}'"
        let (some mdecl₂) := ctx.mctx₂.decls.find? mvarId₂ | throwError
          "unknown metavariable '?{mvarId₂.name}'"
        let gctx? ←
          localContextsEqualUpToIdsCore mdecl₁.lctx mdecl₂.lctx
            mdecl₂.localInstances mdecl₂.localInstances
        let some gctx := gctx?
          | return false
        withTraceNodeBefore `Aesop.Util.EqualUpToIds (return m!"comparing targets") do
          if ← exprsEqualUpToIdsCore₁ mdecl₁.type mdecl₂.type |>.run gctx then
            modify λ s =>
              { s with equalMVarIds := s.equalMVarIds.insert mvarId₁ mvarId₂ }
            return true
          else
            return false
end

end Unsafe

@[implemented_by Unsafe.exprsEqualUpToIdsCore₁]
opaque exprsEqualUpToIdsCore (e₁ e₂ : Expr) : ReaderT GoalContext EqualUpToIdsM Bool

@[implemented_by Unsafe.unassignedMVarsEqualUpToIdsCore]
opaque unassignedMVarsEqualUpToIdsCore (mvarId₁ mvarId₂ : MVarId) :
    EqualUpToIdsM Bool

@[specialize]
def tacticStatesEqualUpToIdsCore (goals₁ goals₂ : Array MVarId) :
    EqualUpToIdsM Bool := do
  if goals₁.size != goals₂.size then
    return false
  for g₁ in goals₁, g₂ in goals₂ do
    if ! (← unassignedMVarsEqualUpToIdsCore g₁ g₂) then
      return false
  return true

end EqualUpToIds

def exprsEqualUpToIds (mctx₁ mctx₂ : MetavarContext)
    (lctx₁ lctx₂ : LocalContext)
    (localInstances₁ localInstances₂ : LocalInstances) (e₁ e₂ : Expr)
    (allowAssignmentDiff := false) : MetaM Bool := do
  EqualUpToIds.exprsEqualUpToIdsCore e₁ e₂
    |>.run { lctx₁, lctx₂, localInstances₁, localInstances₂ }
    |>.run (commonMCtx? := none) mctx₁ mctx₂ allowAssignmentDiff

def exprsEqualUpToIds' (e₁ e₂ : Expr) (allowAssignmentDiff := false) :
    MetaM Bool := do
  let mctx ← getMCtx
  let lctx ← getLCtx
  let localInstances ← getLocalInstances
  exprsEqualUpToIds mctx mctx lctx lctx localInstances localInstances e₁ e₂
    allowAssignmentDiff

def unassignedMVarsEqualUptoIds (commonMCtx? : Option MetavarContext)
    (mctx₁ mctx₂ : MetavarContext) (mvarId₁ mvarId₂ : MVarId)
    (allowAssignmentDiff := false) : MetaM Bool :=
  EqualUpToIds.unassignedMVarsEqualUpToIdsCore mvarId₁ mvarId₂
    |>.run commonMCtx? mctx₁ mctx₂ allowAssignmentDiff

def unassignedMVarsEqualUptoIds' (commonMCtx? : Option MetavarContext)
    (mctx₁ mctx₂ : MetavarContext) (mvarId₁ mvarId₂ : MVarId)
    (allowAssignmentDiff := false) :
    MetaM (Bool × EqualUpToIdsM.State) :=
  EqualUpToIds.unassignedMVarsEqualUpToIdsCore mvarId₁ mvarId₂
    |>.run' commonMCtx? mctx₁ mctx₂ allowAssignmentDiff

def tacticStatesEqualUpToIds (commonMCtx? : Option MetavarContext)
    (mctx₁ mctx₂ : MetavarContext) (goals₁ goals₂ : Array MVarId)
    (allowAssignmentDiff := false) : MetaM Bool :=
  EqualUpToIds.tacticStatesEqualUpToIdsCore goals₁ goals₂
    |>.run commonMCtx? mctx₁ mctx₂ allowAssignmentDiff

def tacticStatesEqualUpToIds' (commonMCtx? : Option MetavarContext)
    (mctx₁ mctx₂ : MetavarContext) (goals₁ goals₂ : Array MVarId)
    (allowAssignmentDiff := false) :
    MetaM (Bool × EqualUpToIdsM.State) :=
  EqualUpToIds.tacticStatesEqualUpToIdsCore goals₁ goals₂
    |>.run' commonMCtx? mctx₁ mctx₂ allowAssignmentDiff

end Aesop



=== LEAN SOURCE: Tactic.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Lean
import Batteries.Tactic.OpenPrivate

open Lean Lean.Meta Lean.Elab.Tactic

namespace Aesop

/--
A `MetaM` version of the `replace` tactic. If `fvarId` refers to the
hypothesis `h`, this tactic asserts a new hypothesis `h : type` with proof
`proof : type` and then tries to clear `fvarId`. Unlike `replaceLocalDecl`,
`replaceFVar` always adds the new hypothesis at the end of the local context.

`replaceFVar` returns the new goal, the `FVarId` of the newly asserted
hypothesis and whether the old hypothesis was cleared.
-/
def replaceFVar (goal : MVarId) (fvarId : FVarId) (type : Expr) (proof : Expr) :
    MetaM (MVarId × FVarId × Bool) := do
  let userName ← goal.withContext $ fvarId.getUserName
  let preClearGoal ← goal.assert userName type proof
  let goal ← preClearGoal.tryClear fvarId
  let clearSuccess := preClearGoal != goal
  let (newFVarId, goal) ← intro1Core goal (preserveBinderNames := true)
  return (goal, newFVarId, clearSuccess)

/-- Introduce as many binders as possible while unfolding definitions with the
ambient transparency. -/
partial def introsUnfolding (mvarId : MVarId) : MetaM (Array FVarId × MVarId) :=
  run mvarId #[]
where
  run (mvarId : MVarId) (fvars : Array FVarId) : MetaM (Array FVarId × MVarId) :=
    mvarId.withContext do
      let type ← whnf (← mvarId.getType)
      let size := getIntrosSize type
      if 0 < size then
        let (fvars', mvarId') ← mvarId.introN size
        run mvarId' (fvars ++ fvars')
      else
        return (fvars, mvarId)

end Aesop



=== LEAN SOURCE: UnionFind.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/
import Std.Data.HashMap

namespace Aesop

structure UnionFind (α) [BEq α] [Hashable α] where
  parents : Array USize
  sizes : Array USize
  toRep : Std.HashMap α USize
  -- Invariant: `toRep` contains exactly the indices of `parents` as values
  deriving Inhabited

namespace UnionFind

variable {α} [BEq α] [Hashable α]

instance : EmptyCollection (UnionFind α) :=
  ⟨{ parents := #[], sizes := #[], toRep := {} }⟩

def size (u : UnionFind α) : Nat :=
  u.parents.size

def add (x : α) (u : UnionFind α) : UnionFind α := Id.run do
  if u.toRep.contains x then
    return u
  let rep := u.parents.size.toUSize
  { parents := u.parents.push rep
    sizes := u.parents.push 1
    toRep := u.toRep.insert x rep }

def addArray (xs : Array α) (u : UnionFind α) : UnionFind α :=
  xs.foldl (init := u) λ u x => u.add x

def ofArray (xs : Array α) : UnionFind α :=
  ({} : UnionFind α).addArray xs

private unsafe def findRepUnsafe (i : USize) (u : UnionFind α) :
    USize × UnionFind α :=
  let parent := u.parents.uget i lcProof
  if parent == i then
    (parent, u)
  else
    let (parent, u) := u.findRepUnsafe parent
    (parent, { u with parents := u.parents.uset i parent lcProof })

@[implemented_by findRepUnsafe]
private opaque findRep : USize → UnionFind α → USize × UnionFind α

partial def find? (x : α) (u : UnionFind α) : Option USize × UnionFind α :=
  match u.toRep[x]? with
  | none => (none, u)
  | some rep =>
    let (rep, u) := u.findRep rep
    (some rep, u)

private unsafe def mergeUnsafe (x y : α) (u : UnionFind α) :
    UnionFind α := Id.run do
  let (some xRep, u) := u.find? x | u
  let (some yRep, u) := u.find? y | u
  if xRep == yRep then
    return u
  else
    let xSize := u.sizes.uget xRep lcProof
    let ySize := u.sizes.uget yRep lcProof
    if xSize < ySize then
      return {
        parents := u.parents.uset xRep yRep lcProof
        sizes := u.sizes.uset yRep (xSize + ySize) lcProof
        toRep := u.toRep
      }
    else
      return {
        parents := u.parents.uset yRep xRep lcProof
        sizes := u.sizes.uset xRep (xSize + ySize) lcProof
        toRep := u.toRep
      }

@[implemented_by mergeUnsafe]
opaque merge (x y : α) : UnionFind α → UnionFind α

def sets {α : Type v} [BEq α] [Hashable α] (u : UnionFind α) : Array (Array α) × UnionFind α :=
  let (sets, u) := u.toRep.fold (init := (∅, u)) λ ((sets : Std.HashMap USize _), u) x rep =>
    let (rep, u) := u.findRep rep
    let sets :=
      match sets[rep]? with
      | some set => sets.insert rep (set.push x)
      | none => sets.insert rep #[x]
    (sets, u)
  let sets := sets.fold (init := Array.mkEmpty sets.size) λ (sets : Array _) _ v =>
    sets.push v
  (sets, u)

end UnionFind

/-- Cluster the `as` according to which `bs` are associated to them by `f`. Two
members `a₁, a₂` of `as` are put in the same cluster iff `f a₁ ∩ f a₂ ≠ ∅`. -/
def cluster [BEq α] [Hashable α] [BEq β] [Hashable β] (f : α → Array β)
    (as : Array α) : Array (Array α) := Id.run do
  let mut clusters := UnionFind.ofArray as
  let mut aOccs : Std.HashMap β (Array α) := {}
  for a in as do
    for b in f a do
      match aOccs[b]? with
      | some as' =>
        for a' in as' do
          clusters := clusters.merge a a'
        aOccs := aOccs.insert b (as'.push a)
      | none =>
        aOccs := aOccs.insert b #[a]
  return clusters.sets.fst

end Aesop



=== LEAN SOURCE: UnorderedArraySet.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/
import Batteries.Data.Array.Merge
import Lean.Message

open Lean Std

namespace Aesop

structure UnorderedArraySet (α) [BEq α] where
  private mk ::
  private rep : Array α
  deriving Inhabited

namespace UnorderedArraySet

variable [BEq α]

/-- O(1) -/
protected def empty : UnorderedArraySet α :=
  ⟨#[]⟩

instance : EmptyCollection (UnorderedArraySet α) :=
  ⟨UnorderedArraySet.empty⟩

/-- O(1) -/
protected def singleton (a : α) : UnorderedArraySet α :=
  ⟨#[a]⟩

/-- O(n) -/
def insert (x : α) : UnorderedArraySet α → UnorderedArraySet α
  | ⟨rep⟩ => if rep.contains x then ⟨rep⟩ else ⟨rep.push x⟩

/-- Precondition: `xs` contains no duplicates. -/
protected def ofDeduplicatedArray (xs : Array α) : UnorderedArraySet α :=
  ⟨xs⟩

/-- Precondition: `xs` is sorted. -/
protected def ofSortedArray (xs : Array α) : UnorderedArraySet α :=
  ⟨xs.dedupSorted⟩

set_option linter.unusedVariables false in
/-- O(n*log(n)) -/
protected def ofArray [ord : Ord α] (xs : Array α) :
    UnorderedArraySet α :=
  ⟨xs.sortDedup⟩

/-- O(n^2) -/
protected def ofArraySlow (xs : Array α) : UnorderedArraySet α :=
  xs.foldl (init := {}) λ s x => s.insert x

protected def ofHashSet [Hashable α] (xs : Std.HashSet α) : UnorderedArraySet α :=
  ⟨xs.toArray⟩

protected def ofPersistentHashSet [Hashable α] (xs : PersistentHashSet α) : UnorderedArraySet α :=
  ⟨xs.fold (init := #[]) λ as a => as.push a⟩

protected def toArray (s : UnorderedArraySet α) : Array α :=
  s.rep

/-- O(n) -/
def erase (x : α) (s : UnorderedArraySet α) : UnorderedArraySet α :=
  ⟨s.rep.erase x⟩

/-- O(n) -/
def filterM [Monad m] (p : α → m Bool) (s : UnorderedArraySet α) :
    m (UnorderedArraySet α) :=
  return ⟨← s.rep.filterM p⟩

/-- O(n) -/
def filter (p : α → Bool) (s : UnorderedArraySet α) : UnorderedArraySet α :=
  ⟨s.rep.filter p⟩

/-- O(n*m) -/
def merge (s t : UnorderedArraySet α) : UnorderedArraySet α :=
  ⟨s.rep.mergeUnsortedDedup t.rep⟩

instance : Append (UnorderedArraySet α) :=
  ⟨merge⟩

/-- O(n) -/
def contains (x : α) (s : UnorderedArraySet α) : Bool :=
  s.rep.contains x

/-- O(n) -/
def foldM [Monad m] (f : σ → α → m σ) (init : σ) (s : UnorderedArraySet α) :
    m σ :=
  s.rep.foldlM f init

instance : ForIn m (UnorderedArraySet α) α where
  forIn s := forIn s.rep

/-- O(n) -/
def fold (f : σ → α → σ) (init : σ) (s : UnorderedArraySet α) : σ :=
  s.rep.foldl f init

def partition (f : α → Bool) (s : UnorderedArraySet α) :
    (UnorderedArraySet α × UnorderedArraySet α) :=
  let (xs, ys) := s.rep.partition f
  (⟨xs⟩, ⟨ys⟩)

/-- O(1) -/
def size (s : UnorderedArraySet α) : Nat :=
  s.rep.size

/-- O(1) -/
def isEmpty (s : UnorderedArraySet α) : Bool :=
  s.rep.isEmpty

/-- O(n) -/
def anyM [Monad m] (p : α → m Bool) (s : UnorderedArraySet α) (start := 0)
    (stop := s.size) : m Bool :=
  s.rep.anyM p start stop

/-- O(n) -/
def any (p : α → Bool) (s : UnorderedArraySet α) (start := 0) (stop := s.size) :
    Bool :=
  s.rep.any p start stop

/-- O(n) -/
def allM [Monad m] (p : α → m Bool) (s : UnorderedArraySet α) (start := 0)
    (stop := s.size) : m Bool :=
  s.rep.allM p start stop

/-- O(n) -/
def all (p : α → Bool) (s : UnorderedArraySet α) (start := 0) (stop := s.size) :
    Bool :=
  s.rep.all p start stop

instance [ToString α] : ToString (UnorderedArraySet α) where
  toString s := toString s.rep

instance [ToFormat α] : ToFormat (UnorderedArraySet α) where
  format s := format s.rep

instance [ToMessageData α] : ToMessageData (UnorderedArraySet α) where
  toMessageData s := toMessageData s.rep

end Aesop.UnorderedArraySet



=== LEAN SOURCE: Ext.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Tracing

open Lean Lean.Meta Lean.Elab.Tactic.Ext

namespace Aesop

structure ExtResult where
  depth : Nat
  commonFVarIds : Array FVarId
  goals : Array (MVarId × Array FVarId)

partial def straightLineExt (goal : MVarId) : MetaM ExtResult :=
  go goal 0 #[]
where
  go (goal : MVarId) (depth : Nat) (commonFVarIds : Array FVarId) :
      MetaM ExtResult:= do
    withConstAesopTraceNode .debug (return m!"straightLineExt") do
    aesop_trace[debug] "goal:{indentD goal}"
    let goals? ← show MetaM _ from observing? $ applyExtTheoremAt goal
    if let some goals := goals? then
      aesop_trace[debug] "ext lemma applied; new goals:{indentD $ Elab.goalsToMessageData goals}"
      let goals := goals.toArray
      if goals.isEmpty then
        return { depth := depth + 1, goals := #[], commonFVarIds := #[] }
      let goals ← goals.mapM λ goal => do
        let (fvarIds, goal) ← goal.intros
        return (goal, fvarIds)
      if h : goals.size = 1 then
        let (goal, fvarIds) := goals[0]
        go goal (depth + 1) (commonFVarIds ++ fvarIds)
      else
        return { depth := depth + 1, goals, commonFVarIds }
    else
      aesop_trace[debug] "no applicable ext lemma"
      return { depth, goals := #[(goal, #[])], commonFVarIds }

def straightLineExtProgress (goal : MVarId) : MetaM ExtResult := do
  let result ← straightLineExt goal
  if result.depth == 0 then
    throwError "no applicable extensionality theorem found"
  return result

end Aesop



=== LEAN SOURCE: Unfold.lean ===
/-
Copyright (c) 2022--2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Lean

open Lean Lean.Meta Lean.Elab.Tactic

namespace Aesop

-- Inspired by Lean.Meta.unfold, Lean.Meta.unfoldTarget,
-- Lean.Meta.unfoldLocalDecl.

def mkUnfoldSimpContext : MetaM Simp.Context := do
  Simp.mkContext Simp.neutralConfig (simpTheorems := #[]) (congrTheorems := ← getSimpCongrTheorems)

@[inline]
def unfoldManyCore (ctx : Simp.Context) (unfold? : Name → Option (Option Name))
    (e : Expr) : StateRefT (Array Name) MetaM Simp.Result :=
  λ usedDeclsRef =>
    (·.fst) <$> Simp.main e ctx (methods := { pre := (pre · usedDeclsRef) })
where
  -- NOTE: once we succeed in unfolding something, we return `done`. This
  -- means that `simp` won't recurse into the unfolded expression, missing
  -- potential further opportunities for unfolding.
  --
  -- I've tried returning
  -- `visit` instead, in which case we get recursive unfolding as desired, but
  -- we also get different results than when we call the `unfold` tactic
  -- multiple times.
  --
  -- Aesop calls `unfold` multiple times anyway, so the current implementation
  -- is slow but correct.
  pre (e : Expr) : StateRefT (Array Name) SimpM Simp.Step := do
    let some decl := e.getAppFn'.constName?
      | return .continue
    match unfold? decl with
    | none =>
      return .continue
    | some none =>
      if let some e' ← delta? e (λ n => n == decl) then
        modify (·.push decl)
        return .done { expr := e' }
      else
        return .continue
    | some (some unfoldThm) =>
      let result? ← withReducible <|
        Simp.tryTheorem? e
          { origin := .decl unfoldThm
            proof := mkConst unfoldThm
            rfl := ← isRflTheorem unfoldThm }
      match result? with
      | none   => return .continue
      | some r =>
        modify (·.push decl)
        match (← reduceMatcher? r.expr) with
        | .reduced e' => return .done { r with expr := e' }
        | _ => return .done r

def unfoldMany (unfold? : Name → Option (Option Name)) (e : Expr) :
    MetaM (Option (Expr × Array Name)) := do
  let e ← instantiateMVars e
  let (r, usedDecls) ← unfoldManyCore (← mkUnfoldSimpContext) unfold? e |>.run {}
  if (← instantiateMVars r.expr) == e then
    return none
  else
    return some (r.expr, usedDecls)

def unfoldManyTarget (unfold? : Name → Option (Option Name)) (goal : MVarId) :
    MetaM (Option (MVarId × Array Name)) := do
  let tgt ← instantiateMVars $ ← goal.getType
  let (result, usedDecls) ←
    unfoldManyCore (← mkUnfoldSimpContext) unfold? tgt |>.run #[]
  if result.expr == tgt then
    return none
  let goal ← applySimpResultToTarget goal tgt result
  return some (goal, usedDecls)

def unfoldManyAt (unfold? : Name → Option (Option Name)) (goal : MVarId)
    (fvarId : FVarId) : MetaM (Option (MVarId × Array Name)) :=
  goal.withContext do
    let type ← instantiateMVars $ ← fvarId.getType
    let (result, usedDecls) ←
      unfoldManyCore (← mkUnfoldSimpContext) unfold? type |>.run #[]
    if result.expr == type then
      return none
    let some (_, goal) ←
        applySimpResultToLocalDecl goal fvarId result (mayCloseGoal := false)
      | throwTacticEx `aesop_unfold goal "internal error: unexpected result of applySimpResultToLocalDecl"
    return some (goal, usedDecls)

def unfoldManyStar (unfold? : Name → Option (Option Name)) (goal : MVarId) :
    MetaM (Option MVarId) :=
  goal.withContext do
    let initialGoal := goal
    let mut goal := goal
    if let some (goal', _) ← unfoldManyTarget unfold? goal then
      goal := goal'
    for ldecl in (← goal.getDecl).lctx do
      if ldecl.isImplementationDetail then
        continue
      if let some (goal', _) ← unfoldManyAt unfold? goal ldecl.fvarId then
        goal := goal'
    if goal == initialGoal then
      return none
    else
      return some goal

private def mkToUnfold (ids : Array Ident) :
    MetaM (Std.HashMap Name (Option Name)) := do
  let mut toUnfold : Std.HashMap Name (Option Name) := {}
  for id in (ids : Array Ident) do
    let decl ← resolveGlobalConstNoOverload id
    toUnfold := toUnfold.insert decl (← getUnfoldEqnFor? decl)
  return toUnfold

elab "aesop_unfold " ids:ident+ : tactic => do
  let toUnfold ← mkToUnfold ids
  liftMetaTactic λ goal => do
    match ← unfoldManyTarget (toUnfold[·]?) goal with
    | none => throwTacticEx `aesop_unfold goal "could not unfold any of the given constants"
    | some (goal, _) => return [goal]

elab "aesop_unfold " ids:ident+ " at " hyps:ident+ : tactic => do
  let toUnfold ← mkToUnfold ids
  liftMetaTactic λ goal => do
    let mut goal := goal
    for hypId in hyps do
      let fvarId := (← getLocalDeclFromUserName hypId.getId).fvarId
      match ← unfoldManyAt (toUnfold[·]?) goal fvarId with
      | none => throwTacticEx `aesop_unfold goal m!"could not unfold any of the given constants at hypothesis '{hypId}'"
      | some (goal', _) => goal := goal'
    return [goal]

end Aesop



=== LEAN SOURCE: 10.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Asta H. From, Jannis Limperg
-/
import Aesop

set_option aesop.check.all true

attribute [aesop unsafe [50% constructors, 50% cases]] List.Mem

theorem Mem.map (f : α → β) (x : α) (xs : List α) (h : x ∈ xs) :
    f x ∈ xs.map f := by
  induction h <;> aesop



=== LEAN SOURCE: 12.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/
import Aesop

set_option aesop.check.all true

attribute [aesop unsafe 50% constructors] List.Mem

@[aesop safe [constructors, cases (cases_patterns := [All _ [], All _ (_ :: _)])]]
inductive All (P : α → Prop) : List α → Prop where
  | none : All P []
  | more (x xs) : P x → All P xs → All P (x :: xs)

theorem weaken (P Q : α → Prop) (wk : ∀ x, P x → Q x) (xs : List α) (h : All P xs)
  : All Q xs := by
  induction h <;> aesop

theorem in_self (xs : List α) : All (· ∈ xs) xs := by
  induction xs
  case nil =>
    aesop
  case cons x xs ih =>
    have wk : ∀ a, a ∈ xs → a ∈ x :: xs := by aesop
    have ih' : All (fun a => a ∈ x :: xs) xs := by aesop (add unsafe 1% weaken)
    aesop



=== LEAN SOURCE: 125.lean ===
import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

@[aesop 90%]
def myTacGen : Aesop.TacGen := fun _ => do
  return #[("exact ⟨val - f { val := val, property := property }, fun a ha => by simpa⟩",
            0.9)]

/-- error: tactic 'aesop' failed, made no progress -/
#guard_msgs in
theorem foo (f : { x // 0 < x } → { x // 0 < x }) (val : Nat)
    (property : 0 < val) :
    ∃ w x, ∀ (a : Nat) (b : 0 < a), ↑(f { val := a, property := b }) = w * a + x := by
  constructor
  aesop



=== LEAN SOURCE: 126.lean ===
import Aesop

set_option aesop.check.all true

-- TODO simp_all introduces spurious metavariables in this example
set_option aesop.check.rules false
set_option aesop.check.tree false

theorem foo {a : Nat → Nat} (ha : a 0 = 37) :
    (match h : a 0 with | 42 => by simp_all | n => n) = 37 := by
  aesop



=== LEAN SOURCE: 13.lean ===
/-
Copyright (c) 2022 Asta H. From. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Asta H. From, Jannis Limperg
-/
import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

inductive Any (P : α → Prop) : List α → Prop where
  | here (x xs) : P x → Any P (x :: xs)

inductive Perm : (xs ys : List α) → Type where
  | refl xs : Perm xs xs
  | prep (x xs ys) : Perm xs ys → Perm (x :: xs) (x :: ys)

theorem Perm.any {xs ys : List α} (perm : Perm xs ys) (P : α → Prop)
  : Any P xs → Any P ys := by
  induction perm <;> aesop (add safe [constructors Any, cases Any])

/--
error: tactic 'aesop' failed, maximum number of rule applications (100) reached. Set the 'maxRuleApplications' option to increase the limit.
-/
#guard_msgs in
theorem error (P : Nat → Prop) (Δ : List Nat) : Any P Δ := by
  aesop (add 50% [constructors Perm, constructors Any, Perm.any])
    (config := { maxRuleApplications := 100, terminal := true })

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
theorem fine (P : α → Prop) (Δ : List α) : Any P Δ := by
  aesop (add unsafe [50% constructors Perm, 50% constructors Any, apply 50% Perm.any])
    (config := { maxRuleApplications := 10, terminal := true })



=== LEAN SOURCE: 13_2.lean ===
/-
Copyright (c) 2022 Asta H. From. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Asta H. From, Jannis Limperg
-/
import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

inductive Perm : (xs ys : List α) → Type where
  | prep {xs} x : Perm (x :: xs) (x :: xs)

inductive Proof : (Γ Δ : List Φ) → Prop where
  | basic (Γ Δ n) : Proof (n :: Γ) (n :: Δ)
  | per_l (Γ Γ' Δ) : Proof Γ Δ → Perm Γ' Γ → Proof Γ' Δ

/--
error: tactic 'aesop' failed, maximum number of rule applications (50) reached. Set the 'maxRuleApplications' option to increase the limit.
-/
#guard_msgs in
theorem weaken (Γ Δ : List Φ) (prf : Proof Γ Δ) (δ : Φ) : Proof Γ (δ :: Δ) := by
  induction prf
  case basic Γ Δ n =>
    aesop (add unsafe [constructors Proof, constructors Perm])
      (config := { maxRuleApplications := 50, terminal := true })
  case per_l Γ Γ' Δ _ perm ih =>
    apply Proof.per_l Γ Γ' (δ :: Δ) ih perm



=== LEAN SOURCE: 18.lean ===
/-
Copyright (c) 2022 Asta H. From. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Asta H. From, Jannis Limperg
-/
import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

attribute [aesop safe cases (cases_patterns := [List.Mem _ []])] List.Mem
attribute [aesop unsafe 50% cases (cases_patterns := [List.Mem _ (_ :: _)])] List.Mem

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
theorem Mem.split [DecidableEq α] (xs : List α) (v : α) (h : v ∈ xs)
  : ∃ l r, xs = l ++ v :: r := by
  induction xs
  case nil =>
    aesop
  case cons x xs ih =>
    have dec : Decidable (x = v) := inferInstance
    cases dec
    case isFalse no =>
      aesop (config := { terminal := true }) (erase Aesop.BuiltinRules.ext)
    case isTrue yes =>
      apply Exists.intro []
      apply Exists.intro xs
      rw [yes]
      rfl



=== LEAN SOURCE: 2.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

-- This option would make Aesop time out.
set_option aesop.check.all false

inductive Even : Nat → Prop
| zero : Even Nat.zero
| plus_two {n} : Even n → Even (n + 2)

attribute [aesop safe] Even.zero Even.plus_two

example : Even 500 := by
  aesop (config := { maxRuleApplications := 0, maxRuleApplicationDepth := 0 })



=== LEAN SOURCE: 20.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Asta H. From, Jannis Limperg
-/
import Aesop

set_option aesop.check.all true

attribute [aesop safe cases (cases_patterns := [List.Mem _ []])] List.Mem
attribute [aesop unsafe 50% constructors] List.Mem
attribute [aesop unsafe 50% cases (cases_patterns := [List.Mem _ (_ :: _)])] List.Mem

@[aesop safe [constructors, cases (cases_patterns := [All _ [], All _ (_ :: _)])]]
inductive All (P : α → Prop) : List α → Prop where
  | none : All P []
  | more {x xs} : P x → All P xs → All P (x :: xs)

@[simp]
theorem All.cons (P : α → Prop) (x : α) (xs : List α)
  : All P (x :: xs) ↔ (P x ∧ All P xs) := by
  aesop

theorem mem (P : α → Prop) (xs : List α)
  : All P xs ↔ ∀ a : α, a ∈ xs → P a := by
  induction xs
  case nil => aesop
  case cons x xs ih => aesop (config := { useSimpAll := false })

theorem mem' (P : α → Prop) (xs : List α)
  : All P xs ↔ ∀ a : α, a ∈ xs → P a := by
  induction xs <;> aesop



=== LEAN SOURCE: 203.lean ===
/-
Copyright (c) 2025 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Frontend

-- Thank to Damiano Testa for this bug report.

/--
info: @[aesop (rule_sets := [builtin✝]) safe✝ apply✝]
example : True✝ :=
  trivial✝
-/
#guard_msgs in
#eval do
  let stx ← `(@[aesop (rule_sets := [builtin]) safe apply] example : True := trivial)
  Lean.logInfo stx



=== LEAN SOURCE: 205.lean ===
/-
Copyright (c) 2025 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

-- Thanks to Bruno Dutertre for reporting this bug.

import Aesop

axiom R {α} : α → α → Prop

@[aesop safe forward] axiom sym : R x y → R y x
@[aesop safe forward] axiom tran : R x y → R y z → R x z

/--
info: Try this:
  have fwd : R b y := sym h₃
  have fwd_1 : R a x := sym h₂
  have fwd_2 : R b b := tran (y := y) fwd h₃
  have fwd_3 : R y y := tran (y := b) h₃ fwd
  have fwd_4 : R a a := tran (y := x) fwd_1 h₂
  have fwd_5 : R x x := tran (y := a) h₂ fwd_1
  sorry
---
warning: declaration uses 'sorry'
-/
#guard_msgs in
example (α : Type u_1) (x y a b : α) (h₂ : R x a) (h₃ : R y b) : False := by
  aesop? (rule_sets := [-builtin]) (config := { warnOnNonterminal := false })
  sorry



=== LEAN SOURCE: 207.lean ===
/-
Copyright (c) 2025 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

-- Thanks to Jireh Loreaux for reporting this bug.

import Aesop

def Set α := α → Prop

instance : Membership α (Set α) :=
  ⟨λ s a => s a⟩

instance : Singleton α (Set α) :=
  ⟨λ a b => b = a⟩

axiom EqOn : (f₁ f₂ : α → α) → Set α → Prop

@[aesop safe forward]
axiom EqOn.eq_of_mem (h : EqOn f₁ f₂ s) (ha : a ∈ s) : f₁ a = f₂ a

@[simp]
axiom eqOn_singleton : EqOn f₁ f₂ {x} ↔ f₁ x = f₂ x

example (s : Set Nat) (x : Nat) (hx : x ∈ s) (f : Nat → Nat)
    (h_eqOn_x : EqOn f (λ _ => 1) {x}) (this : EqOn f (λ _ => 0) s) :
    False := by
  aesop

example (s : Set Nat) (x : Nat) (hx : x ∈ s) (f : Nat → Nat)
    (this : EqOn f (λ _ => 0) s) (h_eqOn_x : EqOn f (λ _ => 1) {x}) :
    False := by
  aesop



=== LEAN SOURCE: 23.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

def Involutive (f : α → α) : Prop :=
  ∀ x, f (f x) = x

example : Involutive not := by
  aesop (add norm simp Involutive)

example : Involutive not := by
  aesop (add norm unfold Involutive)



=== LEAN SOURCE: 26.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Asta H. From, Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

attribute [-simp] List.all_cons List.all_nil List.all_eq_true

/--
warning: aesop: failed to prove the goal after exhaustive search.
---
error: unsolved goals
case left
α : Type u_1
P : α → Bool
x : α
xs : List α
h : (x :: xs).all P = true
⊢ P x = true

case right
α : Type u_1
P : α → Bool
x : α
xs : List α
h : (x :: xs).all P = true
⊢ xs.all P = true
-/
#guard_msgs in
theorem all_cons (P : α → Bool) (x : α) (xs : List α) (h : (x :: xs).all P)
  : P x ∧ xs.all P := by
  aesop



=== LEAN SOURCE: 27.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Asta H. From, Jannis Limperg
-/

-- This test checks whether the output of trace.aesop.proof is
-- copy-and-pastable. When the test breaks because Aesop's output has changed,
-- please copy-and-paste the output to All.split_cons₂ and check whether it
-- still works.

import Aesop

set_option aesop.check.all true

@[aesop safe [constructors, cases (cases_patterns := [All _ [], All _ (_ :: _)])]]
inductive All (P : α → Prop) : List α → Prop
  | nil : All P []
  | cons {x xs} : P x → All P xs → All P (x :: xs)

/--
trace: [aesop.proof] Final proof:
      (fun (h_1 : All P (x :: xs)) =>
          ((fun (h_2 : All P (x :: xs)) =>
                (casesOn (P := P) (motive := fun a x_1 => x :: xs = a → h ≍ x_1 → P x ∧ All P xs) h_2
                    (fun h_3 => List.noConfusion h_3) fun {x_1} {xs_1} a a_1 h_3 =>
                    List.noConfusion h_3 fun head_eq =>
                      Eq.ndrec (motive := fun {x_1} =>
                        ∀ (a : P x_1), xs = xs_1 → h ≍ cons (P := P) a a_1 → P x ∧ All P xs)
                        (fun a tail_eq =>
                          Eq.ndrec (motive := fun {xs_1} =>
                            ∀ (a_1 : All P xs_1), h ≍ cons (P := P) a a_1 → P x ∧ All P xs)
                            (fun a_1 h =>
                              of_eq_true (Eq.trans (congr (congrArg And (eq_true a)) (eq_true a_1)) (and_self True)))
                            tail_eq a_1)
                        head_eq a :
                  x :: xs = x :: xs → h ≍ h_2 → P x ∧ All P xs))
              h_1 :
            x :: xs = x :: xs → h ≍ h_1 → P x ∧ All P xs))
        h (Eq.refl (x :: xs)) (HEq.refl h)
-/
#guard_msgs in
theorem All.split_cons (P : α → Prop) (x : α) (xs : List α) (h : All P (x :: xs))
  : P x ∧ All P xs := by
  set_option trace.aesop.proof true in
  aesop

theorem All.split_cons₂ (P : α → Prop) (x : α) (xs : List α) (h : All P (x :: xs))
  : P x ∧ All P xs :=
      (fun (h_1 : All P (x :: xs)) =>
          ((fun (h_2 : All P (x :: xs)) =>
                (All.casesOn (P := P) (motive := fun a x_1 => x :: xs = a → h ≍ x_1 → P x ∧ All P xs) h_2
                    (fun h_1 => List.noConfusion h_1) fun {x_1} {xs_1} a a_1 h_1 =>
                    List.noConfusion h_1 fun head_eq =>
                      Eq.ndrec (motive := fun {x_1} =>
                        ∀ (a : P x_1), xs = xs_1 → h ≍ All.cons (P := P) a a_1 → P x ∧ All P xs)
                        (fun a tail_eq =>
                          Eq.ndrec (motive := fun {xs_1} =>
                            ∀ (a_1 : All P xs_1), h ≍ All.cons (P := P) a a_1 → P x ∧ All P xs)
                            (fun a_1 h_1 =>
                              Eq.ndrec (motive := fun h => P x ∧ All P xs)
                                (of_eq_true (Eq.trans (congr (congrArg And (eq_true a)) (eq_true a_1)) (and_self True)))
                                (Eq.symm (eq_of_heq h_1)))
                            tail_eq a_1)
                        head_eq a :
                  x :: xs = x :: xs → h ≍ h_2 → P x ∧ All P xs))
              h_1 :
            x :: xs = x :: xs → h ≍ h_1 → P x ∧ All P xs))
        h (Eq.refl (x :: xs)) (HEq.refl h)



=== LEAN SOURCE: 41.lean ===
import Aesop

set_option aesop.check.all true

/--
error: no such rule set: 'Nonexistent'
  (Use 'declare_aesop_rule_set' to declare rule sets.
   Declared rule sets are not visible in the current file; they only become visible once you import the declaring file.)
-/
#guard_msgs in
example : True := by
  aesop (rule_sets := [Nonexistent])



=== LEAN SOURCE: 43.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

structure A

open Lean.Elab.Tactic in
@[aesop norm]
def tac : TacticM Unit := do
  evalTactic $ ← `(tactic| exact A.mk)

example : A := by
  set_option aesop.check.script false in
  set_option aesop.check.script.steps false in
  aesop



=== LEAN SOURCE: AddRulesCommand.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

-- Basic examples

structure TT₁ where

/-- error: tactic 'aesop' failed, made no progress -/
#guard_msgs in
example : TT₁ := by
  aesop

add_aesop_rules safe TT₁

example : TT₁ := by
  aesop

-- Local rules

structure TT₂ where

namespace Test

local add_aesop_rules safe TT₂

example : TT₂ := by
  aesop

end Test

/-- error: tactic 'aesop' failed, made no progress -/
#guard_msgs in
example : TT₂ := by
  aesop

-- Scoped rules

structure TT₃ where

namespace Test

scoped add_aesop_rules safe TT₃

example : TT₃ := by
  aesop

end Test

/-- error: tactic 'aesop' failed, made no progress -/
#guard_msgs in
example : TT₃ := by
  aesop

def Test.example : TT₃ := by
  aesop

-- Tactics

structure TT₄ where

/-- error: tactic 'aesop' failed, made no progress -/
#guard_msgs in
example : TT₄ := by
  aesop

add_aesop_rules safe (by exact TT₄.mk)

example : TT₄ := by
  aesop

-- Multiple rules

axiom T : Type
axiom U : Type
axiom f : T → U
axiom t : T

/-- error: tactic 'aesop' failed, made no progress -/
#guard_msgs in
example : U := by
  aesop

add_aesop_rules safe [(by apply f), t]

noncomputable example : U := by
  aesop



=== LEAN SOURCE: Aesop.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

open Lean
open Lean.Meta
open Lean.Elab.Tactic

section EvenOdd

inductive Even : Nat → Prop
| zero : Even 0
| plus_two {n} : Even n → Even (n + 2)

inductive Odd : Nat → Prop
| one : Odd 1
| plus_two {n} : Odd n → Odd (n + 2)

inductive EvenOrOdd : Nat → Prop
| even {n} : Even n → EvenOrOdd n
| odd {n} : Odd n → EvenOrOdd n

attribute [aesop unsafe] EvenOrOdd.even EvenOrOdd.odd
attribute [aesop safe] Even.zero Even.plus_two
attribute [aesop 100%] Odd.one Odd.plus_two

@[aesop norm unfold]
def EvenOrOdd' (n : Nat) : Prop := EvenOrOdd n

example : EvenOrOdd' 3 := by
  aesop

end EvenOdd

-- In this example, the goal is solved already during normalisation.
example : 0 = 0 := by aesop


-- An intentionally looping Aesop call, to test the limiting options
section Loop

structure Wrap (α) where
  unwrap : α

/--
error: tactic 'aesop' failed, maximum number of rule applications (20) reached. Set the 'maxRuleApplications' option to increase the limit.
-/
#guard_msgs in
example (h : α → α) (h' : Wrap α) : α := by
  aesop (add safe h)
    (config := { maxRuleApplications := 20, maxGoals := 0, maxRuleApplicationDepth := 0, terminal := true })

/--
error: tactic 'aesop' failed, maximum number of goals (20) reached. Set the 'maxGoals' option to increase the limit.
-/
#guard_msgs in
example (h : α → α) (h' : Wrap α) : α := by
  aesop (add safe h)
    (config := { maxGoals := 20, maxRuleApplications := 0, maxRuleApplicationDepth := 0, terminal := true })

/--
error: tactic 'aesop' failed, failed to prove the goal. Some goals were not explored because the maximum rule application depth (20) was reached. Set option 'maxRuleApplicationDepth' to increase the limit.
-/
#guard_msgs in
example (h : α → α) (h' : Wrap α) : α := by
  aesop (add safe h)
    (config := { maxRuleApplicationDepth := 20, maxGoals := 0, maxRuleApplications := 0, terminal := true })

end Loop


-- This example tests the builtin rule that applies local hypotheses.
example (Even : Nat → Prop) (zero : Even 0)
    (plusTwo : ∀ n, Even n → Even (n + 2)) : Even 20 := by
  aesop



=== LEAN SOURCE: AllWeaken.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg, Asta H. From
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

inductive All (P : α → Prop) : List α → Prop where
  | none : All P []
  | more {x xs} : P x → All P xs → All P (x :: xs)

@[aesop unsafe]
axiom weaken {α} (P Q : α → Prop) (wk : ∀ x, P x → Q x) (xs : List α)
  (h : All P xs) : All Q xs

/--
error: tactic 'aesop' failed, maximum number of rule applications (50) reached. Set the 'maxRuleApplications' option to increase the limit.
-/
#guard_msgs in
example : All (· ∈ []) (@List.nil α) := by
  aesop (config := { maxRuleApplications := 50, terminal := true })



=== LEAN SOURCE: ApplyHypsTransparency.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

def T := Unit → Nat

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example (h : T) : Nat := by
  aesop (config := { applyHypsTransparency := .reducible, terminal := true })

example (h : T) : Nat := by
  aesop

@[irreducible] def U := Empty

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example (h : Unit → Empty) : U := by
  aesop (config := { applyHypsTransparency := .reducible, terminal := true })

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example (h : Unit → Empty) : U := by
  aesop (config := { terminal := true })

example (h : Unit → Empty) : U := by
  aesop (config := { applyHypsTransparency := .all })



=== LEAN SOURCE: ApplyTransparency.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

def T := True

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : T := by
  aesop (add safe apply True.intro) (config := { terminal := true })

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : T := by
  aesop (add safe apply (transparency := default) True.intro)
    (config := { terminal := true })

example : T := by
  aesop (add safe apply (transparency! := default) True.intro)

@[irreducible] def U := T

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : U := by
  aesop (add safe apply True.intro) (config := { terminal := true })

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : U := by
  aesop (add safe apply (transparency := default) True.intro)
    (config := { terminal := true })

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : U := by
  aesop (add safe apply (transparency! := default) True.intro)
    (config := { terminal := true })

example : U := by
  aesop (add safe apply (transparency! := all) True.intro)



=== LEAN SOURCE: AssumptionTransparency.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

def T := Empty

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example (h : T) : Empty := by
  aesop (erase Aesop.BuiltinRules.applyHyps)
    (config := { assumptionTransparency := .reducible, terminal := true })

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example (h : T) : Empty := by
  aesop (erase Aesop.BuiltinRules.applyHyps)
    (config := { assumptionTransparency := .reducible, terminal := true })

example (h : T) : Empty := by
  aesop (erase Aesop.BuiltinRules.applyHyps)

@[irreducible] def U := False

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example (h : U) : False := by
  aesop (config := { terminal := true })

example (h : U) : False := by
  aesop (config := { assumptionTransparency := .all })



=== LEAN SOURCE: AuxDecl.lean ===
/-
Copyright (c) 2025 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

/-
This test case checks whether tactics that make use of auxiliary declarations,
such as `omega` and `bv_decide`, work with Aesop. Auxiliary declarations are
problematic because we can't allows tactics on different branches of the search
tree to add auxiliary declarations with the same name.
-/

theorem foo (m n : Nat) : n + m = m + n ∧ m + n = n + m := by
  fail_if_success aesop (config := { terminal := true })
  aesop (add safe (by omega))

local instance [Add α] [Add β] : Add (α × β) :=
  ⟨λ (a, b) (a', b') => (a + a', b + b')⟩

theorem bar
    (fst snd fst_1 snd_1 fst_2 snd_2 w w_1 w_2 w_3 : BitVec 128)
    (left : w_1.uaddOverflow w_3 = true)
    (left_1 : w.uaddOverflow w_2 = true)
    (right : (w_1 + w_3).uaddOverflow 1#128 = true) :
    (fst_2, snd_2) = (fst, snd) + (fst_1, snd_1) := by
  aesop (add safe (by bv_decide))

theorem baz (a b : BitVec 1) : (a = 0 ∨ a = 1) ∧ (b = 0 ∨ b = 1) := by
  aesop (add safe 1000 (by bv_decide))



=== LEAN SOURCE: BigStep.lean ===
/-
Copyright (c) 2024 Asei Inoue. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Asei Inoue, Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

abbrev Variable := String

def State := Variable → Nat

inductive Stmt : Type where
  | skip : Stmt
  | assign : Variable → (State → Nat) → Stmt
  | seq : Stmt → Stmt → Stmt
  | ifThenElse : (State → Prop) → Stmt → Stmt → Stmt
  | whileDo : (State → Prop) → Stmt → Stmt

infix:60 ";; " => Stmt.seq

export Stmt (skip assign seq ifThenElse whileDo)

set_option quotPrecheck false in
notation s:70 "[" x:70 "↦" n:70 "]" => (fun v ↦ if v = x then n else s v)

inductive BigStep : Stmt → State → State → Prop where
  | protected skip (s : State) : BigStep skip s s
  | protected assign (x : Variable) (a : State → Nat) (s : State) : BigStep (assign x a) s (s[x ↦ a s])
  | protected seq {S T : Stmt} {s t u : State} (hS : BigStep S s t) (hT : BigStep T t u) :
    BigStep (S;; T) s u
  | protected if_true {B : State → Prop} {s t : State} (hcond : B s) (S T : Stmt) (hbody : BigStep S s t) :
    BigStep (ifThenElse B S T) s t
  | protected if_false {B : State → Prop} {s t : State} (hcond : ¬ B s) (S T : Stmt) (hbody : BigStep T s t) :
    BigStep (ifThenElse B S T) s t
  | while_true {B S s t u} (hcond : B s) (hbody : BigStep S s t) (hrest : BigStep (whileDo B S) t u) :
    BigStep (whileDo B S) s u
  | while_false {B S s} (hcond : ¬ B s) : BigStep (whileDo B S) s s

notation:55 "(" S:55 "," s:55 ")" " ==> " t:55 => BigStep S s t

add_aesop_rules safe [BigStep.skip, BigStep.assign, BigStep.seq, BigStep.while_false]
add_aesop_rules 50% [apply BigStep.while_true]
add_aesop_rules safe [
  (by apply BigStep.if_true (hcond := by assumption) (hbody := by assumption)),
  (by apply BigStep.if_false (hcond := by assumption) (hbody := by assumption))
]

namespace BigStep

@[aesop safe destruct]
theorem cases_if_of_true {B S T s t} (hcond : B s) : (ifThenElse B S T, s) ==> t → (S, s) ==> t := by
  intro h; cases h <;> aesop

@[aesop safe destruct]
theorem cases_if_of_false {B S T s t} (hcond : ¬ B s) : (ifThenElse B S T, s) ==> t → (T, s) ==> t := by
  intro h; cases h <;> aesop

@[aesop 30%]
theorem and_excluded {P Q R : Prop} (hQ : P → Q) (hR : ¬ P → R) : (P ∧ Q ∨ ¬ P ∧ R) := by
  by_cases h : P <;> aesop

theorem if_iff {B S T s t} : (ifThenElse B S T, s) ==> t ↔
    (B s ∧ (S, s) ==> t) ∨ (¬ B s ∧ (T, s) ==> t) := by
  aesop

end BigStep



=== LEAN SOURCE: Cases.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/
import Aesop

set_option aesop.check.all true

@[aesop 50% cases]
inductive FancyAnd (α β : Prop) : Prop
  | dummy (p : Empty)
  | and (a : α) (b : β)

attribute [aesop safe -51 cases] Empty

example {α β} (h : FancyAnd α β) : α ∧ β := by
  aesop

@[aesop safe cases (cases_patterns := [All _ [], All _ (_ :: _)])]
inductive All (P : α → Prop) : List α → Prop
  | nil : All P []
  | cons : P x → All P xs → All P (x :: xs)

@[aesop 99% constructors]
structure MyTrue : Prop

-- Without the patterns on the `cases` rule for `All`, this test would loop
-- since the `constructors` rule would never be applied.
example {P : α → Prop} (h : All P (x :: xs)) : MyTrue := by
  aesop



=== LEAN SOURCE: CasesScript.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

@[aesop 50% cases]
inductive FancyAnd (α β : Prop) : Prop
  | dummy (p : Empty)
  | and (a : α) (b : β)

/--
info: Try this:
  apply And.intro
  ·
    cases h with
    | dummy p =>
      have fwd : False := Aesop.BuiltinRules.empty_false p
      simp_all only
    | and a b => simp_all only
  ·
    cases h with
    | dummy p =>
      have fwd : False := Aesop.BuiltinRules.empty_false p
      simp_all only
    | and a b => simp_all only
-/
#guard_msgs in
example {α β} (h : FancyAnd α β) : α ∧ β := by
  aesop?

@[aesop safe cases (cases_patterns := [All _ [], All _ (_ :: _)])]
inductive All (P : α → Prop) : List α → Prop
  | nil : All P []
  | cons : P x → All P xs → All P (x :: xs)

@[aesop 99% constructors]
structure MyTrue : Prop

/--
info: Try this:
  rcases h with ⟨⟩ | @⟨x_1, xs_1, a, a_1⟩
  apply MyTrue.mk
-/
#guard_msgs in
example {P : α → Prop} (h : All P (x :: xs)) : MyTrue := by
  aesop?



=== LEAN SOURCE: CasesTransparency.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

example (h : False) : α := by
  aesop

def T := False

variable {α : Type}

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example (h : T) : α := by
  aesop (config := { terminal := true })

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example (h : T) : α := by
  aesop (add safe cases (transparency! := reducible) False)
    (config := { terminal := true })

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example (h : T) : α := by
  aesop (add safe cases (transparency := default) False)
    (config := { terminal := true })

example (h : T) : α := by
  aesop (add safe cases (transparency! := default) False)

def U := T

example (h : U) : α := by
  aesop (add safe cases (transparency! := default) False)



=== LEAN SOURCE: Com.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/
import Aesop

set_option aesop.check.all false
-- With this option, the test becomes unbearably slow.

abbrev State := String → Int

inductive Com where
| Skip : Com
| Seq : Com → Com → Com

declare_syntax_cat com

syntax "SKIP" : com
syntax com ";" com : com
syntax "(" com ")" : com
syntax term : com

syntax "[Com|" com "]" : term

macro_rules
| `([Com| SKIP]) => `(Com.Skip)
| `([Com| $x ; $y]) => `(Com.Seq [Com| $x] [Com| $y])
| `([Com| ( $x:com )]) => `([Com| $x])
| `([Com| $x:term ]) => `($x)

@[aesop safe [constructors, -100 cases (index := [hyp BigStep Com.Skip _ _, hyp BigStep [Com| _;_] _ _])]]
inductive BigStep : Com → State → State → Prop where
| Skip : BigStep Com.Skip s s
| Seq (h1 : BigStep c₁ s t) (h2 : BigStep c₂ t u) : BigStep [Com| c₁;c₂] s u

theorem seq_assoc :
    BigStep [Com| (c1;c2);c3] s s' ↔ BigStep [Com| c1;c2;c3] s s' := by
  aesop



=== LEAN SOURCE: CompositeLocalRuleTerm.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

-- Composite terms are supported by the `apply` and `forward` builders...

structure A where

/--
error: tactic 'aesop' failed, made no progress
-/
#guard_msgs in
example (h : A → β → γ) (b : β) : γ := by
  aesop

example (h : A → β → γ) (b : β) : γ := by
  aesop (add safe apply (h {}))

example (h : A → β → γ) (b : β) : γ := by
  aesop (add safe forward (h {}))

-- ... and also by the `simp` builder.

/--
error: tactic 'aesop' failed, made no progress
-/
#guard_msgs in
example {P : α → Prop} (h : A → x = y) (p : P x) : P y := by
  aesop

example {P : α → Prop} (h : A → x = y) (p : P x) : P y := by
  aesop (add simp (h {}))

/--
error: tactic 'aesop' failed, made no progress
-/
#guard_msgs in
example {P : α → Prop} (h₁ : A → x = y) (h₂ : A → y = z) (p : P x) : P z := by
  aesop

example {P : α → Prop} (h₁ : A → x = y) (h₂ : A → y = z) (p : P x) : P z := by
  aesop (add simp [(h₁ {}), (h₂ {})])



=== LEAN SOURCE: ConstructorEquations.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

-- From an equation where both sides contain only constructor applications
-- and variables, Aesop should derive equations about the variables.

example (h : Nat.zero = Nat.succ n) : False := by
  aesop

example (h : Nat.succ (Nat.succ n) = Nat.succ Nat.zero) : False := by
  aesop

example (h : (Nat.succ m, Nat.succ n) = (Nat.succ a, Nat.succ b)) :
    m = a ∧ n = b := by
  aesop

structure MyProd (A B : Type _) where
  toProd : A × B

example (h : MyProd.mk (x, y) = .mk (a, b)) : x = a ∧ y = b := by
  aesop



=== LEAN SOURCE: Constructors.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

@[aesop safe]
inductive Even : Nat → Type
  | zero : Even 0
  | plusTwo : Even n → Even (n + 2)

example : Even 6 := by
  aesop

attribute [-aesop] Even

def T n := Even n

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : T 6 := by
  aesop (config := { terminal := true })

example : T 6 := by
  aesop (add safe constructors (transparency! := default) Even)



=== LEAN SOURCE: CustomIndexing.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

variable {α : Type}

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example (h : α) : α := by
  aesop (rule_sets := [-builtin,-default])
        (add safe h apply (index := [target False]))
        (config := { terminal := true })

example (h : α) : α := by
  aesop (rule_sets := [-builtin,-default]) (add safe h apply)

-- See Com test for a more realistic scenario.



=== LEAN SOURCE: CustomTactic.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

def Foo := True

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : Foo := by
  aesop (config := { terminal := true })

example : Foo := by
  simp [Foo]

open Lean.Elab.Tactic in
@[aesop safe]
def myTactic : TacticM Unit := do
  evalTactic $ ← `(tactic| rw [Foo])

example : Foo := by
  set_option aesop.check.script false in
  set_option aesop.check.script.steps false in
  aesop



=== LEAN SOURCE: DefaultRuleSets.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import AesopTest.DefaultRuleSetsInit

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

@[aesop norm unfold (rule_sets := [regular₁])]
def T := True

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : T := by
  aesop (config := { terminal := true })

example : T := by
  aesop (rule_sets := [regular₁])

@[aesop norm unfold (rule_sets := [regular₂, dflt₁])]
def U := True

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : U := by
  aesop (rule_sets := [-dflt₁]) (config := { terminal := true })

example : U := by
  aesop



=== LEAN SOURCE: DefaultRuleSetsInit.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

declare_aesop_rule_sets [regular₁, regular₂]

declare_aesop_rule_sets [dflt₁, dflt₂] (default := true)



=== LEAN SOURCE: DestructProducts.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

-- This file tests the builtin rules that destruct hypotheses with product-like
-- types.

import Aesop

set_option aesop.check.all true

@[aesop safe constructors]
inductive Ex (α : Sort u) (β : α → Prop) : Prop
  | intro (fst : α) (snd : β fst)

@[aesop safe constructors]
structure Sig (α : Sort u) (β : α → Sort v) : Sort _ where
  fst : α
  snd : β fst

example (h : α ∧ β) : Sig α (λ _ => β) := by
  aesop

example (h : α × β) : Sig α (λ _ => β) := by
  aesop

example (h : PProd α β) : Sig α (λ _ => β) := by
  aesop

example (h : MProd α β) : Sig α (λ _ => β) := by
  aesop

example {p : α → Prop} (h : ∃ a, p a) : Ex α p := by
  aesop

example {p : α → Prop} (h : { a // p a }) : Sig α p := by
  aesop

example {p : α → Type} (h : Σ a, p a) : Sig α p := by
  aesop

example {p : α → Type} (h : Σ' a, p a) : Sig α p := by
  aesop

-- Test case for a bug reported by Jakob von Raumer.
example (x y : α × α) (h: p ∧ (x = y)) : x = y := by
  aesop (config := { enableSimp := false })



=== LEAN SOURCE: DestructProductsTransparency.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

@[aesop safe constructors]
structure Sig (α : Sort u) (β : α → Sort v) : Sort _ where
  fst : α
  snd : β fst

def T α β := α ∧ β

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example (h : T α β) : Sig α (λ _ => β) := by
  aesop (config := { terminal := true })

example (h : T α β) : Sig α (λ _ => β) := by
  aesop (config := { destructProductsTransparency := .default })

def U := T

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example (h : U α β) : Sig α (λ _ => β) := by
  aesop (config := { terminal := true })

example (h : U α β) : Sig α (λ _ => β) := by
  aesop (config := { destructProductsTransparency := .default })

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example (h : U α β ∧ U γ δ) : Sig α (λ _ => γ) := by
  aesop (config := { terminal := true })

example (h : U α β ∧ U γ δ) : Sig α (λ _ => γ) := by
  aesop (config := { destructProductsTransparency := .default })



=== LEAN SOURCE: DocLists.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

-- NOTE: This file contains examples for, and therefore should be kept in sync
-- with, the README.

import Aesop

set_option aesop.check.all true

inductive MyList (α : Type _)
  | nil
  | cons (hd : α) (tl : MyList α)

namespace MyList

protected def append : (_ _ : MyList α) → MyList α
  | nil, ys => ys
  | cons x xs, ys => cons x (MyList.append xs ys)

instance : Append (MyList α) :=
  ⟨MyList.append⟩

@[simp]
theorem nil_append : nil ++ xs = xs := rfl

@[simp]
theorem cons_append : cons x xs ++ ys = cons x (xs ++ ys) := rfl

@[aesop safe [constructors, cases]]
inductive NonEmpty : MyList α → Prop
  | cons : NonEmpty (cons x xs)

@[aesop 50%]
theorem nonEmpty_append₁ {xs : MyList α} ys :
    NonEmpty xs → NonEmpty (xs ++ ys) := by
  aesop

/--
info: Try this:
  intro a
  obtain @⟨x, xs_1⟩ := a
  simp_all only [cons_append]
  apply MyList.NonEmpty.cons
-/
#guard_msgs in
theorem nonEmpty_append₁' {xs : MyList α} ys :
    NonEmpty xs → NonEmpty (xs ++ ys) := by
  aesop?

example {α : Type _} {xs : MyList α} ys zs :
    NonEmpty xs → NonEmpty (xs ++ ys ++ zs) := by
  aesop

theorem nil_not_nonEmpty (xs : MyList α) : xs = nil → ¬ NonEmpty xs := by
  aesop (add unsafe 10% cases MyList)

@[simp]
theorem append_nil {xs : MyList α} :
    xs ++ nil = xs := by
  induction xs <;> aesop

theorem append_assoc {xs ys zs : MyList α} :
    (xs ++ ys) ++ zs = xs ++ (ys ++ zs) := by
  induction xs <;> aesop

end MyList



=== LEAN SOURCE: DroppedMVars.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jesse Vogel, Jannis Limperg
-/

-- Thanks to Jesse Vogel for this test case. It demonstrates the handling of
-- 'dropped' mvars. A rapp drops an mvar if the mvar appears in the parent goal
-- of the rapp, but not in any of its subgoals. In this case, we add an
-- additional regular goal for the mvar.

import Aesop

set_option aesop.check.all true

axiom Ring : Type

axiom RingHom (R S : Ring) : Type

@[aesop 99%]
axiom RingId (R : Ring) : RingHom R R

@[aesop 99%]
axiom ZZ : Ring

example : ∃ (R : Ring) (_ : RingHom R R), True := by
  aesop (add safe True.intro) (config := { enableSimp := false })



=== LEAN SOURCE: ElabConfig.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

/--
error: 'noSuchOption' is not a field of structure 'Aesop.Options'
-/
#guard_msgs in
example : True := by
  aesop (config := { noSuchOption := true })

/--
error: 'noSuchOption' is not a field of structure 'Lean.Meta.Simp.ConfigCtx'
-/
#guard_msgs in
example : True := by
  aesop (simp_config := { noSuchOption := true })



=== LEAN SOURCE: EnableUnfold.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

@[aesop norm unfold]
def T := True

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : T := by
  aesop (config := { enableUnfold := false, terminal := true })

example : T := by
  aesop



=== LEAN SOURCE: EqualUpToIds.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Util.Basic
import Aesop.Util.EqualUpToIds
import Aesop.Tree.RunMetaM

-- Some simple test cases for the EqualUpToIds module. The module is mostly
-- tested by using it in script validation, which is run on almost all Aesop
-- calls in the test suite.

open Aesop Lean Lean.Elab.Tactic

def assertEqualTactics (t₁ t₂ : TacticM Unit) : TacticM Unit := do
  let commonMCtx ← getMCtx
  let preState ← show MetaM _ from saveState
  let preGoals ← getGoals
  let (state₁, goals₁) ← runTacticMCapturingPostState t₁ preState preGoals
  let (state₂, goals₂) ← runTacticMCapturingPostState t₂ preState preGoals
  let eq ←
    tacticStatesEqualUpToIds commonMCtx state₁.meta.mctx state₂.meta.mctx
      goals₁.toArray goals₂.toArray
  if ! eq then
    throwError "Tactics produced different tactic states.\nTactic 1:{indentD $ ← ppTacticState state₁ goals₁}\nTactic 2:{indentD $ ← ppTacticState state₂ goals₂}\n"
where
  ppTacticState (state : Meta.SavedState) (goals : List MVarId) :
      MetaM MessageData :=
    state.runMetaM' do
      addMessageContext $ .joinSep (goals.map toMessageData) "\n"

open Lean.Elab.Tactic in
elab &"assert_equal_tactics "
    " { " ts₁:tacticSeq " } " " { " ts₂:tacticSeq " } " : tactic => do
  assertEqualTactics (evalTactic ts₁) (evalTactic ts₂)

example : True := by
  assert_equal_tactics { trivial } { trivial }
  trivial

example : True := by
  assert_equal_tactics { open Classical in trivial } { trivial }
  trivial

/--
error: Tactics produced different tactic states.
Tactic 1:
  case zero
  m : Nat
  ⊢ True
  case succ
  m n✝ : Nat
  ⊢ True
Tactic 2:
  case zero
  n : Nat
  ⊢ True
  case succ
  n n✝ : Nat
  ⊢ True
-/
#guard_msgs in
example (n m : Nat) : True := by
  assert_equal_tactics { cases n } { cases m }
  trivial

example : 0 < 3 := by
  apply Nat.lt_trans
  assert_equal_tactics { exact Nat.lt_succ_self 0 } { exact Nat.lt_succ_self 0 }
  (case m => exact 1); all_goals decide

example : 0 < 3 := by
  apply Nat.lt_trans
  assert_equal_tactics { apply Nat.lt_trans } { apply Nat.lt_trans }
  (case m => exact 1); all_goals decide



=== LEAN SOURCE: Erase.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

@[aesop [10% cases, safe constructors]]
inductive Even : Nat → Prop
  | zero : Even 0
  | plus_two : Even n → Even (n + 2)

example : Even 2 := by
  aesop

-- Removing the Aesop attribute erases all rules associated with the identifier
-- from all rule sets.
attribute [-aesop] Even

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : Even 2 := by
  aesop (config := { terminal := true })

example : Even 2 := by
  aesop (add safe Even)

-- We can also selectively remove rules in a certain phase or with a certain
-- builder.
attribute [aesop [unsafe 10% cases, safe constructors]] Even

erase_aesop_rules [ unsafe Even ]

example : Even 2 := by
  aesop

erase_aesop_rules [ constructors Even ]

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : Even 2 := by
  aesop (config := { terminal := true })

example : Even 2 := by
  aesop (add safe constructors Even)



=== LEAN SOURCE: EraseSimp.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

example (n : Nat) : n + m = m + n := by
  aesop (add simp Nat.add_comm)

attribute [local simp] Nat.add_comm

example (n : Nat) : n + m = m + n := by
  aesop

/--
error: tactic 'aesop' failed, made no progress
-/
#guard_msgs in
example (n : Nat) : n + m = m + n := by
  aesop (erase Nat.add_comm) (config := { warnOnNonterminal := false })

/--
error: tactic 'aesop' failed, made no progress
-/
#guard_msgs in
example (n : Nat) : n + m = m + n := by
  aesop (erase norm simp Nat.add_comm) (config := { warnOnNonterminal := false })

/--
error: aesop: 'Nat.add_comm' is not registered (with the given features) in any rule set.
-/
#guard_msgs in
example (n : Nat) : n + m = m + n := by
  aesop (erase apply Nat.add_comm)



=== LEAN SOURCE: EraseUnfold.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux, Jannis Limperg
-/

-- Thanks to Jireh Loreaux for reporting this MWE.

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

@[irreducible]
def foo : Nat := 37

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : foo = 37 := by
  aesop (config := { terminal := true }) (erase Aesop.BuiltinRules.rfl)

example : foo = 37 := by
  unfold foo
  rfl

attribute [aesop norm unfold] foo

example : foo = 37 := by aesop (erase Aesop.BuiltinRules.rfl)

attribute [-aesop] foo

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : foo = 37 := by
  aesop (config := { terminal := true }) (erase Aesop.BuiltinRules.rfl)

example : foo = 37 := by
  unfold foo
  rfl



=== LEAN SOURCE: Ext.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

example (f g : α → β) (h : ∀ a, f a = g a) : f = g := by
  aesop

example (x y : α × β) (h₁ : x.1 = y.1) (h₂ : x.2 = y.2) : x = y := by
  aesop



=== LEAN SOURCE: ExtScript.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

@[ext]
structure MyProd (α β : Type _) where
  fst : α
  snd : β

variable {α β γ δ ι: Type}

/--
info: Try this:
  ext : 1
  · sorry
  · sorry
---
warning: declaration uses 'sorry'
-/
#guard_msgs in
example {p q : MyProd α β} : p = q := by
  aesop? (add safe Aesop.BuiltinRules.ext)
    (config := { warnOnNonterminal := false })
  all_goals sorry

/--
info: Try this:
  ext : 1
  · sorry
  · ext : 1
    · sorry
    · sorry
---
warning: declaration uses 'sorry'
-/
#guard_msgs in
example {p q : MyProd α (MyProd β γ)} : p = q := by
  aesop? (add safe Aesop.BuiltinRules.ext)
    (config := { warnOnNonterminal := false })
  all_goals sorry

/--
info: Try this:
  ext : 1
  · ext x : 1
    sorry
  · sorry
---
warning: declaration uses 'sorry'
-/
#guard_msgs in
example {p q : MyProd (α → β) γ} : p = q := by
  aesop? (add safe Aesop.BuiltinRules.ext)
    (config := { warnOnNonterminal := false })
  all_goals sorry

/--
info: Try this:
  ext : 1
  · ext x : 1
    sorry
  · ext x x_1 : 2
    sorry
---
warning: declaration uses 'sorry'
-/
#guard_msgs in
example {p q : (α → β) × (γ → δ → ι)} : p = q := by
  aesop? (add safe Aesop.BuiltinRules.ext)
    (erase Aesop.BuiltinRules.destructProducts)
    (config := { warnOnNonterminal := false })
  all_goals sorry

-- This test case checks script generation for ext calls which generate subgoals
-- with different numbers of new hypotheses.

axiom T : Type
axiom U : Type
axiom u : U
axiom v : U

@[ext (iff := false)]
axiom T_ext : ∀ x y : T, u = v → (∀ u v : U, u = v) → x = y

/--
info: Try this:
  ext u v : 1
  · sorry
  · sorry
---
warning: declaration uses 'sorry'
-/
#guard_msgs in
example (x y : T) : x = y := by
  aesop? (add safe Aesop.BuiltinRules.ext)
    (config := { warnOnNonterminal := false })
  all_goals sorry



=== LEAN SOURCE: Filter.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sebastian Ullrich, Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

namespace TBA

inductive List (α : Type) where
  | nil : List α
  | cons (head : α) (tail : List α) : List α

notation  (priority := high) "[" "]" => List.nil
infixr:67 (priority := high) " :: "  => List.cons

def filter (p : α → Prop) [DecidablePred p] (as : List α) : List α :=
  match as with
  | [] => []
  | a::as => if p a then a :: filter p as else filter p as

variable {p : α → Prop} [DecidablePred p] {as bs : List α}

@[simp]
theorem filter_cons_true (h : p a) : filter p (a :: as) = a :: filter p as := by
  simp [filter, h]

@[simp]
theorem filter_cons_false (h : ¬ p a) : filter p (a :: as) = filter p as := by
  simp [filter, h]

@[aesop 50% [constructors, cases]]
inductive Mem (a : α) : List α → Prop where
  | head {as} : Mem a (a::as)
  | tail {as} : Mem a as → Mem a (a'::as)

infix:50 " ∈ " => Mem

theorem mem_filter : a ∈ filter p as ↔ a ∈ as ∧ p a := by
  apply Iff.intro
  case mp =>
    intro h
    induction as with
    | nil => cases h
    | cons a' as ih => by_cases ha' : p a' <;> aesop
  case mpr =>
    intro h
    induction as with
    | nil => cases h.1
    | cons a' as ih =>
      cases h.1 with
      | head =>
        rw [filter_cons_true h.2]
        constructor
      | tail ha =>
        have : a ∈ filter p as := ih ⟨ha, h.2⟩
        by_cases hpa' : p a'
        case pos =>
          rw [filter_cons_true hpa']
          exact Mem.tail this
        case neg =>
          rw [filter_cons_false hpa']
          exact this

end TBA



=== LEAN SOURCE: Forward.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true
set_option pp.mvars false

/--
info: Try this:
  have fwd : γ₁ ∧ γ₂ := r₁ a b
  have fwd_1 : δ₁ ∧ δ₂ := r₂ a
---
error: unsolved goals
α : Sort u_1
β : Sort u_2
γ₁ γ₂ δ₁ δ₂ : Prop
a : α
b : β
r₁ : ∀ (a : α) (b : β), γ₁ ∧ γ₂
r₂ : ∀ (a : α), δ₁ ∧ δ₂
fwd : γ₁ ∧ γ₂
fwd_1 : δ₁ ∧ δ₂
⊢ γ₁ ∧ γ₂ ∧ δ₁ ∧ δ₂
-/
#guard_msgs in
example (a : α) (b : β) (r₁ : (a : α) → (b : β) → γ₁ ∧ γ₂)
    (r₂ : (a : α) → δ₁ ∧ δ₂) : γ₁ ∧ γ₂ ∧ δ₁ ∧ δ₂ := by
  saturate? [*]

/--
info: Try this:
  have fwd : β := h₁ h₃
  have fwd_1 : γ := h₂ fwd
---
error: unsolved goals
α β γ : Prop
h₁ : α → β
h₂ : β → γ
h₃ : α
fwd : β
fwd_1 : γ
⊢ γ
-/
#guard_msgs in
example {α β γ : Prop} (h₁ : α → β) (h₂ : β → γ) (h₃ : α) : γ := by
  saturate? [*]

/--
info: Try this:
have fwd : β := h₁ h₃
---
error: unsolved goals
α β γ : Prop
h₁ : α → β
h₂ : β → γ
h₃ : α
fwd : β
⊢ γ
-/
#guard_msgs in
example {α β γ : Prop} (h₁ : α → β) (h₂ : β → γ) (h₃ : α) : γ := by
  forward? [*]

/--
info: Try this:
have fwd : β := h₁ h₃
---
error: unsolved goals
α β γ : Prop
h₁ : α → β
h₂ : β → γ
h₃ : α
fwd : β
⊢ γ
-/
#guard_msgs in
example {α β γ : Prop} (h₁ : α → β) (h₂ : β → γ) (h₃ : α) : γ := by
  saturate? 1 [*]

/--
info: Try this:
  have fwd : β := h₁ h₄
  have fwd_1 : γ := h₂ fwd
---
error: unsolved goals
α β γ δ : Prop
h₁ : α → β
h₂ : β → γ
h₃ : γ → δ
h₄ : α
fwd : β
fwd_1 : γ
⊢ δ
-/
#guard_msgs in
example {α β γ δ : Prop} (h₁ : α → β) (h₂ : β → γ) (h₃ : γ → δ) (h₄ : α) : δ := by
  saturate? 2 [*]

/--
info: Try this:
  have fwd : β := h₁ h₄
  have fwd_1 : γ := h₂ h₄
---
error: unsolved goals
α β γ δ : Prop
h₁ : α → β
h₂ : α → γ
h₃ : β → γ → δ
h₄ : α
fwd : β
fwd_1 : γ
⊢ δ
-/
#guard_msgs in
example {α β γ δ : Prop} (h₁ : α → β) (h₂ : α → γ) (h₃ : β → γ → δ) (h₄ : α) : δ := by
  saturate? 1 [*]

example {P : Nat → Prop} (hP : P 0) (hPn : ∀ n, P n → P (n + 1)) : P 20 := by
  saturate 20 [*]
  assumption

section

axiom A : Type
axiom B : Type
axiom C : Type

@[local aesop safe forward]
axiom ab : A → B

@[local aesop norm forward]
axiom bc : B → C

/--
info: Try this:
have fwd : P := rule P (Q ∧ R) h
-/
#guard_msgs in
example (rule : ∀ α β, α ∧ β → α) (h : P ∧ Q ∧ R) : P := by
  forward? [*]
  guard_hyp fwd : P
  assumption

/--
info: Try this:
  have fwd : B := ab a
  have fwd_1 : C := bc fwd
---
error: unsolved goals
a : A
fwd : B
fwd_1 : C
⊢ C
-/
#guard_msgs in
noncomputable example : A → C := by
  intro a
  saturate?

end

/--
info: Try this:
have fwd : R a b := h₁ a b h₂ h₃
---
error: unsolved goals
α : Sort u_1
β : Sort u_2
a : α
b : β
P Q R : α → β → Prop
h₁ : ∀ (a : α) (b : β), P a b → Q a b → R a b
h₂ : P a b
h₃ : Q a b
fwd : R a b
⊢ R a b
-/
#guard_msgs in
example {P Q R : α → β → Prop} (h₁ : ∀ a b, P a b → Q a b → R a b)
    (h₂ : P a b) (h₃ : Q a b) : R a b := by
  saturate? [h₁]

/--
info: Try this:
have fwd : R a b := h₁ a b h₂ h₄
---
error: unsolved goals
α : Sort u_1
a b : α
P Q R : α → α → Prop
h₁ : ∀ (a b : α), P a b → Q b a → R a b
h₂ : P a b
h₃ : Q a b
h₄ : Q b a
fwd : R a b
⊢ R a b
-/
#guard_msgs in
example {P Q R : α → α → Prop} (h₁ : ∀ a b, P a b → Q b a → R a b)
    (h₂ : P a b) (h₃ : Q a b) (h₄ : Q b a) : R a b := by
  saturate? [*]

/--
error: unsolved goals
α : Sort u_1
a b : α
P Q R : α → α → Prop
h₁ : ∀ (a b : α), P a b → Q b a → R a b
h₂ : P a b
h₃ : Q a b
⊢ R a b
-/
#guard_msgs in
example {P Q R : α → α → Prop} (h₁ : ∀ a b, P a b → Q b a → R a b)
    (h₂ : P a b) (h₃ : Q a b) : R a b := by
  saturate [*]

/--
info: Try this:
have fwd : R b a := h₁ b a h₄ h₃
---
error: unsolved goals
α : Sort u_1
c d a b : α
P Q R : α → α → Prop
h₁ : ∀ (a b : α), P a b → Q b a → R a b
h₂ : P c d
h₃ : Q a b
h₄ : P b a
fwd : R b a
⊢ R b a
-/
#guard_msgs in
example {P Q R : α → α → Prop} (h₁ : ∀ a b, P a b → Q b a → R a b)
    (h₂ : P c d) (h₃ : Q a b) (h₄ : P b a) : R b a := by
  saturate? [*]

/--
info: Try this:
  have fwd : R c c := h₁ c d d c h₂ h₅
  have fwd_1 : R c b := h₁ c d a b h₂ h₃
  have fwd_2 : R b c := h₁ b a d c h₄ h₅
  have fwd_3 : R b b := h₁ b a a b h₄ h₃
---
error: unsolved goals
α : Sort u_1
c d a b : α
P Q R : α → α → Prop
h₁ : ∀ (a b c d : α), P a b → Q c d → R a d
h₂ : P c d
h₃ : Q a b
h₄ : P b a
h₅ : Q d c
fwd : R c c
fwd_1 : R c b
fwd_2 : R b c
fwd_3 : R b b
⊢ R c b
-/
#guard_msgs in
example {P Q R : α → α → Prop} (h₁ : ∀ a b c d, P a b → Q c d → R a d)
    (h₂ : P c d) (h₃ : Q a b) (h₄ : P b a) (h₅ : Q d c) : R c b := by
  saturate? [*]

/--
info: Try this:
  have fwd : S a d := h₁ a b c d h₂ h₃ h₄
  have fwd_1 : S a c := h₁ a b d c h₂ h₃ h₅
---
error: unsolved goals
α : Sort u_1
a b c d : α
P Q R S : α → α → Prop
h₁ : ∀ (a b c d : α), P a b → Q b a → R c d → S a d
h₂ : P a b
h₃ : Q b a
h₄ : R c d
h₅ : R d c
fwd : S a d
fwd_1 : S a c
⊢ S a d
-/
#guard_msgs in
example {P Q R S : α → α → Prop} (h₁ : ∀ a b c d, P a b → Q b a → R c d → S a d)
    (h₂ : P a b) (h₃ : Q b a) (h₄ : R c d) (h₅ : R d c) : S a d := by
  saturate? [*]

/--
info: Try this:
have fwd : R b a := h₁ a b h₂ h₃ h₄
---
error: unsolved goals
α : Sort u_1
a b : α
P : α → Prop
Q R : α → α → Prop
h₁ : ∀ (a b : α), P a → P b → Q a b → R b a
h₂ : P a
h₃ : P b
h₄ : Q a b
fwd : R b a
⊢ Q b a
-/
#guard_msgs in
example {P : α → Prop} {Q R : α → α → Prop}
    (h₁ : ∀ a b, P a → P b → Q a b → R b a)
    (h₂ : P a) (h₃ : P b) (h₄ : Q a b) : Q b a := by
  saturate? [*]

/--
info: Try this:
have fwd : R b a := h₁ a b h₆ h₅ h₄
---
error: unsolved goals
α : Sort u_1
c d a b : α
P : α → Prop
Q R : α → α → Prop
h₁ : ∀ (a b : α), P a → P b → Q a b → R b a
h₂ : P c
h₃ : P d
h₄ : Q a b
h₅ : P b
h₆ : P a
fwd : R b a
⊢ Q b a
-/
#guard_msgs in
example {P : α → Prop} {Q R : α → α → Prop}
    (h₁ : ∀ a b, P a → P b → Q a b → R b a)
    (h₂ : P c) (h₃ : P d) (h₄ : Q a b) (h₅ : P b) (h₆ : P a) : Q b a := by
  saturate? [*]

/--
info: Try this:
  have fwd : R c d := h₁ d c h₃ h₂ h₇
  have fwd_1 : R b a := h₁ a b h₆ h₅ h₄
---
error: unsolved goals
α : Sort u_1
c d a b : α
P : α → Prop
Q R : α → α → Prop
h₁ : ∀ (a b : α), P a → P b → Q a b → R b a
h₂ : P c
h₃ : P d
h₄ : Q a b
h₅ : P b
h₆ : P a
h₇ : Q d c
fwd : R c d
fwd_1 : R b a
⊢ Q b a
-/
#guard_msgs in
example {P : α → Prop} {Q R : α → α → Prop}
    (h₁ : ∀ a b, P a → P b → Q a b → R b a)
    (h₂ : P c) (h₃ : P d) (h₄ : Q a b) (h₅ : P b) (h₆ : P a) (h₇ : Q d c) : Q b a := by
  saturate? [*]

example (a : α) (b : β) (r₁ : (a : α) → (b : β) → γ₁ ∧ γ₂)
    (r₂ : (a : α) → δ₁ ∧ δ₂) : γ₁ ∧ γ₂ ∧ δ₁ ∧ δ₂ := by
  aesop (add safe [forward r₁, forward (immediate := [a]) r₂])

section MatchRedundancy

-- Complete matches are considered redundant (and hence do not produce new
-- hypotheses) if they agree on all variables that appear in the conclusion.

/--
error: unsolved goals
γ : Sort u_1
α : Prop
β : Type
r : α → β → γ
a₁ a₂ : α
b₁ b₂ : β
fwd : γ
⊢ True
-/
#guard_msgs in
example {α : Prop} {β : Type} (r : α → β → γ) (a₁ a₂ : α) (b₁ b₂ : β) : True := by
  saturate [r]
  -- Only one new hypothesis.

/--
error: unsolved goals
α : Sort u_1
a₁ a₂ : α
P Q : α → Prop
r : ∀ (a : α), P a → Q a
p₁ : P a₁
p₂ p₂' : P a₂
fwd : Q a₁
fwd_1 : Q a₂
⊢ True
-/
#guard_msgs in
example {P Q : α → Prop} (r : ∀ a, P a → Q a) (p₁ : P a₁) (p₂ : P a₂)
    (p₂' : P a₂) : True := by
  saturate [r]
  -- Two new hypotheses, one for `a₁` and one for `a₂` (but not two).

-- When a hypothesis already exists in the context, it is not added again.

/--
error: unsolved goals
α : Sort u_1
β : Sort u_2
r₁ r₂ : α → β
a₁ a₂ : α
fwd : β
⊢ True
-/
#guard_msgs in
example (r₁ r₂ : α → β) (a₁ a₂ : α) : True := by
  saturate [r₁, r₂]
  -- Two new hypotheses (but not four).

end MatchRedundancy

/--
info: Try this:
  have fwd : γ₁ ∧ γ₂ := r₁ a b
  simp_all only [and_self, implies_true, true_and]
  obtain ⟨left, right⟩ := fwd
  have fwd : δ₁ ∧ δ₂ := r₂ a
  simp_all only [and_self, implies_true]
-/
#guard_msgs in
example (a : α) (b : β) (r₁ : (a : α) → (b : β) → γ₁ ∧ γ₂)
    (r₂ : (a : α) → δ₁ ∧ δ₂) : γ₁ ∧ γ₂ ∧ δ₁ ∧ δ₂ := by
  aesop? (add safe [forward r₁, forward (immediate := [a]) r₂])

-- `destruct` rules only clear propositional hypotheses. So this succeeds:

example (a : α) (b : β) (r₁ : (a : α) → (b : β) → γ)
    (r₂ : (a : α) → δ) : γ ∧ δ := by
  aesop (add safe [destruct r₁, destruct (immediate := [a]) r₂])
    (config := { enableSimp := false, terminal := true })

-- ... but this fails:

/-- error: tactic 'aesop' failed, failed to prove the goal after exhaustive search. -/
#guard_msgs in
example {α : Prop} (a : α) (b : β) (r₁ : (a : α) → (b : β) → γ)
    (r₂ : (a : α) → δ) : γ ∧ δ := by
  aesop (add safe [destruct r₁, destruct (immediate := [a]) r₂])
    (config := { enableSimp := false, terminal := true })

-- Same examples with `saturate`. Note: We currently can't make local `saturate`
-- rules into `destruct` rules.

namespace SaturateEx₁

axiom α : Type
axiom β : Type
axiom γ₁ : Prop
axiom γ₂ : Prop
axiom δ₁ : Prop
axiom δ₂ : Prop
@[aesop safe destruct]
axiom r₁ : α → β → γ₁ ∧ γ₂
@[aesop safe destruct]
axiom r₂ : α → δ₁ ∧ δ₂

/--
error: unsolved goals
a : α
b : β
fwd : γ₁ ∧ γ₂
fwd_1 : δ₁ ∧ δ₂
⊢ γ₁ ∧ γ₂ ∧ δ₁ ∧ δ₂
-/
#guard_msgs in
example (a : α) (b : β) : γ₁ ∧ γ₂ ∧ δ₁ ∧ δ₂ := by
  saturate

end SaturateEx₁

namespace SaturateEx₂

axiom α : Prop
axiom β : Type
axiom γ₁ : Prop
axiom γ₂ : Prop
axiom δ₁ : Prop
axiom δ₂ : Prop
@[aesop safe destruct]
axiom r₁ : α → β → γ₁ ∧ γ₂
@[aesop safe destruct]
axiom r₂ : α → δ₁ ∧ δ₂

/--
error: unsolved goals
b : β
fwd : γ₁ ∧ γ₂
⊢ γ₁ ∧ γ₂ ∧ δ₁ ∧ δ₂
-/
#guard_msgs in
example (a : α) (b : β) : γ₁ ∧ γ₂ ∧ δ₁ ∧ δ₂ := by
  saturate

end SaturateEx₂

example (a : α) (b : β) (r₁ : (a : α) → (b : β) → γ₁ ∧ γ₂)
    (r₂ : (a : α) → δ₁ ∧ δ₂) : γ₁ ∧ γ₂ ∧ δ₁ ∧ δ₂ := by
  aesop (add safe [forward r₁], 90% destruct r₂)

/--
warning: aesop: failed to prove the goal after exhaustive search.
---
error: unsolved goals
α β γ : Prop
h₁ : α
h₂ : β
fwd : γ
⊢ False
-/
#guard_msgs in
example {α β γ : Prop} (h : α → β → γ) (h₁ : α) (h₂ : β) : False := by
  aesop (add norm -1 forward h)

-- In the following example, `h` does not apply because `simp_all` discharges
-- the premises `α` and `β`. The stateful implementation of forward reasoning
-- can't reasonably deal with local rules whose types change during the course
-- of the search; the best we can do is try to detect when this happens.

/--
warning: aesop: failed to prove the goal after exhaustive search.
---
error: unsolved goals
α β γ : Prop
h : γ
h₁ : α
h₂ : β
⊢ False
-/
#guard_msgs in
example {α β γ : Prop} (h : α → β → γ) (h₁ : α) (h₂ : β) : False := by
  aesop (add safe forward h)

section Computation

-- Stateful forward reasoning sees through `reducible` definitions...

abbrev rid (x : α) : α := x

example {P Q : α → Prop} (h₁ : ∀ a, P a → Q a → X) (h₂ : P (rid a)) (h₃ : Q a) : X := by
  saturate [h₁]
  exact fwd

-- ... but not through semireducible ones.

/--
error: unsolved goals
α : Sort _
X : Sort _
a : α
P Q : α → Prop
h₁ : (a : α) → P a → Q a → X
h₂ : P (id a)
h₃ : Q a
⊢ X
-/
#guard_msgs in
example {P Q : α → Prop} (h₁ : ∀ a, P a → Q a → X) (h₂ : P (id a)) (h₃ : Q a) : X := by
  saturate [h₁]

end Computation

namespace Immediate

axiom α : Type
axiom P : α → Prop
axiom Q : α → Prop
axiom R : α → Prop

@[aesop safe forward (immediate := [h₂])]
axiom foo : ∀ a (h₁ : P a) (h₂ : Q a), R a

/--
error: unsolved goals
a : α
h : Q a
fwd : P a → R a
⊢ False
-/
#guard_msgs in
example (h : Q a) : False := by
  saturate

end Immediate

namespace Instance

class Foo (α : Type) : Prop

axiom β : Type

@[aesop safe forward]
axiom foo : ∀ (α : Type) (a : α) [Foo α], β

/--
error: unsolved goals
α : Type
inst✝ : Foo α
a : α
fwd : β
⊢ False
-/
#guard_msgs in
example [Foo α] (a : α) : False := by
  saturate

axiom γ : Type

instance : Foo γ where

/--
error: unsolved goals
c : γ
fwd : β
⊢ False
-/
#guard_msgs in
example (c : γ) : False := by
  saturate

@[aesop safe forward (immediate := [a])]
axiom bar : ∀ α β (a : α) (b : β) [Foo β], γ

/--
error: unsolved goals
α : Sort u_1
a : α
⊢ False
-/
#guard_msgs in
example (a : α) : False := by
  saturate

/--
error: unsolved goals
c : γ
fwd : β
⊢ False
-/
#guard_msgs in
example (c : γ) : False := by
  saturate

end Instance

namespace ConstForwardRule

axiom α : Type
@[local aesop safe forward]
axiom a : α

noncomputable example : α := by
  aesop

/--
error: unsolved goals
fwd : α
⊢ α
-/
#guard_msgs in
noncomputable example : α := by
  saturate

end ConstForwardRule

section MultipleUniverses

-- Here we test the handling of rules with multiple universe parameters.

axiom α.{u} : Type u
axiom β.{v} : Type v
axiom γ.{w} : Type w
axiom P.{u, v, w} : α.{u} → β.{v} → γ.{w} → Prop
axiom Q.{u, v, w} : β.{v} → α.{u} → γ.{w} → Prop

@[local aesop safe forward]
axiom foo {a b c} : P a b c → Q b a c

example (h : P a b c) : Q b a c := by
  saturate
  assumption

end MultipleUniverses



=== LEAN SOURCE: ForwardConstant.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

structure Foo where
  foo ::

/--
error: tactic 'aesop' failed, made no progress
-/
#guard_msgs in
example : Foo := by
  aesop

example : Foo := by
  aesop (add safe forward Foo.foo)



=== LEAN SOURCE: ForwardRedundantHypsWithMVars.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Son Ho, Jannis Limperg
-/

-- Regression test for a failure of the `forward` rule builder to realise that
-- it had already added certain hypotheses. The `saturate` loop below adds the
-- same hyp over and over again, only with different level mvars. Thanks to Son
-- Ho for providing this test case.

import Aesop

set_option aesop.check.all true

axiom len {α} (ls : List α) : Int

@[aesop safe forward (pattern := len ls)]
axiom len_pos {α} {ls : List α} : 0 ≤ len (ls : List α)

/--
error: unsolved goals
a : Type u_1
l : List a
fwd : 0 ≤ len l
⊢ 0 ≤ len l
-/
#guard_msgs in
example (l: List a): 0 ≤ len l := by
  saturate



=== LEAN SOURCE: ForwardTransparency.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

-- Forward rules always operate at reducible transparency.

def T := Unit → Empty

variable {α : Type}

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example (h : T) (u : Unit) : α := by
  aesop (config := { terminal := true })

def U := Unit

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example (h : T) (u : U) : α := by
  aesop (config := { terminal := true })

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example (h : T) (u : U) : α := by
  aesop (add forward safe h) (config := { terminal := true })

abbrev V := Unit

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example (h : Unit → Empty) (u : V) : α := by
  aesop (config := { terminal := true })

example (h : Unit → Empty) (u : V) : α := by
  aesop (add forward safe h)



=== LEAN SOURCE: ForwardUnknownFVar.lean ===
/-
Copyright (c) 2025 Xavier Généreux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Xavier Généreux, Jannis Limperg
-/

import Aesop

attribute [aesop safe forward 1] Nat.le_trans
attribute [-aesop] Aesop.BuiltinRules.applyHyps

variable (a b c d e f : Nat)

/-- error: tactic 'aesop' failed, failed to prove the goal after exhaustive search. -/
#guard_msgs in
set_option aesop.smallErrorMessages true in
example (h₃ : c ≤ d) (h₄ : d ≤ e) (h₅ : e ≤ f) (h : a = f) : False := by
  aesop (config := { terminal := true })



=== LEAN SOURCE: GlobalRuleIdentErrorChecking.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

/--
error: duplicate rule 'Nat.add_assoc'; rule 'bar' was already given.
Use [<term>,...] to give multiple rules.
-/
#guard_msgs in
@[aesop norm simp Nat.add_assoc]
theorem bar : True := trivial



=== LEAN SOURCE: HeartbeatLimit.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true
set_option linter.unreachableTactic false

@[aesop safe constructors]
inductive Even : Nat → Prop
  | zero : Even 0
  | plusTwo : Even n → Even (n + 2)

/-- error: tactic 'aesop' failed, failed to prove the goal after exhaustive search. -/
#guard_msgs in
example : Even 10 := by
  aesop (config := { maxRuleHeartbeats := 1, terminal := true })

example : Even 10 := by
  aesop

/--
error: aesop: error in norm simp: tactic 'simp' failed, nested error:
(deterministic) timeout at `simp`, maximum number of heartbeats (1) has been reached

Note: Use `set_option maxHeartbeats <num>` to set the limit.

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.
-/
#guard_msgs in
example (n m k : Nat) : n + m + k = (n + m) + k := by
  aesop (config := { maxSimpHeartbeats := 1, terminal := true })

example (n m k : Nat) : n + m + k = (n + m) + k := by
  aesop



=== LEAN SOURCE: IncompleteScript.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

-- set_option aesop.check.script.steps false

/--
info: Try this:
  intro a
  simp_all only [Nat.add_zero]
  sorry
---
warning: aesop: failed to prove the goal after exhaustive search.
---
error: unsolved goals
n : Nat
P : Nat → Prop
a : P n
⊢ P (n + 1)
-/
#guard_msgs in
example {P : Nat → Prop} : P (n + 0) → P (n + 1) := by
  aesop?

inductive Even : Nat → Prop where
  | zero : Even 0
  | add_two : Even n → Even (n + 2)

/--
info: Try this:
sorry
---
error: tactic 'aesop' failed, made no progress
-/
#guard_msgs in
example : Even 5 := by
  aesop?

attribute [aesop safe constructors] Even

/--
info: Try this:
  apply Even.add_two
  apply Even.add_two
  sorry
---
warning: aesop: failed to prove the goal after exhaustive search.
---
error: unsolved goals
case a.a
⊢ Even 1
-/
#guard_msgs in
example : Even 5 := by
  aesop?



=== LEAN SOURCE: Intros.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

def Injective₁ (f : α → β) := ∀ x y, f x = f y → x = y

abbrev Injective₂ (f : α → β) := ∀ x y, f x = f y → x = y

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : Injective₁ (@id Nat) := by
  aesop (config := { terminal := true })

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : Injective₁ (@id Nat) := by
  aesop (config := { introsTransparency? := some .reducible, terminal := true })

example : Injective₁ (@id Nat) := by
  aesop (config := { introsTransparency? := some .default })

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : Injective₂ (@id Nat) := by
  aesop (config := { terminal := true })

example : Injective₂ (@id Nat) := by
  aesop (config := { introsTransparency? := some .reducible })

example : Injective₂ (@id Nat) := by
  aesop (config := { introsTransparency? := some .default })



=== LEAN SOURCE: IntrosAllTransparency.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

@[irreducible] def T := False → True

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : T := by
  aesop (config := { terminal := true })

example : T := by
  aesop (config := { introsTransparency? := some .all })



=== LEAN SOURCE: Jesse.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jesse Vogel, Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

axiom Ring : Type
axiom Morphism (R S : Ring) : Type

@[aesop 99%]
axiom ZZ : Ring

@[aesop 99%]
axiom f : Morphism ZZ ZZ

noncomputable example : Σ (R : Ring), Morphism R R := by
  aesop

axiom domain (R : Ring) : Prop

@[aesop 99%]
axiom ZZ_domain : domain ZZ

noncomputable example : ∃ (R : Ring), domain R := by
  aesop



=== LEAN SOURCE: LegacyForward.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true
set_option pp.mvars false

-- This file contains regression tests for the old, stateless forward reasoning.
set_option aesop.dev.statefulForward false

open Aesop Lean Lean.Meta Lean.Elab.Tactic

/-! # Unit tests for the MetaM tactic that implements forward rules -/

syntax (name := forward) "t_forward " ident (" [" ident* "]")? : tactic
syntax (name := elim)    "t_elim "    ident (" [" ident* "]")? : tactic

def forwardTac (goal : MVarId) (id : Ident) (immediate : Option (Array Syntax))
    (clear : Bool) : MetaM (List MVarId) := do
  let userName := id.getId
  let ldecl ← getLocalDeclFromUserName userName
  let immediate ← RuleBuilder.getImmediatePremises ldecl.type none
    (immediate.map (·.map (·.getId)))
  let ((goal, _), _) ←
    RuleTac.applyForwardRule goal (mkFVar ldecl.fvarId) none immediate clear
      (maxDepth? := none) ∅ |>.run.run
  return [goal.mvarId]

@[tactic forward]
def evalForward : Tactic
  | `(tactic| t_forward $t:ident $[[ $immediate:ident* ]]?) =>
    liftMetaTactic (forwardTac · t immediate (clear := false))
  | _ => unreachable!

@[tactic elim]
def evalElim : Tactic
  | `(tactic| t_elim $t:ident $[[ $immediate:ident* ]]?) =>
    liftMetaTactic (forwardTac · t immediate (clear := true))
  | _ => unreachable!

example (rule : (a : α) → (b : β) → γ) (h₁ : α) (h₂ : β) : γ := by
  t_forward rule [a b]
  assumption

example {P Q R : α → Type} (rule : ∀ a (p : P a) (q : Q a), R a)
    (h₁ : P a) (h₁' : P a) (h₂ : Q a) (h₃ : P b) (h₄ : Q c) : R a := by
  t_forward rule [p q]
  assumption

example {P Q R : α → Type} (rule : ∀ a (p : P a) (q : Q a), R a)
    (h₁ : P a) (h₁' : P a) (h₂ : Q a) (h₃ : P b) (h₄ : Q c) : R a := by
  t_forward rule
  assumption

example {P Q R : α → Type} (rule : ∀ a (p : P a) (q : Q a), R a)
    (h₁ : P a) (h₂ : P b) : (Q a → R a) × (Q b → R b) := by
  t_forward rule [p]
  exact (by assumption, by assumption)

example (rule : ∀ α β, α ∧ β → α) (h : P ∧ Q ∧ R) : P := by
  t_elim rule
  assumption

/-! # Tests for the `forward` and `saturate` tactics -/

/--
info: Try this:
have fwd : P := rule P (Q ∧ R) h
-/
#guard_msgs in
example (rule : ∀ α β, α ∧ β → α) (h : P ∧ Q ∧ R) : P := by
  forward? [*]
  guard_hyp fwd : P
  assumption

/--
info: Try this:
  have fwd : γ₁ ∧ γ₂ := r₁ a b
  have fwd_1 : δ₁ ∧ δ₂ := r₂ a
-/
#guard_msgs in
example (a : α) (b : β) (r₁ : (a : α) → (b : β) → γ₁ ∧ γ₂)
    (r₂ : (a : α) → δ₁ ∧ δ₂) : γ₁ ∧ γ₂ ∧ δ₁ ∧ δ₂ := by
  saturate? [*]
  guard_hyp fwd : γ₁ ∧ γ₂
  guard_hyp fwd_1 : δ₁ ∧ δ₂
  aesop

/--
info: Try this:
  have fwd : β := h₁ h₃
  have fwd_1 : γ := h₂ fwd
-/
#guard_msgs in
example {α β γ : Prop} (h₁ : α → β) (h₂ : β → γ) (h₃ : α) : γ := by
  saturate? [*]
  guard_hyp fwd : β
  guard_hyp fwd_1 : γ
  assumption

/--
info: Try this:
have fwd : β := h₁ h₃
---
error: unsolved goals
α β γ : Prop
h₁ : α → β
h₂ : β → γ
h₃ : α
fwd : β
⊢ γ
-/
#guard_msgs in
example {α β γ : Prop} (h₁ : α → β) (h₂ : β → γ) (h₃ : α) : γ := by
  forward? [*]

/--
info: Try this:
have fwd : β := h₁ h₃
---
error: unsolved goals
α β γ : Prop
h₁ : α → β
h₂ : β → γ
h₃ : α
fwd : β
⊢ γ
-/
#guard_msgs in
example {α β γ : Prop} (h₁ : α → β) (h₂ : β → γ) (h₃ : α) : γ := by
  saturate? 1 [*]

/--
info: Try this:
  have fwd : β := h₁ h₄
  have fwd_1 : γ := h₂ fwd
---
error: unsolved goals
α β γ δ : Prop
h₁ : α → β
h₂ : β → γ
h₃ : γ → δ
h₄ : α
fwd : β
fwd_1 : γ
⊢ δ
-/
#guard_msgs in
example {α β γ δ : Prop} (h₁ : α → β) (h₂ : β → γ) (h₃ : γ → δ) (h₄ : α) : δ := by
  saturate? 2 [*]

/--
info: Try this:
  have fwd : β := h₁ h₄
  have fwd_1 : γ := h₂ h₄
---
error: unsolved goals
α β γ δ : Prop
h₁ : α → β
h₂ : α → γ
h₃ : β → γ → δ
h₄ : α
fwd : β
fwd_1 : γ
⊢ δ
-/
#guard_msgs in
example {α β γ δ : Prop} (h₁ : α → β) (h₂ : α → γ) (h₃ : β → γ → δ) (h₄ : α) : δ := by
  saturate? 1 [*]

axiom A : Type
axiom B : Type
axiom C : Type

@[aesop safe forward]
axiom ab : A → B

@[aesop norm forward]
axiom bc : B → C

/--
info: Try this:
  have fwd : B := ab a
  have fwd_1 : C := bc fwd
-/
#guard_msgs in
noncomputable example : A → C := by
  intro a
  saturate?
  guard_hyp fwd : B
  guard_hyp fwd_1 : C
  exact fwd_1

/-! # Tests for Aesop's forward rules -/

example (a : α) (b : β) (r₁ : (a : α) → (b : β) → γ₁ ∧ γ₂)
    (r₂ : (a : α) → δ₁ ∧ δ₂) : γ₁ ∧ γ₂ ∧ δ₁ ∧ δ₂ := by
  aesop (add safe [forward r₁, forward (immediate := [a]) r₂])

/--
info: Try this:
  have fwd : γ₁ ∧ γ₂ := r₁ a b
  simp_all only [and_self, implies_true, true_and]
  obtain ⟨left, right⟩ := fwd
  have fwd : δ₁ ∧ δ₂ := r₂ a
  simp_all only [and_self, implies_true]
-/
#guard_msgs in
example (a : α) (b : β) (r₁ : (a : α) → (b : β) → γ₁ ∧ γ₂)
    (r₂ : (a : α) → δ₁ ∧ δ₂) : γ₁ ∧ γ₂ ∧ δ₁ ∧ δ₂ := by
  aesop? (add safe [forward r₁, forward (immediate := [a]) r₂])

-- `destruct` rules only clear propositional hypotheses. So this succeeds:

example (a : α) (b : β) (r₁ : (a : α) → (b : β) → γ)
    (r₂ : (a : α) → δ) : γ ∧ δ := by
  aesop (add 1% [destruct r₁, destruct (immediate := [a]) r₂])
    (config := { enableSimp := false, terminal := true })

-- ... but this fails:

/-- error: tactic 'aesop' failed, failed to prove the goal after exhaustive search. -/
#guard_msgs in
example {α : Prop} (a : α) (b : β) (r₁ : (a : α) → (b : β) → γ)
    (r₂ : (a : α) → δ) : γ ∧ δ := by
  aesop (add safe [destruct r₁, destruct (immediate := [a]) r₂])
    (config := { enableSimp := false, terminal := true })

example (a : α) (b : β) (r₁ : (a : α) → (b : β) → γ₁ ∧ γ₂)
    (r₂ : (a : α) → δ₁ ∧ δ₂) : γ₁ ∧ γ₂ ∧ δ₁ ∧ δ₂ := by
  aesop (add safe [forward r₁], 90% destruct r₂)



=== LEAN SOURCE: List.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/
-- Ported from mathlib3, file src/data/list/basic.lean,
-- commit a945b3769cb82bc238ee004b4327201a6864e7e0

import Aesop

set_option aesop.check.script true

-- We use this constant to 'prove' theorems which Aesop can't solve. We don't
-- use `sorry` because it generates lots of warnings.
axiom ADMIT : ∀ {α : Sort _}, α

class IsEmpty (α : Sort _) where
  false : α → False

@[aesop safe forward]
def IsEmpty.false' (h : IsEmpty α) (a : α) : False :=
  h.false a

@[aesop safe constructors]
structure Unique (α : Sort _) extends Inhabited α where
  uniq : ∀ a : α, a = toInhabited.default

class IsLeftId (α : Type _) (op : α → α → α) (o : outParam α) : Prop where
  leftId : ∀ a, op o a = a

def Injective (f : α → β) : Prop :=
  ∀ x y, f x = f y → x = y

@[aesop safe forward]
theorem injective_elim (h₁ : Injective f) (h₂ : f a = f b) : a = b :=
  h₁ _ _ h₂

@[aesop 99%]
theorem injective_intro (h : ∀ a b, f a = f b → a = b) : Injective f :=
  h

def Surjective (f : α → β) : Prop :=
  ∀ b, ∃ a, f a = b

@[aesop norm forward (immediate := [h])]
theorem surjective_elim (h : Surjective f) : ∀ b, ∃ a, f a = b :=
  h

@[aesop 99%]
theorem surjective_intro (h : ∀ b, ∃ a, f a = b) : Surjective f :=
  h

@[aesop norm unfold]
def Bijective (f : α → β) : Prop :=
  Injective f ∧ Surjective f

def Involutive (f : α → α) : Prop :=
  ∀ x, f (f x) = x

@[aesop norm forward]
theorem involutive_elim {f : α → α} (h : Involutive f) (a : α) : f (f a) = a :=
  h a

@[aesop 99%]
theorem involutive_intro (h : ∀ a, f (f a) = a) : Involutive f :=
  h

@[aesop 25%]
theorem Involutive.injective : Involutive f → Injective f :=
  λ h x y hxy => by rw [← h x, ← h y, hxy]

@[aesop 25%]
theorem Involutive.surjective : Involutive f → Surjective f :=
  λ h x => ⟨f x, h x⟩

theorem Involutive.bijective (h : Involutive f) : Bijective f :=
  ⟨h.injective, h.surjective⟩

namespace Option

@[aesop safe [constructors, cases]]
inductive Mem (a : α) : Option α → Prop
  | some : Mem a (some a)

instance : Membership α (Option α) :=
  ⟨λ a o => Option.Mem a o⟩

@[simp]
theorem mem_spec {o : Option α} : a ∈ o ↔ o = some a := by
  aesop (add norm simp Membership.mem)

@[simp]
theorem mem_none : a ∈ none ↔ False := by
  aesop

@[simp]
def iget [Inhabited α] : Option α → α
  | none => default
  | some a => a

end Option

namespace List

-- The `ext` rule for lists says that `l₁ = l₂ ↔ (∀ a, a ∈ l₁ ↔ a ∈ l₂)`. This
-- is not particularly helpful for this file.
attribute [-aesop] Aesop.BuiltinRules.ext

attribute [simp] map List.flatMap

instance : Pure List where
  pure x := [x]

def init : List α → List α
  | [] => []
  | [_] => []
  | a :: as => a :: init as

@[simp]
def last : (l : List α) → l ≠ [] → α
  | [], h => nomatch h
  | [a], _ => a
  | _ :: a :: as, _ => last (a :: as) (by aesop)

-- The unnecessarily complicated case split in this definition is inherited from
-- Lean 3.
@[simp]
def ilast [Inhabited α] : List α → α
  | [] => default
  | [a] => a
  | [_, b] => b
  | _ :: _ :: l => ilast l

@[simp]
def head' : List α → Option α
  | [] => none
  | a :: _ => some a

@[simp]
def ihead [Inhabited α] : List α → α
  | [] => default
  | a :: _ => a

@[simp]
def nth_le : ∀ (l : List α) (n), n < l.length → α
  | [],       n,     h => absurd h n.not_lt_zero
  | (a :: _), 0,     _ => a
  | (_ :: l), (n+1), h => nth_le l n (by simp_all +arith)

@[simp]
def modify_head (f : α → α) : List α → List α
  | [] => []
  | (a :: as) => f a :: as

@[simp]
def Empty : List α → Prop
  | [] => True
  | _ :: _ => False

@[simp] theorem mem_eq_mem : Mem x xs ↔ x ∈ xs := Iff.rfl

theorem subset_trans {l₁ l₂ l₃ : List α} : l₁ ⊆ l₂ → l₂ ⊆ l₃ → l₁ ⊆ l₃ := by
  intro h₁ h₂ a ha
  cases l₁ with
  | nil =>
    cases ha
  | cons x xs =>
    cases ha with
    | head =>
      apply h₂
      apply h₁
      constructor
    | tail _ hxs =>
      apply h₂
      apply h₁
      constructor
      assumption

-- END PRELUDE

instance unique_of_is_empty [IsEmpty α] : Unique (List α) := by
  aesop (add 1% cases List)

-- instance : is_left_id (list α) has_append.append [] :=
-- ⟨ nil_append ⟩

-- instance : is_right_id (list α) has_append.append [] :=
-- ⟨ append_nil ⟩

-- instance : is_associative (list α) has_append.append :=
-- ⟨ append_assoc ⟩

-- attribute [-simp] cons_ne_nil
theorem X.cons_ne_nil (a : α) (l : List α) : a::l ≠ [] := by
  aesop

-- attribute [-simp] cons_ne_self
theorem X.cons_ne_self (a : α) (l : List α) : a::l ≠ l := by
  aesop (add 1% cases Eq)

-- attribute [-simp] head_eq_of_cons_eq
theorem X.head_eq_of_cons_eq {h₁ h₂ : α} {t₁ t₂ : List α} :
      (h₁::t₁) = (h₂::t₂) → h₁ = h₂ := by
  aesop

-- attribute [-simp] tail_eq_of_cons_eq
theorem X.tail_eq_of_cons_eq {h₁ h₂ : α} {t₁ t₂ : List α} :
      (h₁::t₁) = (h₂::t₂) → t₁ = t₂ := by
  aesop

@[simp] theorem cons_injective {a : α} : Injective (cons a) := by
  aesop

-- attribute [-simp] cons_inj
theorem X.cons_inj (a : α) {l l' : List α} : a::l = a::l' ↔ l = l' := by
  aesop

-- attribute [-simp] exists_cons_of_ne_nil
theorem X.exists_cons_of_ne_nil : l ≠ nil → ∃ b L, l = b :: L := by
  aesop (add 1% cases List)

-- theorem set_of_mem_cons (l : list α) (a : α) : {x | x ∈ a :: l} = insert a {x | x ∈ l} := rfl

/-! ### mem -/

attribute [aesop safe constructors] List.Mem
attribute [aesop safe cases (cases_patterns := [List.Mem _ [], List.Mem _ (_ :: _)])] List.Mem

-- attribute [-simp] mem_singleton_self
@[simp]
theorem X.mem_singleton_self (a : α) : a ∈ [a] := by
  aesop

-- attribute [-simp] eq_of_mem_singleton
theorem X.eq_of_mem_singleton {a b : α} : a ∈ [b] → a = b := by
  aesop

@[simp]
theorem X.mem_singleton {a b : α} : a ∈ [b] ↔ a = b := by
  aesop

-- attribute [-simp] mem_of_mem_cons_of_mem
theorem X.mem_of_mem_cons_of_mem {a b : α} {l : List α} : a ∈ b::l → b ∈ l → a ∈ l := by
  aesop

set_option linter.unusedVariables false in
theorem _root_.decidable.list.eq_or_ne_mem_of_mem [deq : DecidableEq α]
  {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ (a ≠ b ∧ a ∈ l) :=
  ADMIT
  -- cases deq a b <;> aesop

-- attribute [-simp] eq_or_ne_mem_of_mem
theorem X.eq_or_ne_mem_of_mem {a b : α} {l : List α} : a ∈ b :: l → a = b ∨ (a ≠ b ∧ a ∈ l) := by
  open Classical in
  aesop (add safe [decidable.list.eq_or_ne_mem_of_mem])

-- attribute [-simp] not_mem_append
theorem X.not_mem_append {a : α} {s t : List α} (h₁ : a ∉ s) (h₂ : a ∉ t) : a ∉ s ++ t := by
  induction s <;> aesop

-- attribute [-simp] ne_nil_of_mem
theorem X.ne_nil_of_mem {a : α} {l : List α} (h : a ∈ l) : l ≠ [] := by
  aesop

set_option linter.unusedVariables false in
theorem mem_split {a : α} {l : List α} (h : a ∈ l) : ∃ s t : List α, l = s ++ a :: t :=
  ADMIT -- Nontrivial existential.

-- attribute [-simp] mem_of_ne_of_mem
theorem X.mem_of_ne_of_mem {a y : α} {l : List α} (h₁ : a ≠ y) (h₂ : a ∈ y :: l) : a ∈ l := by
  aesop

-- attribute [-simp] ne_of_not_mem_cons
theorem X.ne_of_not_mem_cons {a b : α} {l : List α} : a ∉ b::l → a ≠ b := by
  aesop

-- attribute [-simp] not_mem_of_not_mem_cons
theorem X.not_mem_of_not_mem_cons {a b : α} {l : List α} : a ∉ b::l → a ∉ l := by
  aesop

-- attribute [-simp] not_mem_cons_of_ne_of_not_mem
theorem X.not_mem_cons_of_ne_of_not_mem {a y : α} {l : List α} : a ≠ y → a ∉ l → a ∉ y::l := by
  aesop

-- attribute [-simp] ne_and_not_mem_of_not_mem_cons
theorem X.ne_and_not_mem_of_not_mem_cons {a y : α} {l : List α} : a ∉ y::l → a ≠ y ∧ a ∉ l := by
  aesop

-- attribute [-simp] mem_map
@[simp] theorem X.mem_map {f : α → β} {b : β} {l : List α} : b ∈ map f l ↔ ∃ a, a ∈ l ∧ f a = b := by
  induction l <;> aesop

-- attribute [-simp] mem_map_of_mem
@[aesop safe]
theorem X.mem_map_of_mem (f : α → β) {a : α} {l : List α} (h : a ∈ l) : f a ∈ map f l := by
  aesop

theorem mem_map_of_injective {f : α → β} (H : Injective f) {a : α} {l : List α} :
  f a ∈ map f l ↔ a ∈ l := by
  set_option aesop.check.script false in -- TODO pp.analyze bug?
  aesop

@[simp] theorem _root_.function.involutive.exists_mem_and_apply_eq_iff {f : α → α}
  (hf : Involutive f) (x : α) (l : List α) :
  (∃ (y : α), y ∈ l ∧ f y = x) ↔ f x ∈ l := by
  aesop

theorem mem_map_of_involutive {f : α → α} (hf : Involutive f) {a : α} {l : List α} :
  a ∈ map f l ↔ f a ∈ l := by
  aesop

-- attribute [-simp] forall_mem_map_iff
theorem X.forall_mem_map_iff {f : α → β} {l : List α} {P : β → Prop} :
  (∀ i, i ∈ l.map f → P i) ↔ ∀ j, j ∈ l → P (f j) := by
  aesop

-- attribute [-simp] map_eq_nil
@[simp] theorem X.map_eq_nil {f : α → β} {l : List α} : map f l = [] ↔ l = [] := by
  aesop (add 1% cases List)

attribute [-simp] mem_flatten
@[simp] theorem X.mem_flatten {a : α} : ∀ {L : List (List α)}, a ∈ flatten L ↔ ∃ l, l ∈ L ∧ a ∈ l := by
  intro L; induction L <;> aesop

-- attribute [-simp] exists_of_mem_flatten
theorem X.exists_of_mem_flatten {a : α} {L : List (List α)} : a ∈ flatten L → ∃ l, l ∈ L ∧ a ∈ l := by
  aesop

-- attribute [-simp] mem_flatten_of_mem
theorem X.mem_flatten_of_mem {a : α} {L : List (List α)} {l} (lL : l ∈ L) (al : a ∈ l) : a ∈ flatten L := by
  aesop

-- attribute [-simp] mem_flatMap
@[simp] theorem X.mem_flatMap {b : β} {l : List α} {f : α → List β} : b ∈ l.flatMap f ↔ ∃ a, a ∈ l ∧ b ∈ f a := by
  induction l <;> aesop

-- attribute [-simp] exists_of_mem_flatMap
theorem X.exists_of_mem_flatMap {l : List α} :
    b ∈ l.flatMap f → ∃ a, a ∈ l ∧ b ∈ f a := by
  aesop

-- attribute [-simp] mem_flatMap_of_mem
theorem X.mem_flatMap_of_mem {l : List α} :
    (∃ a, a ∈ l ∧ b ∈ f a) → b ∈ l.flatMap f := by
  induction l <;> aesop

-- attribute [-simp] flatMap_map
theorem X.flatMap_map {g : α → List β} {f : β → γ} :
  ∀ l : List α, map f (l.flatMap g) = l.flatMap (λa => (g a).map f) := by
  intro l; induction l <;> aesop

theorem map_flatMap' (g : β → List γ) (f : α → β) :
  ∀ l : List α, (map f l).flatMap g = l.flatMap (λ a => g (f a)) := by
  intro l; induction l <;> aesop

-- theorem range_map (f : α → β) : set.range (map f) = {l | ∀ x ∈ l, x ∈ set.range f} :=

-- theorem range_map_coe (s : set α) : set.range (map (coe : s → α)) = {l | ∀ x ∈ l, x ∈ s} :=

-- instance [h : can_lift α β] : can_lift (list α) (list β) :=

/-! ### length -/

-- attribute [-simp] length_eq_zero
theorem X.length_eq_zero {l : List α} : length l = 0 ↔ l = [] := by
  aesop (add 1% cases List)

attribute [-simp] length_singleton
@[simp] theorem X.length_singleton (a : α) : length [a] = 1 := rfl

-- attribute [-simp] length_pos_of_mem
theorem X.length_pos_of_mem {a : α} : ∀ {l : List α}, a ∈ l → 0 < length l := by
  aesop (add 1% cases List) (simp_config := { arith := true })

-- attribute [-simp] exists_mem_of_length_pos
theorem X.exists_mem_of_length_pos : ∀ {l : List α}, 0 < length l → ∃ a, a ∈ l := by
  aesop (add 1% cases List)

-- attribute [-simp] length_pos_iff_exists_mem
theorem X.length_pos_iff_exists_mem {l : List α} : 0 < length l ↔ ∃ a, a ∈ l := by
  aesop (add unsafe [length_pos_of_mem, exists_mem_of_length_pos])

-- attribute [-simp] ne_nil_of_length_pos
theorem X.ne_nil_of_length_pos {l : List α} : 0 < length l → l ≠ [] := by
  aesop (add 1% cases List)

theorem length_pos_of_ne_nil {l : List α} : l ≠ [] → 0 < length l := by
  aesop (add 1% cases List) (simp_config := { arith := true })

theorem length_pos_iff_ne_nil {l : List α} : 0 < length l ↔ l ≠ [] := by
  aesop (add unsafe [ne_nil_of_length_pos, length_pos_of_ne_nil])

-- attribute [-simp] exists_mem_of_ne_nil
theorem X.exists_mem_of_ne_nil (l : List α) (h : l ≠ []) : ∃ x, x ∈ l := by
  aesop (add 1% cases List)

-- attribute [-simp] length_eq_one
theorem X.length_eq_one : length l = 1 ↔ ∃ a, l = [a] := by
  aesop (add 1% cases List)

theorem exists_of_length_succ {n} :
  ∀ l : List α, l.length = n + 1 → ∃ h t, l = h :: t := by
  intro l; induction l <;> aesop (simp_config := { arith := true })

@[simp] theorem length_injective_iff : Injective (length : List α → Nat) ↔ Subsingleton α :=
  ADMIT -- Requires induction after case split.

@[simp] theorem length_injective [Subsingleton α] : Injective (length : List α → Nat) := by
  aesop

theorem length_eq_two {l : List α} : l.length = 2 ↔ ∃ a b, l = [a, b] := by
  aesop (add 50% cases List)

theorem length_eq_three {l : List α} : l.length = 3 ↔ ∃ a b c, l = [a, b, c] := by
  aesop (add 50% cases List)

/-! ### set-theoretic notation of lists -/

attribute [-simp] empty_eq
theorem X.empty_eq : (∅ : List α) = [] := rfl

-- theorem singleton_eq (x : α) : ({x} : List α) = [x]

-- theorem insert_neg [DecidableEq α] {x : α} {l : List α} (h : x ∉ l) :
--   has_insert.insert x l = x :: l

-- theorem insert_pos [DecidableEq α] {x : α} {l : List α} (h : x ∈ l) :
--   has_insert.insert x l = l

-- theorem doubleton_eq [DecidableEq α] {x y : α} (h : x ≠ y) : ({x, y} : List α) = [x, y]

/-! ### bounded quantifiers over lists -/

-- The notation used in Lean 3 (`∀ x ∈ xs, P x` and `∃ x ∈ xs, P x`) does not
-- exist in Lean 4. We've expanded it manually.

-- attribute [-simp] forall_mem_nil
theorem X.forall_mem_nil (p : α → Prop) : ∀ x, x ∈ @nil α → p x := by
  aesop

-- attribute [-simp] forall_mem_cons
theorem X.forall_mem_cons : ∀ {p : α → Prop} {a : α} {l : List α},
    (∀ x, x ∈ a :: l → p x) ↔ p a ∧ ∀ x, x ∈ l → p x := by
  aesop

theorem forall_mem_of_forall_mem_cons {p : α → Prop} {a : α} {l : List α}
    (h : ∀ x, x ∈ a :: l → p x) :
  ∀ x, x ∈ l → p x := by
  aesop

-- attribute [-simp] forall_mem_singleton
theorem X.forall_mem_singleton {p : α → Prop} {a : α} : (∀ x, x ∈ [a] → p x) ↔ p a := by
  aesop

-- attribute [-simp] forall_mem_append
theorem X.forall_mem_append {p : α → Prop} {l₁ l₂ : List α} :
    (∀ x, x ∈ l₁ ++ l₂ → p x) ↔ (∀ x, x ∈ l₁ → p x) ∧ (∀ x, x ∈ l₂ → p x) := by
  aesop

theorem not_exists_mem_nil (p : α → Prop) : ¬ ∃ x, x ∈ @nil α ∧ p x := by
  aesop

theorem exists_mem_cons_of {p : α → Prop} {a : α} (l : List α) (h : p a) :
    ∃ x, x ∈ a :: l ∧ p x := by
  aesop

theorem exists_mem_cons_of_exists {p : α → Prop} {a : α} {l : List α} (h : ∃ x, x ∈ l ∧ p x) :
  ∃ x, x ∈ a :: l ∧ p x := by
  aesop

theorem or_exists_of_exists_mem_cons {p : α → Prop} {a : α} {l : List α} (h : ∃ x, x ∈ a :: l ∧ p x) :
  p a ∨ ∃ x, x ∈ l ∧ p x := by
  aesop

theorem exists_mem_cons_iff (p : α → Prop) (a : α) (l : List α) :
  (∃ x, x ∈ a :: l ∧ p x) ↔ p a ∨ ∃ x, x ∈ l ∧ p x := by
  aesop

/-! ### list subset -/

-- attribute [-simp] subset_def
theorem X.subset_def {l₁ l₂ : List α} : l₁ ⊆ l₂ ↔ ∀ ⦃a : α⦄, a ∈ l₁ → a ∈ l₂ := by
  aesop

-- attribute [-simp] subset_append_of_subset_left
theorem X.subset_append_of_subset_left (l l₁ l₂ : List α) : l ⊆ l₁ → l ⊆ l₁++l₂ := by
  aesop (add 1% subset_trans)

-- attribute [-simp] subset_append_of_subset_right
theorem X.subset_append_of_subset_right (l l₁ l₂ : List α) : l ⊆ l₂ → l ⊆ l₁ ++ l₂ := by
  aesop (add 1% subset_trans)

attribute [-simp] cons_subset
@[simp] theorem X.cons_subset {a : α} {l m : List α} :
  a::l ⊆ m ↔ a ∈ m ∧ l ⊆ m := by
  aesop (add norm simp [HasSubset.Subset, List.Subset])

theorem cons_subset_of_subset_of_mem {a : α} {l m : List α}
    (ainm : a ∈ m) (lsubm : l ⊆ m) : a::l ⊆ m := by
  aesop

theorem append_subset_of_subset_of_subset {l₁ l₂ l : List α} (l₁subl : l₁ ⊆ l) (l₂subl : l₂ ⊆ l) :
  l₁ ++ l₂ ⊆ l := by
  aesop (add norm simp [HasSubset.Subset, List.Subset])

@[simp] theorem append_subset_iff {l₁ l₂ l : List α} :
    l₁ ++ l₂ ⊆ l ↔ l₁ ⊆ l ∧ l₂ ⊆ l := by
  aesop (add norm simp [HasSubset.Subset, List.Subset])

@[aesop safe destruct]
theorem eq_nil_of_subset_nil' {l : List α} : l ⊆ [] → l = [] := by
  aesop (add 1% cases List)

-- attribute [-simp] eq_nil_iff_forall_not_mem
theorem X.eq_nil_iff_forall_not_mem {l : List α} : l = [] ↔ ∀ a, a ∉ l :=
  ADMIT
  -- used to be by `aesop (add 1% cases List)` until simp changes around nightly
  -- 2024-03-11

-- attribute [-simp] map_subset
theorem X.map_subset {l₁ l₂ : List α} (f : α → β) (H : l₁ ⊆ l₂) : map f l₁ ⊆ map f l₂ := by
  aesop (add norm simp [HasSubset.Subset, List.Subset])

theorem map_subset_iff {l₁ l₂ : List α} (f : α → β) (h : Injective f) :
    map f l₁ ⊆ map f l₂ ↔ l₁ ⊆ l₂ := by
  induction l₁ <;> induction l₂
  · aesop
  · aesop
  · aesop
  · set_option aesop.check.script false in
    aesop -- TODO timeout in script generation

/-! ### append -/

theorem append_eq_has_append {L₁ L₂ : List α} : List.append L₁ L₂ = L₁ ++ L₂ := rfl

attribute [-simp] singleton_append
@[simp] theorem X.singleton_append {x : α} {l : List α} : [x] ++ l = x :: l := rfl

-- attribute [-simp] append_ne_nil_of_ne_nil_left
theorem X.append_ne_nil_of_ne_nil_left (s t : List α) : s ≠ [] → s ++ t ≠ [] := by
  induction s <;> aesop

-- attribute [-simp] append_ne_nil_of_ne_nil_right
theorem X.append_ne_nil_of_ne_nil_right (s t : List α) : t ≠ [] → s ++ t ≠ [] := by
  induction s <;> aesop

@[simp] theorem X.append_eq_nil {p q : List α} : (p ++ q) = [] ↔ p = [] ∧ q = [] := by
  aesop (add 1% cases List)

-- attribute [-simp] nil_eq_append_iff
@[simp] theorem X.nil_eq_append_iff {a b : List α} : [] = a ++ b ↔ a = [] ∧ b = [] := by
  induction a <;> aesop

-- attribute [-simp] append_eq_cons_iff
theorem X.append_eq_cons_iff {a b c : List α} {x : α} :
  a ++ b = x :: c ↔ (a = [] ∧ b = x :: c) ∨ (∃a', a = x :: a' ∧ c = a' ++ b) := by
  aesop (add 1% cases List)

-- attribute [-simp] cons_eq_append_iff
theorem X.cons_eq_append_iff {a b c : List α} {x : α} :
    (x :: c : List α) = a ++ b ↔ (a = [] ∧ b = x :: c) ∨ (∃a', a = x :: a' ∧ c = a' ++ b) := by
  aesop (add norm simp [append_eq_cons_iff, eq_comm])

-- attribute [-simp] append_eq_append_iff
theorem X.append_eq_append_iff {a b c d : List α} :
    a ++ b = c ++ d ↔ (∃a', c = a ++ a' ∧ b = a' ++ d) ∨ (∃c', a = c ++ c' ∧ d = c' ++ b) :=
  ADMIT -- Nontrivial existential.

attribute [-simp] take_append_drop
@[simp] theorem X.take_append_drop : ∀ (n : Nat) (l : List α), take n l ++ drop n l = l
  | 0        , a         => by aesop
  | (.succ _), []        => by aesop
  | (.succ n), (_ :: xs) => by
    have ih := take_append_drop n xs
    aesop

@[aesop safe forward]
theorem X.append_inj :
  ∀ {s₁ s₂ t₁ t₂ : List α}, s₁ ++ t₁ = s₂ ++ t₂ → length s₁ = length s₂ → s₁ = s₂ ∧ t₁ = t₂
  | []     , []     , t₁, t₂, h, _  => by aesop
  | (a::s₁), []     , t₁, t₂, _, hl => by aesop
  | []     , (b::s₂), t₁, t₂, _, hl => by aesop
  | (a::s₁), (b::s₂), t₁, t₂, h, hl => by
    have ih := @append_inj _ s₁ s₂ t₁ t₂
    aesop

-- attribute [-simp] append_inj_right
theorem X.append_inj_right {s₁ s₂ t₁ t₂ : List α} (h : s₁ ++ t₁ = s₂ ++ t₂)
    (hl : length s₁ = length s₂) : t₁ = t₂ := by
  aesop

-- attribute [-simp] append_inj_left
theorem X.append_inj_left {s₁ s₂ t₁ t₂ : List α} (h : s₁ ++ t₁ = s₂ ++ t₂)
    (hl : length s₁ = length s₂) : s₁ = s₂ := by
  aesop

-- attribute [-simp] append_inj'
set_option linter.unusedVariables false in
@[aesop safe forward]
theorem X.append_inj' {s₁ s₂ t₁ t₂ : List α} (h : s₁ ++ t₁ = s₂ ++ t₂) (hl : length t₁ = length t₂) :
  s₁ = s₂ ∧ t₁ = t₂ := by
  induction s₁ generalizing s₂ <;> induction s₂ <;>
    aesop (simp_config := { arith := true })

-- attribute [-simp] append_inj_right'
theorem X.append_inj_right' {s₁ s₂ t₁ t₂ : List α} (h : s₁ ++ t₁ = s₂ ++ t₂)
    (hl : length t₁ = length t₂) : t₁ = t₂ := by
  aesop

-- attribute [-simp] append_inj_left'
theorem X.append_inj_left' {s₁ s₂ t₁ t₂ : List α} (h : s₁ ++ t₁ = s₂ ++ t₂)
    (hl : length t₁ = length t₂) : s₁ = s₂ := by
  aesop

theorem append_left_cancel {s t₁ t₂ : List α} (h : s ++ t₁ = s ++ t₂) : t₁ = t₂ := by
  aesop

theorem append_right_cancel {s₁ s₂ t : List α} (h : s₁ ++ t = s₂ ++ t) : s₁ = s₂ := by
  aesop

theorem append_right_injective (s : List α) : Injective (λ t => s ++ t) := by
  aesop

-- attribute [-simp] append_right_inj
theorem X.append_right_inj {t₁ t₂ : List α} (s) : s ++ t₁ = s ++ t₂ ↔ t₁ = t₂ := by
  aesop

theorem append_left_injective (t : List α) : Injective (λ s => s ++ t) := by
  aesop

-- attribute [-simp] append_left_inj
theorem X.append_left_inj {s₁ s₂ : List α} (t) : s₁ ++ t = s₂ ++ t ↔ s₁ = s₂ := by
  aesop

-- attribute [-simp] map_eq_append_split
set_option linter.unusedVariables false in
theorem X.map_eq_append_split {f : α → β} {l : List α} {s₁ s₂ : List β}
    (h : map f l = s₁ ++ s₂) : ∃ l₁ l₂, l = l₁ ++ l₂ ∧ map f l₁ = s₁ ∧ map f l₂ = s₂ :=
  ADMIT -- Nontrivial existential.

/-! ### replicate/repeat -/

-- Note: `replicate` is called `repeat` in Lean 3 and has flipped arguments.

-- attribute [-simp] replicate_succ
@[simp] theorem X.replicate_succ (a : α) (n) : replicate (n + 1) a = a :: replicate n a := rfl

-- attribute [-simp] mem_replicate
@[simp] theorem X.mem_replicate {a b : α} {n} : b ∈ replicate n a ↔ n ≠ 0 ∧ b = a := by
  induction n <;> aesop

-- attribute [-simp] eq_of_mem_replicate
@[aesop safe destruct]
theorem X.eq_of_mem_replicate {a b : α} {n} (h : b ∈ replicate n a) : b = a := by
  aesop

-- attribute [-simp] eq_replicate_of_mem
theorem X.eq_replicate_of_mem {a : α} {l : List α} : (∀ b, b ∈ l → b = a) → l = replicate l.length a := by
  induction l <;> aesop (config := { useSimpAll := false })

theorem eq_replicate' {a : α} {l : List α} : l = replicate l.length a ↔ ∀ b, b ∈ l → b = a := by
  induction l <;> aesop

-- attribute [-simp] eq_replicate
theorem X.eq_replicate {a : α} {n} {l : List α} : l = replicate n a ↔ length l = n ∧ ∀ b, b ∈ l → b = a := by
  aesop (add norm simp eq_replicate')

theorem replicate_add (a : α) (m n) : replicate (m + n) a = replicate m a ++ replicate n a :=
  ADMIT -- Need to apply associativity of addition to let `replicate` reduce.

theorem replicate_subset_singleton (a : α) (n) : replicate n a ⊆ [a] := by
  aesop (add norm simp [HasSubset.Subset, List.Subset])

theorem subset_singleton_iff {a : α} {L : List α} : L ⊆ [a] ↔ ∃ n, L = replicate n a :=
  ADMIT -- Nontrivial existential.

attribute [-simp] map_const
-- attribute [-simp] map_const'
@[simp] theorem map_const'' (l : List α) (b : β) : map (λ _ => b) l = replicate l.length b := by
  induction l <;> aesop

theorem eq_of_mem_map_const {b₁ b₂ : β} {l : List α} (h : b₁ ∈ map (λ _ => b₂) l) :
  b₁ = b₂ := by
  aesop

attribute [-simp] map_replicate
@[simp] theorem map_replicate' (f : α → β) (a : α) (n) : map f (replicate n a) = replicate n (f a) := by
  induction n <;> aesop

attribute [-simp] tail_replicate
@[simp] theorem tail_replicate' (a : α) (n) : tail (replicate n a) = replicate n.pred a := by
  aesop (add 1% cases Nat)

attribute [-simp] flatten_replicate_nil
@[simp] theorem flatten_replicate_nil' (n : Nat) : flatten (replicate n []) = @nil α := by
  induction n <;> aesop

theorem replicate_left_injective {n : Nat} (hn : n ≠ 0) :
    Injective (λ a : α => replicate n a) := by
  induction n <;> aesop

@[simp] theorem replicate_left_inj' {a b : α} :
  ∀ {n}, replicate n a = replicate n b ↔ n = 0 ∨ a = b := by
  intro n; induction n <;> aesop

theorem replicate_right_injective (a : α) : Injective (λ n => replicate n a) := by
  unfold Injective; intro x y
  induction x generalizing y <;> induction y <;>
    aesop (config := { useSimpAll := false })

@[simp] theorem replicate_right_inj {a : α} {n m : Nat} :
    replicate n a = replicate m a ↔ n = m := by
  aesop

/-! ### pure -/

@[simp] theorem mem_pure {α} (x y : α) :
    x ∈ (pure y : List α) ↔ x = y := by
  aesop (add norm simp pure)

/-! ### flatMap -/

instance : Bind List where
  bind l f := List.flatMap f l

@[simp] theorem bind_eq_flatMap {α β} (f : α → List β) (l : List α) :
    l >>= f = l.flatMap f := rfl

attribute [-simp] flatMap_append
theorem X.flatMap_append (f : α → List β) (l₁ l₂ : List α) :
  (l₁ ++ l₂).flatMap f = l₁.flatMap f ++ l₂.flatMap f := by
  induction l₁ <;> aesop

attribute [-simp] flatMap_singleton'
@[simp] theorem X.flatMap_singleton' (f : α → List β) (x : α) : [x].flatMap f = f x := by
  aesop

@[simp] theorem X.flatMap_singleton'' (l : List α) : l.flatMap (λ x => [x]) = l := by
  induction l <;> aesop

theorem map_eq_flatMap' {α β} (f : α → β) (l : List α) : map f l = l.flatMap (λ x => [f x]) := by
  induction l <;> aesop

theorem flatMap_assoc' {α β γ : Type u} (l : List α) (f : α → List β) (g : β → List γ) :
    (l.flatMap f).flatMap g = l.flatMap (λ x => (f x).flatMap g) :=
  ADMIT
  -- have aux {δ : Type u} (xs ys : List (List δ)) : flatten (xs ++ ys) = flatten xs ++ flatten ys := by
  --   induction xs <;> aesop
  -- induction l <;> aesop (add norm [simp [flatMap_append], unfold [flatMap]])

/-! ### concat -/

-- attribute [-simp] concat_nil
@[simp] theorem X.concat_nil (a : α) : concat [] a = [a] := rfl

-- attribute [-simp] concat_cons
@[simp] theorem X.concat_cons (a b : α) (l : List α) : concat (a :: l) b = a :: concat l b := rfl

attribute [-simp] concat_eq_append
@[simp] theorem X.concat_eq_append (a : α) (l : List α) : concat l a = l ++ [a] := by
  induction l <;> aesop

-- attribute [-simp] init_eq_of_concat_eq
theorem X.init_eq_of_concat_eq {a : α} {l₁ l₂ : List α} : concat l₁ a = concat l₂ a → l₁ = l₂ := by
  aesop

-- attribute [-simp] last_eq_of_concat_eq
theorem X.last_eq_of_concat_eq {a b : α} {l : List α} : concat l a = concat l b → a = b := by
  aesop

-- attribute [-simp] concat_ne_nil
theorem X.concat_ne_nil (a : α) (l : List α) : concat l a ≠ [] := by
  aesop

attribute [simp] append_assoc

-- attribute [-simp] concat_append
theorem X.concat_append (a : α) (l₁ l₂ : List α) : concat l₁ a ++ l₂ = l₁ ++ a :: l₂ := by
  aesop

-- attribute [-simp] length_concat
theorem X.length_concat (a : α) (l : List α) : length (concat l a) = .succ (length l) := by
  aesop

-- attribute [-simp] append_concat
theorem X.append_concat (a : α) (l₁ l₂ : List α) : l₁ ++ concat l₂ a = concat (l₁ ++ l₂) a := by
  aesop

/-! ### reverse -/

attribute [-simp] reverse_nil
@[simp] theorem X.reverse_nil : reverse (@nil α) = [] := rfl

attribute [-simp] reverse_cons
@[simp] theorem X.reverse_cons (a : α) (l : List α) : reverse (a::l) = reverse l ++ [a] :=
  ADMIT
  -- have aux : ∀ l₁ l₂, reverseAux l₁ l₂ ++ [a] = reverseAux l₁ (l₂ ++ [a]) := by
  --   intro l₁; induction l₁ <;> aesop (add norm unfold reverseAux)
  -- aesop (add norm unfold reverse)

-- Note: reverse_core is called reverseAux in Lean 4.
attribute [-simp] reverseAux_eq
@[simp] theorem X.reverseAux_eq (l₁ l₂ : List α) : reverseAux l₁ l₂ = reverse l₁ ++ l₂ := by
  induction l₁ generalizing l₂ <;> aesop

theorem reverse_cons' (a : α) (l : List α) : reverse (a::l) = concat (reverse l) a := by
  aesop

@[simp] theorem reverse_singleton (a : α) : reverse [a] = [a] := rfl

-- TODO: after nightly-2024-08-27, `aesop` can not prove this anymore!
attribute [-simp] reverse_append in
@[simp] theorem X.reverse_append (s t : List α) : reverse (s ++ t) = (reverse t) ++ (reverse s) :=
  ADMIT
  -- induction s <;> aesop

-- attribute [-simp] reverse_concat
theorem X.reverse_concat (l : List α) (a : α) : reverse (concat l a) = a :: reverse l := by
  aesop

attribute [-simp] reverse_reverse
@[simp] theorem X.reverse_reverse (l : List α) : reverse (reverse l) = l := by
  induction l <;> aesop

@[simp] theorem reverse_involutive : Involutive (@reverse α) := by
  aesop

@[simp] theorem reverse_injective {α : Type u} : Injective (@reverse α) := by
  aesop

@[simp] theorem reverse_surjective {α : Type u} : Surjective (@reverse α) := by
  aesop

@[simp] theorem reverse_bijective : Bijective (@reverse α) := by
  aesop

@[simp] theorem reverse_inj' {l₁ l₂ : List α} : reverse l₁ = reverse l₂ ↔ l₁ = l₂ := by
  aesop (add safe forward reverse_injective)

-- attribute [-simp] reverse_eq_iff
theorem X.reverse_eq_iff {l l' : List α} :
  l.reverse = l' ↔ l = l'.reverse := by
  aesop

@[simp] theorem reverse_eq_nil {l : List α} : reverse l = [] ↔ l = [] := by
  aesop (add norm simp reverse_eq_iff)

theorem concat_eq_reverse_cons (a : α) (l : List α) : concat l a = reverse (a :: reverse l) := by
  induction l <;> aesop

attribute [-simp] length_reverse
@[simp] theorem X.length_reverse (l : List α) : length (reverse l) = length l := by
  induction l <;> aesop

theorem map_reverse' (f : α → β) (l : List α) : map f (reverse l) = reverse (map f l) := by
  induction l <;> aesop

-- attribute [-simp] map_reverseAux
theorem map_reverse_core (f : α → β) (l₁ l₂ : List α) :
  map f (reverseAux l₁ l₂) = reverseAux (map f l₁) (map f l₂) := by
  aesop (add norm simp map_reverse')

attribute [-simp] mem_reverse
@[simp] theorem X.mem_reverse {a : α} {l : List α} : a ∈ reverse l ↔ a ∈ l := by
  induction l <;> aesop

@[simp] theorem reverse_replicate' (a : α) (n) : reverse (replicate n a) = replicate n a :=
  ADMIT -- Several missing lemmas.

/-! ### empty -/

theorem empty_iff_eq_nil {l : List α} : Empty l ↔ l = [] := by
  aesop

/-! ### init -/

@[simp] theorem length_init : ∀ (l : List α), length (init l) = length l - 1
  | [] => by aesop
  | [_] => by aesop
  | (_ :: y :: zs) => by
    have ih := length_init (y :: zs)
    aesop (add norm simp [init, Nat.add_sub_cancel])

/-! ### last -/

@[simp] theorem last_cons {a : α} {l : List α} :
  ∀ (h : l ≠ nil), last (a :: l) (cons_ne_nil a l) = last l h := by
  aesop (add 1% cases List)

@[simp] theorem last_append_singleton {a : α} (l : List α) :
  last (l ++ [a]) (append_ne_nil_of_right_ne_nil l (cons_ne_nil a _)) = a := by
  induction l <;> aesop

theorem last_append (l₁ l₂ : List α) (h : l₂ ≠ []) :
  last (l₁ ++ l₂) (append_ne_nil_of_right_ne_nil l₁ h) = last l₂ h := by
  induction l₁ <;> aesop

theorem last_concat {a : α} (l : List α) : last (concat l a) (X.concat_ne_nil a l) = a := by
  aesop

@[simp] theorem last_singleton (a : α) : last [a] (cons_ne_nil a []) = a := rfl

@[simp] theorem last_cons_cons (a₁ a₂ : α) (l : List α) :
  last (a₁::a₂::l) (cons_ne_nil _ _) = last (a₂::l) (cons_ne_nil a₂ l) := rfl

theorem init_append_last : ∀ {l : List α} (h : l ≠ []), init l ++ [last l h] = l
  | [] => by aesop
  | [_] => by aesop
  | x :: y :: zs => by
    have ih := init_append_last (l := y :: zs)
    aesop (add norm simp [init, last])

theorem last_congr {l₁ l₂ : List α} (h₁ : l₁ ≠ []) (h₂ : l₂ ≠ []) (h₃ : l₁ = l₂) :
  last l₁ h₁ = last l₂ h₂ := by
  aesop

theorem last_mem : ∀ {l : List α} (h : l ≠ []), last l h ∈ l := by
  intro l; induction l <;> aesop (add norm simp last, 1% cases List)

theorem last_replicate_succ (a m : Nat) :
  (replicate m.succ a).last
    (ne_nil_of_length_eq_add_one
      (show (replicate m.succ a).length = m.succ by rw [length_replicate])) =
  a := by
  induction m <;> aesop

/-! ### getLast? -/

section getLast?

@[simp] theorem getLast?_is_none :
  ∀ {l : List α}, (getLast? l).isNone ↔ l = []
  | [] => by aesop
  | [a] => by aesop
  | a :: a' :: as => by
    have ih := getLast?_is_none (l := a' :: as)
    aesop

@[simp] theorem getLast?_is_some : ∀ {l : List α}, l.getLast?.isSome ↔ l ≠ []
  | [] => by aesop
  | [a] => by aesop
  | a :: a' :: as => by
    have ih := getLast?_is_some (l := a' :: as)
    aesop

theorem mem_getLast?_eq_last : ∀ {l : List α} {x : α}, x ∈ l.getLast? → ∃ h, x = last l h
  | [], _, h => by aesop
  | [_], _, h => by aesop
  | a :: a' :: as, x, h => by
    have ih := mem_getLast?_eq_last (l := a' :: as) (x := x)
    aesop (add norm simp getLast?)

theorem getLast?_eq_last_of_ne_nil : ∀ {l : List α} (h : l ≠ []), l.getLast? = some (l.last h)
  | [], h => by aesop
  | [a], _ => by aesop
  | _ :: b :: l, _ => by
    have ih := getLast?_eq_last_of_ne_nil (l := b :: l)
    aesop

theorem mem_getLast?_cons {x y : α} : ∀ {l : List α} (_ : x ∈ l.getLast?), x ∈ (y :: l).getLast? := by
  intro l; induction l <;> aesop

-- attribute [-simp] mem_of_mem_getLast?
theorem X.mem_of_mem_getLast? {l : List α} {a : α} (ha : a ∈ l.getLast?) : a ∈ l := by
  match l with
  | [] => aesop
  | [_] => aesop
  | x :: y :: zs =>
    have ih := X.mem_of_mem_getLast? (l := y :: zs) (a := a)
    aesop

theorem init_append_getLast? : ∀ {l : List α} {a}, a ∈ l.getLast? → init l ++ [a] = l
  | [], _ => by aesop
  | [_], _ => by aesop
  | x :: y :: zs, a => by
    have ih := init_append_getLast? (l := y :: zs) (a := a)
    aesop (add norm simp init)

theorem ilast_eq_getLast? [Inhabited α] : ∀ l : List α, l.ilast = l.getLast?.iget
  | [] => by aesop
  | [a] => by aesop
  | [_, _] => by aesop
  | [_, _, _] => by aesop
  | (_ :: _ :: c :: l) => by
    have ih := ilast_eq_getLast? (c :: l)
    aesop

@[simp] theorem getLast?_append_cons : ∀ (l₁ : List α) (a : α) (l₂ : List α),
  getLast? (l₁ ++ a :: l₂) = getLast? (a :: l₂)
  | [], a, l₂ => by aesop
  | [_], a, l₂ => by aesop
  | _ :: c :: l₁, a, l₂ =>
    have ih := getLast?_append_cons (c :: l₁) a
    by aesop

@[simp] theorem getLast?_cons_cons' (x y : α) (l : List α) :
  getLast? (x :: y :: l) = getLast? (y :: l) := rfl

theorem getLast?_append_of_ne_nil (l₁ : List α) : ∀ {l₂ : List α} (_ : l₂ ≠ []),
  getLast? (l₁ ++ l₂) = getLast? l₂
  | [], hl₂ => by aesop
  | b :: l₂, _ => by aesop

theorem getLast?_append' {l₁ l₂ : List α} {x : α} (h : x ∈ l₂.getLast?) :
  x ∈ (l₁ ++ l₂).getLast? := by
  aesop (add 1% cases List)

end getLast?

/-! ### head(') and tail -/

-- Note: Lean 3 head is Lean 4 ihead.

-- attribute [-simp] ihead_eq_head'
theorem head_eq_head' [Inhabited α] (l : List α) : ihead l = (head' l).iget := by
  aesop (add 1% cases List)

theorem mem_of_mem_head' {x : α} : ∀ {l : List α}, x ∈ l.head' → x ∈ l := by
  intro l; induction l <;> aesop

-- attribute [-simp] head'_cons
@[simp] theorem X.head'_cons [Inhabited α] (a : α) (l : List α) : head' (a::l) = a := rfl

attribute [-simp] tail_nil
@[simp] theorem X.tail_nil : tail (@nil α) = [] := rfl

attribute [-simp] tail_cons
@[simp] theorem X.tail_cons (a : α) (l : List α) : tail (a::l) = l := rfl

-- attribute [-simp] head_append
@[simp] theorem X.head_append [Inhabited α] (t : List α) {s : List α} (h : s ≠ []) :
  ihead (s ++ t) = ihead s := by
  aesop (add 1% cases List)

theorem head'_append {s t : List α} {x : α} (h : x ∈ s.head') :
  x ∈ (s ++ t).head' := by
  aesop (add 1% cases List)

theorem head'_append_of_ne_nil : ∀ (l₁ : List α) {l₂ : List α} (_ : l₁ ≠ []),
  head' (l₁ ++ l₂) = head' l₁ := by
  aesop (add 1% cases List)

theorem tail_append_singleton_of_ne_nil {a : α} {l : List α} (h : l ≠ nil) :
  tail (l ++ [a]) = tail l ++ [a] := by
  induction l <;> aesop

theorem cons_head'_tail : ∀ {l : List α} {a : α} (_ : a ∈ head' l), a :: tail l = l := by
  aesop

-- attribute [-simp] ihead_mem_head'
theorem head_mem_head' [Inhabited α] : ∀ {l : List α} (_ : l ≠ []), ihead l ∈ head' l := by
  aesop

-- attribute [-simp] cons_ihead_tail
theorem cons_head_tail [Inhabited α] {l : List α} (h : l ≠ []) : (ihead l)::(tail l) = l := by
  aesop

end List



=== LEAN SOURCE: LocalRuleSet.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

-- We used to add local rules to the `default` rule set, but this doesn't work
-- well when the default rule set is disabled.

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : Unit := by
  aesop (rule_sets := [-default, -builtin]) (config := { terminal := true })

example : Unit := by
  aesop (add safe PUnit.unit) (rule_sets := [-default, -builtin])



=== LEAN SOURCE: LocalTactic.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

/--
error: tactic 'aesop' failed, made no progress
-/
#guard_msgs in
example (m n : Nat) : m * n = n * m := by
  aesop

example (m n : Nat) : m * n = n * m := by
  aesop (add safe (by rw [Nat.mul_comm]))

example (m n : Nat) : m * n = n * m := by
  aesop (add safe tactic (by rw [Nat.mul_comm m n]))

/--
error: tactic 'aesop' failed, made no progress
-/
#guard_msgs in
example (m n : Nat) : m * n = n * m := by
  aesop (add safe (by rw [Nat.mul_comm m m]))

example (m n : Nat) : m * n = n * m := by
  aesop (add safe (by apply Nat.mul_comm; done))



=== LEAN SOURCE: Logic.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

example : True := by
  aesop

example : Unit := by
  aesop

example : PUnit.{u} := by
  aesop

example (h : False) : α := by
  aesop

example (h : Empty) : α := by
  aesop

example (h : PEmpty.{u}) : α := by
  aesop



=== LEAN SOURCE: Metas.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

example (P : α → Prop) (a : α) (h : P a) : ∃ a, P a := by
  aesop

example (P : α → β → Prop) (a : α) (b : β) (h : P a b) : ∃ a b, P a b := by
  aesop

example (P : α → Type) (a : α) (h : P a) : Σ a, P a := by
  aesop

example (P : α → β → Type) (a : α) (b : β) (h : P a b) : Σ a b, P a b := by
  aesop

example (P Q : α → Prop) (hPQ : ∀ a, P a → Q a) (a : α) (h : P a) : ∃ a, Q a := by
  aesop

example (P Q Dead R : α → Prop)
    (hPQ : ∀ a, P a → Q a)
    (hDeadR : ∀ a, Dead a → R a)
    (hQR : ∀ a, Q a → R a)
    (a : α) (h : P a) :
    ∃ a, R a := by
  aesop

example (R : α → α → Prop) (R_trans : ∀ x y z, R x y → R y z → R x z) (a b c d)
    (hab : R a b) (hbc : R b c) (hcd : R c d) : R a d := by
  aesop



=== LEAN SOURCE: MVarsInInitialGoal.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

example {n m k : Nat} (h : n < m) (h₂ : m < k) : n < k := by
  apply Nat.lt_trans <;> aesop



=== LEAN SOURCE: NameResolution.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/
import Aesop

set_option aesop.check.all true

-- When parsing the names of declarations for local rules, Aesop should take the
-- currently opened namespaces into account.

example : List α := by
  aesop (add safe List.nil)

namespace List

example : List α := by
  aesop (add safe List.nil)

example : List α := by
  aesop (add safe nil)

end List



=== LEAN SOURCE: NoImportClash.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

/-
This test case ensures that Aesop does not define anything that already exists
in our dependencies.
-/

import Aesop
import Lean
import Batteries



=== LEAN SOURCE: NoNormSimp.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : 1 = 2 → False := by
  aesop (config := { enableSimp := false, terminal := true })

example : 1 = 2 → False := by
  aesop



=== LEAN SOURCE: Nonterminal.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

structure MyTrue₁
structure MyTrue₂

@[aesop safe]
structure MyTrue₃ where
  tt : MyTrue₁

/--
warning: aesop: failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : MyTrue₃ := by
  aesop
  apply MyTrue₁.mk

@[aesop safe]
structure MyFalse where
  falso : False

/--
warning: aesop: failed to prove the goal after exhaustive search.
---
error: unsolved goals
⊢ False
-/
#guard_msgs in
example : MyFalse := by
  aesop

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : MyFalse := by
  aesop (config := { terminal := true })

/--
error: unsolved goals
⊢ False
-/
#guard_msgs in
example : MyFalse := by
  aesop (config := { warnOnNonterminal := false })

@[aesop safe]
structure MyFalse₂ where
  falso : False
  tt : MyTrue₃

/--
warning: aesop: failed to prove the goal after exhaustive search.
---
error: unsolved goals
case falso
⊢ False

case tt
⊢ MyTrue₁
-/
#guard_msgs in
example : MyFalse₂ := by
  aesop



=== LEAN SOURCE: NoProgress.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

def T := True

/--
error: tactic 'aesop' failed, made no progress
-/
#guard_msgs in
example : T := by
  aesop

@[aesop norm simp]
def F := False

/--
warning: aesop: failed to prove the goal after exhaustive search.
---
error: unsolved goals
⊢ False
-/
#guard_msgs in
example : F := by
  aesop

def F' := False

@[aesop safe apply]
theorem F'_def : False → F' := id

/--
warning: aesop: failed to prove the goal after exhaustive search.
---
error: unsolved goals
⊢ False
-/
#guard_msgs in
example : F' := by
  aesop

attribute [-aesop] F'_def
attribute [aesop 100%] F'_def

-- When an unsafe rule is applied, we don't count this as progress because the
-- remaining goal that the user gets to see is exactly the same as the initial
-- goal.

/--
error: tactic 'aesop' failed, made no progress
-/
#guard_msgs in
example : F' := by
  aesop



=== LEAN SOURCE: NormSimp.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

-- A basic test for local simp rules.
example {α : Prop} (h : α) : α := by
  aesop (rule_sets := [-builtin,-default]) (add h norm simp)

-- This test checks that we don't 'self-simplify' hypotheses: `h` should not
-- be used to simplify itself.
example (h : (α ∧ β) ∨ γ) : α ∨ γ := by
  aesop (add h norm simp)

-- Ditto, but we can omit the 'norm'.
example (h : (α ∧ β) ∨ γ) : α ∨ γ := by
  aesop (add h simp)

-- This test checks that the norm simp config is passed around properly.

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example {α β : Prop} (ha : α) (h : α → β) : β := by
  aesop (rule_sets := [-builtin,-default])
    (simp_config := { maxDischargeDepth := 0 })
    (config := { terminal := true, useDefaultSimpSet := false })

example {α β : Prop} (ha : α) (h : α → β) : β := by
  aesop (rule_sets := [-builtin,-default])

-- Ditto.

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : true && false = false := by
  aesop (rule_sets := [-default,-builtin])
    (simp_config := { decide := false })
    (config := { terminal := true, useDefaultSimpSet := false })

example : true && false = false := by
  aesop (rule_sets := [-default,-builtin]) (simp_config := { decide := true })

-- We can use the `useSimpAll` config option to switch between `simp_all` and
-- `simp at *`.

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example {α : Prop} (ha : α) : α := by
  aesop (rule_sets := [-builtin,-default])
    (config := { useSimpAll := false, terminal := true })

example {α : Prop} (ha : α) : α := by
  aesop (rule_sets := [-builtin,-default])

-- We can give priorities to `simp` rules, corresponding to the priorities of
-- `simp` lemmas.

opaque T : Prop

@[aesop simp 1]
axiom TF : T ↔ False

@[aesop simp 2]
axiom TT : T ↔ True

example : T := by aesop

attribute [-aesop] TF
attribute [aesop simp 3] TF

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : T := by
  aesop (config := { terminal := true })

example : T := by
  rw [TT]; trivial



=== LEAN SOURCE: Persistence0.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

declare_aesop_rule_sets [test_persistence1]



=== LEAN SOURCE: Persistence1.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import AesopTest.Persistence0

set_option aesop.check.all true

namespace Aesop

@[aesop 50% constructors (rule_sets := [test_persistence1])]
inductive NatOrBool where
  | ofNat (n : Nat)
  | ofBool (b : Bool)

example (b : Bool) : NatOrBool := by
  aesop (rule_sets := [test_persistence1])

end Aesop



=== LEAN SOURCE: Persistence2.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

declare_aesop_rule_sets [test_persistence2]



=== LEAN SOURCE: Persistence3.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import AesopTest.Persistence1
import AesopTest.Persistence2

set_option aesop.check.all true

namespace Aesop

@[aesop 50% (rule_sets := [test_persistence2])]
def test (b : Bool) : NatOrBool := by
  aesop (rule_sets := [test_persistence1])

end Aesop



=== LEAN SOURCE: PostponeSafeRules.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

-- This is a test case for postponed safe rules. When a safe rule assigns mvars,
-- it is not applied but instead postponed. Then we later try it again as an
-- unsafe rule.
--
-- It's hard to test this feature completely because we can't really tell from
-- the outside when a rule has been applied. But we can at least look at the
-- traces of the following test cases.

axiom T : Nat → Prop

@[aesop safe]
axiom t : T 0

example : ∃ (i : Nat), T i := by
  aesop


axiom U : Nat → Prop

@[aesop safe 0]
axiom u₁ : U 0

@[aesop safe 1]
axiom u₂ : U 1

example : ∃ i, U i ∧ i = 1 := by
  aesop



=== LEAN SOURCE: RecursiveUnfoldRule.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

-- We forbid `unfold` rules for recursive functions since they would lead to
-- infinite unfolding.

@[aesop norm unfold]
def f₁ : Nat → Nat :=
  λ _ => 0

/--
error: Recursive definition 'f₂' cannot be used as an unfold rule (it would be unfolded infinitely often). Try adding a simp rule for it.
-/
#guard_msgs in
@[aesop norm unfold]
def f₂ : Nat → Nat
  | 0 => 0
  | n + 1 => f₂ n

/--
error: Recursive definition 'f₃' cannot be used as an unfold rule (it would be unfolded infinitely often). Try adding a simp rule for it.
-/
#guard_msgs in
@[aesop norm unfold]
def f₃ : Nat → Nat :=
  λ n =>
    match n with
    | 0 => 0
    | n + 1 => f₃ n


/--
error: Recursive definition 'f₄' cannot be used as an unfold rule (it would be unfolded infinitely often). Try adding a simp rule for it.
-/
#guard_msgs in
@[aesop norm unfold]
def f₄ : Nat → Nat
  | 0 => 0
  | n + 1 => f₄ n

-- A limitation of our approach to checking for recursive `unfold` rules:
-- mutually recursive rules are not detected. But that's probably fine in
-- practice.

mutual
  @[aesop norm unfold]
  def f₅ : Nat → Nat
    | 0 => 0
    | n + 1 => f₆ n

  @[aesop norm unfold]
  def f₆ : Nat → Nat
    | 0 => 0
    | n + 1 => f₅ n
end

-- We also forbid `unfold` rules for declarations that don't unfold.

/--
error: Declaration 'test' cannot be unfolded.
-/
#guard_msgs in
@[aesop norm unfold]
axiom test : Nat



=== LEAN SOURCE: RulePattern.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

macro "aesop!" : tactic =>
  `(tactic| aesop (config := { warnOnNonterminal := false }))

axiom falso : ∀ {α : Sort _}, α

macro "falso" : tactic => `(tactic| exact falso)

@[aesop norm -100 forward (pattern := (↑n : Int))]
axiom nat_pos (n : Nat) : 0 ≤ (↑n : Int)

example (m n : Nat) : (↑m : Int) < 0 ∧ (↑n : Int) > 0 := by
  set_option aesop.check.script.steps false in -- TODO lean4#4315
  set_option aesop.check.script false in
  aesop (config := { enableSimp := false, warnOnNonterminal := false })
  all_goals
    guard_hyp fwd   : 0 ≤ (n : Int)
    guard_hyp fwd_1 : 0 ≤ (m : Int)
    falso

@[aesop safe forward (pattern := min x y)]
axiom foo : ∀ {x y : Nat} (_ : 0 < x) (_ : 0 < y), 0 < min x y

example (hx : 0 < x) (hy : 0 < y) (_ : min x y < z): False := by
  aesop!
  guard_hyp fwd : 0 < min x y
  falso

axiom abs (n : Int) : Nat

notation "|" t "|" => abs t

@[aesop safe forward (pattern := |a + b|)]
axiom triangle (a b : Int) : |a + b| ≤ |a| + |b|

example : |a + b| ≤ |c + d| := by
  aesop!
  guard_hyp fwd   : |a + b| ≤ |a| + |b|
  guard_hyp fwd_1 : |c + d| ≤ |c| + |d|
  falso

@[aesop safe apply (pattern := (0 : Nat))]
axiom falso' : True → False

/--
error: tactic 'aesop' failed, made no progress
Initial goal:
  ⊢ False
-/
#guard_msgs in
example : False := by
  aesop

example (h : n = 0) : False := by
  aesop (rule_sets := [-builtin])

-- Patterns may only contain variables mentioned in the rule.

/--
error: unknown identifier 'z'
-/
#guard_msgs in
@[aesop safe forward (pattern := z)]
axiom quuz (x y : Nat) : True

-- When a premise of a forward rule is mentioned in a pattern, it can't also
-- be an immediate argument.

@[aesop safe forward (pattern := (↑x : Int)) (immediate := [y])]
axiom bar (x y : Nat) : True

/--
error: aesop: forward builder: argument 'x' cannot be immediate since it is already determined by a pattern
-/
#guard_msgs in
@[aesop safe forward (pattern := (↑x : Int)) (immediate := [y, x])]
axiom baz (x y : Nat) : True

-- For types with 'reducibly hidden' forall binders, the pattern can only refer
-- to the syntactically visible variables.

abbrev T := (tt : True) → False

/--
error: unknown identifier 'tt'
-/
#guard_msgs in
@[aesop safe forward (pattern := tt)]
axiom falso₁ : T

-- We support dependencies in patterns. E.g. in the following pattern, only the
-- premise `x` occurs syntactically, but the type of `x` depends on `a` and `p`,
-- so these premises are also determined by the pattern substitution.
-- (Thanks to Son Ho for this test case.)

@[aesop safe forward (pattern := x)]
theorem get_prop {a : Type} {p : a → Prop} (x : Subtype p) : p x.val :=
  x.property

example {a : Type} {p : a → Prop} (x : Subtype p × Subtype p)
    (h : x.1.val = x.2.val) : p x.1.val ∧ p x.2.val := by
  saturate
  apply And.intro <;> assumption



=== LEAN SOURCE: RulePatternLooseBVar.lean ===
/-
Copyright (c) 2024 Son Ho. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Son Ho, Jannis Limperg
-/

-- A regression test for a bug in rule pattern matching. Thanks to Son Ho for
-- the bug report.

import Aesop

inductive ScalarTy
| U32

@[simp]
def U32.min   : Int  := 0
def U32.max   : Int  := 4294967295

def Scalar.min (ty : ScalarTy) : Int :=
  match ty with
  | .U32   => U32.min

def Scalar.max (ty : ScalarTy) : Int :=
  match ty with
  | .U32   => U32.max

structure Scalar (ty : ScalarTy) where
  val : Int
  hmin : Scalar.min ty ≤ val
  hmax : val ≤ Scalar.max ty

@[reducible] def U32   := Scalar .U32

def Scalar.ofIntCore {ty : ScalarTy} (x : Int)
  (h : Scalar.min ty ≤ x ∧ x ≤ Scalar.max ty) : Scalar ty :=
  { val := x, hmin := h.left, hmax := h.right }

def U32.ofIntCore   := @Scalar.ofIntCore .U32

@[aesop safe forward (pattern := x)]
theorem Scalar.bounds {ty : ScalarTy} (x : Scalar ty) :
  Scalar.min ty ≤ x.val ∧ x.val ≤ Scalar.max ty :=
  And.intro x.hmin x.hmax

/--
error: unsolved goals
x : Int
h0 : 0 ≤ x
h1 : x ≤ U32.max
fwd : Scalar.min ScalarTy.U32 ≤ (U32.ofIntCore x ⋯).val ∧ (U32.ofIntCore x ⋯).val ≤ Scalar.max ScalarTy.U32
⊢ (U32.ofIntCore x ⋯).val ≤ U32.max
-/
#guard_msgs in
example (x : Int) (h0 : 0 ≤ x) (h1 : x ≤ U32.max) :
  (U32.ofIntCore x
    (⟨Eq.mp (congrArg (fun x_1 => x_1 ≤ x) rfl) h0, h1⟩)).val ≤ U32.max := by
  saturate



=== LEAN SOURCE: RulePatternUniverseBug.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Son Ho, Jannis Limperg
-/

-- A regression test for an issue where universe mvars were not correctly
-- assigned during rule pattern matching. Thanks to Son Ho for reporting this
-- issue.

import Aesop.Frontend.Attribute
import Aesop.Frontend.Saturate

set_option aesop.check.all true

namespace List

@[simp]
def len (ls : List α) : Int :=
  match ls with
  | [] => 0
  | _ :: tl => 1 + len tl

@[aesop safe forward (pattern := len ls)]
theorem len_pos : 0 ≤ len (ls : List α) := by
  induction ls <;> simp [*]
  omega

def indexOpt (ls : List α) (i : Int) : Option α :=
  match ls with
  | [] => none
  | hd :: tl => if i = 0 then some hd else indexOpt tl (i - 1)

theorem indexOpt_bounds (ls : List α) (i : Int) :
    ls.indexOpt i = none ↔ i < 0 ∨ ls.len ≤ i := by
  match ls with
  | [] => simp [indexOpt]; omega
  | _ :: tl =>
    have := indexOpt_bounds tl (i - 1)
    if h : i = 0 then
      simp [indexOpt, *]
      saturate
      omega
    else
      simp [indexOpt, len, *]
      constructor <;> intro a <;> cases a
      . left
        saturate
        omega
      . right; omega
      . left; omega
      . right; omega



=== LEAN SOURCE: RuleSetNameHygiene0.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

declare_aesop_rule_sets [test]



=== LEAN SOURCE: RuleSetNameHygiene1.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import AesopTest.RuleSetNameHygiene0

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

macro "aesop_test" : tactic => `(tactic| aesop (rule_sets := [test]))

@[aesop safe (rule_sets := [test])]
structure TT where

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : TT := by
  aesop (config := { terminal := true })

example : TT := by
  aesop_test



=== LEAN SOURCE: RuleSets0.lean ===
/-
Copyright (c) 2022-2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

declare_aesop_rule_sets [test_A, test_B, test_C, test_D]



=== LEAN SOURCE: RuleSets1.lean ===
/-
Copyright (c) 2022-2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import AesopTest.RuleSets0

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

@[aesop safe (rule_sets := [test_A])]
inductive A : Prop where
| intro

@[aesop safe (rule_sets := [test_B])]
inductive B : Prop where
| intro

@[aesop safe]
inductive C : Prop where
| intro

inductive D : Prop where
| intro

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : A := by
  aesop (config := { terminal := true })

example : A := by
  aesop (rule_sets := [test_A])

example : B := by
  aesop (rule_sets := [test_A, test_B])

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : C := by
  aesop (rule_sets := [-default]) (config := { terminal := true })

example : C := by
  aesop

attribute [aesop safe (rule_sets := [test_C])] C

-- Removing the attribute removes all rules associated with C from all rule
-- sets.
attribute [-aesop] C

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : C := by
  aesop (rule_sets := [test_C]) (config := { terminal := true })

example : C := by
  aesop (add safe C)

@[aesop norm simp]
theorem ad : D ↔ A :=
  ⟨λ _ => A.intro, λ _ => D.intro⟩

example : D := by
  aesop (rule_sets := [test_A])

attribute [-aesop] ad

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : D := by
  aesop (rule_sets := [test_A]) (config := { terminal := true })

example : D := by
  aesop (add norm ad) (rule_sets := [test_A])

-- Rules can also be local.

inductive E : Prop where
  | intro

section

attribute [local aesop safe] E

example : E := by
  aesop

end

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : E := by
  aesop (config := { terminal := true })

example : E := by
  constructor

-- Rules can also be scoped.

namespace EScope

attribute [scoped aesop safe] E

example : E := by
  aesop

end EScope

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : E := by
  aesop (config := { terminal := true })

example : E := by
  open EScope in aesop



=== LEAN SOURCE: Safe.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

@[aesop 50%]
inductive Even : Nat → Prop
| zero : Even 0
| plus_two {n} : Even n → Even (n + 2)

structure Even' (n) : Prop where
  even : Even n

theorem even'_of_false : False → Even' n
| h => nomatch h

theorem even'_of_even' : Even' n → Even' n :=
  id

-- Once a safe rule is applied, the corresponding goal is marked as inactive
-- and never visited again.

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : Even' 2 := by
  aesop (add safe [even'_of_false 0, Even'.mk 1])
    (config := { terminal := true })

/--
error: tactic 'aesop' failed, maximum number of rule applications (10) reached. Set the 'maxRuleApplications' option to increase the limit.
-/
#guard_msgs in
example : Even' 2 := by
  aesop (add safe [even'_of_even'], unsafe [Even'.mk 100%])
    (config := { maxRuleApplications := 10, terminal := true })

example : Even' 2 := by
  aesop (add safe [even'_of_false 1, Even'.mk 0])



=== LEAN SOURCE: SafeExtractionCopyIntroducedMVars.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

axiom P : Prop
axiom T : Prop
axiom Q : Nat → Prop
axiom R : Nat → Prop
axiom S : Nat → Prop

@[aesop safe]
axiom q_r_p : ∀ x, Q x → R x → P

@[aesop safe]
axiom s_q : ∀ x y, S y → Q x

@[aesop safe]
axiom s_r : ∀ x y, S y → R x

axiom s : S 0

/--
warning: aesop: failed to prove the goal after exhaustive search.
---
error: unsolved goals
case a.a
⊢ S ?a.y✝

case a.a
⊢ S ?a.y✝

case x
⊢ Nat

case a.a
⊢ S ?a.y✝

case a.a
⊢ S ?a.y✝

case x
⊢ Nat
---
error: (kernel) declaration has metavariables '_example'
-/
#guard_msgs in
example : P := by
  aesop



=== LEAN SOURCE: SafePrefixExpansionRappLimit.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

@[aesop safe]
axiom loopy {α : Prop} : α ∨ α → α

/--
warning: aesop: failed to prove the goal. Some goals were not explored because the maximum rule application depth (30) was reached. Set option 'maxRuleApplicationDepth' to increase the limit.
---
warning: aesop: safe prefix was not fully expanded because the maximum number of rule applications (50) was reached.
---
error: unsolved goals
case a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a
⊢ False
-/
#guard_msgs in
example : False := by
  aesop

/--
error: tactic 'aesop' failed, failed to prove the goal. Some goals were not explored because the maximum rule application depth (30) was reached. Set option 'maxRuleApplicationDepth' to increase the limit.
Initial goal:
  ⊢ False
Remaining goals after safe rules:
  case a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a
  ⊢ False
The safe prefix was not fully expanded because the maximum number of rule applications (50) was reached.
-/
#guard_msgs in
example : False := by
  aesop (config := { terminal := true })



=== LEAN SOURCE: SafePrefixInTerminalError.lean ===
import Aesop

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
Initial goal:
  ⊢ ∀ (a b : Nat), a + b = b + 2 * a
Remaining goals after safe rules:
  a b : Nat
  ⊢ a + b = b + 2 * a
-/
#guard_msgs in
example : ∀ (a b : Nat), a + b = b + 2 * a := by
  aesop (config := { terminal := true })



=== LEAN SOURCE: SaturatePerformance.lean ===
/-
Copyright (c) 2024 Son Ho. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Son Ho, Jannis Limperg
-/

import Aesop

@[aesop safe forward (pattern := l)] theorem th1  (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th2  (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th3  (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th4  (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th5  (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th6  (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th7  (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th8  (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th9  (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th10 (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th11 (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th12 (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th13 (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th14 (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th15 (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th16 (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th17 (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th18 (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th19 (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th20 (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th21 (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th22 (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th23 (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th24 (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th25 (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th26 (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th27 (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th28 (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th29 (l : List α) : l.length ≥ 0 := by simp
@[aesop safe forward (pattern := l)] theorem th30 (l : List α) : l.length ≥ 0 := by simp

/--
error: unsolved goals
α : Type u_1
l0 l1 l2 : List α
fwd : l0.length ≥ 0
fwd_1 : l1.length ≥ 0
fwd_2 : l2.length ≥ 0
fwd_3 : (l0 ++ l1).length ≥ 0
fwd_4 : (l0 ++ l1 ++ l2).length ≥ 0
⊢ (l0 ++ l1 ++ l2).length = l0.length + l1.length + l2.length
-/
#guard_msgs in
theorem test (l0 l1 l2 : List α) : (l0 ++ l1 ++ l2).length = l0.length + l1.length + l2.length := by
  saturate



=== LEAN SOURCE: ScriptWithOptions.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

/--
info: Try this:
simp_all (config := { }) only
-/
#guard_msgs in
example : True := by
  aesop? (config := {}) (simp_config := {})



=== LEAN SOURCE: SeqCalcProver.lean ===
/-
Copyright (c) 2022 Asta H. From. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Asta H. From
-/

import Aesop

set_option aesop.check.script true
set_option aesop.check.script.steps true

--- Decidable

attribute [aesop unsafe [50% constructors, 50% cases]] Decidable
attribute [aesop safe apply] instDecidableAnd


--- Mem

attribute [aesop safe cases (cases_patterns := [List.Mem _ []])] List.Mem
attribute [aesop unsafe 50% constructors] List.Mem
attribute [aesop unsafe 50% cases (cases_patterns := [List.Mem _ (_ :: _)])] List.Mem

theorem Mem.map {x : α} {xs : List α} (f : α → β) (h : x ∈ xs) : f x ∈ xs.map f := by
  induction h <;> aesop

theorem Mem.split [DecidableEq α] {xs : List α} {v : α} (h : v ∈ xs)
  : ∃ l r, xs = l ++ v :: r := by
  induction xs
  case nil =>
    aesop
  case cons x xs ih =>
    have dec : Decidable (x = v) := inferInstance
    cases dec
    case isFalse no =>
      let ⟨l, r, eq⟩ : ∃ l r, xs = l ++ v :: r := by aesop
      rw [eq]
      exact ⟨x :: l, r, rfl⟩
    case isTrue yes =>
      rw [yes]
      exact ⟨[], xs, rfl⟩


--- All

@[aesop safe [constructors, cases (cases_patterns := [All _ [], All _ (_ :: _)])]]
inductive All (P : α → Prop) : List α → Prop
  | nil : All P []
  | cons {x xs} : P x → All P xs → All P (x :: xs)

namespace All

@[simp]
theorem split_cons (P : α → Prop) (x : α) (xs : List α)
  : All P (x :: xs) ↔ (P x ∧ All P xs) := by
  aesop

theorem mem (P : α → Prop) (xs : List α)
  : All P xs ↔ ∀ a : α, a ∈ xs → P a := by
  induction xs <;> aesop

theorem weaken (P Q : α → Prop) (wk : ∀ x, P x → Q x) (xs : List α) (h : All P xs)
  : All Q xs := by
  induction h <;> aesop

-- TODO: the trace.aesop.proof does not work here
theorem in_self (xs : List α) : All (· ∈ xs) xs := by
  induction xs <;> aesop (add unsafe apply weaken)

theorem map (P : β → Prop) (f : α → β) (xs : List α)
  : All P (xs.map f) ↔ All (fun x => P (f x)) xs := by
  induction xs <;> aesop

end All


--- Any

@[aesop safe cases (cases_patterns := [Any _ []]),
  aesop unsafe [50% constructors, 50% cases (cases_patterns := [Any _ (_ :: _ )])]]
inductive Any (P : α → Prop) : List α → Prop
  | here {x xs} : P x → Any P (x :: xs)
  | there {x xs} : Any P xs → Any P (x :: xs)

namespace Any

@[simp]
theorem cons (P : α → Prop) (x : α) (xs : List α)
  : Any P (x :: xs) ↔ (P x ∨ Any P xs) := by
  aesop

theorem mem (P : α → Prop) (xs : List α)
  : Any P xs ↔ ∃ a : α, P a ∧ a ∈ xs := by
  apply Iff.intro
  case mp =>
    intro AnyPxs
    induction AnyPxs <;> aesop
  case mpr =>
    intro ⟨a, Pa, Ea⟩
    induction Ea <;> aesop

theorem map (P : β → Prop) (f : α → β) (xs : List α)
  : Any P (xs.map f) ↔ Any (fun x => P (f x)) xs := by
  induction xs <;> aesop

instance instDecidablePred (P : α → Prop) [d : DecidablePred P]
  : DecidablePred (Any P) := by
  intro xs
  match xs with
  | [] => aesop
  | x :: xs =>
    have ih : Decidable (Any P xs) := instDecidablePred P xs
    cases d x <;> aesop

end Any


--- Common

@[simp]
def Common (xs ys : List α) : Prop :=
  Any (· ∈ ys) xs

namespace Common

theorem mem {xs ys : List α} (h : Common xs ys)
  : ∃ a : α, a ∈ xs ∧ a ∈ ys := by
  induction h <;> aesop

theorem sym {xs ys : List α} (h : Common xs ys)
  : Common ys xs := by
  have other : ∃ a, a ∈ ys ∧ a ∈ xs := Iff.mp (Any.mem (· ∈ ys) xs) h
  apply Iff.mpr (Any.mem (· ∈ xs) ys)
  aesop

instance instDecidable [DecidableEq α] (xs ys : List α)
  : Decidable (Common xs ys) := by
  apply Any.instDecidablePred

end Common


--- List Permutations

-- From https://github.com/agda/agda-stdlib/blob/master/src/Data/List/Relation/Binary/Permutation/Propositional.agda
@[aesop unsafe [50% constructors, 25% cases (cases_patterns := [Perm (_ :: _) (_ :: _ )])]]
inductive Perm : (xs ys : List α) → Prop
  | refl {xs} : Perm xs xs
  | prep {xs ys} x : Perm xs ys → Perm (x :: xs) (x :: ys)
  | swap {xs ys} x y : Perm xs ys → Perm (x :: y :: xs) (y :: x :: ys)
  | tran {xs ys zs} : Perm xs ys → Perm ys zs → Perm xs zs

infix:45 " ↭ " => Perm

namespace Perm

noncomputable section

def sym {xs ys : List α} (perm : xs ↭ ys)
  : ys ↭ xs := by
  induction perm <;> aesop

def shift (v : α) (xs ys : List α)
  : xs ++ v :: ys ↭ v :: xs ++ ys := by
  induction xs <;> aesop

def map {xs ys : List α} (f : α → β) (perm : xs ↭ ys)
  : xs.map f ↭ ys.map f := by
  induction perm <;> aesop

theorem all {xs ys : List α} (perm : xs ↭ ys) (P : α → Prop)
  : All P xs → All P ys := by
  induction perm <;> aesop

theorem any {xs ys : List α} (perm : xs ↭ ys) (P : α → Prop)
  : Any P xs → Any P ys := by
  induction perm <;> aesop

end

end Perm


--- Syntax

inductive Form (Φ : Type)
| pro : Φ → Form Φ
| fls : Form Φ
| imp (φ ψ : Form Φ) : Form Φ

prefix:80 "♩" => Form.pro
notation "⊥" => Form.fls
infixr:75 " ⇒ " => Form.imp


--- Semantics

@[simp]
def Val (i : Φ → Prop) : Form Φ → Prop
  | ♩n => i n
  | ⊥ => false
  | φ ⇒ ψ => Val i φ → Val i ψ

instance Val.instDecidable (i : Φ → Prop) [d : DecidablePred i] (φ : Form Φ)
  : Decidable (Val i φ) := by
  match φ with
  | ♩n => aesop
  | ⊥ => aesop
  | φ ⇒ ψ =>
    have ihφ : Decidable (Val i φ) := instDecidable i φ
    have ihψ : Decidable (Val i ψ) := instDecidable i ψ
    aesop

abbrev Valid (φ : Form Φ) : Prop := ∀ i, DecidablePred i → Val i φ

@[simp]
def SC (i : Φ → Prop) (Γ Δ : List (Form Φ)) : Prop :=
  All (Val i) Γ → Any (Val i) Δ

namespace SC

theorem all {i : Φ → Prop} {Γ Γ' Δ : List (Form Φ)} (perm : Γ' ↭ Γ) (h : SC i Γ Δ)
  : SC i Γ' Δ := by aesop (add unsafe apply Perm.all)

theorem any {i : Φ → Prop} {Γ Δ Δ' : List (Form Φ)} (perm : Δ ↭ Δ') (h : SC i Γ Δ)
  : SC i Γ Δ' := by aesop (add unsafe apply Perm.any)

end SC


--- Prover

@[simp]
def sum : List Nat → Nat
  | [] => 0
  | x :: xs => sum xs + x

@[simp]
def Cal (l r : List Φ) : (Γ Δ : List (Form Φ)) → Prop
  | [], [] => Common l r
  | ⊥ :: _, [] => true
  | Γ, ⊥ :: Δ => Cal l r Γ Δ
  | ♩n :: Γ, [] => Cal (n :: l) r Γ []
  | Γ, ♩n :: Δ => Cal l (n :: r) Γ Δ
  | φ ⇒ ψ :: Γ, [] => Cal l r Γ [φ] ∧ Cal l r (ψ :: Γ) []
  | Γ, φ ⇒ ψ :: Δ => Cal l r (φ :: Γ) (ψ :: Δ)
termination_by Γ Δ => sum (Γ.map sizeOf) + sum (Δ.map sizeOf)

instance Cal.instDecidable [DecidableEq Φ] (l r : List Φ) (Γ Δ : List (Form Φ))
  : Decidable (Cal l r Γ Δ) := by
  match Γ, Δ with
  | [], [] => unfold Cal; apply Common.instDecidable l r
  | ⊥ :: Γ, [] => aesop
  | Γ, ⊥ :: Δ =>
    have ih : Decidable (Cal l r Γ Δ) := instDecidable l r Γ Δ
    aesop
  | ♩n :: Γ, [] =>
    have ih : Decidable (Cal (n :: l) r Γ []) := instDecidable (n :: l) r Γ []
    aesop
  | Γ, ♩n :: Δ =>
    have ih : Decidable (Cal l (n :: r) Γ Δ) := instDecidable l (n :: r) Γ Δ
    aesop
  | φ ⇒ ψ :: Γ, [] =>
    have ih₁ : Decidable (Cal l r Γ [φ]) := instDecidable l r Γ [φ]
    have ih₂ : Decidable (Cal l r (ψ :: Γ) []) := instDecidable l r (ψ :: Γ) []
    aesop
  | Γ, φ ⇒ ψ :: Δ =>
    have ih : Decidable (Cal l r (φ :: Γ) (ψ :: Δ)) := instDecidable l r (φ :: Γ) (ψ :: Δ)
    aesop
termination_by sum (Γ.map sizeOf) + sum (Δ.map sizeOf)
decreasing_by all_goals simp_wf <;> simp +arith

abbrev Prove (φ : Form Φ) : Prop := Cal [] [] [] [φ]

example : Prove (⊥ ⇒ ♩0) := by simp
example : Prove (♩0 ⇒ ♩0) := by simp
example : Prove (♩0 ⇒ ♩1 ⇒ ♩0) := by simp
example : ¬ Prove (♩0 ⇒ ♩1) := by simp (config := {decide := true})


--- Soundness and Completeness

@[simp]
def SC' (i : Φ → Prop) (l r : List Φ) (Γ Δ : List (Form Φ)) : Prop :=
  SC i (Γ ++ l.map (♩·)) (Δ ++ r.map (♩·))

theorem Cal_sound_complete [DecidableEq Φ]
  (l r : List Φ) (Γ Δ : List (Form Φ))
  : Cal l r Γ Δ ↔ ∀ i : Φ → Prop, DecidablePred i → SC' i l r Γ Δ := by
  match Γ, Δ with
  | [], [] =>
    apply Iff.intro
    case mp =>
      intro h i _ A
      let ⟨a, al, ar⟩ : ∃ a, a ∈ l ∧ a ∈ r := by
        unfold Cal at h
        exact Common.mem h
      have ml : ♩a ∈ l.map (♩·) := Mem.map (♩·) al
      have Va : Val i (♩a) := Iff.mp (All.mem (Val i) (l.map (♩·))) A (♩a) ml
      have mr : ♩a ∈ r.map (♩·) := Mem.map (♩·) ar
      apply Iff.mpr (Any.mem (Val i) _) ⟨♩a, ⟨Va, mr⟩⟩
    case mpr =>
      intro h
      let i a := a ∈ l
      have dec : DecidablePred i := inferInstance
      have h' : All (Val i) (l.map (♩·)) → Any (Val i) (r.map (♩·)) := h i dec
      have All_l : All (Val i) (l.map (♩·)) := Iff.mpr (All.map (Val i) (♩·) l) (All.in_self l)
      have Any_r : Any (Val (· ∈ l)) (r.map (♩·)) := h' All_l
      have Any_r' : Any (fun n => Val (· ∈ l) (♩n)) r := Iff.mp (Any.map (Val i) (♩·) r) Any_r
      unfold Cal
      apply Common.sym Any_r'
  | ⊥ :: Γ, [] =>
    simp
  | Γ, ⊥ :: Δ =>
    have ih : Cal l r Γ Δ ↔ ∀ i, DecidablePred i → SC' i l r Γ Δ :=
      Cal_sound_complete l r Γ Δ
    aesop
  | ♩n :: Γ, [] =>
    have ih : Cal (n :: l) r Γ [] ↔ ∀ i, DecidablePred i → SC' i (n :: l) r Γ [] :=
      Cal_sound_complete (n :: l) r Γ []
    have perm : (Γ ++ ♩n :: l.map (♩·)) ↭ (♩n :: Γ ++ l.map (♩·)) := Perm.shift (♩n) Γ _
    apply Iff.intro
    case mp =>
      intro h i dec
      unfold Cal at h
      have ihr : SC' i (n :: l) r Γ [] := Iff.mp ih h i dec
      apply SC.all (Perm.sym perm) ihr
    case mpr =>
      intro h
      have hSC : ∀ i, DecidablePred i → SC' i (n :: l) r Γ [] := by
        intro i dec
        apply SC.all perm (h i dec)
      unfold Cal
      apply Iff.mpr ih hSC
  | Γ, ♩n :: Δ =>
    have ih : Cal l (n :: r) Γ Δ ↔ ∀ i, DecidablePred i → SC' i l (n :: r) Γ Δ :=
      Cal_sound_complete l (n :: r) Γ Δ
    have perm : (Δ ++ ♩n :: r.map (♩·)) ↭ (♩n :: Δ ++ r.map (♩·)) := Perm.shift (♩n) Δ _
    apply Iff.intro
    case mp =>
      intro h i dec
      simp at h
      have ihr : SC' i l (n :: r) Γ Δ := Iff.mp ih h i dec
      apply SC.any perm ihr
    case mpr =>
      intro h
      have hSC : ∀ i, DecidablePred i → SC' i l (n :: r) Γ Δ := by
        intro i dec
        apply SC.any (Perm.sym perm) (h i dec)
      simp [Iff.mpr ih hSC]
  | φ ⇒ ψ :: Γ, [] =>
    have ih₁ : Cal l r Γ [φ] ↔ ∀ i, DecidablePred i → SC' i l r Γ [φ] :=
      Cal_sound_complete l r Γ [φ]
    have ih₂ : Cal l r (ψ :: Γ) [] ↔ ∀ i, DecidablePred i → SC' i l r (ψ :: Γ) [] :=
      Cal_sound_complete l r (ψ :: Γ) []
    apply Iff.intro
    case mp =>
      intro h i dec
      simp at h
      have ih₁' : SC' i l r Γ [φ] := Iff.mp ih₁ h.left i dec
      cases (Val.instDecidable i φ) <;> simp_all
    case mpr =>
      intro h
      simp
      apply And.intro
      case left =>
        apply Iff.mpr ih₁
        intro i dec
        cases (Val.instDecidable i φ) <;> simp_all
      case right =>
        apply Iff.mpr ih₂
        intro i dec
        cases (Val.instDecidable i φ) <;> simp_all
  | Γ, φ ⇒ ψ :: Δ =>
    have ih : Cal l r (φ :: Γ) (ψ :: Δ) ↔ ∀ i, DecidablePred i →
      SC' i l r (φ :: Γ) (ψ :: Δ) :=
      Cal_sound_complete l r (φ :: Γ) (ψ :: Δ)
    apply Iff.intro
    case mp =>
      intro h i dec
      cases (Val.instDecidable i φ) <;> simp_all
    case mpr =>
      intro h
      simp
      apply Iff.mpr ih
      intro i dec
      cases (Val.instDecidable i φ)
      case isFalse no =>
        simp_all
      case isTrue yes =>
        intro AllφΓ
        have AllΓ : All (Val i) (Γ ++ l.map (♩·)) := by simp_all
        have AnyφψΔ : Any (Val i) (φ ⇒ ψ :: Δ ++ r.map (♩·)) := h i dec AllΓ
        simp_all
termination_by sum (Γ.map sizeOf) + sum (Δ.map sizeOf)
decreasing_by all_goals simp_wf <;> simp +arith

theorem Prove_sound_complete [DecidableEq Φ] (φ : Form Φ)
  : Prove φ ↔ Valid φ := by
  have h : Prove φ ↔ ∀ i : Φ → Prop, DecidablePred i → SC' i [] [] [] [φ]  :=
    Cal_sound_complete [] [] [] [φ]
  apply Iff.intro
  case mp =>
    intro Pφ i dec
    have h' : Any (Val i) (φ :: [].map (♩·)) := Iff.mp h Pφ i dec All.nil
    aesop
  case mpr =>
    aesop (add simp Valid)


--- Proof System

inductive Proof : (Γ Δ : List (Form Φ)) → Prop
  | basic Γ Δ n : Proof (♩n :: Γ) (♩n :: Δ)
  | fls_l Γ Δ : Proof (⊥ :: Γ) Δ
  | imp_l Γ Δ φ ψ : Proof Γ (φ :: Δ) → Proof (ψ :: Γ) Δ → Proof (φ ⇒ ψ :: Γ) Δ
  | imp_r Γ Δ φ ψ: Proof (φ :: Γ) (ψ :: Δ) → Proof Γ (φ ⇒ ψ :: Δ)
  | per_l Γ Γ' Δ : Proof Γ Δ → Γ' ↭ Γ → Proof Γ' Δ
  | per_r Γ Δ Δ' : Proof Γ Δ → Δ ↭ Δ' → Proof Γ Δ'

attribute [aesop safe apply] Proof.basic Proof.fls_l
attribute [aesop unsafe 50% apply] Proof.imp_l Proof.imp_r
attribute [aesop unsafe 20% apply] Proof.per_l Proof.per_r

namespace Proof

theorem weaken (Γ Δ : List (Form Φ)) (prf : Proof Γ Δ) (δ : Form Φ)
  : Proof Γ (δ :: Δ) := by
  induction prf with
  | imp_r Γ Δ φ ψ =>
    have ih' : Proof (φ :: Γ) (ψ :: δ :: Δ) := by aesop
    aesop
  | _ => aesop (config := { maxRuleApplications := 250 })


--- Soundness

theorem sound (i : Φ → Prop) [DecidablePred i] (prf : Proof Γ Δ) : SC i Γ Δ := by
  induction prf with
  | imp_r Γ Δ φ ψ _ ih =>
    have d : Decidable (Val i φ) := inferInstance
    aesop
  | _ => aesop (add unsafe apply [Perm.all, Perm.any])

end Proof

@[simp]
def Proof' (l r : List Φ) (Γ Δ : List (Form Φ)) : Prop :=
  Proof (Γ ++ l.map (♩·)) (Δ ++ r.map (♩·))

theorem Cal_Proof [DecidableEq Φ]
  (l r : List Φ) (Γ Δ : List (Form Φ)) (h : Cal l r Γ Δ)
  : Proof' l r Γ Δ := by
  match Γ, Δ with
  | [], [] =>
    let ⟨a, al, ar⟩ : ∃ a, a ∈ l ∧ a ∈ r := by
      unfold Cal at h
      exact Common.mem h
    let ⟨ll, lr, leq⟩ : ∃ ll lr, l = ll ++ a :: lr := Mem.split al
    let ⟨rl, rr, req⟩ : ∃ rl rr, r = rl ++ a :: rr := Mem.split ar
    rw [leq, req]
    have p : Proof' (a :: ll ++ lr) (a :: rl ++ rr) [] [] := by apply Proof.basic
    have p' : Proof' (ll ++ a :: lr) (a :: rl ++ rr) [] [] := by
      aesop (add unsafe apply [Perm.map, Perm.shift])
    aesop (add unsafe apply [Perm.map, Perm.shift, Perm.sym])
  | ⊥ :: Γ, [] =>
    aesop
  | Γ, ⊥ :: Δ =>
    simp at h
    have ih : Proof' l r Γ Δ := Cal_Proof l r Γ Δ h
    apply Proof.weaken _ _ ih ⊥
  | ♩n :: Γ, [] =>
    unfold Cal at h
    have ih : Proof' (n :: l) r Γ [] := Cal_Proof (n :: l) r Γ [] h
    apply Proof.per_l _ _ _ ih
    aesop (add unsafe apply [Perm.shift, Perm.sym])
  | Γ, ♩n :: Δ =>
    simp at h
    have ih : Proof' l (n :: r) Γ Δ := Cal_Proof l (n :: r) Γ Δ h
    aesop (add unsafe apply [Perm.shift])
  | φ ⇒ ψ :: Γ, [] =>
    simp at h
    have ih₁ : Proof' l r Γ [φ] := Cal_Proof l r Γ [φ] h.left
    have ih₂ : Proof' l r (ψ :: Γ) [] := Cal_Proof l r (ψ :: Γ) [] h.right
    aesop
  | Γ, φ ⇒ ψ :: Δ =>
    simp at h
    have ih : Proof' l r (φ :: Γ) (ψ :: Δ) := Cal_Proof l r (φ :: Γ) (ψ :: Δ) h
    aesop
termination_by sum (Γ.map sizeOf) + sum (Δ.map sizeOf)
decreasing_by all_goals simp_wf <;> simp +arith

theorem Proof_sound_complete [DecidableEq Φ] (φ : Form Φ)
  : Proof [] [φ] ↔ Valid φ := by
  apply Iff.intro
  case mp =>
    intro prf i dec
    have h : Any (Val i) [φ] := Proof.sound i prf All.nil
    aesop
  case mpr =>
    intro h
    have c : Prove φ := Iff.mpr (Prove_sound_complete φ) h
    have prf : Proof' [] [] [] [φ] := Cal_Proof [] [] [] [φ] c
    exact prf



=== LEAN SOURCE: SimpLetHypotheses.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

-- Aesop `simp` substitutes `let` hypotheses even when `zetaDelta` is disabled
-- (which is the default).

/--
error: unsolved goals
P : Nat → Type
h : P 0
x : Nat := 0
⊢ P 0
-/
#guard_msgs in
example (P : Nat → Type) (h : P 0) : let x := 0; P x := by
  intro x
  aesop (rule_sets := [-builtin,-default])
    (config := { warnOnNonterminal := false })

/--
error: unsolved goals
P : Nat → Type
h : P 0
x : Nat := 0
⊢ P 0
-/
#guard_msgs in
example (P : Nat → Type) (h : P 0) : let x := 0; P x := by
  intro x
  aesop (rule_sets := [-builtin,-default])
    (config := { useSimpAll := false, warnOnNonterminal := false })



=== LEAN SOURCE: Simprocs.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

open Lean Lean.Meta

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

def unfoldConst («from» to : Name) : Simp.Simproc := λ e =>
  if e.isConstOf «from» then
    return .done { expr := .const to [] }
  else
    return .continue

@[irreducible] def T₁ := True

/--
error: tactic 'aesop' failed, made no progress
-/
#guard_msgs in
example : T₁ := by
  aesop

simproc unfoldT₁ (T₁) := unfoldConst ``T₁ ``True

example : T₁ := by
  aesop

/--
error: tactic 'aesop' failed, made no progress
-/
#guard_msgs in
example : T₁ := by
  aesop (config := { useDefaultSimpSet := false })

@[irreducible] def T₂ := True

/--
error: tactic 'aesop' failed, made no progress
-/
#guard_msgs in
example : T₂ := by
  aesop

simproc [aesop_builtin] unfoldT₂ (T₂) := unfoldConst ``T₂ ``True

/--
error: tactic 'aesop' failed, made no progress
-/
#guard_msgs in
example : T₂ := by
  aesop (rule_sets := [-builtin])

example : T₂ := by
  aesop



=== LEAN SOURCE: Split.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

-- Tests the builtin split rules.

@[aesop norm unfold]
def id' (n : Nat) : Nat :=
  match n with
  | .zero => .zero
  | .succ n => .succ n


-- First, the rule for splitting targets.
example : id' n = n := by
  aesop

-- Second, the rule for splitting hypotheses. We introduce a custom equality to
-- make sure that in the following example, Aesop doesn't just substitute the
-- hypothesis during norm simp.
inductive MyEq (x : α) : α → Prop
  | rfl : MyEq x x

@[aesop unsafe]
def MyEq.elim : MyEq x y → x = y
  | rfl => by rfl

example (h : MyEq n (id' m)) : n = m := by
  aesop



=== LEAN SOURCE: SplitScript.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

open Classical

inductive MyFalse : Prop

/--
info: Try this:
  split
  next h => sorry
  next h => sorry
---
warning: declaration uses 'sorry'
-/
#guard_msgs in
example {A B : Prop} : if P then A else B := by
  aesop? (config := { warnOnNonterminal := false })
  all_goals sorry

/--
info: Try this:
  split at h
  next h_1 => simp_all only [true_or]
  next h_1 => simp_all only [or_true]
-/
#guard_msgs in
example (h : if P then A else B) : A ∨ B := by
  aesop?

/--
info: Try this:
  split at h
  next n => simp_all only [true_or]
  next n => simp_all only [true_or, or_true]
  next n_1 x x_1 => simp_all only [imp_false, or_true]
-/
#guard_msgs in
theorem foo (n : Nat) (h : match n with | 0 => A | 1 => B | _ => C) :
    A ∨ B ∨ C := by
  set_option aesop.check.rules false in -- TODO simp introduces mvar
  set_option aesop.check.tree false in
  aesop?



=== LEAN SOURCE: Stats.lean ===
/-
Copyright (c) 2025 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

/-
Regression test for a bug involving the stats extension and async elaboration.
The commands below should not panic and should show non-zero stats.
-/

set_option aesop.collectStats true
set_option trace.aesop.stats true

#guard_msgs (drop trace) in
theorem mem_spec {o : Option α} : a ∈ o ↔ o = some a := by
  aesop (add norm simp Membership.mem)

#guard_msgs (drop info) in
#aesop_stats



=== LEAN SOURCE: Strategy.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

@[aesop 50% constructors]
inductive I₁
  | ofI₁ : I₁ → I₁
  | ofTrue : True → I₁

example : I₁ := by
  aesop

example : I₁ := by
  aesop (config := { strategy := .bestFirst })

example : I₁ := by
  aesop (config := { strategy := .breadthFirst })

/--
error: tactic 'aesop' failed, maximum number of rule applications (10) reached. Set the 'maxRuleApplications' option to increase the limit.
-/
#guard_msgs in
example : I₁ := by
  aesop (config :=
    { strategy := .depthFirst
      maxRuleApplicationDepth := 0
      maxRuleApplications := 10,
      terminal := true })

example : I₁ := by
  aesop (config := { strategy := .depthFirst, maxRuleApplicationDepth := 10 })



=== LEAN SOURCE: Subst.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

-- These test cases test the builtin subst tactic.

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example (h₁ : x = 5) (h₂ : y = 5) : x = y := by
  aesop (erase Aesop.BuiltinRules.subst)
    (config := { useSimpAll := false, terminal := true })

example (h₁ : x = 5) (h₂ : y = 5) : x = y := by
  aesop (config := { useSimpAll := false })

variable {α : Type}

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example {x y z : α} (h₁ : x = y) (h₂ : y = z) : x = z := by
  aesop (erase Aesop.BuiltinRules.subst)
    (config := { useSimpAll := false, terminal := true })

example {x y z : α} (h₁ : x = y) (h₂ : y = z) : x = z := by
  aesop (config := { useSimpAll := false })

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example {x y : α }(P : ∀ x y, x = y → Prop) (h₁ : x = y) (h₂ : P x y h₁) :
    x = y := by
  aesop
    (erase Aesop.BuiltinRules.subst, Aesop.BuiltinRules.assumption,
           Aesop.BuiltinRules.applyHyps)
    (config := { useSimpAll := false, terminal := true })

example {x y : α }(P : ∀ x y, x = y → Prop) (h₁ : x = y) (h₂ : P x y h₁) :
    x = y := by
  aesop
    (erase Aesop.BuiltinRules.assumption,
           Aesop.BuiltinRules.applyHyps)
    (config := { useSimpAll := false })

-- Subst also works for bi-implications.

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example (h₁ : P ↔ Q) (h₂ : Q ↔ R) (h₃ : P) : R  := by
  aesop (erase Aesop.BuiltinRules.subst)
    (config := { useSimpAll := false, terminal := true })

example (h₁ : P ↔ Q) (h₂ : Q ↔ R) (h₃ : P) : R  := by
  aesop (config := { useSimpAll := false })

-- Subst also works for morally-homogeneous heterogeneous equalities (using a
-- builtin simp rule which turns these into actual homogeneous equalities).

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example {P : α → Prop} {x y z : α} (h₁ : x ≍ y) (h₂ : y ≍ z) (h₃ : P x) :
    P z  := by
  aesop (erase Aesop.BuiltinRules.subst)
    (config := { useSimpAll := false, terminal := true })

example {P : α → Prop} {x y z : α} (h₁ : x ≍ y) (h₂ : y ≍ z) (h₃ : P x) :
    P z  := by
  aesop (config := { useSimpAll := false })



=== LEAN SOURCE: TacGen.lean ===
import Aesop

open Lean
open Lean.Meta

theorem foo (a b c : Nat) : a + b + c = c + b + a := by
  rw [Nat.add_assoc, Nat.add_comm, Nat.add_comm b]

@[aesop 100%]
def tacGen₁ : Aesop.TacGen := λ _ => do
 return #[("apply foo", 1.0)]

example (a b c : Nat) : a + b + c = c + b + a := by
  aesop

@[aesop 100%]
def tacGen₂ : Aesop.TacGen := λ _ =>
  return #[
    ("rw [Nat.add_comm b]", 0.5),
    ("rw [Nat.add_assoc]", 0.9),
    ("rw [Nat.add_comm]", 0.8)
  ]

example (a b c : Nat) : a + b + c = c + b + a := by
  aesop (erase tacGen₁)



=== LEAN SOURCE: TacticConfig.lean ===
/-
Copyright (c) 2021 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

inductive Even : Nat → Prop
| zero : Even 0
| plus_two {n} : Even n → Even (n + 2)

inductive Odd : Nat → Prop
| one : Odd 1
| plus_two {n} : Odd n → Odd (n + 2)

inductive EvenOrOdd : Nat → Prop
| even {n} : Even n → EvenOrOdd n
| odd {n} : Odd n → EvenOrOdd n

-- We can add constants as rules.
example : EvenOrOdd 3 := by
  aesop
    (add safe [Even.zero, Even.plus_two, Odd.one, Odd.plus_two],
         unsafe [apply 50% EvenOrOdd.even, 50% EvenOrOdd.odd])

-- Same with local hypotheses, or a mix.
example : EvenOrOdd 3 := by
  have h : ∀ n, Odd n → EvenOrOdd n := λ _ p => EvenOrOdd.odd p
  aesop
    (add safe [Odd.one, Odd.plus_two], unsafe [EvenOrOdd.even 50%, h 50%])
    (erase Aesop.BuiltinRules.applyHyps) -- This rule subsumes h.

attribute [aesop 50%] Even.zero Even.plus_two

-- We can also erase global rules...

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : EvenOrOdd 2 := by
  aesop (add safe EvenOrOdd.even) (erase Even.zero)
    (config := { terminal := true })

example : EvenOrOdd 2 := by
  aesop (add safe EvenOrOdd.even)

-- ... as well as local ones (but what for?).


/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
-/
#guard_msgs in
example : EvenOrOdd 2 := by
  have h : ∀ n, Even n → EvenOrOdd n := λ _ p => EvenOrOdd.even p
  aesop (add safe h) (erase Aesop.BuiltinRules.applyHyps, h)
    (config := { terminal := true })

example : EvenOrOdd 2 := by
  have h : ∀ n, Even n → EvenOrOdd n := λ _ p => EvenOrOdd.even p
  aesop (add safe h) (erase Aesop.BuiltinRules.applyHyps)



=== LEAN SOURCE: Tauto.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Renshaw, Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

-- This is an example which is currently challenging for Lean 4 `tauto`.
example {α : Type} [LE α] (a b c : α) (x₀ x₁ x₂ : Prop)
 (this1 : x₀ → x₁ → a ≤ c)
 (this2 : x₁ → x₂ → b ≤ a)
 (this3 : x₂ → x₀ → c ≤ b) :
    ((x₀ ∧ ¬b ≤ a) ∧ x₁ ∧ ¬c ≤ b ∨
         (x₁ ∧ ¬c ≤ b) ∧ x₂ ∧ ¬a ≤ c ∨ (x₂ ∧ ¬a ≤ c) ∧ x₀ ∧ ¬b ≤ a ↔
       (x₀ ∧ x₁ ∨ x₁ ∧ x₂ ∨ x₂ ∧ x₀) ∧
         ¬(c ≤ b ∧ b ≤ a ∨ b ≤ a ∧ a ≤ c ∨ a ≤ c ∧ c ≤ b)) :=
by aesop



=== LEAN SOURCE: TerminalError.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

/--
error: tactic 'aesop' failed, failed to prove the goal after exhaustive search.
Initial goal:
  ⊢ False
Remaining goals after safe rules:
  ⊢ False
-/
#guard_msgs in
example : False := by
  aesop (config := { terminal := true })



=== LEAN SOURCE: TraceProof.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true
set_option aesop.smallErrorMessages true

set_option trace.aesop.proof true

/--
error: tactic 'aesop' failed, made no progress
---
trace: [aesop.proof] <no proof>
-/
#guard_msgs in
example : α := by
  aesop

@[aesop norm simp]
def F := False

set_option pp.mvars false in
/--
warning: aesop: failed to prove the goal after exhaustive search.
---
error: unsolved goals
⊢ False
---
trace: [aesop.proof] id ?_
-/
#guard_msgs in
example : F := by
  aesop



=== LEAN SOURCE: TryThisIndentation.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

/--
info: Try this:
  intro a_1 a_2
  simp_all only [ne_eq, List.mem_cons, or_self, not_false_eq_true]
-/
#guard_msgs in
example {a y : α} {l : List α} : a ≠ y → a ∉ l → a ∉ y::l := by
  aesop?

/--
info: Try this:
simp_all only [ne_eq, List.mem_cons, or_self, not_false_eq_true]
-/
#guard_msgs in
example {a y : α} {l : List α} : a ≠ y → a ∉ l → a ∉ y::l := by
  intros
  have : ¬ a ∈ y :: l := by
    aesop?
  exact this



=== LEAN SOURCE: Unfold.lean ===
/-
Copyright (c) 2023 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

-- Inspired by this Zulip discussion:
-- https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Goal.20state.20not.20updating.2C.20bugs.2C.20etc.2E/near/338356062

import Aesop

set_option aesop.check.all true

structure WalkingPair

def WidePullbackShape A B := Sum A B

abbrev WalkingCospan : Type := WidePullbackShape Empty Empty

@[aesop norm destruct]
def WalkingCospan_elim : WalkingCospan → Sum Empty Empty := id

/--
info: Try this:
  unfold WalkingCospan at h
  unfold WidePullbackShape at h
  cases h with
  | inl val =>
    have fwd : False := Aesop.BuiltinRules.empty_false val
    simp_all only
  | inr val_1 =>
    have fwd : False := Aesop.BuiltinRules.empty_false val_1
    simp_all only
-/
#guard_msgs in
example (h : WalkingCospan) : α := by
  aesop? (add norm unfold [WidePullbackShape, WalkingCospan])

example (h : WalkingCospan) : α := by
  aesop (add norm simp [WidePullbackShape, WalkingCospan])

@[aesop norm unfold]
def Foo := True

@[aesop norm unfold]
def Bar := False

/--
info: Try this:
  unfold Bar Foo
  unfold Foo at h₁
  unfold Foo Bar at h₂
  simp_all only
  cases h₂ with
  | inl val =>
    simp_all only
    apply PSum.inr
    simp_all only
  | inr val_1 => simp_all only
-/
#guard_msgs in
example (h₁ : Foo) (h₂ : PSum Foo Bar) : PSum Bar Foo := by
  aesop?



=== LEAN SOURCE: UnreachableTacticLinter.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

add_aesop_rules safe (by simp)



=== LEAN SOURCE: WarnApplyIff.lean ===
/-
Copyright (c) 2024 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop

set_option aesop.check.all true

/--
warning: Apply builder was used for a theorem with conclusion A ↔ B.
You probably want to use the simp builder or create an alias that applies the theorem in one direction.
Use `set_option aesop.warn.applyIff false` to disable this warning.
-/
#guard_msgs in
@[aesop safe apply]
axiom foo : True ↔ True

@[aesop simp]
axiom bar : True ↔ True

set_option aesop.warn.applyIff false in
@[aesop 1% apply]
axiom baz : True ↔ True



=== LEAN SOURCE: Batteries.lean ===
import Batteries.Classes.Cast
import Batteries.Classes.Deprecated
import Batteries.Classes.Order
import Batteries.Classes.RatCast
import Batteries.Classes.SatisfiesM
import Batteries.CodeAction
import Batteries.CodeAction.Attr
import Batteries.CodeAction.Basic
import Batteries.CodeAction.Deprecated
import Batteries.CodeAction.Match
import Batteries.CodeAction.Misc
import Batteries.Control.AlternativeMonad
import Batteries.Control.ForInStep
import Batteries.Control.ForInStep.Basic
import Batteries.Control.ForInStep.Lemmas
import Batteries.Control.LawfulMonadState
import Batteries.Control.Lemmas
import Batteries.Control.Monad
import Batteries.Control.Nondet.Basic
import Batteries.Control.OptionT
import Batteries.Data.Array
import Batteries.Data.AssocList
import Batteries.Data.BinaryHeap
import Batteries.Data.BinomialHeap
import Batteries.Data.BitVec
import Batteries.Data.ByteArray
import Batteries.Data.ByteSubarray
import Batteries.Data.Char
import Batteries.Data.DList
import Batteries.Data.Fin
import Batteries.Data.FloatArray
import Batteries.Data.HashMap
import Batteries.Data.Int
import Batteries.Data.List
import Batteries.Data.MLList
import Batteries.Data.NameSet
import Batteries.Data.Nat
import Batteries.Data.PairingHeap
import Batteries.Data.RBMap
import Batteries.Data.Random
import Batteries.Data.Range
import Batteries.Data.Rat
import Batteries.Data.Stream
import Batteries.Data.String
import Batteries.Data.UInt
import Batteries.Data.UnionFind
import Batteries.Data.Vector
import Batteries.Lean.AttributeExtra
import Batteries.Lean.EStateM
import Batteries.Lean.Except
import Batteries.Lean.Expr
import Batteries.Lean.Float
import Batteries.Lean.HashMap
import Batteries.Lean.HashSet
import Batteries.Lean.IO.Process
import Batteries.Lean.Json
import Batteries.Lean.LawfulMonad
import Batteries.Lean.LawfulMonadLift
import Batteries.Lean.Meta.Basic
import Batteries.Lean.Meta.DiscrTree
import Batteries.Lean.Meta.Expr
import Batteries.Lean.Meta.Inaccessible
import Batteries.Lean.Meta.InstantiateMVars
import Batteries.Lean.Meta.SavedState
import Batteries.Lean.Meta.Simp
import Batteries.Lean.Meta.UnusedNames
import Batteries.Lean.MonadBacktrack
import Batteries.Lean.NameMapAttribute
import Batteries.Lean.PersistentHashMap
import Batteries.Lean.PersistentHashSet
import Batteries.Lean.Position
import Batteries.Lean.SatisfiesM
import Batteries.Lean.Syntax
import Batteries.Lean.System.IO
import Batteries.Lean.TagAttribute
import Batteries.Lean.Util.EnvSearch
import Batteries.Linter
import Batteries.Linter.UnnecessarySeqFocus
import Batteries.Linter.UnreachableTactic
import Batteries.Logic
import Batteries.Tactic.Alias
import Batteries.Tactic.Basic
import Batteries.Tactic.Case
import Batteries.Tactic.Congr
import Batteries.Tactic.Exact
import Batteries.Tactic.HelpCmd
import Batteries.Tactic.Init
import Batteries.Tactic.Instances
import Batteries.Tactic.Lemma
import Batteries.Tactic.Lint
import Batteries.Tactic.Lint.Basic
import Batteries.Tactic.Lint.Frontend
import Batteries.Tactic.Lint.Misc
import Batteries.Tactic.Lint.Simp
import Batteries.Tactic.Lint.TypeClass
import Batteries.Tactic.NoMatch
import Batteries.Tactic.OpenPrivate
import Batteries.Tactic.PermuteGoals
import Batteries.Tactic.PrintDependents
import Batteries.Tactic.PrintOpaques
import Batteries.Tactic.PrintPrefix
import Batteries.Tactic.SeqFocus
import Batteries.Tactic.ShowUnused
import Batteries.Tactic.SqueezeScope
import Batteries.Tactic.Trans
import Batteries.Tactic.Unreachable
import Batteries.Util.Cache
import Batteries.Util.ExtendedBinder
import Batteries.Util.LibraryNote
import Batteries.Util.Panic
import Batteries.Util.Pickle
import Batteries.Util.ProofWanted
import Batteries.WF



=== LEAN SOURCE: CodeAction.lean ===
import Batteries.CodeAction.Attr
import Batteries.CodeAction.Basic
import Batteries.CodeAction.Misc
import Batteries.CodeAction.Match



=== LEAN SOURCE: Linter.lean ===
import Batteries.Linter.UnreachableTactic
import Batteries.Linter.UnnecessarySeqFocus



=== LEAN SOURCE: Logic.lean ===
/-
Copyright (c) 2014 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Leonardo de Moura, Jeremy Avigad, Floris van Doorn, Mario Carneiro
-/
import Batteries.Tactic.Alias

instance {f : α → β} [DecidablePred p] : DecidablePred (p ∘ f) :=
  inferInstanceAs <| DecidablePred fun x => p (f x)

/-! ## id -/

theorem Function.id_def : @id α = fun x => x := rfl

/-! ## decidable -/

protected alias ⟨Decidable.exists_not_of_not_forall, _⟩ := Decidable.not_forall

/-! ## classical logic -/

namespace Classical

alias ⟨exists_not_of_not_forall, _⟩ := not_forall

end Classical

/-! ## equality -/

theorem heq_iff_eq {a b : α} : a ≍ b ↔ a = b := ⟨eq_of_heq, heq_of_eq⟩

@[simp] theorem eq_rec_constant {α : Sort _} {a a' : α} {β : Sort _} (y : β) (h : a = a') :
    (@Eq.rec α a (fun _ _ => β) y a' h) = y := by cases h; rfl

theorem congrArg₂ (f : α → β → γ) {x x' : α} {y y' : β}
    (hx : x = x') (hy : y = y') : f x y = f x' y' := by subst hx hy; rfl

theorem congrFun₂ {β : α → Sort _} {γ : ∀ a, β a → Sort _}
    {f g : ∀ a b, γ a b} (h : f = g) (a : α) (b : β a) :
    f a b = g a b :=
  congrFun (congrFun h _) _

theorem congrFun₃ {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _}
      {f g : ∀ a b c, δ a b c} (h : f = g) (a : α) (b : β a) (c : γ a b) :
    f a b c = g a b c :=
  congrFun₂ (congrFun h _) _ _

theorem funext₂ {β : α → Sort _} {γ : ∀ a, β a → Sort _}
    {f g : ∀ a b, γ a b} (h : ∀ a b, f a b = g a b) : f = g :=
  funext fun _ => funext <| h _

theorem funext₃ {β : α → Sort _} {γ : ∀ a, β a → Sort _} {δ : ∀ a b, γ a b → Sort _}
    {f g : ∀ a b c, δ a b c} (h : ∀ a b c, f a b c = g a b c) : f = g :=
  funext fun _ => funext₂ <| h _

protected theorem Eq.congr (h₁ : x₁ = y₁) (h₂ : x₂ = y₂) : x₁ = x₂ ↔ y₁ = y₂ := by
  subst h₁; subst h₂; rfl

theorem Eq.congr_left {x y z : α} (h : x = y) : x = z ↔ y = z := by rw [h]

theorem Eq.congr_right {x y z : α} (h : x = y) : z = x ↔ z = y := by rw [h]

alias congr_arg := congrArg
alias congr_arg₂ := congrArg₂
alias congr_fun := congrFun
alias congr_fun₂ := congrFun₂
alias congr_fun₃ := congrFun₃

theorem heq_of_cast_eq : ∀ (e : α = β) (_ : cast e a = a'), a ≍ a'
  | rfl, rfl => .rfl

theorem cast_eq_iff_heq : cast e a = a' ↔ a ≍ a' :=
  ⟨heq_of_cast_eq _, fun h => by cases h; rfl⟩

theorem eqRec_eq_cast {α : Sort _} {a : α} {motive : (a' : α) → a = a' → Sort _}
    (x : motive a rfl) {a' : α} (e : a = a') :
    @Eq.rec α a motive x a' e = cast (e ▸ rfl) x := by
  subst e; rfl

--Porting note: new theorem. More general version of `eqRec_heq`
theorem eqRec_heq_self {α : Sort _} {a : α} {motive : (a' : α) → a = a' → Sort _}
    (x : motive a rfl) {a' : α} (e : a = a') : @Eq.rec α a motive x a' e ≍ x := by
  subst e; rfl

@[simp]
theorem eqRec_heq_iff_heq {α : Sort _} {a : α} {motive : (a' : α) → a = a' → Sort _}
    {x : motive a rfl} {a' : α} {e : a = a'} {β : Sort _} {y : β} :
    @Eq.rec α a motive x a' e ≍ y ↔ x ≍ y := by
  subst e; rfl

@[simp]
theorem heq_eqRec_iff_heq {α : Sort _} {a : α} {motive : (a' : α) → a = a' → Sort _}
    {x : motive a rfl} {a' : α} {e : a = a'} {β : Sort _} {y : β} :
    y ≍ @Eq.rec α a motive x a' e ↔ y ≍ x := by
  subst e; rfl

/-! ## miscellaneous -/

@[simp] theorem not_nonempty_empty  : ¬Nonempty Empty := fun ⟨h⟩ => h.elim
@[simp] theorem not_nonempty_pempty : ¬Nonempty PEmpty := fun ⟨h⟩ => h.elim

-- TODO(Mario): profile first, this is a dangerous instance
-- instance (priority := 10) {α} [Subsingleton α] : DecidableEq α
--   | a, b => isTrue (Subsingleton.elim a b)

-- TODO(Mario): profile adding `@[simp]` to `eq_iff_true_of_subsingleton`

/-- If all points are equal to a given point `x`, then `α` is a subsingleton. -/
theorem subsingleton_of_forall_eq (x : α) (h : ∀ y, y = x) : Subsingleton α :=
  ⟨fun a b => h a ▸ h b ▸ rfl⟩

theorem subsingleton_iff_forall_eq (x : α) : Subsingleton α ↔ ∀ y, y = x :=
  ⟨fun _ y => Subsingleton.elim y x, subsingleton_of_forall_eq x⟩

theorem congr_eqRec {β : α → Sort _} (f : (x : α) → β x → γ) (h : x = x') (y : β x) :
  f x' (Eq.rec y h) = f x y := by cases h; rfl



=== LEAN SOURCE: WF.lean ===
/-
Copyright (c) 2023 Miyahara Kō. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Miyahara Kō
-/

/-!
# Computable Acc.rec and WellFounded.fix

This file exports no public definitions / theorems, but by importing it the compiler will
be able to compile `Acc.rec` and functions that use it. For example:

Before:
```
-- failed to compile definition, consider marking it as 'noncomputable'
-- because it depends on 'WellFounded.fix', and it does not have executable code
def log2p1 : Nat → Nat :=
  WellFounded.fix Nat.lt_wfRel.2 fun n IH =>
    let m := n / 2
    if h : m < n then
      IH m h + 1
    else
      0
```

After:
```
import Batteries.WF

def log2p1 : Nat → Nat := -- works!
  WellFounded.fix Nat.lt_wfRel.2 fun n IH =>
    let m := n / 2
    if h : m < n then
      IH m h + 1
    else
      0

#eval log2p1 4   -- 3
```
-/

namespace Acc

instance wfRel {r : α → α → Prop} : WellFoundedRelation { val // Acc r val } where
  rel := InvImage r (·.1)
  wf  := ⟨fun ac => InvImage.accessible _ ac.2⟩

/-- A computable version of `Acc.rec`. Workaround until Lean has native support for this. -/
@[specialize, elab_as_elim, semireducible] private def recC {motive : (a : α) → Acc r a → Sort v}
    (intro : (x : α) → (h : ∀ (y : α), r y x → Acc r y) →
     ((y : α) → (hr : r y x) → motive y (h y hr)) → motive x (intro x h))
    {a : α} (t : Acc r a) : motive a t :=
  intro a (fun _ h => t.inv h) (fun _ hr => recC intro (t.inv hr))
termination_by Subtype.mk a t

private theorem recC_intro {motive : (a : α) → Acc r a → Sort v}
    (intro : (x : α) → (h : ∀ (y : α), r y x → Acc r y) →
     ((y : α) → (hr : r y x) → motive y (h y hr)) → motive x (intro x h))
    {a : α} (h : ∀ (y : α), r y a → Acc r y) :
    recC intro (Acc.intro _ h) = intro a h (fun y hr => recC intro (h y hr)) :=
  rfl

@[csimp] private theorem rec_eq_recC : @Acc.rec = @Acc.recC := by
  funext α r motive intro a t
  induction t with
  | intro x h ih =>
    dsimp only [recC_intro intro h]
    congr; funext y hr; exact ih _ hr

/-- A computable version of `Acc.ndrec`. Workaround until Lean has native support for this. -/
@[inline] private abbrev ndrecC {C : α → Sort v}
    (m : (x : α) → ((y : α) → r y x → Acc r y) → ((y : α) → (a : r y x) → C y) → C x)
    {a : α} (n : Acc r a) : C a :=
  n.recC m

@[csimp] private theorem ndrec_eq_ndrecC : @Acc.ndrec = @Acc.ndrecC := by
  funext α r motive intro a t
  rw [Acc.ndrec, rec_eq_recC, Acc.ndrecC]

/-- A computable version of `Acc.ndrecOn`. Workaround until Lean has native support for this. -/
@[inline] private abbrev ndrecOnC {C : α → Sort v} {a : α} (n : Acc r a)
    (m : (x : α) → ((y : α) → r y x → Acc r y) → ((y : α) → r y x → C y) → C x) : C a :=
  n.recC m

@[csimp] private theorem ndrecOn_eq_ndrecOnC : @Acc.ndrecOn = @Acc.ndrecOnC := by
  funext α r motive intro a t
  rw [Acc.ndrecOn, rec_eq_recC, Acc.ndrecOnC]

end Acc

namespace WellFounded

/-- Attaches to `x` the proof that `x` is accessible in the given well-founded relation.
This can be used in recursive function definitions to explicitly use a different relation
than the one inferred by default:

```
def otherWF : WellFounded Nat := …
def foo (n : Nat) := …
termination_by otherWF.wrap n
```
-/
def wrap {α : Sort u} {r : α → α → Prop} (h : WellFounded r) (x : α) : {x : α // Acc r x} :=
  ⟨_, h.apply x⟩

/-- A computable version of `WellFounded.fixF`.
Workaround until Lean has native support for this. -/
@[inline] private def fixFC {α : Sort u} {r : α → α → Prop}
    {C : α → Sort v} (F : ∀ x, (∀ y, r y x → C y) → C x) (x : α) (a : Acc r x) : C x := by
  induction a using Acc.recC with
  | intro x₁ _ ih => exact F x₁ ih

@[csimp] private theorem fixF_eq_fixFC : @fixF = @fixFC := by
  funext α r C F x a
  rw [fixF, Acc.rec_eq_recC, fixFC]

/-- A computable version of `fix`. Workaround until Lean has native support for this. -/
@[specialize] private def fixC {α : Sort u} {C : α → Sort v} {r : α → α → Prop}
    (hwf : WellFounded r) (F : ∀ x, (∀ y, r y x → C y) → C x) (x : α) : C x :=
  F x (fun y _ => fixC hwf F y)
termination_by hwf.wrap x

unseal fixC

@[csimp] private theorem fix_eq_fixC : @fix = @fixC := rfl

end WellFounded



=== LEAN SOURCE: Cast.lean ===
/-
Copyright (c) 2014 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro, Gabriel Ebner
-/
import Batteries.Util.LibraryNote

library_note "coercion into rings"
/--
Coercions such as `Nat.castCoe` that go from a concrete structure such as
`Nat` to an arbitrary ring `R` should be set up as follows:
```lean
instance : CoeTail Nat R where coe := ...
instance : CoeHTCT Nat R where coe := ...
```

It needs to be `CoeTail` instead of `Coe` because otherwise type-class
inference would loop when constructing the transitive coercion `Nat → Nat → Nat → ...`.
Sometimes we also need to declare the `CoeHTCT` instance
if we need to shadow another coercion
(e.g. `Nat.cast` should be used over `Int.ofNat`).
-/



=== LEAN SOURCE: Deprecated.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Batteries.Classes.Order

/-! Deprecated Batteries comparison classes

Examples are to ensure that old instances have equivalent new instances.
-/

set_option linter.deprecated false

namespace Batteries

/-- `OrientedCmp cmp` asserts that `cmp` is determined by the relation `cmp x y = .lt`. -/
@[deprecated Std.OrientedCmp (since := "2025-07-01")]
class OrientedCmp (cmp : α → α → Ordering) : Prop where
  /-- The comparator operation is symmetric, in the sense that if `cmp x y` equals `.lt` then
  `cmp y x = .gt` and vice versa. -/
  symm (x y) : (cmp x y).swap = cmp y x

attribute [deprecated Std.OrientedOrd.eq_swap (since := "2025-07-01")] OrientedCmp.symm

namespace OrientedCmp

@[deprecated Std.OrientedCmp.gt_iff_lt (since := "2025-07-01")]
theorem cmp_eq_gt [OrientedCmp cmp] : cmp x y = .gt ↔ cmp y x = .lt := by
  rw [← Ordering.swap_inj, symm]; exact .rfl

@[deprecated Std.OrientedCmp.le_iff_ge (since := "2025-07-01")]
theorem cmp_ne_gt [OrientedCmp cmp] : cmp x y ≠ .gt ↔ cmp y x ≠ .lt := not_congr cmp_eq_gt

@[deprecated Std.OrientedCmp.eq_comm (since := "2025-07-01")]
theorem cmp_eq_eq_symm [OrientedCmp cmp] : cmp x y = .eq ↔ cmp y x = .eq := by
  rw [← Ordering.swap_inj, symm]; exact .rfl

@[deprecated Std.ReflCmp.compare_self (since := "2025-07-01")]
theorem cmp_refl [OrientedCmp cmp] : cmp x x = .eq :=
  match e : cmp x x with
  | .lt => nomatch e.symm.trans (cmp_eq_gt.2 e)
  | .eq => rfl
  | .gt => nomatch (cmp_eq_gt.1 e).symm.trans e

@[deprecated Std.OrientedCmp.not_lt_of_lt  (since := "2025-07-01")]
theorem lt_asymm [OrientedCmp cmp] (h : cmp x y = .lt) : cmp y x ≠ .lt :=
  fun h' => nomatch h.symm.trans (cmp_eq_gt.2 h')

@[deprecated Std.OrientedCmp.not_gt_of_gt  (since := "2025-07-01")]
theorem gt_asymm [OrientedCmp cmp] (h : cmp x y = .gt) : cmp y x ≠ .gt :=
  mt cmp_eq_gt.1 <| lt_asymm <| cmp_eq_gt.1 h

end OrientedCmp

/-- `TransCmp cmp` asserts that `cmp` induces a transitive relation. -/
@[deprecated Std.TransCmp (since := "2025-07-01")]
class TransCmp (cmp : α → α → Ordering) : Prop extends OrientedCmp cmp where
  /-- The comparator operation is transitive. -/
  le_trans : cmp x y ≠ .gt → cmp y z ≠ .gt → cmp x z ≠ .gt

attribute [deprecated Std.TransCmp.le_trans (since := "2025-07-01")] TransCmp.le_trans

namespace TransCmp
variable [TransCmp cmp]
open OrientedCmp Decidable

@[deprecated Std.TransCmp.ge_trans (since := "2025-07-01")]
theorem ge_trans (h₁ : cmp x y ≠ .lt) (h₂ : cmp y z ≠ .lt) : cmp x z ≠ .lt := by
  have := @TransCmp.le_trans _ cmp _ z y x
  simp [cmp_eq_gt] at *; exact this h₂ h₁

@[deprecated Std.TransCmp.lt_of_le_of_lt (since := "2025-07-01")]
theorem le_lt_trans (h₁ : cmp x y ≠ .gt) (h₂ : cmp y z = .lt) : cmp x z = .lt :=
  byContradiction fun h₃ => ge_trans (mt cmp_eq_gt.2 h₁) h₃ h₂

@[deprecated Std.TransCmp.lt_of_lt_of_le (since := "2025-07-01")]
theorem lt_le_trans (h₁ : cmp x y = .lt) (h₂ : cmp y z ≠ .gt) : cmp x z = .lt :=
  byContradiction fun h₃ => ge_trans h₃ (mt cmp_eq_gt.2 h₂) h₁

@[deprecated Std.TransCmp.lt_trans (since := "2025-07-01")]
theorem lt_trans (h₁ : cmp x y = .lt) (h₂ : cmp y z = .lt) : cmp x z = .lt :=
  le_lt_trans (gt_asymm <| cmp_eq_gt.2 h₁) h₂

@[deprecated Std.TransCmp.gt_trans (since := "2025-07-01")]
theorem gt_trans (h₁ : cmp x y = .gt) (h₂ : cmp y z = .gt) : cmp x z = .gt := by
  rw [cmp_eq_gt] at h₁ h₂ ⊢; exact lt_trans h₂ h₁

@[deprecated Std.TransCmp.congr_left (since := "2025-07-01")]
theorem cmp_congr_left (xy : cmp x y = .eq) : cmp x z = cmp y z :=
  match yz : cmp y z with
  | .lt => byContradiction (ge_trans (nomatch ·.symm.trans (cmp_eq_eq_symm.1 xy)) · yz)
  | .gt => byContradiction (le_trans (nomatch ·.symm.trans (cmp_eq_eq_symm.1 xy)) · yz)
  | .eq => match xz : cmp x z with
    | .lt => nomatch ge_trans (nomatch ·.symm.trans xy) (nomatch ·.symm.trans yz) xz
    | .gt => nomatch le_trans (nomatch ·.symm.trans xy) (nomatch ·.symm.trans yz) xz
    | .eq => rfl

@[deprecated Std.TransCmp.congr_left (since := "2025-07-01")]
theorem cmp_congr_left' (xy : cmp x y = .eq) : cmp x = cmp y :=
  funext fun _ => cmp_congr_left xy

@[deprecated Std.TransCmp.congr_right (since := "2025-07-01")]
theorem cmp_congr_right (yz : cmp y z = .eq) : cmp x y = cmp x z := by
  rw [← Ordering.swap_inj, symm, symm, cmp_congr_left yz]

end TransCmp

instance [inst : OrientedCmp cmp] : OrientedCmp (flip cmp) where
  symm _ _ := inst.symm ..

example [inst : Std.OrientedCmp cmp] : Std.OrientedCmp (flip cmp) := inferInstance

instance [inst : TransCmp cmp] : TransCmp (flip cmp) where
  le_trans h1 h2 := inst.le_trans h2 h1

example [inst : Std.TransCmp cmp] : Std.TransCmp (flip cmp) := inferInstance

/-- `BEqCmp cmp` asserts that `cmp x y = .eq` and `x == y` coincide. -/
@[deprecated Std.LawfulBEqCmp (since := "2025-07-01")]
class BEqCmp [BEq α] (cmp : α → α → Ordering) : Prop where
  /-- `cmp x y = .eq` holds iff `x == y` is true. -/
  cmp_iff_beq : cmp x y = .eq ↔ x == y

attribute [deprecated Std.LawfulBEqCmp.compare_eq_iff_beq
  (since := "2025-07-01")] BEqCmp.cmp_iff_beq

@[deprecated Std.LawfulEqCmp.compare_eq_iff_eq (since := "2025-07-01")]
theorem BEqCmp.cmp_iff_eq [BEq α] [LawfulBEq α] [BEqCmp (α := α) cmp] : cmp x y = .eq ↔ x = y := by
  simp [BEqCmp.cmp_iff_beq]

/-- `LTCmp cmp` asserts that `cmp x y = .lt` and `x < y` coincide. -/
@[deprecated Std.LawfulLTCmp (since := "2025-07-01")]
class LTCmp [LT α] (cmp : α → α → Ordering) : Prop extends OrientedCmp cmp where
  /-- `cmp x y = .lt` holds iff `x < y` is true. -/
  cmp_iff_lt : cmp x y = .lt ↔ x < y

attribute [deprecated Std.LawfulLTCmp.eq_lt_iff_lt (since := "2025-07-01")] LTCmp.cmp_iff_lt

@[deprecated Std.LawfulLTCmp.eq_gt_iff_gt (since := "2025-07-01")]
theorem LTCmp.cmp_iff_gt [LT α] [LTCmp (α := α) cmp] : cmp x y = .gt ↔ y < x := by
  rw [OrientedCmp.cmp_eq_gt, LTCmp.cmp_iff_lt]

/-- `LECmp cmp` asserts that `cmp x y ≠ .gt` and `x ≤ y` coincide. -/
@[deprecated Std.LawfulLECmp (since := "2025-07-01")]
class LECmp [LE α] (cmp : α → α → Ordering) : Prop extends OrientedCmp cmp where
  /-- `cmp x y ≠ .gt` holds iff `x ≤ y` is true. -/
  cmp_iff_le : cmp x y ≠ .gt ↔ x ≤ y

attribute [deprecated Std.LawfulLECmp.ne_gt_iff_le (since := "2025-07-01")] LECmp.cmp_iff_le

@[deprecated Std.LawfulLECmp.ne_lt_iff_ge (since := "2025-07-01")]
theorem LECmp.cmp_iff_ge [LE α] [LECmp (α := α) cmp] : cmp x y ≠ .lt ↔ y ≤ x := by
  rw [← OrientedCmp.cmp_ne_gt, LECmp.cmp_iff_le]

/-- `LawfulCmp cmp` asserts that the `LE`, `LT`, `BEq` instances are all coherent with each other
and with `cmp`, describing a strict weak order (a linear order except for antisymmetry). -/
@[deprecated Std.LawfulBCmp (since := "2025-07-01")]
class LawfulCmp [LE α] [LT α] [BEq α] (cmp : α → α → Ordering) : Prop extends
  TransCmp cmp, BEqCmp cmp, LTCmp cmp, LECmp cmp

/-- `OrientedOrd α` asserts that the `Ord` instance satisfies `OrientedCmp`. -/
@[deprecated Std.OrientedOrd (since := "2025-07-01")]
abbrev OrientedOrd (α) [Ord α] := OrientedCmp (α := α) compare

/-- `TransOrd α` asserts that the `Ord` instance satisfies `TransCmp`. -/
@[deprecated Std.TransOrd (since := "2025-07-01")]
abbrev TransOrd (α) [Ord α] := TransCmp (α := α) compare

/-- `BEqOrd α` asserts that the `Ord` and `BEq` instances are coherent via `BEqCmp`. -/
@[deprecated Std.LawfulBEqOrd (since := "2025-07-01")]
abbrev BEqOrd (α) [BEq α] [Ord α] := BEqCmp (α := α) compare

/-- `LTOrd α` asserts that the `Ord` instance satisfies `LTCmp`. -/
@[deprecated Std.LawfulLTOrd (since := "2025-07-01")]
abbrev LTOrd (α) [LT α] [Ord α] := LTCmp (α := α) compare

/-- `LEOrd α` asserts that the `Ord` instance satisfies `LECmp`. -/
@[deprecated Std.LawfulLEOrd (since := "2025-07-01")]
abbrev LEOrd (α) [LE α] [Ord α] := LECmp (α := α) compare

/-- `LawfulOrd α` asserts that the `Ord` instance satisfies `LawfulCmp`. -/
@[deprecated Std.LawfulBOrd (since := "2025-07-01")]
abbrev LawfulOrd (α) [LE α] [LT α] [BEq α] [Ord α] := LawfulCmp (α := α) compare

@[deprecated Std.TransCmp.compareOfLessAndEq_of_irrefl_of_trans_of_antisymm
  (since := "2025-07-01")]
protected theorem TransCmp.compareOfLessAndEq
    [LT α] [DecidableRel (LT.lt (α := α))] [DecidableEq α]
    (lt_irrefl : ∀ x : α, ¬x < x)
    (lt_trans : ∀ {x y z : α}, x < y → y < z → x < z)
    (lt_antisymm : ∀ {x y : α}, ¬x < y → ¬y < x → x = y) :
    TransCmp (α := α) (compareOfLessAndEq · ·) := by
  have : OrientedCmp (α := α) (compareOfLessAndEq · ·) := by
    refine { symm := fun x y => ?_ }
    simp [compareOfLessAndEq]; split <;> [rename_i xy; split <;> [subst y; rename_i xy ne]]
    · rw [if_neg, if_neg]; rfl
      · rintro rfl; exact lt_irrefl _ xy
      · exact fun yx => lt_irrefl _ (lt_trans xy yx)
    · rw [if_neg ‹_›, if_pos rfl]; rfl
    · split <;> [rfl; rename_i yx]
      cases ne (lt_antisymm xy yx)
  refine { this with le_trans := fun {x y z} yx zy => ?_ }
  rw [Ne, this.cmp_eq_gt, compareOfLessAndEq_eq_lt] at yx zy ⊢
  intro zx
  if xy : x < y then exact zy (lt_trans zx xy)
  else exact zy (lt_antisymm yx xy ▸ zx)

@[deprecated Std.TransCmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm
  (since := "2025-07-01")]
theorem TransCmp.compareOfLessAndEq_of_le
    [LT α] [LE α] [DecidableRel (LT.lt (α := α))] [DecidableEq α]
    (lt_irrefl : ∀ x : α, ¬x < x)
    (lt_trans : ∀ {x y z : α}, x < y → y < z → x < z)
    (not_lt : ∀ {x y : α}, ¬x < y → y ≤ x)
    (le_antisymm : ∀ {x y : α}, x ≤ y → y ≤ x → x = y) :
    TransCmp (α := α) (compareOfLessAndEq · ·) :=
  .compareOfLessAndEq lt_irrefl lt_trans fun xy yx => le_antisymm (not_lt yx) (not_lt xy)

@[deprecated Std.LawfulBEqCmp.compareOfLessAndEq_of_lt_irrefl (since := "2025-07-01")]
protected theorem BEqCmp.compareOfLessAndEq
    [LT α] [DecidableRel (LT.lt (α := α))] [DecidableEq α] [BEq α] [LawfulBEq α]
    (lt_irrefl : ∀ x : α, ¬x < x) :
    BEqCmp (α := α) (compareOfLessAndEq · ·) where
  cmp_iff_beq {x y} := by
    simp [compareOfLessAndEq]
    split <;> [skip; split] <;> simp [*]
    rintro rfl; exact lt_irrefl _ ‹_›

@[deprecated Std.LawfulLTCmp.compareOfLessAndEq_of_irrefl_of_trans_of_antisymm
  (since := "2025-07-01")]
protected theorem LTCmp.compareOfLessAndEq
    [LT α] [DecidableRel (LT.lt (α := α))] [DecidableEq α]
    (lt_irrefl : ∀ x : α, ¬x < x)
    (lt_trans : ∀ {x y z : α}, x < y → y < z → x < z)
    (lt_antisymm : ∀ {x y : α}, ¬x < y → ¬y < x → x = y) :
    LTCmp (α := α) (compareOfLessAndEq · ·) :=
  { TransCmp.compareOfLessAndEq lt_irrefl lt_trans lt_antisymm with
    cmp_iff_lt := compareOfLessAndEq_eq_lt }

@[deprecated Std.LawfulLTCmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm
  (since := "2025-07-01")]
protected theorem LTCmp.compareOfLessAndEq_of_le
    [LT α] [DecidableRel (LT.lt (α := α))] [DecidableEq α] [LE α]
    (lt_irrefl : ∀ x : α, ¬x < x)
    (lt_trans : ∀ {x y z : α}, x < y → y < z → x < z)
    (not_lt : ∀ {x y : α}, ¬x < y → y ≤ x)
    (le_antisymm : ∀ {x y : α}, x ≤ y → y ≤ x → x = y) :
    LTCmp (α := α) (compareOfLessAndEq · ·) :=
  { TransCmp.compareOfLessAndEq_of_le lt_irrefl lt_trans not_lt le_antisymm with
    cmp_iff_lt := compareOfLessAndEq_eq_lt }

@[deprecated Std.LawfulLECmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm
  (since := "2025-07-01")]
protected theorem LECmp.compareOfLessAndEq
    [LT α] [DecidableRel (LT.lt (α := α))] [DecidableEq α] [LE α]
    (lt_irrefl : ∀ x : α, ¬x < x)
    (lt_trans : ∀ {x y z : α}, x < y → y < z → x < z)
    (not_lt : ∀ {x y : α}, ¬x < y ↔ y ≤ x)
    (le_antisymm : ∀ {x y : α}, x ≤ y → y ≤ x → x = y) :
    LECmp (α := α) (compareOfLessAndEq · ·) :=
  have := TransCmp.compareOfLessAndEq_of_le lt_irrefl lt_trans not_lt.1 le_antisymm
  { this with
    cmp_iff_le := (this.cmp_ne_gt).trans <| (not_congr compareOfLessAndEq_eq_lt).trans not_lt }

@[deprecated Std.LawfulCmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm
  (since := "2025-07-01")]
protected theorem LawfulCmp.compareOfLessAndEq
    [LT α] [DecidableRel (LT.lt (α := α))] [DecidableEq α] [BEq α] [LawfulBEq α] [LE α]
    (lt_irrefl : ∀ x : α, ¬x < x)
    (lt_trans : ∀ {x y z : α}, x < y → y < z → x < z)
    (not_lt : ∀ {x y : α}, ¬x < y ↔ y ≤ x)
    (le_antisymm : ∀ {x y : α}, x ≤ y → y ≤ x → x = y) :
    LawfulCmp (α := α) (compareOfLessAndEq · ·) :=
  { TransCmp.compareOfLessAndEq_of_le lt_irrefl lt_trans not_lt.1 le_antisymm,
    LTCmp.compareOfLessAndEq_of_le lt_irrefl lt_trans not_lt.1 le_antisymm,
    LECmp.compareOfLessAndEq lt_irrefl lt_trans not_lt le_antisymm,
    BEqCmp.compareOfLessAndEq lt_irrefl with }

@[deprecated Std.LawfulLTCmp.eq_compareOfLessAndEq (since := "2025-07-01")]
theorem LTCmp.eq_compareOfLessAndEq
    [LT α] [DecidableEq α] [BEq α] [LawfulBEq α] [BEqCmp cmp] [LTCmp cmp]
    (x y : α) [Decidable (x < y)] : cmp x y = compareOfLessAndEq x y := by
  simp [compareOfLessAndEq]
  split <;> rename_i h1 <;> [skip; split <;> rename_i h2]
  · exact LTCmp.cmp_iff_lt.2 h1
  · exact BEqCmp.cmp_iff_eq.2 h2
  · cases e : cmp x y
    · cases h1 (LTCmp.cmp_iff_lt.1 e)
    · cases h2 (BEqCmp.cmp_iff_eq.1 e)
    · rfl

instance [inst₁ : OrientedCmp cmp₁] [inst₂ : OrientedCmp cmp₂] :
    OrientedCmp (compareLex cmp₁ cmp₂) where
  symm _ _ := by simp [compareLex, Ordering.swap_then]; rw [inst₁.symm, inst₂.symm]

example [inst₁ : Std.OrientedCmp cmp₁] [inst₂ : Std.OrientedCmp cmp₂] :
    Std.OrientedCmp (compareLex cmp₁ cmp₂) := inferInstance

instance [inst₁ : TransCmp cmp₁] [inst₂ : TransCmp cmp₂] :
    TransCmp (compareLex cmp₁ cmp₂) where
  le_trans {a b c} h1 h2 := by
    simp only [compareLex, ne_eq, Ordering.then_eq_gt, not_or, not_and] at h1 h2 ⊢
    refine ⟨inst₁.le_trans h1.1 h2.1, fun e1 e2 => ?_⟩
    match ab : cmp₁ a b with
    | .gt => exact h1.1 ab
    | .eq => exact inst₂.le_trans (h1.2 ab) (h2.2 (inst₁.cmp_congr_left ab ▸ e1)) e2
    | .lt => exact h2.1 <| (inst₁.cmp_eq_gt).2 (inst₁.cmp_congr_left e1 ▸ ab)

example [inst₁ : Std.TransCmp cmp₁] [inst₂ : Std.TransCmp cmp₂] :
    Std.TransCmp (compareLex cmp₁ cmp₂) := inferInstance

instance [Ord β] [OrientedOrd β] (f : α → β) : OrientedCmp (compareOn f) where
  symm _ _ := OrientedCmp.symm (α := β) ..

example [Ord β] [Std.OrientedOrd β] (f : α → β) : Std.OrientedCmp (compareOn f) :=
  inferInstance

instance [Ord β] [TransOrd β] (f : α → β) : TransCmp (compareOn f) where
  le_trans := TransCmp.le_trans (α := β)

example [Ord β] [Std.TransOrd β] (f : α → β) : Std.TransCmp (compareOn f) :=
  inferInstance

section «non-canonical instances»
-- Note: the following instances seem to cause lean to fail, see:
-- https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Typeclass.20inference.20crashes/near/432836360

/-- Local instance for `OrientedOrd lexOrd`. -/
@[deprecated "instance exists" (since := "2025-07-01")]
theorem OrientedOrd.instLexOrd [Ord α] [Ord β]
    [OrientedOrd α] [OrientedOrd β] : @OrientedOrd (α × β) lexOrd := by
  rw [OrientedOrd, lexOrd_def]; infer_instance

/-- Local instance for `TransOrd lexOrd`. -/
@[deprecated "instance exists" (since := "2025-07-01")]
theorem TransOrd.instLexOrd [Ord α] [Ord β]
    [TransOrd α] [TransOrd β] : @TransOrd (α × β) lexOrd := by
  rw [TransOrd, lexOrd_def]; infer_instance

/-- Local instance for `OrientedOrd ord.opposite`. -/
@[deprecated Std.OrientedOrd.opposite (since := "2025-07-01")]
theorem OrientedOrd.instOpposite [ord : Ord α] [inst : OrientedOrd α] :
    @OrientedOrd _ ord.opposite where symm _ _ := inst.symm ..

/-- Local instance for `TransOrd ord.opposite`. -/
@[deprecated Std.TransOrd.opposite (since := "2025-07-01")]
theorem TransOrd.instOpposite [ord : Ord α] [inst : TransOrd α] : @TransOrd _ ord.opposite :=
  { OrientedOrd.instOpposite with le_trans := fun h1 h2 => inst.le_trans h2 h1 }

/-- Local instance for `OrientedOrd (ord.on f)`. -/
@[deprecated Std.OrientedOrd.instOn (since := "2025-07-01")]
theorem OrientedOrd.instOn [ord : Ord β] [OrientedOrd β] (f : α → β) : @OrientedOrd _ (ord.on f) :=
  inferInstanceAs (@OrientedCmp _ (compareOn f))

/-- Local instance for `TransOrd (ord.on f)`. -/
@[deprecated Std.TransOrd.instOn (since := "2025-07-01")]
theorem TransOrd.instOn [ord : Ord β] [TransOrd β] (f : α → β) : @TransOrd _ (ord.on f) :=
  inferInstanceAs (@TransCmp _ (compareOn f))

/-- Local instance for `OrientedOrd (oα.lex oβ)`. -/
@[deprecated "instance exists" (since := "2025-07-01")]
theorem OrientedOrd.instOrdLex [oα : Ord α] [oβ : Ord β] [OrientedOrd α] [OrientedOrd β] :
    @OrientedOrd _ (oα.lex oβ) := OrientedOrd.instLexOrd

/-- Local instance for `TransOrd (oα.lex oβ)`. -/
@[deprecated "instance exists" (since := "2025-07-01")]
theorem TransOrd.instOrdLex [oα : Ord α] [oβ : Ord β] [TransOrd α] [TransOrd β] :
    @TransOrd _ (oα.lex oβ) := TransOrd.instLexOrd

/-- Local instance for `OrientedOrd (oα.lex' oβ)`. -/
@[deprecated Std.OrientedOrd.instOrdLex' (since := "2025-07-01")]
theorem OrientedOrd.instOrdLex' (ord₁ ord₂ : Ord α) [@OrientedOrd _ ord₁] [@OrientedOrd _ ord₂] :
    @OrientedOrd _ (ord₁.lex' ord₂) :=
  inferInstanceAs (OrientedCmp (compareLex ord₁.compare ord₂.compare))

/-- Local instance for `TransOrd (oα.lex' oβ)`. -/
@[deprecated Std.TransOrd.instOrdLex' (since := "2025-07-01")]
theorem TransOrd.instOrdLex' (ord₁ ord₂ : Ord α) [@TransOrd _ ord₁] [@TransOrd _ ord₂] :
    @TransOrd _ (ord₁.lex' ord₂) :=
  inferInstanceAs (TransCmp (compareLex ord₁.compare ord₂.compare))

end «non-canonical instances»



=== LEAN SOURCE: Order.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Batteries.Tactic.Basic
import Batteries.Tactic.SeqFocus
import Std.Classes.Ord

theorem lexOrd_def [Ord α] [Ord β] :
    (lexOrd : Ord (α × β)).compare = compareLex (compareOn (·.1)) (compareOn (·.2)) := rfl

/-- Pull back a comparator by a function `f`, by applying the comparator to both arguments. -/
@[inline] def Ordering.byKey (f : α → β) (cmp : β → β → Ordering) (a b : α) : Ordering :=
  cmp (f a) (f b)

namespace Batteries

/-- `TotalBLE le` asserts that `le` has a total order, that is, `le a b ∨ le b a`. -/
class TotalBLE (le : α → α → Bool) : Prop where
  /-- `le` is total: either `le a b` or `le b a`. -/
  total : le a b ∨ le b a

theorem compareOfLessAndEq_eq_lt {x y : α} [LT α] [Decidable (x < y)] [DecidableEq α] :
    compareOfLessAndEq x y = .lt ↔ x < y := by
  simp [compareOfLessAndEq]
  split <;> simp

end Batteries

/-! Batteries features not in core Std -/

namespace Std
open Batteries (compareOfLessAndEq_eq_lt)

namespace OrientedCmp
variable {cmp : α → α → Ordering} [OrientedCmp cmp]

theorem le_iff_ge : cmp x y ≠ .gt ↔ cmp y x ≠ .lt :=
  not_congr OrientedCmp.gt_iff_lt

end OrientedCmp

namespace TransCmp
variable {cmp : α → α → Ordering} [TransCmp cmp]

theorem le_trans : cmp x y ≠ .gt → cmp y z ≠ .gt → cmp x z ≠ .gt := by
  simp only [ne_eq, ← Ordering.isLE_iff_ne_gt]; exact isLE_trans

theorem lt_of_lt_of_le : cmp x y = .lt → cmp y z ≠ .gt → cmp x z = .lt := by
  simp only [ne_eq, ← Ordering.isLE_iff_ne_gt]; exact lt_of_lt_of_isLE

theorem lt_of_le_of_lt : cmp x y ≠ .gt → cmp y z = .lt → cmp x z = .lt := by
  simp only [ne_eq, ← Ordering.isLE_iff_ne_gt]; exact lt_of_isLE_of_lt

theorem ge_trans : cmp x y ≠ .lt → cmp y z ≠ .lt → cmp x z ≠ .lt := by
  simp only [ne_eq, ← Ordering.isGE_iff_ne_lt]; exact isGE_trans

theorem gt_of_gt_of_ge : cmp x y = .gt → cmp y z ≠ .lt → cmp x z = .gt := by
  simp only [ne_eq, ← Ordering.isGE_iff_ne_lt]; exact gt_of_gt_of_isGE

theorem gt_of_ge_of_gt : cmp x y ≠ .lt → cmp y z = .gt → cmp x z = .gt := by
  simp only [ne_eq, ← Ordering.isGE_iff_ne_lt]; exact gt_of_isGE_of_gt

end TransCmp

/-- `LawfulLTCmp cmp` asserts that `cmp x y = .lt` and `x < y` coincide. -/
class LawfulLTCmp [LT α] (cmp : α → α → Ordering) : Prop extends OrientedCmp cmp where
  /-- `cmp x y = .lt` holds iff `x < y` is true. -/
  eq_lt_iff_lt : cmp x y = .lt ↔ x < y

theorem LawfulLTCmp.eq_gt_iff_gt [LT α] [LawfulLTCmp (α := α) cmp] :
    cmp x y = .gt ↔ y < x := by rw [OrientedCmp.gt_iff_lt, eq_lt_iff_lt]

/-- `LawfulLECmp cmp` asserts that `(cmp x y).isLE` and `x ≤ y` coincide. -/
class LawfulLECmp [LE α] (cmp : α → α → Ordering) : Prop extends OrientedCmp cmp where
  /-- `cmp x y ≠ .gt` holds iff `x ≤ y` is true. -/
  isLE_iff_le : (cmp x y).isLE ↔ x ≤ y

theorem LawfulLECmp.isGE_iff_ge [LE α] [LawfulLECmp (α := α) cmp] :
    (cmp x y).isGE ↔ y ≤ x := by rw [← Ordering.isLE_swap, ← OrientedCmp.eq_swap, isLE_iff_le]

theorem LawfulLECmp.ne_gt_iff_le [LE α] [LawfulLECmp (α := α) cmp] :
    cmp x y ≠ .gt ↔ x ≤ y := by rw [← isLE_iff_le (cmp := cmp), Ordering.isLE_iff_ne_gt]

theorem LawfulLECmp.ne_lt_iff_ge [LE α] [LawfulLECmp (α := α) cmp] :
    cmp x y ≠ .lt ↔ y ≤ x := by rw [← isGE_iff_ge (cmp := cmp), Ordering.isGE_iff_ne_lt]

/-- `LawfulBCmp cmp` asserts that the `LE`, `LT`, `BEq` are all coherent with each other
and with `cmp`, describing a strict weak order (a linear order except for antisymmetry). -/
class LawfulBCmp [LE α] [LT α] [BEq α] (cmp : α → α → Ordering) : Prop extends
  TransCmp cmp, LawfulBEqCmp cmp, LawfulLTCmp cmp, LawfulLECmp cmp

/-- `LawfulBCmp cmp` asserts that the `LE`, `LT`, `Eq` are all coherent with each other
and with `cmp`, describing a linear order. -/
class LawfulCmp [LE α] [LT α] (cmp : α → α → Ordering) : Prop extends
  TransCmp cmp, LawfulEqCmp cmp, LawfulLTCmp cmp, LawfulLECmp cmp

/-- Class for types where the ordering function is compatible with the `LT`. -/
abbrev LawfulLTOrd (α) [LT α] [Ord α] := LawfulLTCmp (α := α) compare

/-- Class for types where the ordering function is compatible with the `LE`. -/
abbrev LawfulLEOrd (α) [LE α] [Ord α] := LawfulLECmp (α := α) compare

/-- Class for types where the ordering function is compatible with the `LE`, `LT` and `BEq`. -/
abbrev LawfulBOrd (α) [LE α] [LT α] [BEq α] [Ord α] := LawfulBCmp (α := α) compare

/-- Class for types where the ordering function is compatible with the `LE`, `LT` and `Eq`. -/
abbrev LawfulOrd (α) [LE α] [LT α] [Ord α] := LawfulCmp (α := α) compare

instance [inst : Std.OrientedCmp cmp] : Std.OrientedCmp (flip cmp) where
  eq_swap := inst.eq_swap

instance [inst : Std.TransCmp cmp] : Std.TransCmp (flip cmp) where
  isLE_trans h1 h2 := inst.isLE_trans h2 h1

instance (f : α → β) (cmp : β → β → Ordering) [Std.OrientedCmp cmp] :
    Std.OrientedCmp (Ordering.byKey f cmp) where
  eq_swap {a b} := Std.OrientedCmp.eq_swap (a := f a) (b := f b)

instance (f : α → β) (cmp : β → β → Ordering) [Std.TransCmp cmp] :
    Std.TransCmp (Ordering.byKey f cmp) where
  isLE_trans h₁ h₂ := Std.TransCmp.isLE_trans (α := β) h₁ h₂

instance [inst₁ : OrientedCmp cmp₁] [inst₂ : OrientedCmp cmp₂] :
    OrientedCmp (compareLex cmp₁ cmp₂) := inferInstance

instance [inst₁ : TransCmp cmp₁] [inst₂ : TransCmp cmp₂] :
    TransCmp (compareLex cmp₁ cmp₂) := inferInstance

instance [Ord β] [OrientedOrd β] (f : α → β) : OrientedCmp (compareOn f) := inferInstance

instance [Ord β] [TransOrd β] (f : α → β) : TransCmp (compareOn f) := inferInstance

theorem OrientedOrd.instOn [ord : Ord β] [OrientedOrd β] (f : α → β) : @OrientedOrd _ (ord.on f) :=
  inferInstanceAs (@OrientedCmp _ (compareOn f))

theorem TransOrd.instOn [ord : Ord β] [TransOrd β] (f : α → β) : @TransOrd _ (ord.on f) :=
  inferInstanceAs (@TransCmp _ (compareOn f))

theorem OrientedOrd.instOrdLex' (ord₁ ord₂ : Ord α) [@OrientedOrd _ ord₁] [@OrientedOrd _ ord₂] :
    @OrientedOrd _ (ord₁.lex' ord₂) :=
  inferInstanceAs (OrientedCmp (compareLex ord₁.compare ord₂.compare))

theorem TransOrd.instOrdLex' (ord₁ ord₂ : Ord α) [@TransOrd _ ord₁] [@TransOrd _ ord₂] :
    @TransOrd _ (ord₁.lex' ord₂) :=
  inferInstanceAs (TransCmp (compareLex ord₁.compare ord₂.compare))

theorem LawfulLTCmp.eq_compareOfLessAndEq
    [LT α] [DecidableEq α] [LawfulEqCmp cmp] [LawfulLTCmp cmp]
    (x y : α) [Decidable (x < y)] : cmp x y = compareOfLessAndEq x y := by
  simp only [compareOfLessAndEq]
  split <;> rename_i h1 <;> [skip; split <;> rename_i h2]
  · exact LawfulLTCmp.eq_lt_iff_lt.2 h1
  · exact LawfulEqCmp.compare_eq_iff_eq.2 h2
  · cases e : cmp x y
    · cases h1 (LawfulLTCmp.eq_lt_iff_lt.1 e)
    · cases h2 (LawfulEqCmp.compare_eq_iff_eq.1 e)
    · rfl

theorem ReflCmp.compareOfLessAndEq_of_lt_irrefl [LT α] [DecidableLT α] [DecidableEq α]
    (lt_irrefl : ∀ x : α, ¬ x < x) :
    ReflCmp (α := α) (compareOfLessAndEq · ·) where
  compare_self {x} := by simp [compareOfLessAndEq, if_neg (lt_irrefl x)]

theorem LawfulBEqCmp.compareOfLessAndEq_of_lt_irrefl
    [LT α] [DecidableLT α] [DecidableEq α] [BEq α] [LawfulBEq α]
    (lt_irrefl : ∀ x : α, ¬x < x) :
    LawfulBEqCmp (α := α) (compareOfLessAndEq · ·) where
  compare_eq_iff_beq {x y} := by
    simp [compareOfLessAndEq]
    split <;> [skip; split] <;> simp [*]
    rintro rfl; exact lt_irrefl _ ‹_›

-- redundant? See `compareOfLessAndEq_of_lt_trans_of_lt_iff` in core
theorem TransCmp.compareOfLessAndEq_of_irrefl_of_trans_of_antisymm
    [LT α] [DecidableLT α] [DecidableEq α]
    (lt_irrefl : ∀ x : α, ¬x < x)
    (lt_trans : ∀ {x y z : α}, x < y → y < z → x < z)
    (lt_antisymm : ∀ {x y : α}, ¬x < y → ¬y < x → x = y) :
    TransCmp (α := α) (compareOfLessAndEq · ·) :=
  TransOrd.compareOfLessAndEq_of_lt_trans_of_lt_iff lt_trans <| by
    intros
    constructor
    · intro h₁
      constructor
      · intro h₂
        apply lt_irrefl
        exact lt_trans h₁ h₂
      · intro | rfl => exact lt_irrefl _ h₁
    · intro ⟨h₁, h₂⟩
      by_contra h₃
      apply h₂
      exact lt_antisymm h₃ h₁

-- redundant? See `compareOfLessAndEq_of_antisymm_of_trans_of_total_of_not_le` in core
theorem TransCmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm
    [LT α] [LE α] [DecidableLT α] [DecidableEq α]
    (lt_irrefl : ∀ x : α, ¬x < x)
    (lt_trans : ∀ {x y z : α}, x < y → y < z → x < z)
    (not_lt : ∀ {x y : α}, ¬x < y → y ≤ x)
    (le_antisymm : ∀ {x y : α}, x ≤ y → y ≤ x → x = y) :
    TransCmp (α := α) (compareOfLessAndEq · ·) :=
  .compareOfLessAndEq_of_irrefl_of_trans_of_antisymm
    lt_irrefl lt_trans fun xy yx => le_antisymm (not_lt yx) (not_lt xy)

-- make redundant?
theorem LawfulLTCmp.compareOfLessAndEq_of_irrefl_of_trans_of_antisymm
    [LT α] [DecidableLT α] [DecidableEq α]
    (lt_irrefl : ∀ x : α, ¬x < x)
    (lt_trans : ∀ {x y z : α}, x < y → y < z → x < z)
    (lt_antisymm : ∀ {x y : α}, ¬x < y → ¬y < x → x = y) :
    LawfulLTCmp (α := α) (compareOfLessAndEq · ·) :=
  { TransCmp.compareOfLessAndEq_of_irrefl_of_trans_of_antisymm
      lt_irrefl lt_trans lt_antisymm with
    eq_lt_iff_lt := Batteries.compareOfLessAndEq_eq_lt }

-- make redundant?
theorem LawfulLTCmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm
    [LT α] [DecidableLT α] [DecidableEq α] [LE α]
    (lt_irrefl : ∀ x : α, ¬x < x)
    (lt_trans : ∀ {x y z : α}, x < y → y < z → x < z)
    (not_lt : ∀ {x y : α}, ¬x < y → y ≤ x)
    (le_antisymm : ∀ {x y : α}, x ≤ y → y ≤ x → x = y) :
    LawfulLTCmp (α := α) (compareOfLessAndEq · ·) :=
  { TransCmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm
      lt_irrefl lt_trans not_lt le_antisymm with
    eq_lt_iff_lt := Batteries.compareOfLessAndEq_eq_lt }

-- make redundant?
theorem LawfulLECmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm
    [LT α] [DecidableLT α] [DecidableEq α] [LE α]
    (lt_irrefl : ∀ x : α, ¬x < x)
    (lt_trans : ∀ {x y z : α}, x < y → y < z → x < z)
    (not_lt : ∀ {x y : α}, ¬x < y ↔ y ≤ x)
    (le_antisymm : ∀ {x y : α}, x ≤ y → y ≤ x → x = y) :
    LawfulLECmp (α := α) (compareOfLessAndEq · ·) :=
  have := TransCmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm
      lt_irrefl lt_trans not_lt.1 le_antisymm
  { this with
    isLE_iff_le := by
      intro x y
      simp only [Ordering.isLE_iff_ne_gt, ← not_lt]
      apply not_congr
      rw [this.gt_iff_lt, Batteries.compareOfLessAndEq_eq_lt] }

theorem LawfulCmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm
    [LT α] [LE α] [DecidableLT α] [DecidableLE α] [DecidableEq α]
    (lt_irrefl : ∀ x : α, ¬x < x)
    (lt_trans : ∀ {x y z : α}, x < y → y < z → x < z)
    (not_lt : ∀ {x y : α}, ¬x < y ↔ y ≤ x)
    (le_antisymm : ∀ {x y : α}, x ≤ y → y ≤ x → x = y) :
    LawfulCmp (α := α) (compareOfLessAndEq · ·) :=
    have instT := TransCmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm
      lt_irrefl lt_trans not_lt.1 le_antisymm
    have instLT := LawfulLTCmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm
      lt_irrefl lt_trans not_lt.1 le_antisymm
    have instLE := LawfulLECmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm
      lt_irrefl lt_trans not_lt le_antisymm
    have le_refl (x : α) : x ≤ x := by rw [← not_lt]; exact lt_irrefl _
    have not_le {x y : α} : ¬x ≤ y ↔ y < x := by simp [← not_lt]
    { instT, instLT, instLE with
      eq_of_compare {_  _}:= by rw [compareOfLessAndEq_eq_eq le_refl not_le]; exact id
    }

instance : LawfulOrd Nat :=
  LawfulCmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm
    Nat.lt_irrefl Nat.lt_trans Nat.not_lt Nat.le_antisymm

instance : LawfulOrd Int :=
  LawfulCmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm
    Int.lt_irrefl Int.lt_trans Int.not_lt Int.le_antisymm

instance : LawfulOrd Bool := by
  apply LawfulCmp.mk <;> decide

instance : LawfulOrd (Fin n) where
  eq_swap := OrientedCmp.eq_swap (α := Nat) (cmp := compare) ..
  eq_lt_iff_lt := LawfulLTCmp.eq_lt_iff_lt (α := Nat) (cmp := compare)
  isLE_iff_le := LawfulLECmp.isLE_iff_le (α := Nat) (cmp := compare)
  isLE_trans := TransCmp.isLE_trans (α := Nat) (cmp := compare)

end Std



=== LEAN SOURCE: RatCast.lean ===
/-
Copyright (c) 2014 Robert Lewis. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Robert Lewis, Leonardo de Moura, Johannes Hölzl, Mario Carneiro, Gabriel Ebner
-/
import Batteries.Data.Rat.Basic

/-- Type class for the canonical homomorphism `Rat → K`. -/
class RatCast (K : Type u) where
  /-- The canonical homomorphism `Rat → K`. -/
  protected ratCast : Rat → K

instance : RatCast Rat where ratCast n := n

/-- Canonical homomorphism from `Rat` to a division ring `K`.
This is just the bare function in order to aid in creating instances of `DivisionRing`. -/
@[coe, reducible, match_pattern] protected def Rat.cast {K : Type u} [RatCast K] : Rat → K :=
  RatCast.ratCast

-- see note [coercion into rings]
instance [RatCast K] : CoeTail Rat K where coe := Rat.cast

-- see note [coercion into rings]
instance [RatCast K] : CoeHTCT Rat K where coe := Rat.cast



=== LEAN SOURCE: SatisfiesM.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro, Kim Morrison
-/
import Batteries.Lean.EStateM
import Batteries.Lean.Except

/-!
## SatisfiesM

The `SatisfiesM` predicate works over an arbitrary (lawful) monad / applicative / functor,
and enables Hoare-like reasoning over monadic expressions. For example, given a monadic
function `f : α → m β`, to say that the return value of `f` satisfies `Q` whenever
the input satisfies `P`, we write `∀ a, P a → SatisfiesM Q (f a)`.

For any monad equipped with `MonadSatisfying m`
one can lift `SatisfiesM` to a monadic value in `Subtype`,
using `satisfying x h : m {a // p a}`, where `x : m α` and `h : SatisfiesM p x`.
This includes `Option`, `ReaderT`, `StateT`, and `ExceptT`, and the Lean monad stack.
(Although it is not entirely clear one should treat the Lean monad stack as lawful,
even though Lean accepts this.)

## Notes

`SatisfiesM` is not yet a satisfactory solution for verifying the behaviour of large scale monadic
programs. Such a solution would allow ergonomic reasoning about large `do` blocks,
with convenient mechanisms for introducing invariants and loop conditions as needed.

It is possible that in the future `SatiesfiesM` will become part of such a solution,
presumably requiring more syntactic support (and smarter `do` blocks) from Lean.
Or it may be that such a solution will look different!
This is an open research program, and for now one should not be overly ambitious using `SatisfiesM`.

In particular lemmas about pure operations on data structures in `Batteries` except for `HashMap`
should avoid `SatisfiesM` for now, so that it is easy to migrate to other approaches in future.
-/

/--
`SatisfiesM p (x : m α)` lifts propositions over a monad. It asserts that `x` may as well
have the type `x : m {a // p a}`, because there exists some `m {a // p a}` whose image is `x`.
So `p` is the postcondition of the monadic value.
-/
def SatisfiesM {m : Type u → Type v} [Functor m] (p : α → Prop) (x : m α) : Prop :=
  ∃ x' : m {a // p a}, Subtype.val <$> x' = x

namespace SatisfiesM

/-- If `p` is always true, then every `x` satisfies it. -/
theorem of_true [Functor m] [LawfulFunctor m] {x : m α}
    (h : ∀ a, p a) : SatisfiesM p x :=
  ⟨(fun a => ⟨a, h a⟩) <$> x, by simp⟩

/--
If `p` is always true, then every `x` satisfies it.
(This is the strongest postcondition version of `of_true`.)
-/
protected theorem trivial [Functor m] [LawfulFunctor m] {x : m α} :
  SatisfiesM (fun _ => True) x := of_true fun _ => trivial

/-- The `SatisfiesM p x` predicate is monotonic in `p`. -/
theorem imp [Functor m] [LawfulFunctor m] {x : m α}
    (h : SatisfiesM p x) (H : ∀ {a}, p a → q a) : SatisfiesM q x :=
  let ⟨x, h⟩ := h; ⟨(fun ⟨_, h⟩ => ⟨_, H h⟩) <$> x, by rw [← h, ← comp_map]; rfl⟩

/-- `SatisfiesM` distributes over `<$>`, general version. -/
protected theorem map [Functor m] [LawfulFunctor m] {x : m α}
    (hx : SatisfiesM p x) (hf : ∀ {a}, p a → q (f a)) : SatisfiesM q (f <$> x) := by
  let ⟨x', hx⟩ := hx
  refine ⟨(fun ⟨a, h⟩ => ⟨f a, hf h⟩) <$> x', ?_⟩
  rw [← hx]; simp

/--
`SatisfiesM` distributes over `<$>`, strongest postcondition version.
(Use this for reasoning forward from assumptions.)
-/
theorem map_post [Functor m] [LawfulFunctor m] {x : m α}
    (hx : SatisfiesM p x) : SatisfiesM (fun b => ∃ a, p a ∧ b = f a) (f <$> x) :=
  hx.map fun h => ⟨_, h, rfl⟩

/--
`SatisfiesM` distributes over `<$>`, weakest precondition version.
(Use this for reasoning backward from the goal.)
-/
theorem map_pre [Functor m] [LawfulFunctor m] {x : m α}
    (hx : SatisfiesM (fun a => p (f a)) x) : SatisfiesM p (f <$> x) :=
  hx.map fun h => h

/-- `SatisfiesM` distributes over `mapConst`, general version. -/
protected theorem mapConst [Functor m] [LawfulFunctor m] {x : m α}
    (hx : SatisfiesM q x) (ha : ∀ {b}, q b → p a) : SatisfiesM p (Functor.mapConst a x) :=
  map_const (f := m) ▸ hx.map ha

/-- `SatisfiesM` distributes over `pure`, general version / weakest precondition version. -/
protected theorem pure [Applicative m] [LawfulApplicative m]
    (h : p a) : SatisfiesM (m := m) p (pure a) := ⟨pure ⟨_, h⟩, by simp⟩

/-- `SatisfiesM` distributes over `<*>`, general version. -/
protected theorem seq [Applicative m] [LawfulApplicative m] {x : m α}
    (hf : SatisfiesM p₁ f) (hx : SatisfiesM p₂ x)
    (H : ∀ {f a}, p₁ f → p₂ a → q (f a)) : SatisfiesM q (f <*> x) := by
  match f, x, hf, hx with | _, _, ⟨f, rfl⟩, ⟨x, rfl⟩ => ?_
  refine ⟨(fun ⟨a, h₁⟩ ⟨b, h₂⟩ => ⟨a b, H h₁ h₂⟩) <$> f <*> x, ?_⟩
  simp only [← pure_seq]; simp [seq_assoc]
  simp only [← pure_seq]; simp [seq_assoc, Function.comp_def]

/-- `SatisfiesM` distributes over `<*>`, strongest postcondition version. -/
protected theorem seq_post [Applicative m] [LawfulApplicative m] {x : m α}
    (hf : SatisfiesM p₁ f) (hx : SatisfiesM p₂ x) :
    SatisfiesM (fun c => ∃ f a, p₁ f ∧ p₂ a ∧ c = f a) (f <*> x) :=
  hf.seq hx fun  hf ha => ⟨_, _, hf, ha, rfl⟩

/--
`SatisfiesM` distributes over `<*>`, weakest precondition version 1.
(Use this when `x` and the goal are known and `f` is a subgoal.)
-/
protected theorem seq_pre [Applicative m] [LawfulApplicative m] {x : m α}
    (hf : SatisfiesM (fun f => ∀ {a}, p₂ a → q (f a)) f) (hx : SatisfiesM p₂ x) :
    SatisfiesM q (f <*> x) :=
  hf.seq hx fun hf ha => hf ha

/--
`SatisfiesM` distributes over `<*>`, weakest precondition version 2.
(Use this when `f` and the goal are known and `x` is a subgoal.)
-/
protected theorem seq_pre' [Applicative m] [LawfulApplicative m] {x : m α}
    (hf : SatisfiesM p₁ f) (hx : SatisfiesM (fun a => ∀ {f}, p₁ f → q (f a)) x) :
    SatisfiesM q (f <*> x) :=
  hf.seq hx fun hf ha => ha hf

/-- `SatisfiesM` distributes over `<*`, general version. -/
protected theorem seqLeft [Applicative m] [LawfulApplicative m] {x : m α}
    (hx : SatisfiesM p₁ x) (hy : SatisfiesM p₂ y)
    (H : ∀ {a b}, p₁ a → p₂ b → q a) : SatisfiesM q (x <* y) :=
  seqLeft_eq x y ▸ (hx.map fun h _ => H h).seq_pre hy

/-- `SatisfiesM` distributes over `*>`, general version. -/
protected theorem seqRight [Applicative m] [LawfulApplicative m] {x : m α}
    (hx : SatisfiesM p₁ x) (hy : SatisfiesM p₂ y)
    (H : ∀ {a b}, p₁ a → p₂ b → q b) : SatisfiesM q (x *> y) :=
  seqRight_eq x y ▸ (hx.map fun h _ => H h).seq_pre hy

/-- `SatisfiesM` distributes over `>>=`, general version. -/
protected theorem bind [Monad m] [LawfulMonad m] {f : α → m β}
    (hx : SatisfiesM p x) (hf : ∀ a, p a → SatisfiesM q (f a)) :
    SatisfiesM q (x >>= f) := by
  match x, hx with | _, ⟨x, rfl⟩ => ?_
  have g a ha := Classical.indefiniteDescription _ (hf a ha)
  refine ⟨x >>= fun ⟨a, h⟩ => g a h, ?_⟩
  simp [← bind_pure_comp]; congr; funext ⟨a, h⟩; simp [← (g a h).2, ← bind_pure_comp]

/-- `SatisfiesM` distributes over `>>=`, weakest precondition version. -/
protected theorem bind_pre [Monad m] [LawfulMonad m] {f : α → m β}
    (hx : SatisfiesM (fun a => SatisfiesM q (f a)) x) :
    SatisfiesM q (x >>= f) := hx.bind fun _ h => h

end SatisfiesM

@[simp] theorem SatisfiesM_Id_eq : SatisfiesM (m := Id) p x ↔ p x :=
  ⟨fun ⟨y, eq⟩ => eq ▸ y.2, fun h => ⟨⟨_, h⟩, rfl⟩⟩

@[simp] theorem SatisfiesM_Option_eq : SatisfiesM (m := Option) p x ↔ ∀ a, x = some a → p a :=
  ⟨by revert x; intro | some _, ⟨some ⟨_, h⟩, rfl⟩, _, rfl => exact h,
   fun h => match x with | some a => ⟨some ⟨a, h _ rfl⟩, rfl⟩ | none => ⟨none, rfl⟩⟩

@[simp] theorem SatisfiesM_Except_eq : SatisfiesM (m := Except ε) p x ↔ ∀ a, x = .ok a → p a :=
  ⟨by revert x; intro | .ok _, ⟨.ok ⟨_, h⟩, rfl⟩, _, rfl => exact h,
   fun h => match x with | .ok a => ⟨.ok ⟨a, h _ rfl⟩, rfl⟩ | .error e => ⟨.error e, rfl⟩⟩

theorem SatisfiesM_EStateM_eq :
    SatisfiesM (m := EStateM ε σ) p x ↔ ∀ s a s', x.run s = .ok a s' → p a := by
  constructor
  · rintro ⟨x, rfl⟩ s a s' h
    match w : x.run s with
    | .ok a s' => simp at h; exact h.1
    | .error e s' => simp [w] at h
  · intro w
    refine ⟨?_, ?_⟩
    · intro s
      match q : x.run s with
      | .ok a s' => exact .ok ⟨a, w s a s' q⟩ s'
      | .error e s' => exact .error e s'
    · ext s
      rw [EStateM.run_map, EStateM.run]
      split <;> simp_all

theorem SatisfiesM_ReaderT_eq [Monad m] :
    SatisfiesM (m := ReaderT ρ m) p x ↔ ∀ s, SatisfiesM p (x.run s) :=
  (exists_congr fun a => by exact ⟨fun eq _ => eq ▸ rfl, funext⟩).trans Classical.skolem.symm

theorem SatisfiesM_StateRefT_eq [Monad m] :
    SatisfiesM (m := StateRefT' ω σ m) p x ↔ ∀ s, SatisfiesM p (x s) := by
  simp [SatisfiesM_ReaderT_eq, ReaderT.run]

theorem SatisfiesM_StateT_eq [Monad m] [LawfulMonad m] :
    SatisfiesM (m := StateT ρ m) (α := α) p x ↔ ∀ s, SatisfiesM (m := m) (p ·.1) (x.run s) := by
  change SatisfiesM (m := StateT ρ m) (α := α) p x ↔ ∀ s, SatisfiesM (m := m) (p ·.1) (x s)
  refine .trans ⟨fun ⟨f, eq⟩ => eq ▸ ?_, fun ⟨f, h⟩ => ?_⟩ Classical.skolem.symm
  · refine ⟨fun s => (fun ⟨⟨a, h⟩, s'⟩ => ⟨⟨a, s'⟩, h⟩) <$> f s, fun s => ?_⟩
    rw [← comp_map, map_eq_pure_bind]; rfl
  · refine ⟨fun s => (fun ⟨⟨a, s'⟩, h⟩ => ⟨⟨a, h⟩, s'⟩) <$> f s, funext fun s => ?_⟩
    show _ >>= _ = _; simp [← h]

theorem SatisfiesM_ExceptT_eq [Monad m] [LawfulMonad m] :
    SatisfiesM (m := ExceptT ρ m) (α := α) p x ↔
      SatisfiesM (m := m) (∀ a, · = .ok a → p a) x.run := by
  change _ ↔ SatisfiesM (m := m) (∀ a, · = .ok a → p a) x
  refine ⟨fun ⟨f, eq⟩ => eq ▸ ?_, fun ⟨f, eq⟩ => eq ▸ ?_⟩
  · exists (fun | .ok ⟨a, h⟩ => ⟨.ok a, fun | _, rfl => h⟩ | .error e => ⟨.error e, nofun⟩) <$> f
    show _ = _ >>= _; rw [← comp_map, map_eq_pure_bind]; congr; funext a; cases a <;> rfl
  · exists ((fun | ⟨.ok a, h⟩ => .ok ⟨a, h _ rfl⟩ | ⟨.error e, _⟩ => .error e) <$> f : m _)
    show _ >>= _ = _; simp [← bind_pure_comp]; congr; funext ⟨a, h⟩; cases a <;> rfl

/--
If a monad has `MonadSatisfying m`, then we can lift a `h : SatisfiesM (m := m) p x` predicate
to monadic value `satisfying x p : m { x // p x }`.

Reader, state, and exception monads have `MonadSatisfying` instances if the base monad does.
-/
class MonadSatisfying (m : Type u → Type v) [Functor m] [LawfulFunctor m] where
  /-- Lift a `SatisfiesM` predicate to a monadic value. -/
  satisfying {p : α → Prop} {x : m α} (h : SatisfiesM (m := m) p x) : m {a // p a}
  /-- The value of the lifted monadic value is equal to the original monadic value. -/
  val_eq {p : α → Prop} {x : m α} (h : SatisfiesM (m := m) p x) : Subtype.val <$> satisfying h = x

export MonadSatisfying (satisfying)

namespace MonadSatisfying

instance : MonadSatisfying Id where
  satisfying {α p x} h := ⟨x, by obtain ⟨⟨_, h⟩, rfl⟩ := h; exact h⟩
  val_eq {α p x} h := rfl

instance : MonadSatisfying Option where
  satisfying {α p x?} h :=
    have h' := SatisfiesM_Option_eq.mp h
    match x? with
    | none => none
    | some x => some ⟨x, h' x rfl⟩
  val_eq {α p x?} h := by cases x? <;> simp

instance : MonadSatisfying (Except ε) where
  satisfying {α p x?} h :=
    have h' := SatisfiesM_Except_eq.mp h
    match x? with
    | .ok x => .ok ⟨x, h' x rfl⟩
    | .error e => .error e
  val_eq {α p x?} h := by cases x? <;> simp

instance [Monad m] [LawfulMonad m][MonadSatisfying m] : MonadSatisfying (ReaderT ρ m) where
  satisfying {α p x} h :=
    have h' := SatisfiesM_ReaderT_eq.mp h
    fun r => satisfying (h' r)
  val_eq {α p x} h := by
    have h' := SatisfiesM_ReaderT_eq.mp h
    ext r
    rw [ReaderT.run_map, ← MonadSatisfying.val_eq (h' r)]
    rfl

instance [Monad m] [LawfulMonad m] [MonadSatisfying m] : MonadSatisfying (StateRefT' ω σ m) :=
  inferInstanceAs <| MonadSatisfying (ReaderT _ _)

instance [Monad m] [LawfulMonad m] [MonadSatisfying m] : MonadSatisfying (StateT ρ m) where
  satisfying {α p x} h :=
    have h' := SatisfiesM_StateT_eq.mp h
    fun r => (fun ⟨⟨a, r'⟩, h⟩ => ⟨⟨a, h⟩, r'⟩) <$> satisfying (h' r)
  val_eq {α p x} h := by
    have h' := SatisfiesM_StateT_eq.mp h
    ext r
    rw [← MonadSatisfying.val_eq (h' r), StateT.run_map]
    simp [StateT.run]

instance [Monad m] [LawfulMonad m] [MonadSatisfying m] : MonadSatisfying (ExceptT ε m) where
  satisfying {α p x} h :=
    let x' := satisfying (SatisfiesM_ExceptT_eq.mp h)
    ExceptT.mk ((fun ⟨y, w⟩ => y.pmap fun a h => ⟨a, w _ h⟩) <$> x')
  val_eq {α p x} h := by
    ext
    refine Eq.trans ?_ (MonadSatisfying.val_eq (SatisfiesM_ExceptT_eq.mp h))
    simp

instance : MonadSatisfying (EStateM ε σ) where
  satisfying {α p x} h :=
    have h' := SatisfiesM_EStateM_eq.mp h
    fun s => match w : x.run s with
    | .ok a s' => .ok ⟨a, h' s a s' w⟩ s'
    | .error e s' => .error e s'
  val_eq {α p x} h := by
    ext s
    rw [EStateM.run_map, EStateM.run]
    split <;> simp_all

end MonadSatisfying



=== LEAN SOURCE: Attr.lean ===
/-
Copyright (c) 2023 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Lean.Server.CodeActions.Basic

/-!
# Initial setup for code action attributes

* `@[hole_code_action]` and `@[command_code_action]` now live in the Lean repository,
  and are builtin.

* Attribute `@[tactic_code_action]` collects code actions which will be called
  on each occurrence of a tactic.
-/
namespace Batteries.CodeAction

open Lean Elab Server Lsp RequestM Snapshots

/-- A tactic code action extension. -/
abbrev TacticCodeAction :=
  CodeActionParams → Snapshot →
  (ctx : ContextInfo) → (stack : Syntax.Stack) → (node : InfoTree) →
  RequestM (Array LazyCodeAction)

/-- A tactic code action extension. -/
abbrev TacticSeqCodeAction :=
  CodeActionParams → Snapshot →
  (ctx : ContextInfo) → (i : Nat) → (stack : Syntax.Stack) → (goals : List MVarId) →
  RequestM (Array LazyCodeAction)

/-- Read a tactic code action from a declaration of the right type. -/
def mkTacticCodeAction (n : Name) : ImportM TacticCodeAction := do
  let { env, opts, .. } ← read
  IO.ofExcept <| unsafe env.evalConstCheck TacticCodeAction opts ``TacticCodeAction n

/-- Read a tacticSeq code action from a declaration of the right type. -/
def mkTacticSeqCodeAction (n : Name) : ImportM TacticSeqCodeAction := do
  let { env, opts, .. } ← read
  IO.ofExcept <| unsafe env.evalConstCheck TacticSeqCodeAction opts ``TacticSeqCodeAction n

/-- An entry in the tactic code actions extension, containing the attribute arguments. -/
structure TacticCodeActionEntry where
  /-- The declaration to tag -/
  declName : Name
  /-- The tactic kinds that this extension supports. If empty it is called on all tactic kinds. -/
  tacticKinds : Array Name
  deriving Inhabited

/-- The state of the tactic code actions extension. -/
structure TacticCodeActions where
  /-- The list of tactic code actions to apply on any tactic. -/
  onAnyTactic : Array TacticCodeAction := {}
  /-- The list of tactic code actions to apply when a particular tactic kind is highlighted. -/
  onTactic : NameMap (Array TacticCodeAction) := {}
  deriving Inhabited

/-- Insert a tactic code action entry into the `TacticCodeActions` structure. -/
def TacticCodeActions.insert (self : TacticCodeActions)
    (tacticKinds : Array Name) (action : TacticCodeAction) : TacticCodeActions :=
  if tacticKinds.isEmpty then
    { self with onAnyTactic := self.onAnyTactic.push action }
  else
    { self with onTactic := tacticKinds.foldl (init := self.onTactic) fun m a =>
        m.insert a ((m.findD a #[]).push action) }

/-- An extension which collects all the tactic code actions. -/
initialize tacticSeqCodeActionExt :
    PersistentEnvExtension Name (Name × TacticSeqCodeAction)
      (Array Name × Array TacticSeqCodeAction) ←
  registerPersistentEnvExtension {
    mkInitial := pure (#[], #[])
    addImportedFn := fun as => return (#[], ← as.foldlM (init := #[]) fun m as =>
      as.foldlM (init := m) fun m a => return m.push (← mkTacticSeqCodeAction a))
    addEntryFn := fun (s₁, s₂) (n₁, n₂) => (s₁.push n₁, s₂.push n₂)
    exportEntriesFn := (·.1)
  }

/-- An extension which collects all the tactic code actions. -/
initialize tacticCodeActionExt :
    PersistentEnvExtension TacticCodeActionEntry (TacticCodeActionEntry × TacticCodeAction)
      (Array TacticCodeActionEntry × TacticCodeActions) ←
  registerPersistentEnvExtension {
    mkInitial := pure (#[], {})
    addImportedFn := fun as => return (#[], ← as.foldlM (init := {}) fun m as =>
      as.foldlM (init := m) fun m ⟨name, kinds⟩ =>
        return m.insert kinds (← mkTacticCodeAction name))
    addEntryFn := fun (s₁, s₂) (e, n₂) => (s₁.push e, s₂.insert e.tacticKinds n₂)
    exportEntriesFn := (·.1)
  }

/--
This attribute marks a code action, which is used to suggest new tactics or replace existing ones.

* `@[tactic_code_action]`: This is a code action which applies to the spaces between tactics,
  to suggest a new tactic to change the goal state.

* `@[tactic_code_action kind]`: This is a code action which applies to applications of the tactic
  `kind` (a tactic syntax kind), which can replace the tactic or insert things before or after it.

* `@[tactic_code_action kind₁ kind₂]`: shorthand for
  `@[tactic_code_action kind₁, tactic_code_action kind₂]`.

* `@[tactic_code_action *]`: This is a tactic code action that applies to all tactics.
  Use sparingly.
-/
syntax (name := tactic_code_action) "tactic_code_action" ("*" <|> (ppSpace ident)*) : attr

initialize
  registerBuiltinAttribute {
    name := `tactic_code_action
    descr := "Declare a new tactic code action, to appear in the code actions on tactics"
    applicationTime := .afterCompilation
    add := fun decl stx kind => do
      unless kind == AttributeKind.global do
        throwError "invalid attribute 'tactic_code_action', must be global"
      match stx with
      | `(attr| tactic_code_action *) =>
        if (IR.getSorryDep (← getEnv) decl).isSome then return -- ignore in progress definitions
        modifyEnv (tacticCodeActionExt.addEntry · (⟨decl, #[]⟩, ← mkTacticCodeAction decl))
      | `(attr| tactic_code_action $[$args]*) =>
        if args.isEmpty then
          if (IR.getSorryDep (← getEnv) decl).isSome then return -- ignore in progress definitions
          modifyEnv (tacticSeqCodeActionExt.addEntry · (decl, ← mkTacticSeqCodeAction decl))
        else
          let args ← args.mapM realizeGlobalConstNoOverloadWithInfo
          if (IR.getSorryDep (← getEnv) decl).isSome then return -- ignore in progress definitions
          modifyEnv (tacticCodeActionExt.addEntry · (⟨decl, args⟩, ← mkTacticCodeAction decl))
      | _ => pure ()
  }



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2023 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Lean.Elab.BuiltinTerm
import Lean.Elab.BuiltinNotation
import Lean.Server.InfoUtils
import Lean.Server.CodeActions.Provider
import Batteries.CodeAction.Attr

/-!
# Initial setup for code actions

This declares a code action provider that calls all `@[hole_code_action]` definitions
on each occurrence of a hole (`_`, `?_` or `sorry`).

(This is in a separate file from `Batteries.CodeAction.Hole.Attr` so that the server does not
attempt to use this code action provider when browsing the `Batteries.CodeAction.Hole.Attr` file
itself.)
-/
namespace Batteries.CodeAction

open Lean Elab Server RequestM CodeAction

/-- A code action which calls `@[tactic_code_action]` code actions. -/
@[code_action_provider] def tacticCodeActionProvider : CodeActionProvider := fun params snap => do
  let doc ← readDoc
  let startPos := doc.meta.text.lspPosToUtf8Pos params.range.start
  let endPos := doc.meta.text.lspPosToUtf8Pos params.range.end
  let pointerCol :=
    if params.range.start.line == params.range.end.line then
      max params.range.start.character params.range.end.character
    else 0
  let some result := findTactic?
    (fun pos => (doc.meta.text.utf8PosToLspPos pos).character ≤ pointerCol)
    ⟨startPos, endPos⟩ snap.stx | return #[]
  let tgtTac := match result with
    | .tactic (tac :: _)
    | .tacticSeq _ _ (_ :: tac :: _) => tac.1
    | _ => unreachable!
  let tgtRange := tgtTac.getRange?.get!
  have info := findInfoTree? tgtTac.getKind tgtRange none snap.infoTree (canonicalOnly := true)
    fun _ info => info matches .ofTacticInfo _
  let some (ctx, node@(.node (.ofTacticInfo info) _)) := info | return #[]
  let mut out := #[]
  match result with
  | .tactic stk@((tac, _) :: _) => do
    let ctx := { ctx with mctx := info.mctxBefore }
    let actions := (tacticCodeActionExt.getState snap.env).2
    if let some arr := actions.onTactic.find? tac.getKind then
      for act in arr do
        try out := out ++ (← act params snap ctx stk node) catch _ => pure ()
    for act in actions.onAnyTactic do
      try out := out ++ (← act params snap ctx stk node) catch _ => pure ()
  | .tacticSeq _ i stk@((seq, _) :: _) =>
    let (ctx, goals) ← if 2*i < seq.getNumArgs then
      let stx := seq[2*i]
      let some stxRange := stx.getRange? | return #[]
      let some (ctx, .node (.ofTacticInfo info') _) :=
          findInfoTree? stx.getKind stxRange ctx node fun _ info => (info matches .ofTacticInfo _)
        | return #[]
      pure ({ ctx with mctx := info'.mctxBefore }, info'.goalsBefore)
    else
      pure ({ ctx with mctx := info.mctxAfter }, info.goalsAfter)
    for act in (tacticSeqCodeActionExt.getState snap.env).2 do
      try out := out ++ (← act params snap ctx i stk goals) catch _ => pure ()
  | _ => unreachable!
  pure out



=== LEAN SOURCE: Deprecated.lean ===
/-
Copyright (c) 2023 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Lean.Server.CodeActions.Provider

/-!
# Code action for @[deprecated] replacements

This is an opt-in mechanism for making machine-applicable `@[deprecated]` definitions. When enabled
(by setting the `machineApplicableDeprecated` tag attribute), a code action will be triggered
whenever the deprecation lint also fires, allowing the user to replace the usage of the deprecated
constant.
-/

namespace Batteries

open Lean Elab Server Lsp RequestM CodeAction

/-- An environment extension for identifying `@[deprecated]` definitions which can be auto-fixed -/
initialize machineApplicableDeprecated : TagDeclarationExtension ← mkTagDeclarationExtension

namespace CodeAction

/-- A code action which applies replacements for `@[deprecated]` definitions. -/
@[code_action_provider]
def deprecatedCodeActionProvider : CodeActionProvider := fun params snap => do
  let mut i := 0
  let doc ← readDoc
  let mut msgs := #[]
  for m in snap.msgLog.toList do
    if m.data.isDeprecationWarning then
      if h : _ then
        msgs := msgs.push (snap.cmdState.messages.toList[i]'h)
    i := i + 1
  if msgs.isEmpty then return #[]
  let start := doc.meta.text.lspPosToUtf8Pos params.range.start
  let stop := doc.meta.text.lspPosToUtf8Pos params.range.end
  for msg in msgs do
    let some endPos := msg.endPos | continue
    let pos := doc.meta.text.ofPosition msg.pos
    let endPos' := doc.meta.text.ofPosition endPos
    unless start ≤ endPos' && pos ≤ stop do continue
    let some (ctx, .node (.ofTermInfo info@{ expr := .const c .., ..}) _) :=
      findInfoTree? identKind ⟨pos, endPos'⟩ none snap.infoTree fun _ i =>
        (i matches .ofTermInfo { elaborator := .anonymous, expr := .const .., ..})
      | continue
    unless machineApplicableDeprecated.isTagged snap.cmdState.env c do continue
    let some c' := Linter.getDeprecatedNewName snap.cmdState.env c | continue
    let eager : CodeAction := {
      title := s!"Replace {c} with {c'}"
      kind? := "quickfix"
      isPreferred? := true
    }
    return #[{
      eager
      lazy? := some do
        let c' ← info.runMetaM ctx (unresolveNameGlobal c')
        let pos := doc.meta.text.leanPosToLspPos msg.pos
        let endPos' := doc.meta.text.leanPosToLspPos endPos
        pure { eager with
          edit? := some <| .ofTextEdit doc.versionedIdentifier {
            range := ⟨pos, endPos'⟩
            newText := toString c'
          }
        }
    }]
  return #[]



=== LEAN SOURCE: Match.lean ===
import Batteries.CodeAction.Misc
import Batteries.Data.List

namespace Batteries.CodeAction

open Lean Meta Elab Server RequestM CodeAction


/-- Filter for the info-nodes to find the match-nodes. -/
def isMatchTerm : Info → Bool
  | .ofTermInfo i => i.stx.isOfKind ``Lean.Parser.Term.match
  | _ => false

/-- Returns the String.range that encompasses `match e (with)`. -/
def getMatchHeaderRange? (matchStx : Syntax) : Option String.Range := do
  match matchStx with
  | `(term| match
    $[(generalizing := $generalizingVal)]?
    $[(motive := $motiveVal)]?
    $[$discrs:matchDiscr],*
    with $_) => --Here the $alts would go, if they were already typed. Else $_  will match "missing"

    -- Isolate the syntax of only the "match" atom to get the starting position:
    let mStx ← matchStx.getArgs.find? (fun s => s.isAtom && s.getAtomVal == "match")
    let startPos ← mStx.getPos? -- begin of 'match' keyword

    -- Depending on the existence of 'with', return the correct range:
    if let some withStx := (matchStx.getArgs.find? (fun s => s.isAtom && s.getAtomVal == "with"))
      then return ⟨startPos, ←withStx.getTailPos?⟩
    else
      let lastMatchDiscr ← discrs.back?
      return ⟨startPos, ←lastMatchDiscr.raw.getTailPos?⟩
  | _ => none

/-- Flattens an Infotree into an array of Info-nodes that fulfill p. -/
partial def findAllInfos (p : Info → Bool) (t : InfoTree) : Array Info :=
  loop t #[]
where
  /-- Inner loop for `findAllInfos`. -/
  loop (t : InfoTree) (acc : Array Info) : Array Info :=
    match t with
    | .context _ childTree => loop childTree acc
    | .node info children  =>
      let acc' := if p info then acc.push info else acc
      children.foldl (fun currentAcc child => loop child currentAcc) acc'
    | .hole _              => acc

/-- From a constructor-name e.g. 'Option.some' construct the corresponding match pattern, e.g.
'.some val'. We implement special cases for Nat and List, Option and Bool to e.g.
produce 'n + 1' instead of 'Nat.succ n'.
-/
def pattern_from_constructor (ctor : Name) (env : Environment) (suffix : String)
    : Option String := do
  let some (.ctorInfo ci) := env.find? ctor | panic! "bad inductive"
  let ctor_short := toString (ctor.updatePrefix .anonymous)
  let mut str := ""
  let explicit_args := getExplicitArgs ci.type #[]
  match ctor with
  | (.str (.str .anonymous "Nat") "zero") => "0"
  /- At the moment this evaluates to "n + 1": -/
  | (.str (.str .anonymous "Nat") "succ") => s!"{explicit_args[0]!}{suffix} + 1" --
  | (.str (.str .anonymous "List") "nil") => "[]"
  /- At the moment this evaluates to "head :: tail": -/
  | (.str (.str .anonymous "List") "cons") =>
    s!"{explicit_args[0]!}{suffix} :: {explicit_args[1]!}{suffix}"
  | (.str (.str .anonymous "Option") "some") => s!"some {explicit_args[0]!}{suffix}"
  | (.str (.str .anonymous "Option") "none") => "none"
  | (.str (.str .anonymous "Bool") "true") => "true"
  | (.str (.str .anonymous "Bool") "false") => "false"
  /- Default case: -/
  | _ =>
    str := str ++ s!".{ctor_short}"
    for arg in explicit_args do
      /- This takes the variable names `arg` which were used in the
      inductive type specification. When using this action with multiple (same-type)
      arguments these might clash, so we fix it by appending a suffix like `_2` -
      you will probably want to rename these suffixed names yourself. -/
      str := str ++ if arg.hasNum || arg.isInternal then " _" else s!" {arg}{suffix}"
    return str

/--
Invoking tactic code action "Generate a list of alternatives for this match." in the
following:
```lean
def myfun2 (n : Nat) : Nat :=
  match n
```
produces:
```lean
def myfun2 (n : Nat) : Nat :=
  match n with
  | 0 => _
  | n + 1 => _
```
Also has support for multiple discriminants, e.g.
```
def myfun3 (o : Option Bool) (m : Nat) : Nat :=
  match o, m with
```
can be expanded into
```
def myfun3 (o : Option Bool) (m : Nat) : Nat :=
  match o, m with
  | none, 0 => _
  | none, n_2 + 1 => _
  | some val_1, 0 => _
  | some val_1, n_2 + 1 => _
```
-/
@[command_code_action]
def matchExpand : CommandCodeAction := fun CodeActionParams snap ctx node => do
  /- Since `match` is a term (not a command) `@[command_code_action Parser.Term.match]` will
  not fire. So we filter `command_code_action` ourselves in Step 1 for now. -/

  /- 1. Find ALL ofTermInfo Info nodes that are of kind `Term.match` -/
  let allMatchInfos := findAllInfos isMatchTerm node

  /- 2. Filter these candidates within the `RequestM` monad based on the cursor being in the
  header lines of these matches. -/
  let doc ← readDoc
  let relevantMatchInfos ← allMatchInfos.filterM fun matchInfo => do
    let some headerRangeRaw := getMatchHeaderRange? matchInfo.stx | return false
    let headerRangeLsp := doc.meta.text.utf8RangeToLspRange headerRangeRaw

    let cursorRangeLsp := CodeActionParams.range
    -- check if the cursor range is contained in the header range
    return (cursorRangeLsp.start ≥ headerRangeLsp.start && cursorRangeLsp.end ≤ headerRangeLsp.end)

  /- 3. Pick the first (and mostly only) candidate. There might sometimes be more,
  since some things are just contained multiple times in 'node'. -/
  let some matchInfo := relevantMatchInfos[0]? | return #[]
  let some headerRangeRaw := getMatchHeaderRange? matchInfo.stx | return #[]

  /- Isolate the array of match-discriminants -/
  let discrs ← match matchInfo.stx with
  | `(term| match
    $[(generalizing := $generalizingVal)]?
    $[(motive := $motiveVal)]?
    $[$discrs:matchDiscr],*
    with $_) => pure discrs
  | _ => return #[]

  /- Reduce discrs to the array of match-discriminants-terms (i.e. "[n1, n2]" in "match n2,n2"). -/
  let some discrTerms := discrs.mapM (fun discr =>
    match discr with
    | `(matchDiscr| $t: term) => some t
    | `(matchDiscr| $_:ident : $t: term) => some t
    | _ => none
    ) | return #[]

  -- Get a Bool, that tells us if "with" is already typed in:
  let withPresent :=
    (matchInfo.stx.getArgs.find? (fun s => s.isAtom && s.getAtomVal == "with")).isSome

  /- Construct a list containing for each discriminant its list of constructor names.
  The list contains the first discriminant constructors last, since we are prepending in the loop.-/
  let mut constructors_rev : List (List Name) := []
  for discrTerm in discrTerms do
    let some (info : TermInfo) := findTermInfo? node discrTerm | return #[]
    let ty ← info.runMetaM ctx (Lean.Meta.inferType info.expr)
    let .const name _ := (← info.runMetaM ctx (whnf ty)).getAppFn | return #[]
    -- Find the inductive constructors of e:
    let some (.inductInfo val) := snap.env.find? name | return #[]
    constructors_rev := val.ctors :: constructors_rev

  let eager : Lsp.CodeAction := {
    title := "Generate a list of equations for this match."
    kind? := "quickfix"
  }

  return #[{ --rest is lightly adapted from eqnStub:
    eager
    lazy? := some do
      let holePos := headerRangeRaw.stop --where we start inserting
      let (indent, _) := findIndentAndIsStart doc.meta.text.source headerRangeRaw.start
      let mut str := if withPresent then "" else " with"

      let indent := "\n".pushn ' ' (indent) --use the same indent as the 'match' line.
      let constructor_combinations := constructors_rev.sections.map List.reverse
      for l in constructor_combinations do
        str := str ++ indent ++ "| "
        for ctor_idx in [:l.length] do
          let ctor := l[ctor_idx]!
          let suffix := if constructors_rev.length ≥ 2 then s!"_{ctor_idx + 1}" else ""
          let some pat := pattern_from_constructor ctor snap.env suffix | panic! "bad inductive"
          str := str ++ pat
          if ctor_idx < l.length - 1 then
            str := str ++ ", "
        str := str ++ s!" => _"
      pure { eager with
        edit? := some <|.ofTextEdit doc.versionedIdentifier {
          range := doc.meta.text.utf8RangeToLspRange ⟨holePos, holePos⟩-- adapted to insert-only
          newText := str
        }
      }
  }]



=== LEAN SOURCE: Misc.lean ===
/-
Copyright (c) 2023 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Lean.Elab.Tactic.Induction
import Batteries.Lean.Position
import Batteries.CodeAction.Attr
import Lean.Server.CodeActions.Provider

/-!
# Miscellaneous code actions

This declares some basic tactic code actions, using the `@[tactic_code_action]` API.
-/
namespace Batteries.CodeAction

open Lean Meta Elab Server RequestM CodeAction

/-- Return the syntax stack leading to `target` from `root`, if one exists. -/
def findStack? (root target : Syntax) : Option Syntax.Stack := do
  let range ← target.getRange?
  root.findStack? (·.getRange?.any (·.includes range))
    (fun s => s.getKind == target.getKind && s.getRange? == range)

/-- Constructs a hole with a kind matching the provided hole elaborator.  -/
def holeKindToHoleString : (elaborator : Name) → (synthName : String) → String
  | ``Elab.Term.elabSyntheticHole, name => "?" ++ name
  | ``Elab.Term.elabSorry, _ => "sorry"
  | _, _ => "_"

/--
Hole code action used to fill in a structure's field when specifying an instance.

In the following:
```lean
instance : Monad Id := _
```

invoking the hole code action "Generate a (minimal) skeleton for the structure under construction."
produces:
```lean
instance : Monad Id where
  pure := _
  bind := _
```

and invoking "Generate a (maximal) skeleton for the structure under construction." produces:
```lean
instance : Monad Id where
  map := _
  mapConst := _
  pure := _
  seq := _
  seqLeft := _
  seqRight := _
  bind := _
```
-/
@[hole_code_action] partial def instanceStub : HoleCodeAction := fun _ snap ctx info => do
  let some ty := info.expectedType? | return #[]
  let .const name _ := (← info.runMetaM ctx (whnf ty)).getAppFn | return #[]
  unless isStructure snap.env name do return #[]
  let doc ← readDoc
  let fields := collectFields snap.env name #[] []
  let only := !fields.any fun (_, auto) => auto
  let mkAutofix minimal :=
    let eager := {
      title := s!"\
        Generate a {if only then "" else if minimal then "(minimal) " else "(maximal) "}\
        skeleton for the structure under construction."
      kind? := "quickfix"
      isPreferred? := minimal
    }
    let lazy? := some do
      let useWhere := do
        let _ :: (stx, _) :: _ ← findStack? snap.stx info.stx | none
        guard (stx.getKind == ``Parser.Command.declValSimple)
        stx[0].getPos?
      let holePos := useWhere.getD info.stx.getPos?.get!
      let (indent, isStart) := findIndentAndIsStart doc.meta.text.source holePos
      let indent := "\n".pushn ' ' indent
      let mut str := if useWhere.isSome then "where" else "{"
      let mut first := useWhere.isNone && isStart
      for (field, auto) in fields do
        if minimal && auto then continue
        if first then
          str := str ++ " "
          first := false
        else
          str := str ++ indent ++ "  "
        let field := toString field
        str := str ++ s!"{field} := {holeKindToHoleString info.elaborator field}"
      if useWhere.isNone then
        if isStart then
          str := str ++ " }"
        else
          str := str ++ indent ++ "}"
      pure { eager with
        edit? := some <| .ofTextEdit doc.versionedIdentifier {
          range := doc.meta.text.utf8RangeToLspRange ⟨holePos, info.stx.getTailPos?.get!⟩
          newText := str
        }
      }
    { eager, lazy? }
  pure <| if only then #[mkAutofix true] else #[mkAutofix true, mkAutofix false]
where
  /-- Returns true if this field is an autoParam or optParam, or if it is given an optional value
  in a child struct. -/
  isAutofillable (env : Environment) (fieldInfo : StructureFieldInfo) (stack : List Name) : Bool :=
    fieldInfo.autoParam?.isSome || env.contains (mkDefaultFnOfProjFn fieldInfo.projFn)
      || stack.any fun struct => env.contains (mkDefaultFnOfProjFn (struct ++ fieldInfo.fieldName))

  /-- Returns the fields of a structure, unfolding parent structures. -/
  collectFields (env : Environment) (structName : Name)
      (fields : Array (Name × Bool)) (stack : List Name) : Array (Name × Bool) :=
    (getStructureFields env structName).foldl (init := fields) fun fields field =>
      if let some fieldInfo := getFieldInfo? env structName field then
        if let some substructName := fieldInfo.subobject? then
          collectFields env substructName fields (structName :: stack)
        else
          fields.push (field, isAutofillable env fieldInfo stack)
      else fields

/-- Returns the explicit arguments given a type. -/
def getExplicitArgs : Expr → Array Name → Array Name
  | .forallE n _ body bi, args =>
    getExplicitArgs body <| if bi.isExplicit then args.push n else args
  | _, args => args

/--
Invoking hole code action "Generate a list of equations for a recursive definition" in the
following:
```lean
def foo : Expr → Unit := _
```

produces:

```lean
def foo : Expr → Unit := fun
  | .bvar deBruijnIndex => _
  | .fvar fvarId => _
  | .mvar mvarId => _
  | .sort u => _
  | .const declName us => _
  | .app fn arg => _
  | .lam binderName binderType body binderInfo => _
  | .forallE binderName binderType body binderInfo => _
  | .letE declName type value body nonDep => _
  | .lit _ => _
  | .mdata data expr => _
  | .proj typeName idx struct => _
```

-/
@[hole_code_action] def eqnStub : HoleCodeAction := fun _ snap ctx info => do
  let some ty := info.expectedType? | return #[]
  let .forallE _ dom .. ← info.runMetaM ctx (whnf ty) | return #[]
  let .const name _ := (← info.runMetaM ctx (whnf dom)).getAppFn | return #[]
  let some (.inductInfo val) := snap.env.find? name | return #[]
  let eager := {
    title := "Generate a list of equations for a recursive definition."
    kind? := "quickfix"
  }
  let doc ← readDoc
  pure #[{
    eager
    lazy? := some do
      let holePos := info.stx.getPos?.get!
      let (indent, isStart) := findIndentAndIsStart doc.meta.text.source holePos
      let mut str := "fun"
      let indent := "\n".pushn ' ' (if isStart then indent else indent + 2)
      for ctor in val.ctors do
        let some (.ctorInfo ci) := snap.env.find? ctor | panic! "bad inductive"
        let ctor := toString (ctor.updatePrefix .anonymous)
        str := str ++ indent ++ s!"| .{ctor}"
        for arg in getExplicitArgs ci.type #[] do
          str := str ++ if arg.hasNum || arg.isInternal then " _" else s!" {arg}"
        str := str ++ s!" => {holeKindToHoleString info.elaborator ctor}"
      pure { eager with
        edit? := some <|.ofTextEdit doc.versionedIdentifier {
          range := doc.meta.text.utf8RangeToLspRange ⟨holePos, info.stx.getTailPos?.get!⟩
          newText := str
        }
      }
  }]

/-- Invoking hole code action "Start a tactic proof" will fill in a hole with `by done`. -/
@[hole_code_action] def startTacticStub : HoleCodeAction := fun _ _ _ info => do
  let holePos := info.stx.getPos?.get!
  let doc ← readDoc
  let indent := (findIndentAndIsStart doc.meta.text.source holePos).1
  pure #[{
    eager.title := "Start a tactic proof."
    eager.kind? := "quickfix"
    eager.edit? := some <|.ofTextEdit doc.versionedIdentifier {
      range := doc.meta.text.utf8RangeToLspRange ⟨holePos, info.stx.getTailPos?.get!⟩
      newText := "by\n".pushn ' ' (indent + 2) ++ "done"
    }
  }]

/-- The "Remove tactics after 'no goals'" code action deletes any tactics following a completed
proof.
```
example : True := by
  trivial
  trivial -- <- remove this, proof is already done
  rfl
```
is transformed to
```
example : True := by
  trivial
```
-/
@[tactic_code_action*]
def removeAfterDoneAction : TacticCodeAction := fun _ _ _ stk node => do
  let .node (.ofTacticInfo info) _ := node | return #[]
  unless info.goalsBefore.isEmpty do return #[]
  let _ :: (seq, i) :: _ := stk | return #[]
  let some stop := seq.getTailPos? | return #[]
  let some prev := (seq.setArgs seq.getArgs[:i]).getTailPos? | return #[]
  let doc ← readDoc
  let eager := {
    title := "Remove tactics after 'no goals'"
    kind? := "quickfix"
    isPreferred? := true
    edit? := some <|.ofTextEdit doc.versionedIdentifier {
      range := doc.meta.text.utf8RangeToLspRange ⟨prev, stop⟩
      newText := ""
    }
  }
  pure #[{ eager }]

/--
Similar to `getElimExprInfo`, but returns the names of binders instead of just the numbers;
intended for code actions which need to name the binders.
-/
def getElimExprNames (elimType : Expr) : MetaM (Array (Name × Array Name)) := do
  -- let inductVal ← getConstInfoInduct inductName
  -- let decl ← getConstInfo declName
  forallTelescopeReducing elimType fun xs type => do
    let motive  := type.getAppFn
    let targets := type.getAppArgs
    let motiveType ← inferType motive
    let mut altsInfo := #[]
    for _h : i in [:xs.size] do
      let x := xs[i]
      if x != motive && !targets.contains x then
        let xDecl ← x.fvarId!.getDecl
        if xDecl.binderInfo.isExplicit then
          let args ← forallTelescopeReducing xDecl.type fun args _ => do
            let lctx ← getLCtx
            pure <| args.filterMap fun y =>
              let yDecl := (lctx.find? y.fvarId!).get!
              if yDecl.binderInfo.isExplicit then some yDecl.userName else none
          altsInfo := altsInfo.push (xDecl.userName, args)
    pure altsInfo

/-- Finds the `TermInfo` for an elaborated term `stx`. -/
def findTermInfo? (node : InfoTree) (stx : Term) : Option TermInfo :=
  match node.findInfo? fun
    | .ofTermInfo i => i.stx.getKind == stx.raw.getKind && i.stx.getRange? == stx.raw.getRange?
    | _ => false
  with
  | some (.ofTermInfo info) => pure info
  | _ => none

/--
Invoking tactic code action "Generate an explicit pattern match for 'induction'" in the
following:
```lean
example (x : Nat) : x = x := by
  induction x
```
produces:
```lean
example (x : Nat) : x = x := by
  induction x with
  | zero => sorry
  | succ n ih => sorry
```

It also works for `cases`.
-/
@[tactic_code_action Parser.Tactic.cases Parser.Tactic.induction]
def casesExpand : TacticCodeAction := fun _ snap ctx _ node => do
  let .node (.ofTacticInfo info) _ := node | return #[]
  let (targets, induction, using_, alts) ← match info.stx with
    | `(tactic| cases $[$[$_ :]? $targets],* $[using $u]? $(alts)?) =>
      pure (targets, false, u, alts)
    | `(tactic| induction $[$[$_ :]? $targets],* $[using $u]? $[generalizing $_*]? $(alts)?) =>
      pure (targets, true, u, alts)
    | _ => return #[]
  let some discrInfos := targets.mapM (findTermInfo? node) | return #[]
  let some discr₀ := discrInfos[0]? | return #[]
  let mut some ctors ← discr₀.runMetaM ctx do
      let targets := discrInfos.map (·.expr)
      match using_ with
      | none =>
        if Tactic.tactic.customEliminators.get (← getOptions) then
          if let some elimName ← getCustomEliminator? targets induction then
            return some (← getElimExprNames (← getConstInfo elimName).type)
        matchConstInduct (← whnf (← inferType discr₀.expr)).getAppFn
            (fun _ => failure) fun val _ => do
          let elimName := if induction then mkRecName val.name else mkCasesOnName val.name
          return some (← getElimExprNames (← getConstInfo elimName).type)
      | some u =>
        let some info := findTermInfo? node u | return none
        return some (← getElimExprNames (← inferType info.expr))
    | return #[]
  let mut fallback := none
  if let some alts := alts then
    if let `(Parser.Tactic.inductionAlts| with $(_)? $alts*) := alts then
      for alt in alts do
        match alt with
        | `(Parser.Tactic.inductionAlt| | _ $_* => $fb) => fallback := fb.raw.getRange?
        | `(Parser.Tactic.inductionAlt| | $id:ident $_* => $_) =>
          ctors := ctors.filter (fun x => x.1 != id.getId)
        | _ => pure ()
  if ctors.isEmpty then return #[]
  let tacName := info.stx.getKind.updatePrefix .anonymous
  let eager := {
    title := s!"Generate an explicit pattern match for '{tacName}'."
    kind? := "quickfix"
  }
  let doc ← readDoc
  pure #[{
    eager
    lazy? := some do
      let tacPos := info.stx.getPos?.get!
      let endPos := doc.meta.text.utf8PosToLspPos info.stx.getTailPos?.get!
      let indent := "\n".pushn ' ' (findIndentAndIsStart doc.meta.text.source tacPos).1
      let (startPos, str') := if alts.isSome then
        let stx' := if fallback.isSome then
          info.stx.modifyArg (if induction then 4 else 3)
            (·.modifyArg 0 (·.modifyArg 2 (·.modifyArgs (·.filter fun s =>
              !(s matches `(Parser.Tactic.inductionAlt| | _ $_* => $_))))))
        else info.stx
        (doc.meta.text.utf8PosToLspPos stx'.getTailPos?.get!, "")
      else (endPos, " with")
      let fallback := if let some ⟨startPos, endPos⟩ := fallback then
        doc.meta.text.source.extract startPos endPos
      else
        "sorry"
      let newText := Id.run do
        let mut str := str'
        for (name, args) in ctors do
          let mut ctor := toString name
          if let some _ := (Parser.getTokenTable snap.env).find? ctor then
            ctor := s!"{idBeginEscape}{ctor}{idEndEscape}"
          str := str ++ indent ++ s!"| {ctor}"
          -- replace n_ih with just ih if there is only one
          let args := if induction &&
            args.foldl (fun c n =>
              if n.eraseMacroScopes.getString!.endsWith "_ih" then c+1 else c) 0 == 1
          then
            args.map (fun n => if !n.hasMacroScopes && n.getString!.endsWith "_ih" then `ih else n)
          else args
          for arg in args do
            str := str ++ if arg.hasNum || arg.isInternal then " _" else s!" {arg}"
          str := str ++ s!" => " ++ fallback
        str
      pure { eager with
        edit? := some <|.ofTextEdit doc.versionedIdentifier {
          range := ⟨startPos, endPos⟩
          newText
        }
      }
  }]

/-- The "Add subgoals" code action puts `· done` subgoals for any goals remaining at the end of a
proof.
```
example : True ∧ True := by
  constructor
  -- <- here
```
is transformed to
```
example : True ∧ True := by
  constructor
  · done
  · done
```
-/
def addSubgoalsActionCore (params : Lsp.CodeActionParams)
  (i : Nat) (stk : Syntax.Stack) (goals : List MVarId) : RequestM (Array LazyCodeAction) := do
  -- If there are zero goals remaining, no need to do anything
  -- If there is one goal remaining, the user can just keep typing and subgoals are not helpful
  unless goals.length > 1 do return #[]
  let seq := stk.head!.1
  let nargs := (seq.getNumArgs + 1) / 2
  unless i == nargs do -- only trigger at the end of a block
    -- or if there is only a `done` or `sorry` terminator
    unless i + 1 == nargs && [
        ``Parser.Tactic.done, ``Parser.Tactic.tacticSorry, ``Parser.Tactic.tacticAdmit
      ].contains seq[2*i].getKind do
      return #[]
  let some startPos := seq[0].getPos? true | return #[]
  let doc ← readDoc
  let eager := { title := "Add subgoals", kind? := "quickfix" }
  pure #[{
    eager
    lazy? := some do
      let indent := "\n".pushn ' ' (doc.meta.text.toPosition startPos).column
      let mut (range, newText) := (default, "")
      if let some tac := seq.getArgs[2*i]? then
        let some range2 := tac.getRange? true | return eager
        range := range2
      else
        let trimmed := seq.modifyArgs (·[:2*i])
        let some tail := trimmed.getTailPos? true | return eager
        (range, newText) := (⟨tail, tail⟩, indent)
        let cursor := doc.meta.text.lspPosToUtf8Pos params.range.end
        if range.stop ≤ cursor && cursor.1 ≤ range.stop.1 + trimmed.getTrailingSize then
          range := { range with stop := cursor }
      newText := newText ++ "· done"
      for _ in goals.tail! do
        newText := newText ++ indent ++ "· done"
      pure { eager with
        edit? := some <|.ofTextEdit doc.versionedIdentifier {
          range := doc.meta.text.utf8RangeToLspRange range
          newText
        }
      }
  }]

@[inherit_doc addSubgoalsActionCore, tactic_code_action]
def addSubgoalsSeqAction : TacticSeqCodeAction := fun params _ _ => addSubgoalsActionCore params

-- This makes sure that the addSubgoals action also triggers
-- when the cursor is on the final `done` of a tactic block
@[inherit_doc addSubgoalsActionCore,
  tactic_code_action Parser.Tactic.done Parser.Tactic.tacticSorry Parser.Tactic.tacticAdmit]
def addSubgoalsAction : TacticCodeAction := fun params _ _ stk node => do
  let (_ :: (seq, i) :: stk@(_ :: t :: _), .node (.ofTacticInfo info) _) := (stk, node) | return #[]
  unless t.1.getKind == ``Parser.Tactic.tacticSeq do return #[]
  addSubgoalsActionCore params (i/2) ((seq, 0) :: stk) info.goalsBefore



=== LEAN SOURCE: AlternativeMonad.lean ===
/-
Copyright (c) 2025 Devon Tuma. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Devon Tuma
-/
import Batteries.Control.Lemmas
import Batteries.Control.OptionT


/-!
# Laws for Monads with Failure

Definitions for monads that also have an `Alternative` instance while sharing the underlying
`Applicative` instance, and a class `LawfulAlternative` for types where the `failure` and `orElse`
operations behave in a natural way. More specifically they satisfy:

* `f <$> failure = failure`
* `failure <*> x = failure`
* `x <|> failure = x`
* `failure <|> y = y`
* `x <|> y <|> z = (x <|> y) <|> z`
* `f <$> (x <|> y) = (f <$> x <|> f <$> y)`

`Option`/`OptionT` are the most basic examples, but transformers like `StateT` also preserve
the lawfulness of this on the underlying monad.

The law `x *> failure = failure` is true for monads like `Option` and `List` that don't
have any "side effects" to execution, but not for something like `OptionT` on some monads,
so we don't include this condition.

We also define a class `LawfulAlternativeLift` similar to `LawfulMonadLift` that states that
a lifting between monads preserves `failure` and `orElse`.

## Tags

monad, alternative, failure
-/

/-- `AlternativeMonad m` means that `m` has both a `Monad` and `Alternative` instance,
which both share the same underlying `Applicative` instance.
The main example is `Option`, but many monad transformers also preserve or add this structure. -/
class AlternativeMonad (m : Type _ → Type _) extends Alternative m, Monad m

section LawfulAlternative

/-- `LawfulAlternative m` means that the `failure` operation on `m` behaves naturally
with respect to `map`, `seq`, and `orElse` operators. -/
class LawfulAlternative (m : Type _ → Type _) [Alternative m] : Prop
    extends LawfulApplicative m where
  /-- Mapping the result of a failure is still a failure -/
  map_failure (f : α → β) : f <$> (failure : m α) = failure
  /-- Sequencing a `failure` call results in failure -/
  failure_seq (x : m α) : (failure : m (α → β)) <*> x = failure
  /-- `failure` is a right identity for `orElse`. -/
  orElse_failure (x : m α) : (x <|> failure) = x
  /-- `failure` is a left identity for `orElse`. -/
  failure_orElse (y : m α) : (failure <|> y) = y
  /-- `orElse` is associative. -/
  orElse_assoc (x y z : m α) : (x <|> y <|> z) = ((x <|> y) <|> z)
  /-- `map` commutes with `orElse`. The stronger statement with `bind` generally isn't true -/
  map_orElse (x y : m α) (f : α → β) : f <$> (x <|> y) = (f <$> x <|> f <$> y)

export LawfulAlternative (map_failure failure_seq orElse_failure failure_orElse orElse_assoc
  map_orElse)
attribute [simp] map_failure failure_seq orElse_failure failure_orElse map_orElse

section Alternative

@[simp] theorem mapConst_failure [Alternative m] [LawfulAlternative m] (y : β) :
    Functor.mapConst y (failure : m α) = failure := by
  rw [LawfulFunctor.map_const, Function.comp_apply, map_failure]

@[simp] theorem mapConst_orElse [Alternative m] [LawfulAlternative m] (x x' : m α) (y : β) :
    Functor.mapConst y (x <|> x') = (Functor.mapConst y x <|> Functor.mapConst y x') := by
  simp only [map_const, Function.comp_apply, map_orElse]

@[simp] theorem failure_seqLeft [Alternative m] [LawfulAlternative m] (x : m α) :
    (failure : m β) <* x = failure := by
  simp only [seqLeft_eq, map_failure, failure_seq]

@[simp] theorem failure_seqRight [Alternative m] [LawfulAlternative m] (x : m α) :
    (failure : m β) *> x = failure := by
  simp only [seqRight_eq, map_failure, failure_seq]

end Alternative

section AlternativeMonad

@[simp] theorem failure_bind [AlternativeMonad m] [LawfulAlternative m] [LawfulMonad m]
    (x : α → m β) : failure >>= x = failure := by
  calc failure >>= x = (PEmpty.elim <$> failure) >>= x := by rw [map_failure]
    _ = failure >>= (x ∘ PEmpty.elim) := by rw [bind_map_left, Function.comp_def]
    _ = failure >>= (pure ∘ PEmpty.elim) := bind_congr fun a => a.elim
    _ = (PEmpty.elim <$> failure) >>= pure := by rw [bind_map_left, Function.comp_def]
    _ = failure := by rw [map_failure, bind_pure]

@[simp] theorem seq_failure [AlternativeMonad m] [LawfulAlternative m] [LawfulMonad m]
    (x : m (α → β)) : x <*> failure = x *> failure := by
  simp only [seq_eq_bind, map_failure, seqRight_eq, bind_map_left]

end AlternativeMonad

end LawfulAlternative

/-- Type-class for monad lifts that preserve the `Alternative` operations. -/
class LawfulAlternativeLift (m : semiOutParam (Type u → Type v)) (n : Type u → Type w)
    [Alternative m] [Alternative n] [MonadLift m n] : Prop where
  /-- Lifting preserves `failure`. -/
  monadLift_failure : monadLift (failure : m α) = (failure : n α)
  /-- Lifting preserves `orElse`. -/
  monadLift_orElse (x y : m α) : monadLift (x <|> y) = (monadLift x <|> monadLift y : n α)

export LawfulAlternativeLift (monadLift_failure monadLift_orElse)
attribute [simp] monadLift_failure monadLift_orElse

namespace Option

instance : AlternativeMonad Option.{u} where

instance : LawfulAlternative Option.{u} where
  map_failure _ := rfl
  failure_seq _ := rfl
  orElse_failure x := by cases x <;> rfl
  failure_orElse := by simp [failure]
  orElse_assoc | some _, _, _ => rfl | none, _, _ => rfl
  map_orElse | some _ => by simp | none => by simp

end Option

namespace OptionT

instance (m) [Monad m] : AlternativeMonad (OptionT m) where

instance (m) [Monad m] [LawfulMonad m] : LawfulAlternative (OptionT m) where
  map_failure _ := pure_bind _ _
  failure_seq _ := pure_bind _ _
  orElse_failure x := (bind_congr (fun | some _ => rfl | none => rfl)).trans (bind_pure x)
  failure_orElse _ := pure_bind _ _
  orElse_assoc _ _ _ := by
    simp only [OptionT.ext_iff, run_orElse, Option.elimM, bind_assoc]
    refine bind_congr fun | some _ => by simp | none => rfl
  map_orElse x y f := by
    simp only [OptionT.ext_iff, run_map, run_orElse, map_bind, bind_map_left, Option.elimM]
    refine bind_congr fun | some _ => by simp | none => rfl

end OptionT

namespace StateT

instance (m) [AlternativeMonad m] : AlternativeMonad (StateT σ m) where

instance (m) [AlternativeMonad m] [LawfulAlternative m] [LawfulMonad m] :
    LawfulAlternative (StateT σ m) where
  map_failure _ := StateT.ext fun _ => by simp only [run_map, run_failure, map_failure]
  failure_seq _ := StateT.ext fun _ => by simp only [run_seq, run_failure, failure_bind]
  orElse_failure _ := StateT.ext fun _ => orElse_failure _
  failure_orElse _ := StateT.ext fun _ => failure_orElse _
  orElse_assoc _ _ _ := StateT.ext fun _ => orElse_assoc _ _ _
  map_orElse _ _ _ := StateT.ext fun _ => by simp only [run_map, run_orElse, map_orElse]

instance (m) [AlternativeMonad m] [LawfulAlternative m] [LawfulMonad m] :
    LawfulAlternativeLift m (StateT σ m) where
  monadLift_failure {α} := StateT.ext fun s => by simp
  monadLift_orElse {α} x y := StateT.ext fun s => by simp

end StateT

namespace ReaderT

instance [AlternativeMonad m] : AlternativeMonad (ReaderT ρ m) where

instance [AlternativeMonad m] [LawfulAlternative m] : LawfulAlternative (ReaderT ρ m) where
  map_failure _ := ReaderT.ext fun _ => map_failure _
  failure_seq _ := ReaderT.ext fun _ => failure_seq _
  orElse_failure _ := ReaderT.ext fun _ => orElse_failure _
  failure_orElse _ := ReaderT.ext fun _ => failure_orElse _
  orElse_assoc _ _ _ := ReaderT.ext fun _ => orElse_assoc _ _ _
  map_orElse _ _ _ := ReaderT.ext fun _ => by simp only [run_map, run_orElse, map_orElse]

instance [AlternativeMonad m] : LawfulAlternativeLift m (ReaderT ρ m) where
  monadLift_failure {α} := ReaderT.ext fun s => by simp
  monadLift_orElse {α} x y := ReaderT.ext fun s => by simp

end ReaderT

namespace StateRefT'

instance [AlternativeMonad m] : AlternativeMonad (StateRefT' ω σ m) where

instance [AlternativeMonad m] [LawfulAlternative m] :
    LawfulAlternative (StateRefT' ω σ m) :=
  inferInstanceAs (LawfulAlternative (ReaderT _ _))

instance [AlternativeMonad m] : LawfulAlternativeLift m (StateRefT' ω σ m) :=
  inferInstanceAs (LawfulAlternativeLift m (ReaderT _ _))

end StateRefT'



=== LEAN SOURCE: ForInStep.lean ===
import Batteries.Control.ForInStep.Basic
import Batteries.Control.ForInStep.Lemmas



=== LEAN SOURCE: LawfulMonadState.lean ===
/-
Copyright (c) 2025 Devon Tuma. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Devon Tuma, Quang Dao
-/

/-!
# Laws for Monads with State

This file defines a typeclass for `MonadStateOf` with compatible `get` and `set` operations.

Note that we use `MonadStateOf` over `MonadState` as the first induces the second,
but we phrase things using `MonadStateOf.set` and `MonadState.get` as those are the
versions that are available at the top level namespace.
-/

/-- The namespaced `MonadStateOf.get` is equal to the `MonadState` provided `get`. -/
@[simp] theorem monadStateOf_get_eq_get [MonadStateOf σ m] :
    (MonadStateOf.get : m σ) = get := rfl

/-- The namespaced `MonadStateOf.modifyGet` is equal to the `MonadState` provided `modifyGet`. -/
@[simp] theorem monadStateOf_modifyGet_eq_modifyGet [MonadStateOf σ m]
    (f : σ → α × σ) : (MonadStateOf.modifyGet f : m α) = modifyGet f := rfl

@[simp] theorem liftM_get {m n}  [MonadStateOf σ m] [MonadLift m n] :
    (liftM (get (m := m)) : n _) = get := rfl

@[simp] theorem liftM_set {m n} [MonadStateOf σ m] [MonadLift m n]
    (s : σ) : (liftM (set (m := m) s) : n _) = set s := rfl

@[simp] theorem liftM_modify {m n} [MonadStateOf σ m] [MonadLift m n]
    (f : σ → σ) : (liftM (modify (m := m) f) : n _) = modify f := rfl

@[simp] theorem liftM_modifyGet {m n} [MonadStateOf σ m] [MonadLift m n]
    (f : σ → α × σ) : (liftM (modifyGet (m := m) f) : n _) = modifyGet f := rfl

@[simp] theorem liftM_getModify {m n} [MonadStateOf σ m] [MonadLift m n]
    (f : σ → σ) : (liftM (getModify (m := m) f) : n _) = getModify f := rfl

/-- Class for well behaved state monads, extending the base `MonadState` type.
Requires that `modifyGet` is equal to the same definition with only `get` and `set`,
that `get` is idempotent if the result isn't used, and that `get` after `set` returns
exactly the value that was previously `set`. -/
class LawfulMonadStateOf (σ : semiOutParam (Type _)) (m : Type _ → Type _)
    [Monad m] [MonadStateOf σ m] extends LawfulMonad m where
  /-- `modifyGet f` is equal to getting the state, modifying it, and returning a result. -/
  modifyGet_eq {α} (f : σ → α × σ) :
    modifyGet (m := m) f = do let z ← f <$> get; set z.2; return z.1
  /-- Discarding the result of `get` is the same as never getting the state. -/
  get_bind_const {α} (mx : m α) : (do let _ ← get; mx) = mx
  /-- Calling `get` twice is the same as just using the first retreived state value. -/
  get_bind_get_bind {α} (mx : σ → σ → m α) :
    (do let s ← get; let s' ← get; mx s s') = (do let s ← get; mx s s)
  /-- Setting the monad state to its current value has no effect. -/
  get_bind_set_bind {α} (mx : σ → PUnit → m α) :
    (do let s ← get; let u ← set s; mx s u) = (do let s ← get; mx s PUnit.unit)
  /-- Setting and then returning the monad state is the same as returning the set value. -/
  set_bind_get (s : σ) : (do set (m := m) s; get) = (do set s; return s)
  /-- Setting the monad twice is the same as just setting to the final state. -/
  set_bind_set (s s' : σ) : (do set (m := m) s; set s') = set s'

namespace LawfulMonadStateOf

variable {σ : Type _} {m : Type _ → Type _} [Monad m]
  [MonadStateOf σ m] [LawfulMonadStateOf σ m]

attribute [simp] get_bind_const get_bind_get_bind get_bind_set_bind set_bind_get set_bind_set

@[simp] theorem get_seqRight (mx : m α) : get *> mx = mx := by
  rw [seqRight_eq_bind, get_bind_const]

@[simp] theorem seqLeft_get (mx : m α) : mx <* get = mx := by
  simp only [seqLeft_eq_bind, get_bind_const, bind_pure]

@[simp] theorem get_map_const (x : α) :
    (fun _ => x) <$> get (m := m) = pure x := by
  rw [map_eq_pure_bind, get_bind_const]

theorem get_bind_get : (do let _ ← get (m := m); get) = get := get_bind_const get

@[simp] theorem get_bind_set :
    (do let s ← get (m := m); set s) = return PUnit.unit := by
  simpa only [bind_pure_comp, id_map', get_map_const] using
    get_bind_set_bind (σ := σ) (m := m) (fun _ _ => return PUnit.unit)

@[simp] theorem get_bind_map_set (f : σ → PUnit → α) :
    (do let s ← get (m := m); f s <$> set s) = (do return f (← get) PUnit.unit) := by
  simp [map_eq_pure_bind, -bind_pure_comp]

@[simp] theorem set_bind_get_bind (s : σ) (f : σ → m α) :
    (do set s; let s' ← get; f s') = (do set s; f s) := by
  rw [← bind_assoc, set_bind_get, bind_assoc, pure_bind]

@[simp] theorem set_bind_map_get (f : σ → α) (s : σ) :
    (do set (m := m) s; f <$> get) = (do set (m := m) s; pure (f s)) := by
  simp [map_eq_pure_bind, -bind_pure_comp]

@[simp] theorem set_bind_set_bind (s s' : σ) (mx : m α) :
    (do set s; set s'; mx) = (do set s'; mx) := by
  rw [← bind_assoc, set_bind_set]

@[simp] theorem set_bind_map_set (s s' : σ) (f : PUnit → α) :
    (do set (m := m) s; f <$> set s') = (do f <$> set s') := by
  simp [map_eq_pure_bind, ← bind_assoc, -bind_pure_comp]

section modify

theorem modifyGetThe_eq (f : σ → α × σ) :
    modifyGetThe σ (m := m) f = do let z ← f <$> get; set z.2; return z.1 := modifyGet_eq f

theorem modify_eq (f : σ → σ) :
    modify (m := m) f = (do set (f (← get))) := by simp [modify, modifyGet_eq]

theorem modifyThe_eq (f : σ → σ) :
    modifyThe σ (m := m) f = (do set (f (← get))) := modify_eq f

theorem getModify_eq (f : σ → σ) :
    getModify (m := m) f = do let s ← get; set (f s); return s := by
  rw [getModify, modifyGet_eq, bind_map_left]

/-- Version of `modifyGet_eq` that preserves an call to `modify`. -/
theorem modifyGet_eq' (f : σ → α × σ) :
    modifyGet (m := m) f = do let s ← get; modify (Prod.snd ∘ f); return (f s).fst := by
  simp [modify_eq, modifyGet_eq]

@[simp] theorem modify_id : modify (m := m) id = pure PUnit.unit := by
  simp [modify_eq]

@[simp] theorem getModify_id : getModify (m := m) id = get := by
  simp [getModify_eq]

@[simp] theorem set_bind_modify (s : σ) (f : σ → σ) :
    (do set (m := m) s; modify f) = set (f s) := by simp [modify_eq]

@[simp] theorem set_bind_modify_bind (s : σ) (f : σ → σ) (mx : PUnit → m α) :
    (do set s; let u ← modify f; mx u) = (do set (f s); mx PUnit.unit) := by
  simp [modify_eq, ← bind_assoc]

@[simp] theorem set_bind_modifyGet (s : σ) (f : σ → α × σ) :
    (do set (m := m) s; modifyGet f) = (do set (f s).2; return (f s).1) := by simp [modifyGet_eq]

@[simp] theorem set_bind_modifyGet_bind (s : σ) (f : σ → α × σ) (mx : α → m β) :
    (do set s; let x ← modifyGet f; mx x) = (do set (f s).2; mx (f s).1) := by simp [modifyGet_eq]

@[simp] theorem set_bind_getModify (s : σ) (f : σ → σ) :
    (do set (m := m) s; getModify f) = (do set (f s); return s) := by simp [getModify_eq]

@[simp] theorem set_bind_getModify_bind (s : σ) (f : σ → σ) (mx : σ → m α) :
    (do set s; let x ← getModify f; mx x) = (do set (f s); mx s) := by
  simp [getModify_eq, ← bind_assoc]

@[simp] theorem modify_bind_modify (f g : σ → σ) :
    (do modify (m := m) f; modify g) = modify (g ∘ f) := by simp [modify_eq]

@[simp] theorem modify_bind_modifyGet (f : σ → σ) (g : σ → α × σ) :
    (do modify (m := m) f; modifyGet g) = modifyGet (g ∘ f) := by
  simp [modify_eq, modifyGet_eq]

@[simp] theorem getModify_bind_modify (f : σ → σ) (g : σ → σ → σ) :
    (do let s ← getModify (m := m) f; modify (g s)) =
      (do let s ← get; modify (g s ∘ f)) := by
  simp [modify_eq, getModify_eq]

theorem modify_comm_of_comp_comm {f g : σ → σ} (h : f ∘ g = g ∘ f) :
    (do modify (m := m) f; modify g) = (do modify (m := m) g; modify f) := by
  simp [modify_bind_modify, h]

theorem modify_bind_get (f : σ → σ) :
    (do modify (m := m) f; get) = (do let s ← get; modify f; return (f s)) := by
  simp [modify_eq]

end modify

/-- `StateT` has lawful state operations if the underlying monad is lawful.
This is applied for `StateM` as well due to the reducibility of that definition. -/
instance {m σ} [Monad m] [LawfulMonad m] : LawfulMonadStateOf σ (StateT σ m) where
  modifyGet_eq f := StateT.ext fun s => by simp
  get_bind_const mx := StateT.ext fun s => by simp
  get_bind_get_bind mx := StateT.ext fun s => by simp
  get_bind_set_bind mx := StateT.ext fun s => by simp
  set_bind_get s := StateT.ext fun s => by simp
  set_bind_set s s' := StateT.ext fun s => by simp

/-- The continuation passing state monad variant `StateCpsT` always has lawful state instance. -/
instance {σ m} : LawfulMonadStateOf σ (StateCpsT σ m) where
  modifyGet_eq _ := rfl
  get_bind_const _ := rfl
  get_bind_get_bind _ := rfl
  get_bind_set_bind _ := rfl
  set_bind_get _ := rfl
  set_bind_set _ _ := rfl

/-- The `EStateM` monad always has a lawful state instance. -/
instance {σ ε} : LawfulMonadStateOf σ (EStateM ε σ) where
  modifyGet_eq _ := rfl
  get_bind_const _ := rfl
  get_bind_get_bind _ := rfl
  get_bind_set_bind _ := rfl
  set_bind_get _ := rfl
  set_bind_set _ _ := rfl

/-- If the underlying monad `m` has a lawful state instance, then the induced state instance on
`ReaderT ρ m` will also be lawful. -/
instance {m σ ρ} [Monad m] [LawfulMonad m] [MonadStateOf σ m] [LawfulMonadStateOf σ m] :
    LawfulMonadStateOf σ (ReaderT ρ m) where
  modifyGet_eq f := ReaderT.ext fun ctx => by
    simp [← liftM_modifyGet, LawfulMonadStateOf.modifyGet_eq, ← liftM_get]
  get_bind_const mx := ReaderT.ext fun ctx => by
    simp [← liftM_get]
  get_bind_get_bind mx := ReaderT.ext fun ctx => by
    simp [← liftM_get]
  get_bind_set_bind mx := ReaderT.ext fun ctx => by
    simp [← liftM_get, ← liftM_set]
  set_bind_get s := ReaderT.ext fun ctx => by
    simp [← liftM_get, ← liftM_set]
  set_bind_set s s' := ReaderT.ext fun ctx => by
    simp [← liftM_set]

instance {m ω σ} [Monad m] [LawfulMonad m] [MonadStateOf σ m] [LawfulMonadStateOf σ m] :
    LawfulMonadStateOf σ (StateRefT' ω σ m) :=
  inferInstanceAs (LawfulMonadStateOf σ (ReaderT _ _))



=== LEAN SOURCE: Lemmas.lean ===
/-
Copyright (c) 2023 François G. Dorais. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: François G. Dorais
-/

namespace ReaderT

attribute [ext] ReaderT.ext

@[simp] theorem run_failure [Monad m] [Alternative m] (ctx : ρ) :
    (failure : ReaderT ρ m α).run ctx = failure := rfl

@[simp] theorem run_orElse [Monad m] [Alternative m] (x y : ReaderT ρ m α) (ctx : ρ) :
    (x <|> y).run ctx = (x.run ctx <|> y.run ctx) := rfl

end ReaderT

namespace StateT

attribute [ext] StateT.ext

@[simp] theorem run_failure {α σ} [Monad m] [Alternative m] (s : σ) :
    (failure : StateT σ m α).run s = failure := rfl

@[simp] theorem run_orElse {α σ} [Monad m] [Alternative m] (x y : StateT σ m α) (s : σ) :
    (x <|> y).run s = (x.run s <|> y.run s) := rfl

end StateT



=== LEAN SOURCE: Monad.lean ===
/-
Copyright (c) 2025 Lean FRO, LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Batteries.Tactic.Alias

@[deprecated (since := "2025-02-09")] alias LawfulFunctor.map_inj_right_of_nonempty :=
map_inj_right_of_nonempty
@[deprecated (since := "2025-02-09")] alias LawfulMonad.map_inj_right :=
map_inj_right



=== LEAN SOURCE: OptionT.lean ===
/-
Copyright (c) 2017 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sebastian Ullrich
-/

import Batteries.Control.LawfulMonadState

/-!
# Lemmas About Option Monad Transformer

This file contains lemmas about the behavior of `OptionT` and `OptionT.run`.
-/

namespace OptionT

@[ext] theorem ext {x x' : OptionT m α} (h : x.run = x'.run) : x = x' := h

@[simp] theorem run_mk {m : Type _ → Type _} (x : m (Option α)) :
    OptionT.run (OptionT.mk x) = x := rfl

@[simp] theorem run_pure (a) [Monad m] : (pure a : OptionT m α).run = pure (some a) := rfl

@[simp] theorem run_bind (f : α → OptionT m β) [Monad m] :
    (x >>= f).run = Option.elimM x.run (pure none) (run ∘ f) := by
  change x.run >>= _ = _
  simp [Option.elimM]
  exact bind_congr fun |some _ => rfl | none => rfl

@[simp] theorem run_map (x : OptionT m α) (f : α → β) [Monad m] [LawfulMonad m] :
    (f <$> x).run = Option.map f <$> x.run := by
  rw [← bind_pure_comp _ x.run]
  change x.run >>= _ = _
  exact bind_congr fun |some _ => rfl | none => rfl

@[simp] theorem run_monadLift [Monad m] [LawfulMonad m] [MonadLiftT n m] (x : n α) :
    (monadLift x : OptionT m α).run = some <$> (monadLift x : m α) := (map_eq_pure_bind _ _).symm

@[simp] theorem run_mapConst [Monad m] [LawfulMonad m] (x : OptionT m α) (y : β) :
    (Functor.mapConst y x).run = Option.map (Function.const α y) <$> x.run := run_map _ _

instance (m) [Monad m] [LawfulMonad m] : LawfulMonad (OptionT m) :=
  LawfulMonad.mk'
    (id_map := by
      intros; apply OptionT.ext; simp only [OptionT.run_map]
      rw [map_congr, id_map]
      intro a; cases a <;> rfl)
    (bind_assoc := by
      refine fun _ _ _ => OptionT.ext ?_
      simp only [run_bind, Option.elimM, bind_assoc]
      refine bind_congr fun | some x => by simp [Option.elimM] | none => by simp)
    (pure_bind := by intros; apply OptionT.ext; simp)

@[simp] theorem run_failure [Monad m] : (failure : OptionT m α).run = pure none := rfl

@[simp] theorem run_orElse [Monad m] (x : OptionT m α) (y : OptionT m α) :
    (x <|> y).run = Option.elimM x.run y.run (pure ∘ some) :=
  bind_congr fun | some _ => rfl | none => rfl

@[simp] theorem run_seq [Monad m] [LawfulMonad m] (f : OptionT m (α → β)) (x : OptionT m α) :
    (f <*> x).run = Option.elimM f.run (pure none) (fun f => Option.map f <$> x.run) := by
  simp only [seq_eq_bind, run_bind, run_map, Function.comp_def]

@[simp] theorem run_seqLeft [Monad m] [LawfulMonad m] (x : OptionT m α) (y : OptionT m β) :
    (x <* y).run = Option.elimM x.run (pure none)
      (fun x => Option.map (Function.const β x) <$> y.run) := by
  simp [seqLeft_eq, seq_eq_bind, Option.elimM, Function.comp_def]

@[simp] theorem run_seqRight [Monad m] [LawfulMonad m] (x : OptionT m α) (y : OptionT m β) :
    (x *> y).run = Option.elimM x.run (pure none) (Function.const α y.run) := by
  simp only [seqRight_eq, run_seq, run_map, Option.elimM_map]
  refine bind_congr (fun | some _ => by simp [Option.elim] | none => by simp [Option.elim])

@[simp] theorem run_monadMap {n} [MonadFunctorT n m] (f : ∀ {α}, n α → n α) :
    (monadMap (@f) x : OptionT m α).run = monadMap (@f) x.run := rfl

instance [Monad m] [LawfulMonad m] [MonadStateOf σ m] [LawfulMonadStateOf σ m] :
    LawfulMonadStateOf σ (OptionT m) where
  modifyGet_eq f := by simp [← liftM_modifyGet, ← liftM_get, LawfulMonadStateOf.modifyGet_eq]
  get_bind_const mx := OptionT.ext (by simp [← liftM_get])
  get_bind_get_bind mx := OptionT.ext (by simp [← liftM_get])
  get_bind_set_bind mx := OptionT.ext (by simp [← liftM_get, ← liftM_set])
  set_bind_get s := OptionT.ext (by simp [← liftM_get, ← liftM_set])
  set_bind_set s s' := OptionT.ext (by simp [← liftM_set])

end OptionT



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/

/-! # Additional definitions on `ForInStep` -/

/--
This is similar to a monadic `bind` operator, except that the two type parameters have to be
the same, which prevents putting a monad instance on `ForInStepT m α := m (ForInStep α)`.
-/
@[inline] protected def ForInStep.bind [Monad m]
    (a : ForInStep α) (f : α → m (ForInStep α)) : m (ForInStep α) :=
  match a with
  | .done a => return .done a
  | .yield a => f a

@[inherit_doc ForInStep.bind] protected abbrev ForInStep.bindM [Monad m]
    (a : m (ForInStep α)) (f : α → m (ForInStep α)) : m (ForInStep α) := a >>= (·.bind f)

/--
Get the value out of a `ForInStep`.
This is usually done at the end of a `forIn` loop to scope the early exit to the loop body.
-/
@[inline] def ForInStep.run : ForInStep α → α
  | .done a
  | .yield a => a

/-- Applies function `f` to each element of a list to accumulate a `ForInStep` value. -/
def ForInStep.bindList [Monad m]
      (f : α → β → m (ForInStep β)) : List α → ForInStep β → m (ForInStep β)
  | [], s => pure s
  | a::l, s => s.bind fun b => f a b >>= (·.bindList f l)



=== LEAN SOURCE: Lemmas.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Batteries.Control.ForInStep.Basic

/-! # Additional theorems on `ForInStep` -/

@[simp] theorem ForInStep.bind_done [Monad m] (a : α) (f : α → m (ForInStep α)) :
    (ForInStep.done a).bind (m := m) f = pure (.done a) := rfl
@[simp] theorem ForInStep.bind_yield [Monad m] (a : α) (f : α → m (ForInStep α)) :
    (ForInStep.yield a).bind (m := m) f = f a := rfl

attribute [simp] ForInStep.bindM

@[simp] theorem ForInStep.run_done : (ForInStep.done a).run = a := rfl
@[simp] theorem ForInStep.run_yield : (ForInStep.yield a).run = a := rfl

@[simp] theorem ForInStep.bindList_nil [Monad m] (f : α → β → m (ForInStep β))
    (s : ForInStep β) : s.bindList f [] = pure s := rfl

@[simp] theorem ForInStep.bindList_cons [Monad m]
    (f : α → β → m (ForInStep β)) (s : ForInStep β) (a l) :
    s.bindList f (a::l) = s.bind fun b => f a b >>= (·.bindList f l) := rfl

@[simp] theorem ForInStep.done_bindList [Monad m]
    (f : α → β → m (ForInStep β)) (a l) :
    (ForInStep.done a).bindList f l = pure (.done a) := by cases l <;> simp

@[simp] theorem ForInStep.bind_yield_bindList [Monad m]
    (f : α → β → m (ForInStep β)) (s : ForInStep β) (l) :
    (s.bind fun a => (yield a).bindList f l) = s.bindList f l := by cases s <;> simp

@[simp] theorem ForInStep.bind_bindList_assoc [Monad m] [LawfulMonad m]
    (f : β → m (ForInStep β)) (g : α → β → m (ForInStep β)) (s : ForInStep β) (l) :
    s.bind f >>= (·.bindList g l) = s.bind fun b => f b >>= (·.bindList g l)  := by
  cases s <;> simp

theorem ForInStep.bindList_cons' [Monad m] [LawfulMonad m]
    (f : α → β → m (ForInStep β)) (s : ForInStep β) (a l) :
    s.bindList f (a::l) = s.bind (f a) >>= (·.bindList f l) := by simp

@[simp] theorem ForInStep.bindList_append [Monad m] [LawfulMonad m]
    (f : α → β → m (ForInStep β)) (s : ForInStep β) (l₁ l₂) :
    s.bindList f (l₁ ++ l₂) = s.bindList f l₁ >>= (·.bindList f l₂) := by
  induction l₁ generalizing s <;> simp [*]



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2023 Kim Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Batteries.Tactic.Lint.Misc
import Batteries.Data.MLList.Basic

/-!
# A nondeterminism monad.

We represent nondeterministic values in a type `α` as a single field structure containing an
`MLList m (σ × α)`, i.e. as a monadic lazy list of possible values,
each equipped with the backtrackable state
required to run further computations in the ambient monad.

We provide an `Alternative` `Monad` instance, as well as functions `bind`, `mapM`, and `filterMapM`,
and functions `singletonM`, `ofListM`, `ofOptionM`, and `firstM`
for entering and leaving the nondeterministic world.

Operations on the nondeterministic value via `bind`, `mapM`, and `filterMapM`
run with the appropriate backtrackable state, and are responsible for updating the state themselves
(typically this doesn't need to be done explicitly,
but just happens as a side effect in the monad `m`).
-/

open Lean (MonadBacktrack)
open Lean.MonadBacktrack

/--
`Nondet m α` is variation on `MLList m α` suitable for use with backtrackable monads `m`.

We think of `Nondet m α` as a nondeterministic value in `α`,
with the possible alternatives stored in a monadic lazy list.

Along with each `a : α` we store the backtrackable state, and ensure that monadic operations
on alternatives run with the appropriate state.

Operations on the nondeterministic value via `bind`, `mapM`, and `filterMapM`
run with the appropriate backtrackable state, and are responsible for updating the state themselves
(typically this doesn't need to be done explicitly,
but just happens as a side effect in the monad `m`).
-/
@[nolint unusedArguments]
structure Nondet (m : Type → Type) [MonadBacktrack σ m] (α : Type) : Type where
  /--
  Convert a non-deterministic value into a lazy list, keeping the backtrackable state.
  Be careful that monadic operations on the `MLList` will not respect this state!
  -/
  toMLList : MLList m (α × σ)

namespace Nondet

variable {m : Type → Type} [Monad m] [MonadBacktrack σ m]

/-- The empty nondeterministic value. -/
def nil : Nondet m α := .mk .nil

instance : Inhabited (Nondet m α) := ⟨.nil⟩

/--
Squash a monadic nondeterministic value to a nondeterministic value.
-/
def squash (L : Unit → m (Nondet m α)) : Nondet m α :=
  .mk <| MLList.squash fun _ => return (← L ()).toMLList

/--
Bind a nondeterministic function over a nondeterministic value,
ensuring the function is run with the relevant backtrackable state at each value.
-/
partial def bind (L : Nondet m α) (f : α → Nondet m β) : Nondet m β := .squash fun _ => do
  match ← L.toMLList.uncons with
  | none => pure .nil
  | some (⟨x, s⟩, xs) => do
    let r := (Nondet.mk xs).bind f
    restoreState s
    match ← (f x).toMLList.uncons with
    | none => return r
    | some (y, ys) => return .mk <| .cons y (ys.append (fun _ => r.toMLList))

/-- Convert any value in the monad to the singleton nondeterministic value. -/
def singletonM (x : m α) : Nondet m α :=
  .mk <| .singletonM do
    let a ← x
    return (a, ← saveState)

/-- Convert a value to the singleton nondeterministic value. -/
def singleton (x : α) : Nondet m α := singletonM (pure x)

/-- `Nondet m` is a monad. -/
instance : Monad (Nondet m) where
  pure a := singletonM (pure a)
  bind := bind

/-- `Nondet m` is an alternative monad. -/
instance : Alternative (Nondet m) where
  failure := .nil
  orElse x y := .mk <| x.toMLList.append fun _ => (y ()).toMLList

instance : MonadLift m (Nondet m) where
  monadLift := singletonM

/--
Lift a list of monadic values to a nondeterministic value.
We ensure that each monadic value is evaluated with the same backtrackable state.
-/
def ofListM (L : List (m α)) : Nondet m α :=
  .squash fun _ => do
    let s ← saveState
    return .mk <| MLList.ofListM <| L.map fun x => do
      restoreState s
      let a ← x
      pure (a, ← saveState)

/--
Lift a list of values to a nondeterministic value.
(The backtrackable state in each will be identical:
whatever the state was when we first read from the result.)
-/
def ofList (L : List α) : Nondet m α := ofListM (L.map pure)

/-- Apply a function which returns values in the monad to every alternative of a `Nondet m α`. -/
def mapM (f : α → m β) (L : Nondet m α) : Nondet m β :=
  L.bind fun a => singletonM (f a)

/-- Apply a function to each alternative in a `Nondet m α` . -/
def map (f : α → β) (L : Nondet m α) : Nondet m β :=
  L.mapM fun a => pure (f a)

/-- Convert a monadic optional value to a nondeterministic value. -/
def ofOptionM (x : m (Option α)) : Nondet m α := .squash fun _ => do
  match ← x with
  | none => return .nil
  | some a => return singleton a

/-- Convert an optional value to a nondeterministic value. -/
def ofOption (x : Option α) : Nondet m α := ofOptionM (pure x)

/-- Filter and map a nondeterministic value using a monadic function which may return `none`. -/
def filterMapM (f : α → m (Option β)) (L : Nondet m α) : Nondet m β :=
  L.bind fun a => ofOptionM (f a)

/-- Filter and map a nondeterministic value. -/
def filterMap (f : α → Option β) (L : Nondet m α) : Nondet m β :=
  L.filterMapM fun a => pure (f a)

/-- Filter a nondeterministic value using a monadic predicate. -/
def filterM (p : α → m (ULift Bool)) (L : Nondet m α) : Nondet m α :=
  L.filterMapM fun a => do
    if (← p a).down then
      pure (some a)
    else
      pure none

/-- Filter a nondeterministic value. -/
def filter (p : α → Bool) (L : Nondet m α) : Nondet m α :=
  L.filterM fun a => pure <| .up (p a)

/--
All iterations of a non-deterministic function on an initial value.

(That is, depth first search.)
-/
partial def iterate (f : α → Nondet m α) (a : α) : Nondet m α :=
  singleton a <|> (f a).bind (iterate f)

/--
Find the first alternative in a nondeterministic value, as a monadic value.
-/
def head [Alternative m] (L : Nondet m α) : m α := do
  let (x, s) ← L.toMLList.head
  restoreState s
  return x

/--
Find the value of a monadic function on the first alternative in a nondeterministic value
where the function succeeds.
-/
def firstM [Alternative m] (L : Nondet m α) (f : α → m (Option β)) : m β :=
  L.filterMapM f |>.head

/--
Convert a non-deterministic value into a lazy list, by discarding the backtrackable state.
-/
def toMLList' (L : Nondet m α) : MLList m α := L.toMLList.map (·.1)

/--
Convert a non-deterministic value into a list in the monad, retaining the backtrackable state.
-/
def toList (L : Nondet m α) : m (List (α × σ)) := L.toMLList.force

/--
Convert a non-deterministic value into a list in the monad, by discarding the backtrackable state.
-/
def toList' (L : Nondet m α) : m (List α) := L.toMLList.map (·.1) |>.force

end Nondet

/-- The `Id` monad is trivially backtrackable, with state `Unit`. -/
-- This is useful so we can use `Nondet Id α` instead of `List α`
-- as the basic non-determinism monad.
instance : MonadBacktrack Unit Id where
  saveState := pure ()
  restoreState _ := pure ()



=== LEAN SOURCE: Array.lean ===
import Batteries.Data.Array.Basic
import Batteries.Data.Array.Init.Lemmas
import Batteries.Data.Array.Lemmas
import Batteries.Data.Array.Match
import Batteries.Data.Array.Merge
import Batteries.Data.Array.Monadic
import Batteries.Data.Array.Pairwise



=== LEAN SOURCE: AssocList.lean ===
/-
Copyright (c) 2019 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Leonardo de Moura, Mario Carneiro
-/
import Batteries.Data.List.Basic

namespace Batteries

/--
`AssocList α β` is "the same as" `List (α × β)`, but flattening the structure
leads to one fewer pointer indirection (in the current code generator).
It is mainly intended as a component of `HashMap`, but it can also be used as a plain
key-value map.
-/
inductive AssocList (α : Type u) (β : Type v) where
  /-- An empty list -/
  | nil
  /-- Add a `key, value` pair to the list -/
  | cons (key : α) (value : β) (tail : AssocList α β)
  deriving Inhabited

namespace AssocList

/--
`O(n)`. Convert an `AssocList α β` into the equivalent `List (α × β)`.
This is used to give specifications for all the `AssocList` functions
in terms of corresponding list functions.
-/
@[simp] def toList : AssocList α β → List (α × β)
  | nil => []
  | cons a b es => (a, b) :: es.toList

instance : EmptyCollection (AssocList α β) := ⟨nil⟩

@[simp] theorem empty_eq : (∅ : AssocList α β) = nil := rfl

/-- `O(1)`. Is the list empty? -/
def isEmpty : AssocList α β → Bool
  | nil => true
  | _   => false

@[simp] theorem isEmpty_eq (l : AssocList α β) : isEmpty l = l.toList.isEmpty := by
  cases l <;> simp [*, isEmpty, List.isEmpty]

/-- The number of entries in an `AssocList`. -/
def length (L : AssocList α β) : Nat :=
  match L with
  | .nil => 0
  | .cons _ _ t => t.length + 1

@[simp] theorem length_nil : length (nil : AssocList α β) = 0 := rfl
@[simp] theorem length_cons : length (cons a b t) = length t + 1 := rfl

theorem length_toList (l : AssocList α β) : l.toList.length = l.length := by
  induction l <;> simp_all

/-- `O(n)`. Fold a monadic function over the list, from head to tail. -/
@[specialize] def foldlM [Monad m] (f : δ → α → β → m δ) : (init : δ) → AssocList α β → m δ
  | d, nil         => pure d
  | d, cons a b es => do foldlM f (← f d a b) es

@[simp] theorem foldlM_eq [Monad m] (f : δ → α → β → m δ) (init l) :
    foldlM f init l = l.toList.foldlM (fun d (a, b) => f d a b) init := by
  induction l generalizing init <;> simp [*, foldlM]

/-- `O(n)`. Fold a function over the list, from head to tail. -/
@[inline] def foldl (f : δ → α → β → δ) (init : δ) (as : AssocList α β) : δ :=
  Id.run (foldlM (fun d a b => pure (f d a b)) init as)

@[simp] theorem foldl_eq (f : δ → α → β → δ) (init l) :
    foldl f init l = l.toList.foldl (fun d (a, b) => f d a b) init := by
  simp [foldl, foldlM_eq]

/-- Optimized version of `toList`. -/
def toListTR (as : AssocList α β) : List (α × β) :=
  as.foldl (init := #[]) (fun r a b => r.push (a, b)) |>.toList

@[csimp] theorem toList_eq_toListTR : @toList = @toListTR := by
  funext α β as; simp [toListTR]

/-- `O(n)`. Run monadic function `f` on all elements in the list, from head to tail. -/
@[specialize] def forM [Monad m] (f : α → β → m PUnit) : AssocList α β → m PUnit
  | nil         => pure ⟨⟩
  | cons a b es => do f a b; forM f es

@[simp] theorem forM_eq [Monad m] (f : α → β → m PUnit) (l) :
    forM f l = l.toList.forM (fun (a, b) => f a b) := by
  induction l <;> simp [*, forM]

/-- `O(n)`. Map a function `f` over the keys of the list. -/
@[simp] def mapKey (f : α → δ) : AssocList α β → AssocList δ β
  | nil        => nil
  | cons k v t => cons (f k) v (mapKey f t)

@[simp] theorem toList_mapKey (f : α → δ) (l : AssocList α β) :
    (mapKey f l).toList = l.toList.map (fun (a, b) => (f a, b)) := by
  induction l <;> simp [*]

@[simp] theorem length_mapKey : (mapKey f l).length = l.length := by
  induction l <;> simp_all

/-- `O(n)`. Map a function `f` over the values of the list. -/
@[simp] def mapVal (f : α → β → δ) : AssocList α β → AssocList α δ
  | nil        => nil
  | cons k v t => cons k (f k v) (mapVal f t)

@[simp] theorem toList_mapVal (f : α → β → δ) (l : AssocList α β) :
    (mapVal f l).toList = l.toList.map (fun (a, b) => (a, f a b)) := by
  induction l <;> simp [*]

@[simp] theorem length_mapVal : (mapVal f l).length = l.length := by
  induction l <;> simp_all

/-- `O(n)`. Returns the first entry in the list whose entry satisfies `p`. -/
@[specialize] def findEntryP? (p : α → β → Bool) : AssocList α β → Option (α × β)
  | nil         => none
  | cons k v es => bif p k v then some (k, v) else findEntryP? p es

@[simp] theorem findEntryP?_eq (p : α → β → Bool) (l : AssocList α β) :
    findEntryP? p l = l.toList.find? fun (a, b) => p a b := by
  induction l <;> simp [findEntryP?, List.find?_cons]; split <;> simp [*]

/-- `O(n)`. Returns the first entry in the list whose key is equal to `a`. -/
@[inline] def findEntry? [BEq α] (a : α) (l : AssocList α β) : Option (α × β) :=
  findEntryP? (fun k _ => k == a) l

@[simp] theorem findEntry?_eq [BEq α] (a : α) (l : AssocList α β) :
    findEntry? a l = l.toList.find? (·.1 == a) := findEntryP?_eq ..

/-- `O(n)`. Returns the first value in the list whose key is equal to `a`. -/
def find? [BEq α] (a : α) : AssocList α β → Option β
  | nil         => none
  | cons k v es => match k == a with
    | true  => some v
    | false => find? a es

theorem find?_eq_findEntry? [BEq α] (a : α) (l : AssocList α β) :
    find? a l = (l.findEntry? a).map (·.2) := by
  induction l <;> simp [find?, List.find?_cons]; split <;> simp [*]

@[simp] theorem find?_eq [BEq α] (a : α) (l : AssocList α β) :
    find? a l = (l.toList.find? (·.1 == a)).map (·.2) := by simp [find?_eq_findEntry?]

/-- `O(n)`. Returns true if any entry in the list satisfies `p`. -/
@[specialize] def any (p : α → β → Bool) : AssocList α β → Bool
  | nil         => false
  | cons k v es => p k v || any p es

@[simp] theorem any_eq (p : α → β → Bool) (l : AssocList α β) :
    any p l = l.toList.any fun (a, b) => p a b := by induction l <;> simp [any, *]

/-- `O(n)`. Returns true if every entry in the list satisfies `p`. -/
@[specialize] def all (p : α → β → Bool) : AssocList α β → Bool
  | nil         => true
  | cons k v es => p k v && all p es

@[simp] theorem all_eq (p : α → β → Bool) (l : AssocList α β) :
    all p l = l.toList.all fun (a, b) => p a b := by induction l <;> simp [all, *]

/-- Returns true if every entry in the list satisfies `p`. -/
def All (p : α → β → Prop) (l : AssocList α β) : Prop := ∀ a ∈ l.toList, p a.1 a.2

/-- `O(n)`. Returns true if there is an element in the list whose key is equal to `a`. -/
@[inline] def contains [BEq α] (a : α) (l : AssocList α β) : Bool := any (fun k _ => k == a) l

@[simp] theorem contains_eq [BEq α] (a : α) (l : AssocList α β) :
    contains a l = l.toList.any (·.1 == a) := by
  induction l <;> simp [*, contains]

/--
`O(n)`. Replace the first entry in the list
with key equal to `a` to have key `a` and value `b`.
-/
@[simp] def replace [BEq α] (a : α) (b : β) : AssocList α β → AssocList α β
  | nil         => nil
  | cons k v es => match k == a with
    | true  => cons a b es
    | false => cons k v (replace a b es)

@[simp] theorem toList_replace [BEq α] (a : α) (b : β) (l : AssocList α β) :
    (replace a b l).toList =
    l.toList.replaceF (bif ·.1 == a then some (a, b) else none) := by
  induction l <;> simp [replace]; split <;> simp [*]

@[simp] theorem length_replace [BEq α] {a : α} : (replace a b l).length = l.length := by
  induction l
  · rfl
  · simp only [replace, length_cons]
    split <;> simp_all

/-- `O(n)`. Remove the first entry in the list with key equal to `a`. -/
@[specialize, simp] def eraseP (p : α → β → Bool) : AssocList α β → AssocList α β
  | nil         => nil
  | cons k v es => bif p k v then es else cons k v (eraseP p es)

@[simp] theorem toList_eraseP (p) (l : AssocList α β) :
    (eraseP p l).toList = l.toList.eraseP fun (a, b) => p a b := by
  induction l <;> simp [List.eraseP, cond]; split <;> simp [*]

/-- `O(n)`. Remove the first entry in the list with key equal to `a`. -/
@[inline] def erase [BEq α] (a : α) (l : AssocList α β) : AssocList α β :=
  eraseP (fun k _ => k == a) l

@[simp] theorem toList_erase [BEq α] (a : α) (l : AssocList α β) :
    (erase a l).toList = l.toList.eraseP (·.1 == a) := toList_eraseP ..

/--
`O(n)`. Replace the first entry `a', b` in the list
with key equal to `a` to have key `a` and value `f a' b`.
-/
@[simp] def modify [BEq α] (a : α) (f : α → β → β) : AssocList α β → AssocList α β
  | nil         => nil
  | cons k v es => match k == a with
    | true  => cons a (f k v) es
    | false => cons k v (modify a f es)

@[simp] theorem toList_modify [BEq α] (a : α) (l : AssocList α β) :
    (modify a f l).toList =
    l.toList.replaceF fun (k, v) => bif k == a then some (a, f k v) else none := by
  simp [cond]
  induction l with simp [List.replaceF]
  | cons k v es ih => cases k == a <;> simp [ih]

@[simp] theorem length_modify [BEq α] {a : α} : (modify a f l).length = l.length := by
  induction l
  · rfl
  · simp only [modify, length_cons]
    split <;> simp_all

/-- The implementation of `ForIn`, which enables `for (k, v) in aList do ...` notation. -/
@[specialize] protected def forIn [Monad m]
    (as : AssocList α β) (init : δ) (f : (α × β) → δ → m (ForInStep δ)) : m δ :=
  match as with
  | nil => pure init
  | cons k v es => do
    match (← f (k, v) init) with
    | ForInStep.done d  => pure d
    | ForInStep.yield d => es.forIn d f

instance : ForIn m (AssocList α β) (α × β) where
  forIn := AssocList.forIn

@[simp] theorem forIn_eq [Monad m] (l : AssocList α β) (init : δ)
    (f : (α × β) → δ → m (ForInStep δ)) : forIn l init f = forIn l.toList init f := by
  simp only [forIn]
  induction l generalizing init <;> simp [AssocList.forIn]
  congr; funext a; split <;> simp [*]

/-- Split the list into head and tail, if possible. -/
def pop? : AssocList α β → Option ((α × β) × AssocList α β)
  | nil => none
  | cons a b l => some ((a, b), l)

instance : ToStream (AssocList α β) (AssocList α β) := ⟨fun x => x⟩
instance : Stream (AssocList α β) (α × β) := ⟨pop?⟩

/-- Converts a list into an `AssocList`. This is the inverse function to `AssocList.toList`. -/
@[simp] def _root_.List.toAssocList : List (α × β) → AssocList α β
  | []          => nil
  | (a,b) :: es => cons a b (toAssocList es)

@[simp] theorem _root_.List.toList_toAssocList (l : List (α × β)) : l.toAssocList.toList = l := by
  induction l <;> simp [*]

@[simp] theorem toList_toAssocList (l : AssocList α β) : l.toList.toAssocList = l := by
  induction l <;> simp [*]

@[simp] theorem _root_.List.length_toAssocList (l : List (α × β)) :
    l.toAssocList.length = l.length := by
  induction l <;> simp [*]

/-- Implementation of `==` on `AssocList`. -/
protected def beq [BEq α] [BEq β] : AssocList α β → AssocList α β → Bool
  | .nil, .nil => true
  | .cons _ _ _, .nil => false
  | .nil, .cons _ _ _ => false
  | .cons a b t, .cons a' b' t' => a == a' && b == b' && AssocList.beq t t'

/--
Boolean equality for `AssocList`.
(This relation cares about the ordering of the key-value pairs.)
-/
instance [BEq α] [BEq β] : BEq (AssocList α β) where beq := AssocList.beq

@[simp] theorem beq_nil₂ [BEq α] [BEq β] : ((.nil : AssocList α β) == .nil) = true := rfl
@[simp] theorem beq_nil_cons [BEq α] [BEq β] : ((.nil : AssocList α β) == .cons a b t) = false :=
  rfl
@[simp] theorem beq_cons_nil [BEq α] [BEq β] : ((.cons a b t : AssocList α β) == .nil) = false :=
  rfl
@[simp] theorem beq_cons₂ [BEq α] [BEq β] :
    ((.cons a b t : AssocList α β) == .cons a' b' t') = (a == a' && b == b' && t == t') := rfl

instance [BEq α] [LawfulBEq α] [BEq β] [LawfulBEq β] : LawfulBEq (AssocList α β) where
  rfl {L} := by induction L <;> simp_all
  eq_of_beq {L M} := by
    induction L generalizing M with
    | nil => cases M <;> simp_all
    | cons a b L ih =>
      cases M with
      | nil => simp_all
      | cons a' b' M =>
        simp_all only [beq_cons₂, Bool.and_eq_true, beq_iff_eq, cons.injEq, true_and, and_imp]
        exact fun _ _ => ih

protected theorem beq_eq [BEq α] [BEq β] {l m : AssocList α β} :
    (l == m) = (l.toList == m.toList) := by
  simp [(· == ·)]
  induction l generalizing m <;> cases m <;> simp [*, (· == ·), AssocList.beq, List.beq]



=== LEAN SOURCE: BinaryHeap.lean ===
/-
Copyright (c) 2021 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro, François G. Dorais
-/


namespace Batteries

/-- A max-heap data structure. -/
structure BinaryHeap (α) (lt : α → α → Bool) where
  /-- `O(1)`. Get data array for a `BinaryHeap`. -/
  arr : Array α

namespace BinaryHeap

private def maxChild (lt : α → α → Bool) (a : Vector α sz) (i : Fin sz) : Option (Fin sz) :=
  let left := 2 * i.1 + 1
  let right := left + 1
  if hleft : left < sz then
    if hright : right < sz then
      if lt a[left] a[right] then
        some ⟨right, hright⟩
      else
        some ⟨left, hleft⟩
    else
      some ⟨left, hleft⟩
  else none

/-- Core operation for binary heaps, expressed directly on arrays.
Given an array which is a max-heap, push item `i` down to restore the max-heap property. -/
def heapifyDown (lt : α → α → Bool) (a : Vector α sz) (i : Fin sz) :
    Vector α sz :=
  match h : maxChild lt a i with
  | none => a
  | some j =>
    have : i < j := by
      cases i; cases j
      simp only [maxChild] at h
      split at h
      · split at h
        · split at h <;> (cases h; simp +arith)
        · cases h; simp +arith
      · contradiction
    if lt a[i] a[j] then
      heapifyDown lt (a.swap i j) j
    else a
termination_by sz - i

/-- Core operation for binary heaps, expressed directly on arrays.
Construct a heap from an unsorted array, by heapifying all the elements. -/
def mkHeap (lt : α → α → Bool) (a : Vector α sz) : Vector α sz :=
  loop (sz / 2) a (Nat.div_le_self ..)
where
  /-- Inner loop for `mkHeap`. -/
  loop : (i : Nat) → (a : Vector α sz) → i ≤ sz → Vector α sz
  | 0, a, _ => a
  | i+1, a, h =>
    let a' := heapifyDown lt a ⟨i, Nat.lt_of_succ_le h⟩
    loop i a' (Nat.le_trans (Nat.le_succ _) h)

/-- Core operation for binary heaps, expressed directly on arrays.
Given an array which is a max-heap, push item `i` up to restore the max-heap property. -/
def heapifyUp (lt : α → α → Bool) (a : Vector α sz) (i : Fin sz) :
    Vector α sz :=
  match i with
  | ⟨0, _⟩ => a
  | ⟨i'+1, hi⟩ =>
    let j := i'/2
    if lt a[j] a[i] then
      heapifyUp lt (a.swap i j) ⟨j, by get_elem_tactic⟩
    else a

/-- `O(1)`. Build a new empty heap. -/
def empty (lt) : BinaryHeap α lt := ⟨#[]⟩

instance (lt) : Inhabited (BinaryHeap α lt) := ⟨empty _⟩
instance (lt) : EmptyCollection (BinaryHeap α lt) := ⟨empty _⟩

/-- `O(1)`. Build a one-element heap. -/
def singleton (lt) (x : α) : BinaryHeap α lt := ⟨#[x]⟩

/-- `O(1)`. Get the number of elements in a `BinaryHeap`. -/
def size (self : BinaryHeap α lt) : Nat := self.1.size

/-- `O(1)`. Get data vector of a `BinaryHeap`. -/
def vector (self : BinaryHeap α lt) : Vector α self.size := ⟨self.1, rfl⟩

/-- `O(1)`. Get an element in the heap by index. -/
def get (self : BinaryHeap α lt) (i : Fin self.size) : α := self.1[i]'(i.2)

/-- `O(log n)`. Insert an element into a `BinaryHeap`, preserving the max-heap property. -/
def insert (self : BinaryHeap α lt) (x : α) : BinaryHeap α lt where
  arr := heapifyUp lt (self.vector.push x) ⟨_, Nat.lt_succ_self _⟩ |>.toArray

@[simp] theorem size_insert (self : BinaryHeap α lt) (x : α) :
    (self.insert x).size = self.size + 1 := by
  simp [size, insert]

/-- `O(1)`. Get the maximum element in a `BinaryHeap`. -/
def max (self : BinaryHeap α lt) : Option α := self.1[0]?

/-- `O(log n)`. Remove the maximum element from a `BinaryHeap`.
Call `max` first to actually retrieve the maximum element. -/
def popMax (self : BinaryHeap α lt) : BinaryHeap α lt :=
  if h0 : self.size = 0 then self else
    have hs : self.size - 1 < self.size := Nat.pred_lt h0
    have h0 : 0 < self.size := Nat.zero_lt_of_ne_zero h0
    let v := self.vector.swap _ _ h0 hs |>.pop
    if h : 0 < self.size - 1 then
      ⟨heapifyDown lt v ⟨0, h⟩ |>.toArray⟩
    else
      ⟨v.toArray⟩

@[simp] theorem size_popMax (self : BinaryHeap α lt) :
    self.popMax.size = self.size - 1 := by
  simp only [popMax, size]
  split
  · simp +arith [*]
  · split <;> simp +arith

/-- `O(log n)`. Return and remove the maximum element from a `BinaryHeap`. -/
def extractMax (self : BinaryHeap α lt) : Option α × BinaryHeap α lt :=
  (self.max, self.popMax)

theorem size_pos_of_max {self : BinaryHeap α lt} (h : self.max = some x) : 0 < self.size := by
  simp only [max, getElem?_def] at h
  split at h
  · assumption
  · contradiction

/-- `O(log n)`. Equivalent to `extractMax (self.insert x)`, except that extraction cannot fail. -/
def insertExtractMax (self : BinaryHeap α lt) (x : α) : α × BinaryHeap α lt :=
  match e : self.max with
  | none => (x, self)
  | some m =>
    if lt x m then
      let v := self.vector.set 0 x (size_pos_of_max e)
      (m, ⟨heapifyDown lt v ⟨0, size_pos_of_max e⟩ |>.toArray⟩)
    else (x, self)

/-- `O(log n)`. Equivalent to `(self.max, self.popMax.insert x)`. -/
def replaceMax (self : BinaryHeap α lt) (x : α) : Option α × BinaryHeap α lt :=
  match e : self.max with
  | none => (none, ⟨self.vector.push x |>.toArray⟩)
  | some m =>
    let v := self.vector.set 0 x (size_pos_of_max e)
    (some m, ⟨heapifyDown lt v ⟨0, size_pos_of_max e⟩ |>.toArray⟩)

/-- `O(log n)`. Replace the value at index `i` by `x`. Assumes that `x ≤ self.get i`. -/
def decreaseKey (self : BinaryHeap α lt) (i : Fin self.size) (x : α) : BinaryHeap α lt where
  arr := heapifyDown lt (self.vector.set i x) i |>.toArray

/-- `O(log n)`. Replace the value at index `i` by `x`. Assumes that `self.get i ≤ x`. -/
def increaseKey (self : BinaryHeap α lt) (i : Fin self.size) (x : α) : BinaryHeap α lt where
  arr := heapifyUp lt (self.vector.set i x) i |>.toArray

end Batteries.BinaryHeap

/-- `O(n)`. Convert an unsorted vector to a `BinaryHeap`. -/
def Batteries.Vector.toBinaryHeap (lt : α → α → Bool) (v : Vector α n) :
    Batteries.BinaryHeap α lt where
  arr := BinaryHeap.mkHeap lt v |>.toArray

open Batteries in
/-- `O(n)`. Convert an unsorted array to a `BinaryHeap`. -/
def Array.toBinaryHeap (lt : α → α → Bool) (a : Array α) : Batteries.BinaryHeap α lt where
  arr := BinaryHeap.mkHeap lt ⟨a, rfl⟩ |>.toArray

open Batteries in
/-- `O(n log n)`. Sort an array using a `BinaryHeap`. -/
@[specialize] def Array.heapSort (a : Array α) (lt : α → α → Bool) : Array α :=
  loop (a.toBinaryHeap (flip lt)) #[]
where
  /-- Inner loop for `heapSort`. -/
  loop (a : Batteries.BinaryHeap α (flip lt)) (out : Array α) : Array α :=
    match e: a.max with
    | none => out
    | some x =>
      have : a.popMax.size < a.size := by
        simp; exact Nat.sub_lt (Batteries.BinaryHeap.size_pos_of_max e) Nat.zero_lt_one
      loop a.popMax (out.push x)
  termination_by a.size



=== LEAN SOURCE: BinomialHeap.lean ===
import Batteries.Data.BinomialHeap.Basic
import Batteries.Data.BinomialHeap.Lemmas



=== LEAN SOURCE: BitVec.lean ===
import Batteries.Data.BitVec.Basic
import Batteries.Data.BitVec.Lemmas



=== LEAN SOURCE: ByteArray.lean ===
/-
Copyright (c) 2023 François G. Dorais. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: François G. Dorais
-/

namespace ByteArray

attribute [ext] ByteArray

instance : DecidableEq ByteArray :=
  fun _ _ => decidable_of_decidable_of_iff ByteArray.ext_iff.symm

theorem getElem_eq_data_getElem (a : ByteArray) (h : i < a.size) : a[i] = a.data[i] := rfl

/-! ### uget/uset -/

@[simp] theorem uset_eq_set (a : ByteArray) {i : USize} (h : i.toNat < a.size) (v : UInt8) :
    a.uset i v h = a.set i.toNat v := rfl

/-! ### empty -/

@[simp] theorem data_mkEmpty (cap) : (emptyWithCapacity cap).data = #[] := rfl

@[simp] theorem data_empty : empty.data = #[] := rfl

@[simp] theorem size_empty : empty.size = 0 := rfl

/-! ### push -/

@[simp] theorem data_push (a : ByteArray) (b : UInt8) : (a.push b).data = a.data.push b := rfl

@[simp] theorem size_push (a : ByteArray) (b : UInt8) : (a.push b).size = a.size + 1 :=
  Array.size_push ..

@[simp] theorem get_push_eq (a : ByteArray) (x : UInt8) : (a.push x)[a.size] = x :=
  Array.getElem_push_eq ..

theorem get_push_lt (a : ByteArray) (x : UInt8) (i : Nat) (h : i < a.size) :
    (a.push x)[i]'(size_push .. ▸ Nat.lt_succ_of_lt h) = a[i] :=
  Array.getElem_push_lt ..

/-! ### set -/

@[simp] theorem data_set (a : ByteArray) (i : Fin a.size) (v : UInt8) :
    (a.set i v).data = a.data.set i v i.isLt := rfl

@[simp] theorem size_set (a : ByteArray) (i : Fin a.size) (v : UInt8) :
    (a.set i v).size = a.size :=
  Array.size_set ..

@[simp] theorem get_set_eq (a : ByteArray) (i : Fin a.size) (v : UInt8) : (a.set i v)[i.val] = v :=
  Array.getElem_set_self _

theorem get_set_ne (a : ByteArray) (i : Fin a.size) (v : UInt8) (hj : j < a.size) (h : i.val ≠ j) :
    (a.set i v)[j]'(a.size_set .. ▸ hj) = a[j] :=
  Array.getElem_set_ne (h := h) ..

theorem set_set (a : ByteArray) (i : Fin a.size) (v v' : UInt8) :
    (a.set i v).set i v' = a.set i v' :=
  ByteArray.ext <| Array.set_set ..

/-! ### copySlice -/

@[simp] theorem data_copySlice (a i b j len exact) :
  (copySlice a i b j len exact).data = b.data.extract 0 j ++ a.data.extract i (i + len)
    ++ b.data.extract (j + min len (a.data.size - i)) b.data.size := rfl

/-! ### append -/

@[simp] theorem append_eq (a b) : ByteArray.append a b = a ++ b := rfl

@[simp] theorem data_append (a b : ByteArray) : (a ++ b).data = a.data ++ b.data := by
  rw [←append_eq]; simp [ByteArray.append, size]
  rw [Array.extract_empty_of_stop_le_start (h:=Nat.le_add_right ..), Array.append_empty]

theorem size_append (a b : ByteArray) : (a ++ b).size = a.size + b.size := by
  simp only [size, append_eq, data_append]; exact Array.size_append ..

theorem get_append_left {a b : ByteArray} (hlt : i < a.size)
    (h : i < (a ++ b).size := size_append .. ▸ Nat.lt_of_lt_of_le hlt (Nat.le_add_right ..)) :
    (a ++ b)[i] = a[i] := by
  simp [getElem_eq_data_getElem]; exact Array.getElem_append_left hlt

theorem get_append_right {a b : ByteArray} (hle : a.size ≤ i) (h : i < (a ++ b).size)
    (h' : i - a.size < b.size := Nat.sub_lt_left_of_lt_add hle (size_append .. ▸ h)) :
    (a ++ b)[i] = b[i - a.size] := by
  simp [getElem_eq_data_getElem]; exact Array.getElem_append_right hle

/-! ### extract -/

@[simp] theorem data_extract (a : ByteArray) (start stop) :
    (a.extract start stop).data = a.data.extract start stop := by
  simp [extract]
  match Nat.le_total start stop with
  | .inl h => simp [h, Nat.add_sub_cancel']
  | .inr h => simp [h, Nat.sub_eq_zero_of_le, Array.extract_empty_of_stop_le_start]

@[simp] theorem size_extract (a : ByteArray) (start stop) :
    (a.extract start stop).size = min stop a.size - start := by
  simp [size]

theorem get_extract_aux {a : ByteArray} {start stop} (h : i < (a.extract start stop).size) :
    start + i < a.size := by
  apply Nat.add_lt_of_lt_sub'; apply Nat.lt_of_lt_of_le h
  rw [size_extract, ← Nat.sub_min_sub_right]; exact Nat.min_le_right ..

@[simp] theorem get_extract {a : ByteArray} {start stop} (h : i < (a.extract start stop).size) :
    (a.extract start stop)[i] = a[start+i]'(get_extract_aux h) := by
  simp [getElem_eq_data_getElem]

/-! ### ofFn -/

/--- `ofFn f` with `f : Fin n → UInt8` returns the byte array whose `i`th element is `f i`. --/
@[inline] def ofFn (f : Fin n → UInt8) : ByteArray :=
  Fin.foldl n (fun acc i => acc.push (f i)) (emptyWithCapacity n)

@[simp] theorem ofFn_zero (f : Fin 0 → UInt8) : ofFn f = empty := rfl

theorem ofFn_succ (f : Fin (n+1) → UInt8) :
    ofFn f = (ofFn fun i => f i.castSucc).push (f (Fin.last n)) := by
  simp [ofFn, Fin.foldl_succ_last, emptyWithCapacity]

@[simp] theorem data_ofFn (f : Fin n → UInt8) : (ofFn f).data = .ofFn f := by
  induction n with
  | zero => rfl
  | succ n ih => simp [ofFn_succ, Array.ofFn_succ, ih, Fin.last]

@[simp] theorem size_ofFn (f : Fin n → UInt8) : (ofFn f).size = n := by
  simp [size]

@[simp] theorem get_ofFn (f : Fin n → UInt8) (i : Fin (ofFn f).size) :
    (ofFn f).get i = f (i.cast (size_ofFn f)) := by
  simp [get, Fin.cast]

@[simp] theorem getElem_ofFn (f : Fin n → UInt8) (i) (h : i < (ofFn f).size) :
    (ofFn f)[i] = f ⟨i, size_ofFn f ▸ h⟩ := get_ofFn f ⟨i, h⟩

/-! ### map/mapM -/

/--
Unsafe optimized implementation of `mapM`.

This function is unsafe because it relies on the implementation limit that the size of an array is
always less than `USize.size`.
-/
@[inline]
unsafe def mapMUnsafe [Monad m] (a : ByteArray) (f : UInt8 → m UInt8) : m ByteArray :=
  loop a 0 a.usize
where
  /-- Inner loop for `mapMUnsafe`. -/
  @[specialize]
  loop (a : ByteArray) (k s : USize) := do
    if k < a.usize then
      let x := a.uget k lcProof
      let y ← f x
      let a := a.uset k y lcProof
      loop a (k+1) s
    else pure a

/-- `mapM f a` applies the monadic function `f` to each element of the array. -/
@[implemented_by mapMUnsafe]
def mapM [Monad m] (a : ByteArray) (f : UInt8 → m UInt8) : m ByteArray := do
  let mut r := a
  for i in [0:r.size] do
    r := r.set! i (← f r[i]!)
  return r

/-- `map f a` applies the function `f` to each element of the array. -/
@[inline]
def map (a : ByteArray) (f : UInt8 → UInt8) : ByteArray :=
  mapM (m:=Id) a f



=== LEAN SOURCE: ByteSubarray.lean ===

/-
Copyright (c) 2021 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro, François G. Dorais
-/

namespace Batteries

/-- A subarray of a `ByteArray`. -/
structure ByteSubarray where
  /-- `O(1)`. Get data array of a `ByteSubarray`. -/
  array : ByteArray
  /-- `O(1)`. Get start index of a `ByteSubarray`. -/
  start : Nat
  /-- `O(1)`. Get stop index of a `ByteSubarray`. -/
  stop : Nat
  /-- Start index is before stop index. -/
  start_le_stop : start ≤ stop
  /-- Stop index is before end of data array. -/
  stop_le_array_size : stop ≤ array.size

namespace ByteSubarray

/-- `O(1)`. Get the size of a `ByteSubarray`. -/
protected def size (self : ByteSubarray) := self.stop - self.start

/-- `O(1)`. Test if a `ByteSubarray` is empty. -/
protected def isEmpty (self : ByteSubarray) := self.start != self.stop

theorem stop_eq_start_add_size (self : ByteSubarray) : self.stop = self.start + self.size := by
  rw [ByteSubarray.size, Nat.add_sub_cancel' self.start_le_stop]

/-- `O(n)`. Extract a `ByteSubarray` to a `ByteArray`. -/
def toByteArray (self : ByteSubarray) : ByteArray :=
  self.array.extract self.start self.stop

/-- `O(1)`. Get the element at index `i` from the start of a `ByteSubarray`. -/
@[inline] def get (self : ByteSubarray) (i : Fin self.size) : UInt8 :=
  have : self.start + i.1 < self.array.size := by
    apply Nat.lt_of_lt_of_le _ self.stop_le_array_size
    rw [stop_eq_start_add_size]
    apply Nat.add_lt_add_left i.is_lt self.start
  self.array[self.start + i.1]

instance : GetElem ByteSubarray Nat UInt8 fun self i => i < self.size where
  getElem self i h := self.get ⟨i, h⟩

/-- `O(1)`. Pop the last element of a `ByteSubarray`. -/
@[inline] def pop (self : ByteSubarray) : ByteSubarray :=
  if h : self.start = self.stop then self else
    {self with
      stop := self.stop - 1
      start_le_stop := Nat.le_pred_of_lt (Nat.lt_of_le_of_ne self.start_le_stop h)
      stop_le_array_size := Nat.le_trans (Nat.pred_le _) self.stop_le_array_size
    }

/-- `O(1)`. Pop the first element of a `ByteSubarray`. -/
@[inline] def popFront (self : ByteSubarray) : ByteSubarray :=
  if h : self.start = self.stop then self else
    {self with
      start := self.start + 1
      start_le_stop := Nat.succ_le_of_lt (Nat.lt_of_le_of_ne self.start_le_stop h)
    }

/-- Folds a monadic function over a `ByteSubarray` from left to right. -/
@[inline] def foldlM [Monad m] (self : ByteSubarray) (f : β → UInt8 → m β) (init : β) : m β :=
  self.array.foldlM f init self.start self.stop

/-- Folds a function over a `ByteSubarray` from left to right. -/
@[inline] def foldl (self : ByteSubarray) (f : β → UInt8 → β) (init : β) : β :=
  self.foldlM (m:=Id) f init

/-- Implementation of `forIn` for a `ByteSubarray`. -/
@[specialize]
protected def forIn [Monad m] (self : ByteSubarray) (init : β) (f : UInt8 → β → m (ForInStep β)) :
    m β := loop self.size (Nat.le_refl _) init
where
  /-- Inner loop of the `forIn` implementation for `ByteSubarray`. -/
  loop (i : Nat) (h : i ≤ self.size) (b : β) : m β := do
    match i, h with
    | 0,   _ => pure b
    | i+1, h =>
      match (← f self[self.size - 1 - i] b) with
      | ForInStep.done b  => pure b
      | ForInStep.yield b => loop i (Nat.le_of_succ_le h) b

instance : ForIn m ByteSubarray UInt8 where
  forIn := ByteSubarray.forIn

instance : Stream ByteSubarray UInt8 where
  next? s := s[0]? >>= fun x => (x, s.popFront)

end Batteries.ByteSubarray

/-- `O(1)`. Coerce a byte array into a byte slice. -/
def ByteArray.toByteSubarray (array : ByteArray) : Batteries.ByteSubarray where
  array := array
  start := 0
  stop := array.size
  start_le_stop := Nat.zero_le _
  stop_le_array_size := Nat.le_refl _

instance : Coe ByteArray Batteries.ByteSubarray where
  coe := ByteArray.toByteSubarray



=== LEAN SOURCE: Char.lean ===
import Batteries.Data.Char.AsciiCasing
import Batteries.Data.Char.Basic



=== LEAN SOURCE: DList.lean ===
import Batteries.Data.DList.Basic
import Batteries.Data.DList.Lemmas



=== LEAN SOURCE: Fin.lean ===
import Batteries.Data.Fin.Basic
import Batteries.Data.Fin.Fold
import Batteries.Data.Fin.Lemmas
import Batteries.Data.Fin.OfBits



=== LEAN SOURCE: FloatArray.lean ===
/-
Copyright (c) 2024 François G. Dorais. All rights reserved.
Released under Apache 2. license as described in the file LICENSE.
Authors: François G. Dorais
-/

namespace FloatArray

attribute [ext] FloatArray

/--
Unsafe optimized implementation of `mapM`.

This function is unsafe because it relies on the implementation limit that the size of an array is
always less than `USize.size`.
-/
@[inline]
unsafe def mapMUnsafe [Monad m] (a : FloatArray) (f : Float → m Float) : m FloatArray :=
  loop a 0 a.usize
where
  /-- Inner loop for `mapMUnsafe`. -/
  @[specialize]
  loop (a : FloatArray) (k s : USize) := do
    if k < s then
      let x := a.uget k lcProof
      let y ← f x
      let a := a.uset k y lcProof
      loop a (k+1) s
    else pure a

/-- `mapM f a` applies the monadic function `f` to each element of the array. -/
@[implemented_by mapMUnsafe]
def mapM [Monad m] (a : FloatArray) (f : Float → m Float) : m FloatArray := do
  let mut r := a
  for i in [0:r.size] do
    r := r.set! i (← f r[i]!)
  return r

/-- `map f a` applies the function `f` to each element of the array. -/
@[inline]
def map (a : FloatArray) (f : Float → Float) : FloatArray :=
  mapM (m:=Id) a f



=== LEAN SOURCE: HashMap.lean ===
import Batteries.Data.HashMap.Basic
import Batteries.Data.HashMap.Lemmas



=== LEAN SOURCE: Int.lean ===
/-
Copyright (c) 2025 François G. Dorais. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: François G. Dorais
-/

import Batteries.Data.Nat.Lemmas

namespace Int

/--
`testBit m n` returns whether the `(n+1)` least significant bit is `1` or `0`, using the two's
complement convention for negative `m`.
-/
def testBit : Int → Nat → Bool
  | ofNat m, n => Nat.testBit m n
  | negSucc m, n => !(Nat.testBit m n)

/--
Construct an integer from a sequence of bits using little endian convention.

The sign is determined using the two's complement convention: the result is negative if and only if
`n > 0` and `f (n-1) = true`.
-/
def ofBits (f : Fin n → Bool) :=
  if 2 * Nat.ofBits f < 2 ^ n then
    ofNat (Nat.ofBits f)
  else
    subNatNat (Nat.ofBits f) (2 ^ n)

@[simp] theorem ofBits_zero (f : Fin 0 → Bool) : ofBits f = 0 := by
  simp [ofBits]

@[simp] theorem testBit_ofBits_lt {f : Fin n → Bool} (h : i < n) :
    (ofBits f).testBit i = f ⟨i, h⟩ := by
  simp only [ofBits]
  split
  · simp only [testBit, Nat.testBit_ofBits_lt, h]
  · have hlt := Nat.ofBits_lt_two_pow f
    simp [subNatNat_of_lt hlt, testBit, Nat.sub_sub, Nat.testBit_two_pow_sub_succ hlt, h]

@[simp] theorem testBit_ofBits_ge {f : Fin n → Bool} (h : i ≥ n) :
    (ofBits f).testBit i = decide (ofBits f < 0) := by
  simp only [ofBits]
  split
  · have hge : ¬ ofNat (Nat.ofBits f) < 0 := by rw [Int.not_lt]; exact natCast_nonneg ..
    simp only [testBit, Nat.testBit_ofBits_ge _ _ h, hge, decide_false]
  · have hlt := Nat.ofBits_lt_two_pow f
    have h : 2 ^ n - Nat.ofBits f - 1 < 2 ^ i :=
      Nat.lt_of_lt_of_le (by omega) (Nat.pow_le_pow_right Nat.zero_lt_two h)
    simp [testBit, subNatNat_of_lt hlt, Nat.testBit_lt_two_pow h, negSucc_lt_zero]

theorem testBit_ofBits (f : Fin n → Bool) :
    (ofBits f).testBit i = if h : i < n then f ⟨i, h⟩ else decide (ofBits f < 0) := by
  split <;> simp_all



=== LEAN SOURCE: List.lean ===
import Batteries.Data.List.ArrayMap
import Batteries.Data.List.Basic
import Batteries.Data.List.Count
import Batteries.Data.List.Init.Lemmas
import Batteries.Data.List.Lemmas
import Batteries.Data.List.Matcher
import Batteries.Data.List.Monadic
import Batteries.Data.List.OfFn
import Batteries.Data.List.Pairwise
import Batteries.Data.List.Perm



=== LEAN SOURCE: MLList.lean ===
import Batteries.Data.MLList.Basic
import Batteries.Data.MLList.Heartbeats
import Batteries.Data.MLList.IO



=== LEAN SOURCE: NameSet.lean ===
/-
Copyright (c) 2023 Kim Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Lean.Data.NameMap


namespace Lean.NameSet

instance : Singleton Name NameSet where
  singleton := fun n => (∅ : NameSet).insert n

instance : Union NameSet where
  union := fun s t => s.fold (fun t n => t.insert n) t

instance : Inter NameSet where
  inter := fun s t => s.fold (fun r n => if t.contains n then r.insert n else r) {}

instance : SDiff NameSet where
  sdiff := fun s t => t.fold (fun s n => s.erase n) s

/-- Create a `Lean.NameSet` from a `List`. This operation is `O(n)` in the length of the list. -/
def ofList (l : List Name) : NameSet :=
  l.foldl (fun s n => s.insert n) {}

/-- Create a `Lean.NameSet` from an `Array`. This operation is `O(n)` in the size of the array. -/
def ofArray (a : Array Name) : NameSet :=
  a.foldl (fun s n => s.insert n) {}

end Lean.NameSet



=== LEAN SOURCE: Nat.lean ===
import Batteries.Data.Nat.Basic
import Batteries.Data.Nat.Bisect
import Batteries.Data.Nat.Digits
import Batteries.Data.Nat.Gcd
import Batteries.Data.Nat.Lemmas



=== LEAN SOURCE: PairingHeap.lean ===
/-
Copyright (c) 2022 Yuyang Zhao. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yuyang Zhao
-/
import Batteries.Classes.Order

namespace Batteries.PairingHeapImp

/--
A `Heap` is the nodes of the pairing heap.
Each node have two pointers: `child` going to the first child of this node,
and `sibling` goes to the next sibling of this tree.
So it actually encodes a forest where each node has children
`node.child`, `node.child.sibling`, `node.child.sibling.sibling`, etc.

Each edge in this forest denotes a `le a b` relation that has been checked, so
the root is smaller than everything else under it.
-/
inductive Heap (α : Type u) where
  /-- An empty forest, which has depth `0`. -/
  | nil : Heap α
  /-- A forest consists of a root `a`, a forest `child` elements greater than `a`,
  and another forest `sibling`. -/
  | node (a : α) (child sibling : Heap α) : Heap α
  deriving Repr

/-- `O(n)`. The number of elements in the heap. -/
def Heap.size : Heap α → Nat
  | .nil => 0
  | .node _ c s => c.size + 1 + s.size

/-- A node containing a single element `a`. -/
def Heap.singleton (a : α) : Heap α := .node a .nil .nil

/-- `O(1)`. Is the heap empty? -/
def Heap.isEmpty : Heap α → Bool
  | .nil => true
  | _    => false

/-- `O(1)`. Merge two heaps. Ignore siblings. -/
@[specialize] def Heap.merge (le : α → α → Bool) : Heap α → Heap α → Heap α
  | .nil, .nil => .nil
  | .nil, .node a₂ c₂ _ => .node a₂ c₂ .nil
  | .node a₁ c₁ _, .nil => .node a₁ c₁ .nil
  | .node a₁ c₁ _, .node a₂ c₂ _ =>
    if le a₁ a₂ then .node a₁ (.node a₂ c₂ c₁) .nil else .node a₂ (.node a₁ c₁ c₂) .nil

/-- Auxiliary for `Heap.deleteMin`: merge the forest in pairs. -/
@[specialize] def Heap.combine (le : α → α → Bool) : Heap α → Heap α
  | h₁@(.node _ _ h₂@(.node _ _ s)) => merge le (merge le h₁ h₂) (s.combine le)
  | h => h

/-- `O(1)`. Get the smallest element in the heap, including the passed in value `a`. -/
@[inline] def Heap.headD (a : α) : Heap α → α
  | .nil => a
  | .node a _ _ => a

/-- `O(1)`. Get the smallest element in the heap, if it has an element. -/
@[inline] def Heap.head? : Heap α → Option α
  | .nil => none
  | .node a _ _ => some a

/-- Amortized `O(log n)`. Find and remove the the minimum element from the heap. -/
@[inline] def Heap.deleteMin (le : α → α → Bool) : Heap α → Option (α × Heap α)
  | .nil => none
  | .node a c _ => (a, combine le c)

/-- Amortized `O(log n)`. Get the tail of the pairing heap after removing the minimum element. -/
@[inline] def Heap.tail? (le : α → α → Bool) (h : Heap α) : Option (Heap α) :=
  deleteMin le h |>.map (·.snd)

/-- Amortized `O(log n)`. Remove the minimum element of the heap. -/
@[inline] def Heap.tail (le : α → α → Bool) (h : Heap α) : Heap α :=
  tail? le h |>.getD .nil

/-- A predicate says there is no more than one tree. -/
inductive Heap.NoSibling : Heap α → Prop
  /-- An empty heap is no more than one tree. -/
  | nil : NoSibling .nil
  /-- Or there is exactly one tree. -/
  | node (a c) : NoSibling (.node a c .nil)

instance : Decidable (Heap.NoSibling s) :=
  match s with
  | .nil => isTrue .nil
  | .node a c .nil => isTrue (.node a c)
  | .node _ _ (.node _ _ _) => isFalse nofun

theorem Heap.noSibling_merge (le) (s₁ s₂ : Heap α) :
    (s₁.merge le s₂).NoSibling := by
  unfold merge
  (split <;> try split) <;> constructor

theorem Heap.noSibling_combine (le) (s : Heap α) :
    (s.combine le).NoSibling := by
  unfold combine; split
  · exact noSibling_merge _ _ _
  · match s with
    | nil | node _ _ nil => constructor
    | node _ _ (node _ _ s) => rename_i h; exact (h _ _ _ _ _ rfl).elim

theorem Heap.noSibling_deleteMin {s : Heap α} (eq : s.deleteMin le = some (a, s')) :
    s'.NoSibling := by
  cases s with cases eq | node a c => exact noSibling_combine _ _

theorem Heap.noSibling_tail? {s : Heap α} : s.tail? le = some s' →
    s'.NoSibling := by
  simp only [Heap.tail?]; intro eq
  match eq₂ : s.deleteMin le, eq with
  | some (a, tl), rfl => exact noSibling_deleteMin eq₂

theorem Heap.noSibling_tail (le) (s : Heap α) : (s.tail le).NoSibling := by
  simp only [Heap.tail]
  match eq : s.tail? le with
  | none => cases s with cases eq | nil => constructor
  | some tl => exact Heap.noSibling_tail? eq

theorem Heap.size_merge_node (le) (a₁ : α) (c₁ s₁ : Heap α) (a₂ : α) (c₂ s₂ : Heap α) :
    (merge le (.node a₁ c₁ s₁) (.node a₂ c₂ s₂)).size = c₁.size + c₂.size + 2 := by
  unfold merge; dsimp; split <;> simp +arith [size]

theorem Heap.size_merge (le) {s₁ s₂ : Heap α} (h₁ : s₁.NoSibling) (h₂ : s₂.NoSibling) :
    (merge le s₁ s₂).size = s₁.size + s₂.size := by
  match h₁, h₂ with
  | .nil, .nil | .nil, .node _ _ | .node _ _, .nil => simp [merge, size]
  | .node _ _, .node _ _ => unfold merge; dsimp; split <;> simp +arith [size]

theorem Heap.size_combine (le) (s : Heap α) :
    (s.combine le).size = s.size := by
  unfold combine; split
  · rename_i a₁ c₁ a₂ c₂ s
    rw [size_merge le (noSibling_merge _ _ _) (noSibling_combine _ _),
      size_merge_node, size_combine le s]
    simp +arith [size]
  · rfl

theorem Heap.size_deleteMin {s : Heap α} (h : s.NoSibling) (eq : s.deleteMin le = some (a, s')) :
    s.size = s'.size + 1 := by
  cases h with cases eq | node a c => rw [size_combine, size, size]

theorem Heap.size_tail? {s : Heap α} (h : s.NoSibling) : s.tail? le = some s' →
    s.size = s'.size + 1 := by
  simp only [Heap.tail?]; intro eq
  match eq₂ : s.deleteMin le, eq with
  | some (a, tl), rfl => exact size_deleteMin h eq₂

theorem Heap.size_tail (le) {s : Heap α} (h : s.NoSibling) : (s.tail le).size = s.size - 1 := by
  simp only [Heap.tail]
  match eq : s.tail? le with
  | none => cases s with cases eq | nil => rfl
  | some tl => simp [Heap.size_tail? h eq]

theorem Heap.size_deleteMin_lt {s : Heap α} (eq : s.deleteMin le = some (a, s')) :
    s'.size < s.size := by
  cases s with cases eq | node a c => simp +arith [size_combine, size]

theorem Heap.size_tail?_lt {s : Heap α} : s.tail? le = some s' →
    s'.size < s.size := by
  simp only [Heap.tail?]; intro eq
  match eq₂ : s.deleteMin le, eq with
  | some (a, tl), rfl => exact size_deleteMin_lt eq₂

/--
`O(n log n)`. Monadic fold over the elements of a heap in increasing order,
by repeatedly pulling the minimum element out of the heap.
-/
@[specialize] def Heap.foldM [Monad m] (le : α → α → Bool) (s : Heap α)
    (init : β) (f : β → α → m β) : m β :=
  match eq : s.deleteMin le with
  | none => pure init
  | some (hd, tl) =>
    have : tl.size < s.size := by simp +arith [Heap.size_deleteMin_lt eq]
    do foldM le tl (← f init hd) f
termination_by s.size

/--
`O(n log n)`. Fold over the elements of a heap in increasing order,
by repeatedly pulling the minimum element out of the heap.
-/
@[inline] def Heap.fold (le : α → α → Bool) (s : Heap α) (init : β) (f : β → α → β) : β :=
  Id.run <| s.foldM le init f

/-- `O(n log n)`. Convert the heap to an array in increasing order. -/
@[inline] def Heap.toArray (le : α → α → Bool) (s : Heap α) : Array α := fold le s #[] Array.push

/-- `O(n log n)`. Convert the heap to a list in increasing order. -/
@[inline] def Heap.toList (le : α → α → Bool) (s : Heap α) : List α := (s.toArray le).toList

/-- `O(n)`. Fold a monadic function over the tree structure to accumulate a value. -/
@[specialize] def Heap.foldTreeM [Monad m] (nil : β) (join : α → β → β → m β) : Heap α → m β
  | .nil => pure nil
  | .node a c s => do join a (← c.foldTreeM nil join) (← s.foldTreeM nil join)

/-- `O(n)`. Fold a function over the tree structure to accumulate a value. -/
@[inline] def Heap.foldTree (nil : β) (join : α → β → β → β) (s : Heap α) : β :=
  Id.run <| s.foldTreeM nil join

/-- `O(n)`. Convert the heap to a list in arbitrary order. -/
def Heap.toListUnordered (s : Heap α) : List α :=
  s.foldTree id (fun a c s l => a :: c (s l)) []

/-- `O(n)`. Convert the heap to an array in arbitrary order. -/
def Heap.toArrayUnordered (s : Heap α) : Array α :=
  s.foldTree id (fun a c s r => s (c (r.push a))) #[]

/--
The well formedness predicate for a heap node.
It asserts that:
* If `a` is added at the top to make the forest into a tree, the resulting tree
  is a `le`-min-heap (if `le` is well-behaved)
-/
def Heap.NodeWF (le : α → α → Bool) (a : α) : Heap α → Prop
  | .nil => True
  | .node b c s => (∀ [TotalBLE le], le a b) ∧ c.NodeWF le b ∧ s.NodeWF le a

/--
The well formedness predicate for a pairing heap.
It asserts that:
* There is no more than one tree.
* It is a `le`-min-heap (if `le` is well-behaved)
-/
inductive Heap.WF (le : α → α → Bool) : Heap α → Prop
  /-- It is an empty heap. -/
  | nil : WF le .nil
  /-- There is exactly one tree and it is a `le`-min-heap. -/
  | node (h : c.NodeWF le a) : WF le (.node a c .nil)

theorem Heap.WF.singleton : (Heap.singleton a).WF le := node trivial

theorem Heap.WF.merge_node (h₁ : NodeWF le a₁ c₁) (h₂ : NodeWF le a₂ c₂) :
    (merge le (.node a₁ c₁ s₁) (.node a₂ c₂ s₂)).WF le := by
  unfold merge; dsimp
  split <;> rename_i h
  · exact node ⟨fun [_] => h, h₂, h₁⟩
  · exact node ⟨fun [_] => TotalBLE.total.resolve_left h, h₁, h₂⟩

theorem Heap.WF.merge (h₁ : s₁.WF le) (h₂ : s₂.WF le) :
    (merge le s₁ s₂).WF le :=
  match h₁, h₂ with
  | .nil, .nil => nil
  | .nil, .node h₂ => node h₂
  | .node h₁, .nil => node h₁
  | .node h₁, .node h₂ => merge_node h₁ h₂

theorem Heap.WF.combine (h : s.NodeWF le a) : (combine le s).WF le :=
  match s with
  | .nil => nil
  | .node _b _c .nil => node h.2.1
  | .node _b₁ _c₁ (.node _b₂ _c₂ _s) => merge (merge_node h.2.1 h.2.2.2.1) (combine h.2.2.2.2)

theorem Heap.WF.deleteMin {s : Heap α} (h : s.WF le)
    (eq : s.deleteMin le = some (a, s')) : s'.WF le := by
  cases h with cases eq | node h => exact Heap.WF.combine h

theorem Heap.WF.tail? (hwf : (s : Heap α).WF le) : s.tail? le = some tl →
  tl.WF le := by
  simp only [Heap.tail?]; intro eq
  match eq₂ : s.deleteMin le, eq with
  | some (a, tl), rfl => exact hwf.deleteMin eq₂

theorem Heap.WF.tail (hwf : (s : Heap α).WF le) : (s.tail le).WF le := by
  simp only [Heap.tail]
  match eq : s.tail? le with
  | none => exact Heap.WF.nil
  | some tl => exact hwf.tail? eq

theorem Heap.deleteMin_fst : ((s : Heap α).deleteMin le).map (·.1) = s.head? :=
  match s with
  | .nil => rfl
  | .node _ _ _ => rfl

end PairingHeapImp

open PairingHeapImp

/--
A [pairing heap](https://en.wikipedia.org/wiki/Pairing_heap) is a data structure which supports
the following primary operations:

* `insert : α → PairingHeap α → PairingHeap α`: add an element to the heap
* `deleteMin : PairingHeap α → Option (α × PairingHeap α)`:
  remove the minimum element from the heap
* `merge : PairingHeap α → PairingHeap α → PairingHeap α`: combine two heaps

The first two operations are known as a "priority queue", so this could be called
a "mergeable priority queue". The standard choice for a priority queue is a binary heap,
which supports `insert` and `deleteMin` in `O(log n)`, but `merge` is `O(n)`.
With a `PairingHeap`, `insert` and `merge` are `O(1)`, `deleteMin` is amortized `O(log n)`.

Note that `deleteMin` may be `O(n)` in a single operation. So if you need an efficient
persistent priority queue, you should use other data structures with better worst-case time.
-/
def PairingHeap (α : Type u) (le : α → α → Bool) :=
  { h : Heap α // h.WF le }

/-- `O(1)`. Make a new empty pairing heap. -/
@[inline] def mkPairingHeap (α : Type u) (le : α → α → Bool) : PairingHeap α le :=
  ⟨.nil, Heap.WF.nil⟩

namespace PairingHeap
variable {α : Type u} {le : α → α → Bool}

/-- `O(1)`. Make a new empty pairing heap. -/
@[inline] def empty : PairingHeap α le := mkPairingHeap α le

instance : Inhabited (PairingHeap α le) := ⟨.empty⟩

/-- `O(1)`. Is the heap empty? -/
@[inline] def isEmpty (b : PairingHeap α le) : Bool := b.1.isEmpty

/-- `O(n)`. The number of elements in the heap. -/
@[inline] def size (b : PairingHeap α le) : Nat := b.1.size

/-- `O(1)`. Make a new heap containing `a`. -/
@[inline] def singleton (a : α) : PairingHeap α le :=
  ⟨Heap.singleton a, Heap.WF.singleton⟩

/-- `O(1)`. Merge the contents of two heaps. -/
@[inline] def merge : PairingHeap α le → PairingHeap α le → PairingHeap α le
  | ⟨b₁, h₁⟩, ⟨b₂, h₂⟩ => ⟨b₁.merge le b₂, h₁.merge h₂⟩

/-- `O(1)`. Add element `a` to the given heap `h`. -/
@[inline] def insert (a : α) (h : PairingHeap α le) : PairingHeap α le :=
  merge (singleton a) h

/-- `O(n log n)`. Construct a heap from a list by inserting all the elements. -/
def ofList (le : α → α → Bool) (as : List α) : PairingHeap α le :=
  as.foldl (flip insert) empty

/-- `O(n log n)`. Construct a heap from a list by inserting all the elements. -/
def ofArray (le : α → α → Bool) (as : Array α) : PairingHeap α le :=
  as.foldl (flip insert) empty

/-- Amortized `O(log n)`. Remove and return the minimum element from the heap. -/
@[inline] def deleteMin (b : PairingHeap α le) : Option (α × PairingHeap α le) :=
  match eq : b.1.deleteMin le with
  | none => none
  | some (a, tl) => some (a, ⟨tl, b.2.deleteMin eq⟩)

/-- `O(1)`. Returns the smallest element in the heap, or `none` if the heap is empty. -/
@[inline] def head? (b : PairingHeap α le) : Option α := b.1.head?

/-- `O(1)`. Returns the smallest element in the heap, or panics if the heap is empty. -/
@[inline] def head! [Inhabited α] (b : PairingHeap α le) : α := b.head?.get!

/-- `O(1)`. Returns the smallest element in the heap, or `default` if the heap is empty. -/
@[inline] def headI [Inhabited α] (b : PairingHeap α le) : α := b.head?.getD default

/--
Amortized `O(log n)`. Removes the smallest element from the heap, or `none` if the heap is empty.
-/
@[inline] def tail? (b : PairingHeap α le) : Option (PairingHeap α le) :=
  match eq : b.1.tail? le with
  | none => none
  | some tl => some ⟨tl, b.2.tail? eq⟩

/-- Amortized `O(log n)`. Removes the smallest element from the heap, if possible. -/
@[inline] def tail (b : PairingHeap α le) : PairingHeap α le := ⟨b.1.tail le, b.2.tail⟩

/-- `O(n log n)`. Convert the heap to a list in increasing order. -/
@[inline] def toList (b : PairingHeap α le) : List α := b.1.toList le

/-- `O(n log n)`. Convert the heap to an array in increasing order. -/
@[inline] def toArray (b : PairingHeap α le) : Array α := b.1.toArray le

/-- `O(n)`. Convert the heap to a list in arbitrary order. -/
@[inline] def toListUnordered (b : PairingHeap α le) : List α := b.1.toListUnordered

/-- `O(n)`. Convert the heap to an array in arbitrary order. -/
@[inline] def toArrayUnordered (b : PairingHeap α le) : Array α := b.1.toArrayUnordered



=== LEAN SOURCE: Random.lean ===
import Batteries.Data.Random.MersenneTwister



=== LEAN SOURCE: Range.lean ===
import Batteries.Data.Range.Lemmas



=== LEAN SOURCE: Rat.lean ===
import Batteries.Data.Rat.Basic
import Batteries.Data.Rat.Float
import Batteries.Data.Rat.Lemmas



=== LEAN SOURCE: RBMap.lean ===
import Batteries.Data.RBMap.Alter
import Batteries.Data.RBMap.Basic
import Batteries.Data.RBMap.Depth
import Batteries.Data.RBMap.Lemmas
import Batteries.Data.RBMap.WF



=== LEAN SOURCE: Stream.lean ===
/-
Copyright (c) 2024 François G. Dorais. All rights reserved.
Released under Apache 2. license as described in the file LICENSE.
Authors: François G. Dorais
-/

namespace Stream

/-- Drop up to `n` values from the stream `s`. -/
def drop [Stream σ α] (s : σ) : Nat → σ
  | 0 => s
  | n+1 =>
    match next? s with
    | none => s
    | some (_, s) => drop s n

/-- Read up to `n` values from the stream `s` as a list from first to last. -/
def take [Stream σ α] (s : σ) : Nat → List α × σ
  | 0 => ([], s)
  | n+1 =>
    match next? s with
    | none => ([], s)
    | some (a, s) =>
      match take s n with
      | (as, s) => (a :: as, s)

@[simp] theorem fst_take_zero [Stream σ α] (s : σ) :
    (take s 0).fst = [] := rfl

theorem fst_take_succ [Stream σ α] (s : σ) :
    (take s (n+1)).fst = match next? s with
      | none => []
      | some (a, s) => a :: (take s n).fst := by
  simp only [take]; split <;> rfl

@[simp] theorem snd_take_eq_drop [Stream σ α] (s : σ) (n : Nat) :
    (take s n).snd = drop s n := by
  induction n generalizing s with
  | zero => rfl
  | succ n ih =>
    simp only [take, drop]
    split <;> simp [ih]

/-- Tail recursive version of `Stream.take`. -/
def takeTR [Stream σ α] (s : σ) (n : Nat) : List α × σ :=
  loop s [] n
where
  /-- Inner loop for `Stream.takeTR`. -/
  loop (s : σ) (acc : List α)
    | 0 => (acc.reverse, s)
    | n+1 => match next? s with
      | none => (acc.reverse, s)
      | some (a, s) => loop s (a :: acc) n

theorem fst_takeTR_loop [Stream σ α] (s : σ) (acc : List α) (n : Nat) :
    (takeTR.loop s acc n).fst = acc.reverseAux (take s n).fst := by
  induction n generalizing acc s with
  | zero => rfl
  | succ n ih => simp only [take, takeTR.loop]; split; rfl; simp [ih]

theorem fst_takeTR [Stream σ α] (s : σ) (n : Nat) : (takeTR s n).fst = (take s n).fst :=
  fst_takeTR_loop ..

theorem snd_takeTR_loop [Stream σ α] (s : σ) (acc : List α) (n : Nat) :
    (takeTR.loop s acc n).snd = drop s n := by
  induction n generalizing acc s with
  | zero => rfl
  | succ n ih => simp only [takeTR.loop, drop]; split; rfl; simp [ih]

theorem snd_takeTR [Stream σ α] (s : σ) (n : Nat) :
    (takeTR s n).snd = drop s n := snd_takeTR_loop ..

@[csimp] theorem take_eq_takeTR : @take = @takeTR := by
  funext; ext : 1; rw [fst_takeTR]; rw [snd_takeTR, snd_take_eq_drop]

end Stream

@[simp] theorem List.stream_drop_eq_drop (l : List α) : Stream.drop l n = l.drop n := by
  induction n generalizing l with
  | zero => rfl
  | succ n ih =>
    match l with
    | [] => rfl
    | _::_ => simp [Stream.drop, List.drop_succ_cons, ih]

@[simp] theorem List.stream_take_eq_take_drop (l : List α) :
    Stream.take l n = (l.take n, l.drop n) := by
  induction n generalizing l with
  | zero => rfl
  | succ n ih =>
    match l with
    | [] => rfl
    | _::_ => simp [Stream.take, ih]



=== LEAN SOURCE: String.lean ===
import Batteries.Data.String.Basic
import Batteries.Data.String.Lemmas
import Batteries.Data.String.Matcher



=== LEAN SOURCE: UInt.lean ===
/-
Copyright (c) 2023 François G. Dorais. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: François G. Dorais, Mario Carneiro
-/
import Batteries.Classes.Order

/-! ### UInt8 -/

@[ext] theorem UInt8.ext : {x y : UInt8} → x.toNat = y.toNat → x = y
  | ⟨⟨_,_⟩⟩, ⟨⟨_,_⟩⟩, rfl => rfl

@[simp] theorem UInt8.toUInt16_toNat (x : UInt8) : x.toUInt16.toNat = x.toNat := rfl

@[simp] theorem UInt8.toUInt32_toNat (x : UInt8) : x.toUInt32.toNat = x.toNat := rfl

@[simp] theorem UInt8.toUInt64_toNat (x : UInt8) : x.toUInt64.toNat = x.toNat := rfl

instance : Std.LawfulOrd UInt8 :=
  Std.LawfulCmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm
    (fun _ => Nat.lt_irrefl _) Nat.lt_trans Nat.not_lt UInt8.le_antisymm

/-! ### UInt16 -/

@[ext] theorem UInt16.ext : {x y : UInt16} → x.toNat = y.toNat → x = y
  | ⟨⟨_,_⟩⟩, ⟨⟨_,_⟩⟩, rfl => rfl

@[simp] theorem UInt16.toUInt8_toNat (x : UInt16) : x.toUInt8.toNat = x.toNat % 2 ^ 8 := rfl

@[simp] theorem UInt16.toUInt32_toNat (x : UInt16) : x.toUInt32.toNat = x.toNat := rfl

@[simp] theorem UInt16.toUInt64_toNat (x : UInt16) : x.toUInt64.toNat = x.toNat := rfl

instance : Std.LawfulOrd UInt16 :=
  Std.LawfulCmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm
    (fun _ => Nat.lt_irrefl _) Nat.lt_trans Nat.not_lt UInt16.le_antisymm

/-! ### UInt32 -/

@[ext] theorem UInt32.ext : {x y : UInt32} → x.toNat = y.toNat → x = y
  | ⟨⟨_,_⟩⟩, ⟨⟨_,_⟩⟩, rfl => rfl

@[simp] theorem UInt32.toUInt8_toNat (x : UInt32) : x.toUInt8.toNat = x.toNat % 2 ^ 8 := rfl

@[simp] theorem UInt32.toUInt16_toNat (x : UInt32) : x.toUInt16.toNat = x.toNat % 2 ^ 16 := rfl

@[simp] theorem UInt32.toUInt64_toNat (x : UInt32) : x.toUInt64.toNat = x.toNat := rfl

instance : Std.LawfulOrd UInt32 :=
  Std.LawfulCmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm
    (fun _ => Nat.lt_irrefl _) Nat.lt_trans Nat.not_lt UInt32.le_antisymm

/-! ### UInt64 -/

@[ext] theorem UInt64.ext : {x y : UInt64} → x.toNat = y.toNat → x = y
  | ⟨⟨_,_⟩⟩, ⟨⟨_,_⟩⟩, rfl => rfl

@[simp] theorem UInt64.toUInt8_toNat (x : UInt64) : x.toUInt8.toNat = x.toNat % 2 ^ 8 := rfl

@[simp] theorem UInt64.toUInt16_toNat (x : UInt64) : x.toUInt16.toNat = x.toNat % 2 ^ 16 := rfl

@[simp] theorem UInt64.toUInt32_toNat (x : UInt64) : x.toUInt32.toNat = x.toNat % 2 ^ 32 := rfl

instance : Std.LawfulOrd UInt64 :=
  Std.LawfulCmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm
    (fun _ => Nat.lt_irrefl _) Nat.lt_trans Nat.not_lt UInt64.le_antisymm

/-! ### USize -/

@[ext] theorem USize.ext : {x y : USize} → x.toNat = y.toNat → x = y
  | ⟨⟨_,_⟩⟩, ⟨⟨_,_⟩⟩, rfl => rfl

theorem USize.toUInt64_toNat (x : USize) : x.toUInt64.toNat = x.toNat := by
  simp

@[simp] theorem UInt32.toUSize_toNat (x : UInt32) : x.toUSize.toNat = x.toNat := rfl

instance : Std.LawfulOrd USize :=
  Std.LawfulCmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm
    (fun _ => Nat.lt_irrefl _) Nat.lt_trans Nat.not_lt USize.le_antisymm



=== LEAN SOURCE: UnionFind.lean ===
import Batteries.Data.UnionFind.Basic
import Batteries.Data.UnionFind.Lemmas



=== LEAN SOURCE: Vector.lean ===
import Batteries.Data.Vector.Basic
import Batteries.Data.Vector.Lemmas
import Batteries.Data.Vector.Monadic



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2021 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Arthur Paulino, Floris van Doorn, Jannis Limperg
-/

/-!
## Definitions on Arrays

This file contains various definitions on `Array`. It does not contain
proofs about these definitions, those are contained in other files in `Batteries.Data.Array`.
-/

namespace Array

/--
Check whether `xs` and `ys` are equal as sets, i.e. they contain the same
elements when disregarding order and duplicates. `O(n*m)`! If your element type
has an `Ord` instance, it is asymptotically more efficient to sort the two
arrays, remove duplicates and then compare them elementwise.
-/
def equalSet [BEq α] (xs ys : Array α) : Bool :=
  xs.all (ys.contains ·) && ys.all (xs.contains ·)

set_option linter.unusedVariables.funArgs false in
/--
Returns the first minimal element among `d` and elements of the array.
If `start` and `stop` are given, only the subarray `xs[start:stop]` is
considered (in addition to `d`).
-/
@[inline]
protected def minWith [ord : Ord α]
    (xs : Array α) (d : α) (start := 0) (stop := xs.size) : α :=
  xs.foldl (init := d) (start := start) (stop := stop) fun min x =>
    if compare x min |>.isLT then x else min

set_option linter.unusedVariables.funArgs false in
/--
Find the first minimal element of an array. If the array is empty, `d` is
returned. If `start` and `stop` are given, only the subarray `xs[start:stop]` is
considered.
-/
@[inline]
protected def minD [ord : Ord α]
    (xs : Array α) (d : α) (start := 0) (stop := xs.size) : α :=
  if h: start < xs.size ∧ start < stop then
    xs.minWith xs[start] (start + 1) stop
  else
    d

set_option linter.unusedVariables.funArgs false in
/--
Find the first minimal element of an array. If the array is empty, `none` is
returned. If `start` and `stop` are given, only the subarray `xs[start:stop]` is
considered.
-/
@[inline]
protected def min? [ord : Ord α]
    (xs : Array α) (start := 0) (stop := xs.size) : Option α :=
  if h : start < xs.size ∧ start < stop then
    some $ xs.minD xs[start] start stop
  else
    none

set_option linter.unusedVariables.funArgs false in
/--
Find the first minimal element of an array. If the array is empty, `default` is
returned. If `start` and `stop` are given, only the subarray `xs[start:stop]` is
considered.
-/
@[inline]
protected def minI [ord : Ord α] [Inhabited α]
    (xs : Array α) (start := 0) (stop := xs.size) : α :=
  xs.minD default start stop

set_option linter.unusedVariables.funArgs false in
/--
Returns the first maximal element among `d` and elements of the array.
If `start` and `stop` are given, only the subarray `xs[start:stop]` is
considered (in addition to `d`).
-/
@[inline]
protected def maxWith [ord : Ord α]
    (xs : Array α) (d : α) (start := 0) (stop := xs.size) : α :=
  xs.minWith (ord := ord.opposite) d start stop

set_option linter.unusedVariables.funArgs false in
/--
Find the first maximal element of an array. If the array is empty, `d` is
returned. If `start` and `stop` are given, only the subarray `xs[start:stop]` is
considered.
-/
@[inline]
protected def maxD [ord : Ord α]
    (xs : Array α) (d : α) (start := 0) (stop := xs.size) : α :=
  xs.minD (ord := ord.opposite) d start stop

set_option linter.unusedVariables.funArgs false in
/--
Find the first maximal element of an array. If the array is empty, `none` is
returned. If `start` and `stop` are given, only the subarray `xs[start:stop]` is
considered.
-/
@[inline]
protected def max? [ord : Ord α]
    (xs : Array α) (start := 0) (stop := xs.size) : Option α :=
  xs.min? (ord := ord.opposite) start stop

set_option linter.unusedVariables.funArgs false in
/--
Find the first maximal element of an array. If the array is empty, `default` is
returned. If `start` and `stop` are given, only the subarray `xs[start:stop]` is
considered.
-/
@[inline]
protected def maxI [ord : Ord α] [Inhabited α]
    (xs : Array α) (start := 0) (stop := xs.size) : α :=
  xs.minI (ord := ord.opposite) start stop

/-!
### Safe Nat Indexed Array functions
The functions in this section offer variants of Array functions which use `Nat` indices
instead of `Fin` indices. All these functions have as parameter a proof that the index is
valid for the array. But this parameter has a default argument `by get_elem_tactic` which
should prove the index bound.
-/

/--
`setN a i h x` sets an element in a vector using a Nat index which is provably valid.
A proof by `get_elem_tactic` is provided as a default argument for `h`.
This will perform the update destructively provided that `a` has a reference count of 1 when called.
-/
abbrev setN (a : Array α) (i : Nat) (x : α) (h : i < a.size := by get_elem_tactic) : Array α :=
  a.set i x

end Array


namespace Subarray

/--
Check whether a subarray is empty.
-/
@[inline]
def isEmpty (as : Subarray α) : Bool :=
  as.start == as.stop

/--
Check whether a subarray contains an element.
-/
@[inline]
def contains [BEq α] (as : Subarray α) (a : α) : Bool :=
  as.any (· == a)

/--
Remove the first element of a subarray. Returns the element and the remaining
subarray, or `none` if the subarray is empty.
-/
def popHead? (as : Subarray α) : Option (α × Subarray α) :=
  if h : as.start < as.stop
    then
      let head := as.array[as.start]'(Nat.lt_of_lt_of_le h as.stop_le_array_size)
      let tail :=
        ⟨{ as.internalRepresentation with
           start := as.start + 1
           start_le_stop := Nat.le_of_lt_succ $ Nat.succ_lt_succ h }⟩
      some (head, tail)
    else
      none

end Subarray



=== LEAN SOURCE: Lemmas.lean ===
/-
Copyright (c) 2021 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.

Authors: Mario Carneiro, Gabriel Ebner
-/
import Batteries.Data.List.Lemmas

namespace Array

@[deprecated forIn_toList (since := "2025-07-01")]
theorem forIn_eq_forIn_toList [Monad m]
    (as : Array α) (b : β) (f : α → β → m (ForInStep β)) :
    forIn as b f = forIn as.toList b f := by
  cases as
  simp

/-! ### idxOf? -/

open List

@[grind =]
theorem idxOf?_toList [BEq α] {a : α} {l : Array α} :
    l.toList.idxOf? a = l.idxOf? a := by
  rcases l with ⟨l⟩
  simp

/-! ### erase -/

@[deprecated (since := "2025-02-06")] alias eraseP_toArray := List.eraseP_toArray
@[deprecated (since := "2025-02-06")] alias erase_toArray := List.erase_toArray

@[simp, grind =] theorem toList_erase [BEq α] (l : Array α) (a : α) :
    (l.erase a).toList = l.toList.erase a := by
  rcases l with ⟨l⟩
  simp

@[simp, grind =] theorem size_eraseIdxIfInBounds (a : Array α) (i : Nat) :
    (a.eraseIdxIfInBounds i).size = if i < a.size then a.size-1 else a.size := by
  grind [eraseIdxIfInBounds]

/-! ### set -/

theorem size_set! (a : Array α) (i v) : (a.set! i v).size = a.size := by simp

/-! ### map -/

/-! ### mem -/

/-! ### insertAt -/

@[deprecated (since := "2025-02-06")] alias getElem_insertIdx_lt := getElem_insertIdx_of_lt
@[deprecated (since := "2025-02-06")] alias getElem_insertIdx_eq := getElem_insertIdx_self
@[deprecated (since := "2025-02-06")] alias getElem_insertIdx_gt := getElem_insertIdx_of_gt



=== LEAN SOURCE: Match.lean ===
/-
Copyright (c) 2023 F. G. Dorais. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: F. G. Dorais
-/

namespace Array

/-- Prefix table for the Knuth-Morris-Pratt matching algorithm

  This is an array of the form `t = [(x₀,n₀), (x₁,n₁), (x₂, n₂), ...]` where for each `i`, `nᵢ` is
  the length of the longest proper prefix of `xs = [x₀,x₁,...,xᵢ]` which is also a suffix of `xs`.
-/
structure PrefixTable (α : Type _) extends Array (α × Nat) where
  /-- Validity condition to help with termination proofs -/
  valid : (h : i < toArray.size) → toArray[i].2 ≤ i

instance : Inhabited (PrefixTable α) where
  default := ⟨#[], nofun⟩

/-- Returns the size of the prefix table -/
abbrev PrefixTable.size (t : PrefixTable α) := t.toArray.size

/-- Transition function for the KMP matcher

  Assuming we have an input `xs` with a suffix that matches the pattern prefix `t.pattern[:len]`
  where `len : Fin (t.size+1)`. Then `xs.push x` has a suffix that matches the pattern prefix
  `t.pattern[:t.step x len]`. If `len` is as large as possible then `t.step x len` will also be
  as large as possible.
-/
def PrefixTable.step [BEq α] (t : PrefixTable α) (x : α) : Fin (t.size+1) → Fin (t.size+1)
  | ⟨k, hk⟩ =>
    let cont := fun () =>
      match k with
      | 0 => ⟨0, Nat.zero_lt_succ _⟩
      | k + 1 =>
        have h2 : k < t.size := Nat.lt_of_succ_lt_succ hk
        let k' := t.toArray[k].2
        have hk' : k' < k + 1 := Nat.lt_succ_of_le (t.valid h2)
        step t x ⟨k', Nat.lt_trans hk' hk⟩
    if hsz : k < t.size then
      if x == t.toArray[k].1 then
        ⟨k+1, Nat.succ_lt_succ hsz⟩
      else cont ()
    else cont ()
termination_by k => k.val

/-- Extend a prefix table by one element

  If `t` is the prefix table for `xs` then `t.extend x` is the prefix table for `xs.push x`.
-/
def PrefixTable.extend [BEq α] (t : PrefixTable α) (x : α) : PrefixTable α where
  toArray := t.toArray.push (x, t.step x ⟨t.size, Nat.lt_succ_self _⟩)
  valid _ := by
    rw [Array.getElem_push]
    split
    · exact t.valid ..
    · next h => exact Nat.le_trans (Nat.lt_succ.1 <| Fin.isLt ..) (Nat.not_lt.1 h)

/-- Make prefix table from a pattern array -/
def mkPrefixTable [BEq α] (xs : Array α) : PrefixTable α := xs.foldl (·.extend) default

/-- Make prefix table from a pattern stream -/
partial def mkPrefixTableOfStream [BEq α] [Stream σ α] (stream : σ) : PrefixTable α :=
  loop default stream
where
  /-- Inner loop for `mkPrefixTableOfStream` -/
  loop (t : PrefixTable α) (stream : σ) :=
    match Stream.next? stream with
    | none => t
    | some (x, stream) => loop (t.extend x) stream

/-- KMP matcher structure -/
structure Matcher (α) where
  /-- Prefix table for the pattern -/
  table : PrefixTable α
  /-- Current longest matching prefix -/
  state : Fin (table.size + 1) := 0

/-- Make a KMP matcher for a given pattern array -/
def Matcher.ofArray [BEq α] (pat : Array α) : Matcher α where
  table := mkPrefixTable pat

/-- Make a KMP matcher for a given a pattern stream -/
def Matcher.ofStream [BEq α] [Stream σ α] (pat : σ) : Matcher α where
  table := mkPrefixTableOfStream pat

/-- Find next match from a given stream

  Runs the stream until it reads a sequence that matches the sought pattern, then returns the stream
  state at that point and an updated matcher state.
-/
partial def Matcher.next? [BEq α] [Stream σ α] (m : Matcher α) (stream : σ) :
    Option (σ × Matcher α) :=
  match Stream.next? stream with
  | none => none
  | some (x, stream) =>
    let state := m.table.step x m.state
    if state = m.table.size then
      some (stream, { m with state })
    else
      next? { m with state } stream

end Array



=== LEAN SOURCE: Merge.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

namespace Array

/--
`O(|xs| + |ys|)`. Merge arrays `xs` and `ys`. If the arrays are sorted according to `lt`, then the
result is sorted as well. If two (or more) elements are equal according to `lt`, they are preserved.
-/
def merge (lt : α → α → Bool) (xs ys : Array α) : Array α :=
  go (Array.mkEmpty (xs.size + ys.size)) 0 0
where
  /-- Auxiliary definition for `merge`. -/
  go (acc : Array α) (i j : Nat) : Array α :=
    if hi : i ≥ xs.size then
      acc ++ ys[j:]
    else if hj : j ≥ ys.size then
      acc ++ xs[i:]
    else
      let x := xs[i]
      let y := ys[j]
      if lt x y then go (acc.push x) (i + 1) j else go (acc.push y) i (j + 1)
  termination_by xs.size + ys.size - (i + j)

-- We name `ord` so it can be provided as a named argument.
set_option linter.unusedVariables.funArgs false in
/--
`O(|xs| + |ys|)`. Merge arrays `xs` and `ys`, which must be sorted according to `compare` and must
not contain duplicates. Equal elements are merged using `merge`. If `merge` respects the order
(i.e. for all `x`, `y`, `y'`, `z`, if `x < y < z` and `x < y' < z` then `x < merge y y' < z`)
then the resulting array is again sorted.
-/
def mergeDedupWith [ord : Ord α] (xs ys : Array α) (merge : α → α → α) : Array α :=
  go (Array.mkEmpty (xs.size + ys.size)) 0 0
where
  /-- Auxiliary definition for `mergeDedupWith`. -/
  go (acc : Array α) (i j : Nat) : Array α :=
    if hi : i ≥ xs.size then
      acc ++ ys[j:]
    else if hj : j ≥ ys.size then
      acc ++ xs[i:]
    else
      let x := xs[i]
      let y := ys[j]
      match compare x y with
      | .lt => go (acc.push x) (i + 1) j
      | .gt => go (acc.push y) i (j + 1)
      | .eq => go (acc.push (merge x y)) (i + 1) (j + 1)
  termination_by xs.size + ys.size - (i + j)

/--
`O(|xs| + |ys|)`. Merge arrays `xs` and `ys`, which must be sorted according to `compare` and must
not contain duplicates. If an element appears in both `xs` and `ys`, only one copy is kept.
-/
@[inline] def mergeDedup [ord : Ord α] (xs ys : Array α) : Array α :=
  mergeDedupWith (ord := ord) xs ys fun x _ => x

set_option linter.unusedVariables false in
/--
`O(|xs| * |ys|)`. Merge `xs` and `ys`, which do not need to be sorted. Elements which occur in
both `xs` and `ys` are only added once. If `xs` and `ys` do not contain duplicates, then neither
does the result.
-/
def mergeUnsortedDedup [eq : BEq α] (xs ys : Array α) : Array α :=
  -- Ideally we would check whether `xs` or `ys` have spare capacity, to prevent
  -- copying if possible. But Lean arrays don't expose their capacity.
  if xs.size < ys.size then go ys xs else go xs ys
where
  /-- Auxiliary definition for `mergeUnsortedDedup`. -/
  @[inline] go (xs ys : Array α) :=
    let xsSize := xs.size
    ys.foldl (init := xs) fun xs y =>
      if xs.any (· == y) (stop := xsSize) then xs else xs.push y

-- We name `eq` so it can be provided as a named argument.
set_option linter.unusedVariables.funArgs false in
/--
`O(|xs|)`. Replace each run `[x₁, ⋯, xₙ]` of equal elements in `xs` with
`f ⋯ (f (f x₁ x₂) x₃) ⋯ xₙ`.
-/
def mergeAdjacentDups [eq : BEq α] (f : α → α → α) (xs : Array α) : Array α :=
  if h : 0 < xs.size then go (mkEmpty xs.size) 1 xs[0] else xs
where
  /-- Auxiliary definition for `mergeAdjacentDups`. -/
  go (acc : Array α) (i : Nat) (hd : α) :=
    if h : i < xs.size then
      let x := xs[i]
      if x == hd then go acc (i + 1) (f hd x) else go (acc.push hd) (i + 1) x
    else
      acc.push hd
  termination_by xs.size - i

/--
`O(|xs|)`. Deduplicate a sorted array. The array must be sorted with to an order which agrees with
`==`, i.e. whenever `x == y` then `compare x y == .eq`.
-/
def dedupSorted [eq : BEq α] (xs : Array α) : Array α :=
  xs.mergeAdjacentDups (eq := eq) fun x _ => x

/-- `O(|xs| log |xs|)`. Sort and deduplicate an array. -/
def sortDedup [ord : Ord α] (xs : Array α) : Array α :=
  have := ord.toBEq
  dedupSorted <| xs.qsort (compare · · |>.isLT)

end Array



=== LEAN SOURCE: Monadic.lean ===
/-
Copyright (c) 2021 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.

Authors: Mario Carneiro, Gabriel Ebner
-/
import Batteries.Classes.SatisfiesM
import Batteries.Util.ProofWanted

/-!
# Results about monadic operations on `Array`, in terms of `SatisfiesM`.

The pure versions of these theorems are proved in `Batteries.Data.Array.Lemmas` directly,
in order to minimize dependence on `SatisfiesM`.
-/

namespace Array

theorem SatisfiesM_foldlM [Monad m] [LawfulMonad m]
    {as : Array α} (motive : Nat → β → Prop) {init : β} (h0 : motive 0 init) {f : β → α → m β}
    (hf : ∀ i : Fin as.size, ∀ b, motive i.1 b → SatisfiesM (motive (i.1 + 1)) (f b as[i])) :
    SatisfiesM (motive as.size) (as.foldlM f init) := by
  let rec go {i j b} (h₁ : j ≤ as.size) (h₂ : as.size ≤ i + j) (H : motive j b) :
    SatisfiesM (motive as.size) (foldlM.loop f as as.size (Nat.le_refl _) i j b) := by
    unfold foldlM.loop; split
    · next hj =>
      split
      · cases Nat.not_le_of_gt (by simp [hj]) h₂
      · exact (hf ⟨j, hj⟩ b H).bind fun _ => go hj (by rwa [Nat.succ_add] at h₂)
    · next hj => exact Nat.le_antisymm h₁ (Nat.ge_of_not_lt hj) ▸ .pure H
  simp [foldlM]; exact go (Nat.zero_le _) (Nat.le_refl _) h0

theorem SatisfiesM_mapM [Monad m] [LawfulMonad m] (as : Array α) (f : α → m β)
    (motive : Nat → Prop) (h0 : motive 0)
    (p : Fin as.size → β → Prop)
    (hs : ∀ i, motive i.1 → SatisfiesM (p i · ∧ motive (i + 1)) (f as[i])) :
    SatisfiesM
      (fun arr => motive as.size ∧ ∃ eq : arr.size = as.size, ∀ i h, p ⟨i, h⟩ arr[i])
      (Array.mapM f as) := by
  rw [mapM_eq_foldlM]
  refine SatisfiesM_foldlM (m := m) (β := Array β)
    (motive := fun i arr => motive i ∧ arr.size = i ∧ ∀ i h2, p i (arr[i.1]'h2)) ?z ?s
    |>.imp fun ⟨h₁, eq, h₂⟩ => ⟨h₁, eq, fun _ _ => h₂ ..⟩
  · case z => exact ⟨h0, rfl, nofun⟩
  · case s =>
    intro ⟨i, hi⟩ arr ⟨ih₁, eq, ih₂⟩
    refine (hs _ ih₁).map fun ⟨h₁, h₂⟩ => ⟨h₂, by simp [eq], fun j hj => ?_⟩
    simp [getElem_push] at hj ⊢; split; {apply ih₂}
    cases j; cases (Nat.le_or_eq_of_le_succ hj).resolve_left ‹_›; cases eq; exact h₁

theorem SatisfiesM_mapM' [Monad m] [LawfulMonad m] (as : Array α) (f : α → m β)
    (p : Fin as.size → β → Prop)
    (hs : ∀ i, SatisfiesM (p i) (f as[i])) :
    SatisfiesM
      (fun arr => ∃ eq : arr.size = as.size, ∀ i h, p ⟨i, h⟩ arr[i])
      (Array.mapM f as) :=
  (SatisfiesM_mapM _ _ (fun _ => True) trivial _ (fun _ h => (hs _).imp (⟨·, h⟩))).imp (·.2)

theorem size_mapM [Monad m] [LawfulMonad m] (f : α → m β) (as : Array α) :
    SatisfiesM (fun arr => arr.size = as.size) (Array.mapM f as) :=
  (SatisfiesM_mapM' _ _ (fun _ _ => True) (fun _ => .trivial)).imp (·.1)

proof_wanted size_mapIdxM [Monad m] [LawfulMonad m] (as : Array α) (f : Nat → α → m β) :
    SatisfiesM (fun arr => arr.size = as.size) (Array.mapIdxM f as)

proof_wanted size_mapFinIdxM [Monad m] [LawfulMonad m]
    (as : Array α) (f : (i : Nat) → α → (h : i < as.size) → m β) :
    SatisfiesM (fun arr => arr.size = as.size) (Array.mapFinIdxM as f)

theorem SatisfiesM_anyM [Monad m] [LawfulMonad m] (p : α → m Bool) (as : Array α) (start stop)
    (hstart : start ≤ min stop as.size) (tru : Prop) (fal : Nat → Prop) (h0 : fal start)
    (hp : ∀ i : Fin as.size, i.1 < stop → fal i.1 →
      SatisfiesM (bif · then tru else fal (i + 1)) (p as[i])) :
    SatisfiesM
      (fun res => bif res then tru else fal (min stop as.size))
      (anyM p as start stop) := by
  let rec go {stop j} (hj' : j ≤ stop) (hstop : stop ≤ as.size) (h0 : fal j)
    (hp : ∀ i : Fin as.size, i.1 < stop → fal i.1 →
      SatisfiesM (bif · then tru else fal (i + 1)) (p as[i])) :
    SatisfiesM
      (fun res => bif res then tru else fal stop)
      (anyM.loop p as stop hstop j) := by
    unfold anyM.loop; split
    · next hj =>
      exact (hp ⟨j, Nat.lt_of_lt_of_le hj hstop⟩ hj h0).bind fun
        | true, h => .pure h
        | false, h => go hj hstop h hp
    · next hj => exact .pure <| Nat.le_antisymm hj' (Nat.ge_of_not_lt hj) ▸ h0
    termination_by stop - j
  simp only [Array.anyM_eq_anyM_loop]
  exact go hstart _ h0 fun i hi => hp i <| Nat.lt_of_lt_of_le hi <| Nat.min_le_left ..

theorem SatisfiesM_anyM_iff_exists [Monad m] [LawfulMonad m]
    (p : α → m Bool) (as : Array α) (start stop) (q : Fin as.size → Prop)
    (hp : ∀ i : Fin as.size, start ≤ i.1 → i.1 < stop → SatisfiesM (· = true ↔ q i) (p as[i])) :
    SatisfiesM
      (fun res => res = true ↔ ∃ i : Fin as.size, start ≤ i.1 ∧ i.1 < stop ∧ q i)
      (anyM p as start stop) := by
  cases Nat.le_total start (min stop as.size) with
  | inl hstart =>
    refine (SatisfiesM_anyM _ _ _ _ hstart
      (fal := fun j => start ≤ j ∧ ¬ ∃ i : Fin as.size, start ≤ i.1 ∧ i.1 < j ∧ q i)
      (tru := ∃ i : Fin as.size, start ≤ i.1 ∧ i.1 < stop ∧ q i) ?_ ?_).imp ?_
    · exact ⟨Nat.le_refl _, fun ⟨i, h₁, h₂, _⟩ => (Nat.not_le_of_gt h₂ h₁).elim⟩
    · refine fun i h₂ ⟨h₁, h₃⟩ => (hp _ h₁ h₂).imp fun hq => ?_
      unfold cond; split <;> simp at hq
      · exact ⟨_, h₁, h₂, hq⟩
      · refine ⟨Nat.le_succ_of_le h₁, h₃.imp fun ⟨j, h₃, h₄, h₅⟩ => ⟨j, h₃, ?_, h₅⟩⟩
        refine Nat.lt_of_le_of_ne (Nat.le_of_lt_succ h₄) fun e => hq (Fin.eq_of_val_eq e ▸ h₅)
    · intro
      | true, h => simp only [true_iff]; exact h
      | false, h =>
        simp only [false_iff, reduceCtorEq]
        exact h.2.imp fun ⟨j, h₁, h₂, hq⟩ => ⟨j, h₁, Nat.lt_min.2 ⟨h₂, j.2⟩, hq⟩
  | inr hstart =>
    rw [anyM_stop_le_start (h := hstart)]
    refine .pure ?_; simp; intro j h₁ h₂
    cases Nat.not_lt.2 (Nat.le_trans hstart h₁) (Nat.lt_min.2 ⟨h₂, j.2⟩)

theorem SatisfiesM_foldrM [Monad m] [LawfulMonad m]
    {as : Array α} (motive : Nat → β → Prop)
    {init : β} (h0 : motive as.size init) {f : α → β → m β}
    (hf : ∀ i : Fin as.size, ∀ b, motive (i.1 + 1) b → SatisfiesM (motive i.1) (f as[i] b)) :
    SatisfiesM (motive 0) (as.foldrM f init) := by
  let rec go {i b} (hi : i ≤ as.size) (H : motive i b) :
    SatisfiesM (motive 0) (foldrM.fold f as 0 i hi b) := by
    unfold foldrM.fold; simp; split
    · next hi => exact .pure (hi ▸ H)
    · next hi =>
      split; {simp at hi}
      · next i hi' =>
        exact (hf ⟨i, hi'⟩ b H).bind fun _ => go _
  simp [foldrM]; split; {exact go _ h0}
  · next h => exact .pure (Nat.eq_zero_of_not_pos h ▸ h0)

theorem SatisfiesM_mapFinIdxM [Monad m] [LawfulMonad m] (as : Array α)
    (f : (i : Nat) → α → (h : i < as.size) → m β)
    (motive : Nat → Prop) (h0 : motive 0)
    (p : (i : Nat) → β → (h : i < as.size) → Prop)
    (hs : ∀ i h, motive i → SatisfiesM (p i · h ∧ motive (i + 1)) (f i as[i] h)) :
    SatisfiesM
      (fun arr => motive as.size ∧ ∃ eq : arr.size = as.size, ∀ i h, p i arr[i] h)
      (Array.mapFinIdxM as f) := by
  let rec go {bs i j h} (h₁ : j = bs.size) (h₂ : ∀ i h h', p i bs[i] h) (hm : motive j) :
    SatisfiesM
      (fun arr => motive as.size ∧ ∃ eq : arr.size = as.size, ∀ i h, p i arr[i] h)
      (Array.mapFinIdxM.map as f i j h bs) := by
    induction i generalizing j bs with simp [mapFinIdxM.map]
    | zero =>
      have := (Nat.zero_add _).symm.trans h
      exact .pure ⟨this ▸ hm, h₁ ▸ this, fun _ _ => h₂ ..⟩
    | succ i ih =>
      refine (hs _ _ (by exact hm)).bind fun b hb => ih (by simp [h₁]) (fun i hi hi' => ?_) hb.2
      simp at hi'; simp [getElem_push]; split
      · next h => exact h₂ _ _ h
      · next h => cases h₁.symm ▸ (Nat.le_or_eq_of_le_succ hi').resolve_left h; exact hb.1
  simp [mapFinIdxM]; exact go rfl nofun h0

theorem SatisfiesM_mapIdxM [Monad m] [LawfulMonad m] (as : Array α) (f : Nat → α → m β)
    (motive : Nat → Prop) (h0 : motive 0)
    (p : (i : Nat) → β → (h : i < as.size) → Prop)
    (hs : ∀ i h, motive i → SatisfiesM (p i · h ∧ motive (i + 1)) (f i as[i])) :
    SatisfiesM
      (fun arr => motive as.size ∧ ∃ eq : arr.size = as.size, ∀ i h, p i arr[i] h)
      (as.mapIdxM f) :=
  SatisfiesM_mapFinIdxM as (fun i a _ => f i a) motive h0 p hs

theorem size_mapFinIdxM [Monad m] [LawfulMonad m]
    (as : Array α) (f : (i : Nat) → α → (h : i < as.size) → m β) :
    SatisfiesM (fun arr => arr.size = as.size) (Array.mapFinIdxM as f) :=
  (SatisfiesM_mapFinIdxM _ _ (fun _ => True) trivial (fun _ _ _ => True)
    (fun _ _ _ => .of_true fun _ => ⟨trivial, trivial⟩)).imp (·.2.1)

theorem size_mapIdxM [Monad m] [LawfulMonad m] (as : Array α) (f : Nat → α → m β) :
    SatisfiesM (fun arr => arr.size = as.size) (Array.mapIdxM f as) :=
  size_mapFinIdxM _ _

theorem size_modifyM [Monad m] [LawfulMonad m] (a : Array α) (i : Nat) (f : α → m α) :
    SatisfiesM (·.size = a.size) (a.modifyM i f) := by
  unfold modifyM; split
  · exact .bind_pre <| .of_true fun _ => .pure <| by simp only [size_set]
  · exact .pure rfl

end Array



=== LEAN SOURCE: Pairwise.lean ===
/-
Copyright (c) 2024 François G. Dorais. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: François G. Dorais
-/
import Batteries.Tactic.Alias

namespace Array

/--
`Pairwise R as` means that all the elements of the array `as` are `R`-related to all elements with
larger indices.

`Pairwise R #[1, 2, 3] ↔ R 1 2 ∧ R 1 3 ∧ R 2 3`

For example `as.Pairwise (· ≠ ·)` asserts that `as` has no duplicates, `as.Pairwise (· < ·)` asserts
that `as` is strictly sorted and `as.Pairwise (· ≤ ·)` asserts that `as` is weakly sorted.
-/
def Pairwise (R : α → α → Prop) (as : Array α) : Prop := as.toList.Pairwise R

theorem pairwise_iff_getElem {as : Array α} : as.Pairwise R ↔
    ∀ (i j : Nat) (_ : i < as.size) (_ : j < as.size), i < j → R as[i] as[j] := by
  unfold Pairwise; simp [List.pairwise_iff_getElem, length_toList]

@[deprecated (since := "2025-02-19")] alias pairwise_iff_get := pairwise_iff_getElem

instance (R : α → α → Prop) [DecidableRel R] (as) : Decidable (Pairwise R as) :=
  have : (∀ (j : Fin as.size) (i : Fin j.val), R as[i.val] (as[j.val])) ↔ Pairwise R as := by
    rw [pairwise_iff_getElem]
    constructor
    · intro h i j _ hj hlt; exact h ⟨j, hj⟩ ⟨i, hlt⟩
    · intro h ⟨j, hj⟩ ⟨i, hlt⟩; exact h i j (Nat.lt_trans hlt hj) hj hlt
  decidable_of_iff _ this

@[grind]
theorem pairwise_empty : #[].Pairwise R := by
  unfold Pairwise; exact List.Pairwise.nil

@[grind]
theorem pairwise_singleton (R : α → α → Prop) (a) : #[a].Pairwise R := by
  unfold Pairwise; exact List.pairwise_singleton ..

@[grind =]
theorem pairwise_pair : #[a, b].Pairwise R ↔ R a b := by
  unfold Pairwise; exact List.pairwise_pair

@[grind =]
theorem pairwise_append {as bs : Array α} :
    (as ++ bs).Pairwise R ↔ as.Pairwise R ∧ bs.Pairwise R ∧ (∀ x ∈ as, ∀ y ∈ bs, R x y) := by
  unfold Pairwise; simp [← mem_toList_iff, toList_append, ← List.pairwise_append]

@[grind =]
theorem pairwise_push {as : Array α} :
    (as.push a).Pairwise R ↔ as.Pairwise R ∧ (∀ x ∈ as, R x a) := by
  unfold Pairwise
  simp [← mem_toList_iff, toList_push, List.pairwise_append]

@[grind ←]
theorem pairwise_extract {as : Array α} (h : as.Pairwise R) (start stop) :
    (as.extract start stop).Pairwise R := by
  simp only [pairwise_iff_getElem, getElem_extract, size_extract] at h ⊢
  intro _ _ _ _ hlt
  apply h
  exact Nat.add_lt_add_left hlt start



=== LEAN SOURCE: Lemmas.lean ===
/-
Copyright (c) 2024 Kim Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.

Authors: Kim Morrison
-/

/-!
While this file is currently empty, it is intended as a home for any lemmas which are required for
definitions in `Batteries.Data.Array.Basic`, but which are not provided by Lean.
-/



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2019 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Leonardo de Moura, Jannis Limperg, Mario Carneiro
-/
import Batteries.Classes.Order
import Batteries.Control.ForInStep.Basic

namespace Batteries
namespace BinomialHeap
namespace Imp

/--
A `HeapNode` is one of the internal nodes of the binomial heap.
It is always a perfect binary tree, with the depth of the tree stored in the `Heap`.
However the interpretation of the two pointers is different: we view the `child`
as going to the first child of this node, and `sibling` goes to the next sibling
of this tree. So it actually encodes a forest where each node has children
`node.child`, `node.child.sibling`, `node.child.sibling.sibling`, etc.

Each edge in this forest denotes a `le a b` relation that has been checked, so
the root is smaller than everything else under it.
-/
inductive HeapNode (α : Type u) where
  /-- An empty forest, which has depth `0`. -/
  | nil : HeapNode α
  /-- A forest of rank `r + 1` consists of a root `a`,
  a forest `child` of rank `r` elements greater than `a`,
  and another forest `sibling` of rank `r`. -/
  | node (a : α) (child sibling : HeapNode α) : HeapNode α
  deriving Repr

/--
The "real size" of the node, counting up how many values of type `α` are stored.
This is `O(n)` and is intended mainly for specification purposes.
For a well formed `HeapNode` the size is always `2^n - 1` where `n` is the depth.
-/
@[simp] def HeapNode.realSize : HeapNode α → Nat
  | .nil => 0
  | .node _ c s => c.realSize + 1 + s.realSize

/-- A node containing a single element `a`. -/
def HeapNode.singleton (a : α) : HeapNode α := .node a .nil .nil

/--
`O(log n)`. The rank, or the number of trees in the forest.
It is also the depth of the forest.
-/
def HeapNode.rank : HeapNode α → Nat
  | .nil => 0
  | .node _ _ s => s.rank + 1

/-- Tail-recursive version of `HeapNode.rank`. -/
@[inline] private def HeapNode.rankTR (s : HeapNode α) : Nat := go s 0 where
  /-- Computes `s.rank + r` -/
  go : HeapNode α → Nat → Nat
  | .nil, r => r
  | .node _ _ s, r => go s (r + 1)

@[csimp] private theorem HeapNode.rankTR_eq : @rankTR = @rank := by
  funext α s; exact go s 0
where
  go {α} : ∀ s n, @rankTR.go α s n = rank s + n
  | .nil, _ => (Nat.zero_add ..).symm
  | .node .., _ => by simp +arith only [rankTR.go, go, rank]

/--
A `Heap` is the top level structure in a binomial heap.
It consists of a forest of `HeapNode`s with strictly increasing ranks.
-/
inductive Heap (α : Type u) where
  /-- An empty heap. -/
  | nil : Heap α
  /-- A cons node contains a tree of root `val`, children `node` and rank `rank`,
  and then `next` which is the rest of the forest. -/
  | cons (rank : Nat) (val : α) (node : HeapNode α) (next : Heap α) : Heap α
  deriving Repr

/--
`O(n)`. The "real size" of the heap, counting up how many values of type `α` are stored.
This is intended mainly for specification purposes.
Prefer `Heap.size`, which is the same for well formed heaps.
-/
@[simp] def Heap.realSize : Heap α → Nat
  | .nil => 0
  | .cons _ _ c s => c.realSize + 1 + s.realSize

/-- `O(log n)`. The number of elements in the heap. -/
def Heap.size : Heap α → Nat
  | .nil => 0
  | .cons r _ _ s => 1 <<< r + s.size

/-- `O(1)`. Is the heap empty? -/
@[inline] def Heap.isEmpty : Heap α → Bool
  | .nil => true
  | _    => false

/-- `O(1)`. The heap containing a single value `a`. -/
@[inline] def Heap.singleton (a : α) : Heap α := .cons 0 a .nil .nil

/-- `O(1)`. Auxiliary for `Heap.merge`: Is the minimum rank in `Heap` strictly larger than `n`? -/
def Heap.rankGT : Heap α → Nat → Prop
  | .nil, _ => True
  | .cons r .., n => n < r

instance : Decidable (Heap.rankGT s n) :=
  match s with
  | .nil => inferInstanceAs (Decidable True)
  | .cons .. => inferInstanceAs (Decidable (_ < _))

/-- `O(log n)`. The number of trees in the forest. -/
@[simp] def Heap.length : Heap α → Nat
  | .nil => 0
  | .cons _ _ _ r => r.length + 1

/--
`O(1)`. Auxiliary for `Heap.merge`: combines two heap nodes of the same rank
into one with the next larger rank.
-/
@[inline] def combine (le : α → α → Bool) (a₁ a₂ : α) (n₁ n₂ : HeapNode α) : α × HeapNode α :=
  if le a₁ a₂ then (a₁, .node a₂ n₂ n₁) else (a₂, .node a₁ n₁ n₂)

/--
Merge two forests of binomial trees. The forests are assumed to be ordered
by rank and `merge` maintains this invariant.
-/
@[specialize] def Heap.merge (le : α → α → Bool) : Heap α → Heap α → Heap α
  | .nil, h  => h
  | h,  .nil => h
  | s₁@(.cons r₁ a₁ n₁ t₁), s₂@(.cons r₂ a₂ n₂ t₂) =>
    if r₁ < r₂ then .cons r₁ a₁ n₁ (merge le t₁ s₂)
    else if r₂ < r₁ then .cons r₂ a₂ n₂ (merge le s₁ t₂)
    else
      let (a, n) := combine le a₁ a₂ n₁ n₂
      let r := r₁ + 1
      if t₁.rankGT r then if t₂.rankGT r
        then .cons r a n (merge le t₁ t₂)
        else merge le (.cons r a n t₁) t₂
      else if t₂.rankGT r
        then merge le t₁ (.cons r a n t₂)
        else .cons r a n (merge le t₁ t₂)
termination_by s₁ s₂ => s₁.length + s₂.length

/--
`O(log n)`. Convert a `HeapNode` to a `Heap` by reversing the order of the nodes
along the `sibling` spine.
-/
def HeapNode.toHeap (s : HeapNode α) : Heap α := go s s.rank .nil where
  /-- Computes `s.toHeap ++ res` tail-recursively, assuming `n = s.rank`. -/
  go : HeapNode α → Nat → Heap α → Heap α
  | .nil, _, res => res
  | .node a c s, n, res => go s (n - 1) (.cons (n - 1) a c res)

/-- `O(log n)`. Get the smallest element in the heap, including the passed in value `a`. -/
@[specialize] def Heap.headD (le : α → α → Bool) (a : α) : Heap α → α
  | .nil => a
  | .cons _ b _ hs => headD le (if le a b then a else b) hs

/-- `O(log n)`. Get the smallest element in the heap, if it has an element. -/
@[inline] def Heap.head? (le : α → α → Bool) : Heap α → Option α
  | .nil => none
  | .cons _ h _ hs => some <| headD le h hs

/--
The return type of `FindMin`, which encodes various quantities needed to
reconstruct the tree in `deleteMin`.
-/
structure FindMin (α) where
  /-- The list of elements prior to the minimum element, encoded as a "difference list". -/
  before : Heap α → Heap α := id
  /-- The minimum element. -/
  val : α
  /-- The children of the minimum element. -/
  node : HeapNode α
  /-- The forest after the minimum element. -/
  next : Heap α

/--
`O(log n)`. Find the minimum element, and return a data structure `FindMin` with information
needed to reconstruct the rest of the binomial heap.
-/
@[specialize] def Heap.findMin (le : α → α → Bool) (k : Heap α → Heap α) :
    Heap α → FindMin α → FindMin α
  | .nil, res => res
  | .cons r a c s, res =>
    -- It is important that we check `le res.val a` here, not the other way
    -- around. This ensures that head? and findMin find the same element even
    -- when we have `le res.val a` and `le a res.val` (i.e. le is not antisymmetric).
    findMin le (k ∘ .cons r a c) s <| if le res.val a then res else ⟨k, a, c, s⟩

/-- `O(log n)`. Find and remove the the minimum element from the binomial heap. -/
def Heap.deleteMin (le : α → α → Bool) : Heap α → Option (α × Heap α)
  | .nil => none
  | .cons r a c s =>
    let { before, val, node, next } := findMin le (.cons r a c) s ⟨id, a, c, s⟩
    some (val, node.toHeap.merge le (before next))

/-- `O(log n)`. Get the tail of the binomial heap after removing the minimum element. -/
@[inline] def Heap.tail? (le : α → α → Bool) (h : Heap α) : Option (Heap α) :=
  deleteMin le h |>.map (·.snd)

/-- `O(log n)`. Remove the minimum element of the heap. -/
@[inline] def Heap.tail (le : α → α → Bool) (h : Heap α) : Heap α := tail? le h |>.getD .nil

theorem Heap.realSize_merge (le) (s₁ s₂ : Heap α) :
    (s₁.merge le s₂).realSize = s₁.realSize + s₂.realSize := by
  unfold merge; split
  · simp
  · simp
  · next r₁ a₁ n₁ t₁ r₂ a₂ n₂ t₂ =>
    have IH₁ r a n := realSize_merge le t₁ (cons r a n t₂)
    have IH₂ r a n := realSize_merge le (cons r a n t₁) t₂
    have IH₃ := realSize_merge le t₁ t₂
    split; · simp [IH₁, Nat.add_assoc]
    split; · simp [IH₂, Nat.add_assoc, Nat.add_left_comm]
    split; simp only; rename_i a n eq
    have : n.realSize = n₁.realSize + 1 + n₂.realSize := by
      rw [combine] at eq; split at eq <;> cases eq <;>
        simp [Nat.add_assoc, Nat.add_left_comm, Nat.add_comm]
    split <;> split <;> simp [IH₁, IH₂, IH₃, this, Nat.add_assoc, Nat.add_left_comm]
termination_by s₁.length + s₂.length

private def FindMin.HasSize (res : FindMin α) (n : Nat) : Prop :=
  ∃ m,
    (∀ s, (res.before s).realSize = m + s.realSize) ∧
    n = m + res.node.realSize + res.next.realSize + 1

private theorem Heap.realSize_findMin {s : Heap α}
    (m) (hk : ∀ s, (k s).realSize = m + s.realSize)
    (eq : n = m + s.realSize) (hres : res.HasSize n) :
    (s.findMin le k res).HasSize n :=
  match s with
  | .nil => hres
  | .cons r a c s => by
    simp [findMin]
    refine realSize_findMin (m + c.realSize + 1)
      (by simp [hk, Nat.add_assoc]) (by simp [eq, Nat.add_assoc]) ?_
    split
    · exact hres
    · exact ⟨m, hk, by simp [eq, Nat.add_comm, Nat.add_left_comm]⟩

theorem HeapNode.realSize_toHeap (s : HeapNode α) : s.toHeap.realSize = s.realSize := go s where
  go {n res} : ∀ s : HeapNode α, (toHeap.go s n res).realSize = s.realSize + res.realSize
  | .nil => (Nat.zero_add _).symm
  | .node a c s => by simp [toHeap.go, go, Nat.add_assoc, Nat.add_left_comm]

theorem Heap.realSize_deleteMin {s : Heap α} (eq : s.deleteMin le = some (a, s')) :
    s.realSize = s'.realSize + 1 := by
  cases s with cases eq | cons r a c s => ?_
  have : (s.findMin le (cons r a c) ⟨id, a, c, s⟩).HasSize (c.realSize + s.realSize + 1) :=
    Heap.realSize_findMin (c.realSize + 1) (by simp) (Nat.add_right_comm ..) ⟨0, by simp⟩
  revert this
  match s.findMin le (cons r a c) ⟨id, a, c, s⟩ with
  | { before, val, node, next } =>
    intro ⟨m, ih₁, ih₂⟩; dsimp only at ih₁ ih₂
    rw [realSize, Nat.add_right_comm, ih₂]
    simp only [realSize_merge, HeapNode.realSize_toHeap, ih₁, Nat.add_assoc, Nat.add_left_comm]

theorem Heap.realSize_tail? {s : Heap α} : s.tail? le = some s' →
    s.realSize = s'.realSize + 1 := by
  simp only [Heap.tail?]; intro eq
  match eq₂ : s.deleteMin le, eq with
  | some (a, tl), rfl => exact realSize_deleteMin eq₂

theorem Heap.realSize_tail (le) (s : Heap α) : (s.tail le).realSize = s.realSize - 1 := by
  simp only [Heap.tail]
  match eq : s.tail? le with
  | none => cases s with cases eq | nil => rfl
  | some tl => simp [Heap.realSize_tail? eq]

/--
`O(n log n)`. Monadic fold over the elements of a heap in increasing order,
by repeatedly pulling the minimum element out of the heap.
-/
@[specialize] def Heap.foldM [Monad m] (le : α → α → Bool) (s : Heap α)
    (init : β) (f : β → α → m β) : m β :=
  match eq : s.deleteMin le with
  | none => pure init
  | some (hd, tl) => do
    have : tl.realSize < s.realSize := by simp +arith [Heap.realSize_deleteMin eq]
    foldM le tl (← f init hd) f
termination_by s.realSize

/--
`O(n log n)`. Fold over the elements of a heap in increasing order,
by repeatedly pulling the minimum element out of the heap.
-/
@[inline] def Heap.fold (le : α → α → Bool) (s : Heap α) (init : β) (f : β → α → β) : β :=
  Id.run <| s.foldM le init f

/-- `O(n log n)`. Convert the heap to an array in increasing order. -/
@[inline] def Heap.toArray (le : α → α → Bool) (s : Heap α) : Array α := fold le s #[] Array.push

/-- `O(n log n)`. Convert the heap to a list in increasing order. -/
@[inline] def Heap.toList (le : α → α → Bool) (s : Heap α) : List α := (s.toArray le).toList

section
variable [Monad m] (nil : β) (join : α → β → β → m β)

/-- `O(n)`. Fold a monadic function over the tree structure to accumulate a value. -/
@[specialize] def HeapNode.foldTreeM : HeapNode α → m β
  | .nil => pure nil
  | .node a c s => do join a (← c.foldTreeM) (← s.foldTreeM)

/-- `O(n)`. Fold a monadic function over the tree structure to accumulate a value. -/
@[specialize] def Heap.foldTreeM : Heap α → m β
  | .nil => pure nil
  | .cons _ a c s => do join a (← c.foldTreeM nil join) (← s.foldTreeM)

end

/-- `O(n)`. Fold a function over the tree structure to accumulate a value. -/
@[inline] def Heap.foldTree (nil : β) (join : α → β → β → β) (s : Heap α) : β :=
  Id.run <| s.foldTreeM nil join

/-- `O(n)`. Convert the heap to a list in arbitrary order. -/
def Heap.toListUnordered (s : Heap α) : List α :=
  s.foldTree id (fun a c s l => a :: c (s l)) []

/-- `O(n)`. Convert the heap to an array in arbitrary order. -/
def Heap.toArrayUnordered (s : Heap α) : Array α :=
  s.foldTree id (fun a c s r => s (c (r.push a))) #[]

/--
The well formedness predicate for a heap node.
It asserts that:
* If `a` is added at the top to make the forest into a tree, the resulting tree
  is a `le`-min-heap (if `le` is well-behaved)
* When interpreting `child` and `sibling` as left and right children of a binary tree,
  it is a perfect binary tree with depth `r`
-/
def HeapNode.WF (le : α → α → Bool) (a : α) : HeapNode α → Nat → Prop
  | .nil, r => r = 0
  | .node b c s, r => ∃ r', r = r' + 1 ∧ (∀ [TotalBLE le], le a b) ∧ c.WF le b r' ∧ s.WF le a r'

/--
The well formedness predicate for a binomial heap.
It asserts that:
* It consists of a list of well formed trees with the specified ranks
* The ranks are in strictly increasing order, and all are at least `n`
-/
def Heap.WF (le : α → α → Bool) (n : Nat) : Heap α → Prop
  | .nil => True
  | .cons r a c s => n ≤ r ∧ c.WF le a r ∧ s.WF le (r+1)

theorem Heap.WF.nil : Heap.nil.WF le n := trivial

theorem Heap.WF.singleton : (Heap.singleton a).WF le 0 := ⟨by decide, rfl, ⟨⟩⟩

theorem Heap.WF.of_rankGT (hlt : s.rankGT n) (h : Heap.WF le n' s) : s.WF le (n+1) :=
  match s with
  | .nil => trivial
  | .cons .. => let ⟨_, h₂, h₃⟩ := h; ⟨hlt, h₂, h₃⟩

theorem Heap.WF.of_le (hle : n ≤ n') (h : Heap.WF le n' s) : s.WF le n :=
  match s with
  | .nil => trivial
  | .cons .. => let ⟨h₁, h₂, h₃⟩ := h; ⟨Nat.le_trans hle h₁, h₂, h₃⟩

theorem Heap.rankGT.of_le (h : Heap.rankGT s n) (h' : n' ≤ n) : s.rankGT n' :=
  match s with
  | .nil => trivial
  | .cons .. => Nat.lt_of_le_of_lt h' h

theorem Heap.WF.rankGT (h : Heap.WF lt (n+1) s) : s.rankGT n :=
  match s with
  | .nil => trivial
  | .cons .. => Nat.lt_of_succ_le h.1

theorem Heap.WF.merge' (h₁ : s₁.WF le n) (h₂ : s₂.WF le n) :
    (merge le s₁ s₂).WF le n ∧ ((s₁.rankGT n ↔ s₂.rankGT n) → (merge le s₁ s₂).rankGT n) := by
  unfold merge; split
  · exact ⟨h₂, fun h => h.1 h₁⟩
  · exact ⟨h₁, fun h => h.2 h₂⟩
  · rename_i r₁ a₁ n₁ t₁ r₂ a₂ n₂ t₂
    let ⟨hr₁, hn₁, ht₁⟩ := h₁
    let ⟨hr₂, hn₂, ht₂⟩ := h₂
    split <;> rename_i lt₁
    · refine ⟨⟨hr₁, hn₁, And.left (merge' ht₁ ⟨lt₁, hn₂, ht₂⟩)⟩, fun h => ?_⟩
      exact h.2 <| Nat.lt_of_le_of_lt hr₁ lt₁
    split <;> rename_i lt₂
    · refine ⟨⟨hr₂, hn₂, And.left (merge' ⟨lt₂, hn₁, ht₁⟩ ht₂)⟩, fun h => ?_⟩
      exact h.1 <| Nat.lt_of_le_of_lt hr₂ lt₂
    cases Nat.le_antisymm (Nat.ge_of_not_lt lt₂) (Nat.ge_of_not_lt lt₁)
    split; rename_i a n eq
    have : n.WF le a (r₁+1) := by
      unfold combine at eq; split at eq <;> cases eq <;> rename_i h
      · exact ⟨r₁, rfl, h, hn₂, hn₁⟩
      · exact ⟨r₁, rfl, TotalBLE.total.resolve_left h, hn₁, hn₂⟩
    simp only; split <;> split <;> rename_i hl₁ hl₂
    · exact ⟨⟨Nat.le_succ_of_le hr₁, this,
        (merge' (ht₁.of_rankGT hl₁) (ht₂.of_rankGT hl₂)).1⟩,
        fun _ => Nat.lt_succ_of_le hr₁⟩
    · let ⟨ih₁, ih₂⟩ := merge' (s₁ := .cons ..)
        ⟨Nat.le_succ_of_le hr₁, this, ht₁.of_rankGT hl₁⟩
        (ht₂.of_le (Nat.le_succ_of_le hr₁))
      exact ⟨ih₁, fun _ => ih₂ ⟨fun _ => ht₂.rankGT.of_le hr₁, fun _ => Nat.lt_succ_of_le hr₁⟩⟩
    · let ⟨ih₁, ih₂⟩ := merge' (s₂ := .cons ..) (ht₁.of_le (Nat.le_succ_of_le hr₁))
        ⟨Nat.le_succ_of_le hr₁, this, ht₂.of_rankGT hl₂⟩
      exact ⟨ih₁, fun _ => ih₂ ⟨fun _ => Nat.lt_succ_of_le hr₁, fun _ => ht₁.rankGT.of_le hr₁⟩⟩
    · let ⟨ih₁, ih₂⟩ := merge' ht₁ ht₂
      exact ⟨⟨Nat.le_succ_of_le hr₁, this, ih₁.of_rankGT (ih₂ (iff_of_false hl₁ hl₂))⟩,
        fun _ => Nat.lt_succ_of_le hr₁⟩
termination_by s₁.length + s₂.length

theorem Heap.WF.merge (h₁ : s₁.WF le n) (h₂ : s₂.WF le n) : (merge le s₁ s₂).WF le n :=
  (merge' h₁ h₂).1

theorem HeapNode.WF.rank_eq : ∀ {n} {s : HeapNode α}, s.WF le a n → s.rank = n
  | _, .nil, h => h.symm
  | _, .node .., ⟨_, rfl, _, _, h⟩ => congrArg Nat.succ (rank_eq h)

theorem HeapNode.WF.toHeap {s : HeapNode α} (h : s.WF le a n) : s.toHeap.WF le 0 :=
  go h trivial
where
  go {res} : ∀ {n s}, s.WF le a n → res.WF le s.rank → (HeapNode.toHeap.go s s.rank res).WF le 0
  | _, .nil, _, hr => hr
  | _, .node a c s, ⟨n, rfl, _, h, h'⟩, hr =>
    go (s := s) h' ⟨Nat.le_refl _, by rw [← h'.rank_eq] at h; exact h, hr⟩

/--
The well formedness predicate for a `FindMin` value.
This is not actually a predicate, as it contains an additional data value
`rank` corresponding to the rank of the returned node, which is omitted from `findMin`.
-/
structure FindMin.WF (le : α → α → Bool) (res : FindMin α) where
  /-- The rank of the minimum element -/
  rank : Nat
  /-- `before` is a difference list which can be appended to a binomial heap
  with ranks at least `rank` to produce another well formed heap. -/
  before : ∀ {s}, s.WF le rank → (res.before s).WF le 0
  /-- `node` is a well formed forest of rank `rank` with `val` at the root. -/
  node : res.node.WF le res.val rank
  /-- `next` is a binomial heap with ranks above `rank + 1`. -/
  next : res.next.WF le (rank + 1)

/-- The conditions under which `findMin` is well-formed. -/
def Heap.WF.findMin {s : Heap α} (h : s.WF le n) (hr : res.WF le)
    (hk : ∀ {s}, s.WF le n → (k s).WF le 0) : ((s : Heap α).findMin le k res).WF le :=
  match s with
  | .nil => hr
  | .cons r a c s => by
    let ⟨h₁, h₂, h₃⟩ := h
    simp [Heap.findMin]
    cases le res.val a with
    | true  => exact findMin h₃ hr (fun h => hk ⟨h₁, h₂, h⟩)
    | false => exact findMin h₃ ⟨_, fun h => hk (h.of_le h₁), h₂, h₃⟩ (fun h => hk ⟨h₁, h₂, h⟩)

theorem Heap.WF.deleteMin {s : Heap α}
    (h : s.WF le n) (eq : s.deleteMin le = some (a, s')) : s'.WF le 0 := by
  cases s with cases eq | cons r a c s => ?_
  have : (s.findMin le (cons r a c) ⟨id, a, c, s⟩).WF le :=
    let ⟨_, h₂, h₃⟩ := h
    h₃.findMin ⟨_, fun h => h.of_le (Nat.zero_le _), h₂, h₃⟩
      fun h => ⟨Nat.zero_le _, h₂, h⟩
  revert this
  let { before, val, node, next } := s.findMin le (cons r a c) ⟨id, a, c, s⟩
  intro ⟨_, hk, ih₁, ih₂⟩
  exact ih₁.toHeap.merge <| hk (ih₂.of_le (Nat.le_succ _))

theorem Heap.WF.tail? (hwf : (s : Heap α).WF le n) : s.tail? le = some tl → tl.WF le 0 := by
  simp only [Heap.tail?]; intro eq
  match eq₂ : s.deleteMin le, eq with
  | some (a, tl), rfl => exact hwf.deleteMin eq₂

theorem Heap.WF.tail (hwf : (s : Heap α).WF le n) : (s.tail le).WF le 0 := by
  simp only [Heap.tail]
  match eq : s.tail? le with
  | none => exact Heap.WF.nil
  | some tl => exact hwf.tail? eq

end Imp
end BinomialHeap

open BinomialHeap.Imp

/--
A [binomial heap](https://en.wikipedia.org/wiki/Binomial_heap) is a data structure which supports
the following primary operations:

* `insert : α → BinomialHeap α → BinomialHeap α`: add an element to the heap
* `deleteMin : BinomialHeap α → Option (α × BinomialHeap α)`:
  remove the minimum element from the heap
* `merge : BinomialHeap α → BinomialHeap α → BinomialHeap α`: combine two heaps

The first two operations are known as a "priority queue", so this could be called
a "mergeable priority queue". The standard choice for a priority queue is a binary heap,
which supports `insert` and `deleteMin` in `O(log n)`, but `merge` is `O(n)`.
With a `BinomialHeap`, all three operations are `O(log n)`.
-/
def BinomialHeap (α : Type u) (le : α → α → Bool) :=
  { h : Heap α // h.WF le 0 }

/-- `O(1)`. Make a new empty binomial heap. -/
@[inline] def mkBinomialHeap (α : Type u) (le : α → α → Bool) : BinomialHeap α le :=
  ⟨.nil, Heap.WF.nil⟩

namespace BinomialHeap
variable {α : Type u} {le : α → α → Bool}

/-- `O(1)`. Make a new empty binomial heap. -/
@[inline] def empty : BinomialHeap α le := mkBinomialHeap α le

instance : EmptyCollection (BinomialHeap α le) := ⟨.empty⟩
instance : Inhabited (BinomialHeap α le) := ⟨.empty⟩

/-- `O(1)`. Is the heap empty? -/
@[inline] def isEmpty (b : BinomialHeap α le) : Bool := b.1.isEmpty

/-- `O(log n)`. The number of elements in the heap. -/
@[inline] def size (b : BinomialHeap α le) : Nat := b.1.size

/-- `O(1)`. Make a new heap containing `a`. -/
@[inline] def singleton (a : α) : BinomialHeap α le := ⟨Heap.singleton a, Heap.WF.singleton⟩

/-- `O(log n)`. Merge the contents of two heaps. -/
@[inline] def merge : BinomialHeap α le → BinomialHeap α le → BinomialHeap α le
  | ⟨b₁, h₁⟩, ⟨b₂, h₂⟩ => ⟨b₁.merge le b₂, h₁.merge h₂⟩

/-- `O(log n)`. Add element `a` to the given heap `h`. -/
@[inline] def insert (a : α) (h : BinomialHeap α le) : BinomialHeap α le := merge (singleton a) h

/-- `O(n log n)`. Construct a heap from a list by inserting all the elements. -/
def ofList (le : α → α → Bool) (as : List α) : BinomialHeap α le := as.foldl (flip insert) empty

/-- `O(n log n)`. Construct a heap from a list by inserting all the elements. -/
def ofArray (le : α → α → Bool) (as : Array α) : BinomialHeap α le := as.foldl (flip insert) empty

/-- `O(log n)`. Remove and return the minimum element from the heap. -/
@[inline] def deleteMin (b : BinomialHeap α le) : Option (α × BinomialHeap α le) :=
  match eq : b.1.deleteMin le with
  | none => none
  | some (a, tl) => some (a, ⟨tl, b.2.deleteMin eq⟩)

instance : Stream (BinomialHeap α le) α := ⟨deleteMin⟩

/--
`O(n log n)`. Implementation of `for x in (b : BinomialHeap α le) ...` notation,
which iterates over the elements in the heap in increasing order.
-/
protected def forIn [Monad m] (b : BinomialHeap α le) (x : β) (f : α → β → m (ForInStep β)) : m β :=
  ForInStep.run <$> b.1.foldM le (.yield x) fun x a => x.bind (f a)

instance : ForIn m (BinomialHeap α le) α := ⟨BinomialHeap.forIn⟩

/-- `O(log n)`. Returns the smallest element in the heap, or `none` if the heap is empty. -/
@[inline] def head? (b : BinomialHeap α le) : Option α := b.1.head? le

/-- `O(log n)`. Returns the smallest element in the heap, or panics if the heap is empty. -/
@[inline] def head! [Inhabited α] (b : BinomialHeap α le) : α := b.head?.get!

/-- `O(log n)`. Returns the smallest element in the heap, or `default` if the heap is empty. -/
@[inline] def headI [Inhabited α] (b : BinomialHeap α le) : α := b.head?.getD default

/-- `O(log n)`. Removes the smallest element from the heap, or `none` if the heap is empty. -/
@[inline] def tail? (b : BinomialHeap α le) : Option (BinomialHeap α le) :=
  match eq : b.1.tail? le with
  | none => none
  | some tl => some ⟨tl, b.2.tail? eq⟩

/-- `O(log n)`. Removes the smallest element from the heap, if possible. -/
@[inline] def tail (b : BinomialHeap α le) : BinomialHeap α le := ⟨b.1.tail le, b.2.tail⟩

/--
`O(n log n)`. Monadic fold over the elements of a heap in increasing order,
by repeatedly pulling the minimum element out of the heap.
-/
@[inline] def foldM [Monad m] (b : BinomialHeap α le) (init : β) (f : β → α → m β) : m β :=
  b.1.foldM le init f

/--
`O(n log n)`. Fold over the elements of a heap in increasing order,
by repeatedly pulling the minimum element out of the heap.
-/
@[inline] def fold (b : BinomialHeap α le) (init : β) (f : β → α → β) : β := b.1.fold le init f

/-- `O(n log n)`. Convert the heap to a list in increasing order. -/
@[inline] def toList (b : BinomialHeap α le) : List α := b.1.toList le

/-- `O(n log n)`. Convert the heap to an array in increasing order. -/
@[inline] def toArray (b : BinomialHeap α le) : Array α := b.1.toArray le

/-- `O(n)`. Convert the heap to a list in arbitrary order. -/
@[inline] def toListUnordered (b : BinomialHeap α le) : List α := b.1.toListUnordered

/-- `O(n)`. Convert the heap to an array in arbitrary order. -/
@[inline] def toArrayUnordered (b : BinomialHeap α le) : Array α := b.1.toArrayUnordered



=== LEAN SOURCE: Lemmas.lean ===
/-
Copyright (c) 2023 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Batteries.Data.BinomialHeap.Basic

namespace Batteries.BinomialHeap
namespace Imp

theorem Heap.findMin_val : ((s : Heap α).findMin le k res).val = s.headD le res.val :=
  match s with
  | .nil => rfl
  | .cons r a c s => by rw [findMin, headD]; split <;> apply findMin_val

theorem Heap.deleteMin_fst : ((s : Heap α).deleteMin le).map (·.1) = s.head? le :=
  match s with
  | .nil => rfl
  | .cons r a c s => by simp only [deleteMin, findMin_val, Option.map, head?]

theorem HeapNode.WF.realSize_eq :
    ∀ {n} {s : HeapNode α}, s.WF le a n → s.realSize + 1 = 2 ^ n
  | _, .nil, rfl => rfl
  | _, .node .., ⟨_, rfl, _, c, s⟩ => by
    rw [realSize, realSize_eq c, Nat.pow_succ, Nat.mul_succ]
    simp [Nat.add_assoc, realSize_eq s]

theorem Heap.WF.size_eq :
    ∀ {s : Heap α}, s.WF le n → s.size = s.realSize
  | .nil, _ => rfl
  | .cons .., ⟨_, h₁, h₂⟩ => by
    simp [size, size_eq h₂]
    simp [Nat.one_shiftLeft, h₁.realSize_eq]

end Imp



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2024 François G. Dorais. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: François G. Dorais
-/

namespace BitVec

/-- `ofFnLEAux f` returns the `BitVec m` whose `i`th bit is `f i` when `i < m`, little endian. -/
@[inline] def ofFnLEAux (m : Nat) (f : Fin n → Bool) : BitVec m :=
  Fin.foldr n (fun i v => v.shiftConcat (f i)) 0

/-- `ofFnLE f` returns the `BitVec n` whose `i`th bit is `f i` with little endian ordering. -/
@[inline] def ofFnLE (f : Fin n → Bool) : BitVec n := ofFnLEAux n f

/-- `ofFnBE f` returns the `BitVec n` whose `i`th bit is `f i` with big endian ordering. -/
@[inline] def ofFnBE (f : Fin n → Bool) : BitVec n := ofFnLE fun i => f i.rev



=== LEAN SOURCE: Lemmas.lean ===
/-
Copyright (c) 2024 François G. Dorais. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: François G. Dorais
-/
import Batteries.Tactic.Alias
import Batteries.Data.BitVec.Basic
import Batteries.Data.Fin.OfBits
import Batteries.Data.Nat.Lemmas
import Batteries.Data.Int

namespace BitVec

@[simp] theorem toNat_ofFnLEAux (m : Nat) (f : Fin n → Bool) :
    (ofFnLEAux m f).toNat = Nat.ofBits f % 2 ^ m := by
  simp only [ofFnLEAux]
  induction n with
  | zero => rfl
  | succ n ih =>
    rw [Fin.foldr_succ, toNat_shiftConcat, Nat.shiftLeft_eq, Nat.pow_one, Nat.ofBits_succ, ih,
      ← Nat.mod_add_div (Nat.ofBits (f ∘ Fin.succ)) (2 ^ m), Nat.mul_add 2, Nat.add_right_comm,
      Nat.mul_left_comm, Nat.add_mul_mod_self_left, Nat.mul_comm 2]
    rfl

@[simp] theorem toFin_ofFnLEAux (m : Nat) (f : Fin n → Bool) :
    (ofFnLEAux m f).toFin = Fin.ofNat (2 ^ m) (Nat.ofBits f) := by
  ext; simp

@[simp, grind =] theorem toNat_ofFnLE (f : Fin n → Bool) : (ofFnLE f).toNat = Nat.ofBits f := by
  rw [ofFnLE, toNat_ofFnLEAux, Nat.mod_eq_of_lt (Nat.ofBits_lt_two_pow f)]

@[simp, grind =] theorem toFin_ofFnLE (f : Fin n → Bool) : (ofFnLE f).toFin = Fin.ofBits f := by
  ext; simp

@[simp, grind =] theorem toInt_ofFnLE (f : Fin n → Bool) : (ofFnLE f).toInt = Int.ofBits f := by
  simp only [BitVec.toInt, Int.ofBits, toNat_ofFnLE, Int.subNatNat_eq_coe]; rfl

-- TODO: consider these for global `grind` attributes.
attribute [local grind] Fin.succ Fin.rev Fin.last Fin.zero_eta

theorem getElem_ofFnLEAux (f : Fin n → Bool) (i) (h : i < n) (h' : i < m) :
    (ofFnLEAux m f)[i] = f ⟨i, h⟩ := by
  simp only [ofFnLEAux]
  induction n generalizing i m with
  | zero => contradiction
  | succ n ih =>
    simp only [Fin.foldr_succ, getElem_shiftConcat]
    cases i with
    | zero => grind
    | succ i => rw [ih] <;> grind

@[simp, grind =] theorem getElem_ofFnLE (f : Fin n → Bool) (i) (h : i < n) :
    (ofFnLE f)[i] = f ⟨i, h⟩ :=
  getElem_ofFnLEAux ..

@[grind =]
theorem getLsb_ofFnLE (f : Fin n → Bool) (i) : (ofFnLE f).getLsb i = f i := by simp

@[deprecated (since := "2025-06-17")] alias getLsb'_ofFnLE := getLsb_ofFnLE

theorem getLsbD_ofFnLE (f : Fin n → Bool) (i) :
    (ofFnLE f).getLsbD i = if h : i < n then f ⟨i, h⟩ else false := by
  grind

@[simp, grind =] theorem getMsb_ofFnLE (f : Fin n → Bool) (i) : (ofFnLE f).getMsb i = f i.rev := by
  grind

@[deprecated (since := "2025-06-17")] alias getMsb'_ofFnLE := getMsb_ofFnLE

@[grind =]
theorem getMsbD_ofFnLE (f : Fin n → Bool) (i) :
    (ofFnLE f).getMsbD i = if h : i < n then f (Fin.rev ⟨i, h⟩) else false := by
  grind

theorem msb_ofFnLE (f : Fin n → Bool) :
    (ofFnLE f).msb = if h : n ≠ 0 then f ⟨n-1, Nat.sub_one_lt h⟩ else false := by
  grind

@[simp, grind =] theorem toNat_ofFnBE (f : Fin n → Bool) :
    (ofFnBE f).toNat = Nat.ofBits (f ∘ Fin.rev) := by
  simp [ofFnBE]; rfl

@[simp, grind =] theorem toFin_ofFnBE (f : Fin n → Bool) :
    (ofFnBE f).toFin = Fin.ofBits (f ∘ Fin.rev) := by
  ext; simp

@[simp, grind =] theorem toInt_ofFnBE (f : Fin n → Bool) :
    (ofFnBE f).toInt = Int.ofBits (f ∘ Fin.rev) := by
  simp [ofFnBE]; rfl

@[simp, grind =] theorem getElem_ofFnBE (f : Fin n → Bool) (i) (h : i < n) :
    (ofFnBE f)[i] = f (Fin.rev ⟨i, h⟩) := by simp [ofFnBE]

@[grind =]
theorem getLsb_ofFnBE (f : Fin n → Bool) (i) : (ofFnBE f).getLsb i = f i.rev := by
  simp

@[deprecated (since := "2025-06-17")] alias getLsb'_ofFnBE := getLsb_ofFnBE

theorem getLsbD_ofFnBE (f : Fin n → Bool) (i) :
    (ofFnBE f).getLsbD i = if h : i < n then f (Fin.rev ⟨i, h⟩) else false := by
  grind

@[simp, grind =] theorem getMsb_ofFnBE (f : Fin n → Bool) (i) : (ofFnBE f).getMsb i = f i := by
  simp [ofFnBE]

@[deprecated (since := "2025-06-17")] alias getMsb'_ofFnBE := getMsb_ofFnBE

@[grind =]
theorem getMsbD_ofFnBE (f : Fin n → Bool) (i) :
    (ofFnBE f).getMsbD i = if h : i < n then f ⟨i, h⟩ else false := by
  grind

@[grind =]
theorem msb_ofFnBE (f : Fin n → Bool) :
    (ofFnBE f).msb = if h : n ≠ 0 then f ⟨0, Nat.zero_lt_of_ne_zero h⟩ else false := by
  grind



=== LEAN SOURCE: AsciiCasing.lean ===
/-
Copyright (c) 2025 François G. Dorais. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: François G. Dorais
-/
import Batteries.Data.Char.Basic
import Batteries.Tactic.Basic

/-! # Lemmas for ASCII-casing

These facts apply for ASCII characters only. Recall that `isAlpha`, `isLower`, `isUpper`, `toLower`,
`toUpper` do not consider characters outside the ASCII character range (code points less than 128).
-/

namespace Char

theorem not_isLower_of_isUpper {c : Char} : c.isUpper → ¬ c.isLower := by
  simp only [isUpper, ge_iff_le, UInt32.le_iff_toNat_le, UInt32.reduceToNat, toNat_val,
    Bool.and_eq_true, decide_eq_true_eq, isLower, not_and, Nat.not_le, and_imp]
  omega

theorem not_isUpper_of_isLower {c : Char} : c.isLower → ¬ c.isUpper := by
  simp only [isUpper, ge_iff_le, UInt32.le_iff_toNat_le, UInt32.reduceToNat, toNat_val,
    Bool.and_eq_true, decide_eq_true_eq, isLower, not_and, Nat.not_le, and_imp]
  omega

theorem toLower_eq_of_not_isUpper {c : Char} (h : ¬ c.isUpper) : c.toLower = c := by
  simp only [isUpper, ge_iff_le, Bool.and_eq_true, decide_eq_true_eq, not_and] at h
  simp only [toLower, ge_iff_le, ite_eq_right_iff, and_imp]
  intro h65 h90
  absurd h h65
  exact h90

theorem toLower_eq_of_isUpper {c : Char} (h : c.isUpper) : c.toLower = ofNat (c.toNat + 32) := by
  simp only [isUpper, ge_iff_le, Bool.and_eq_true, decide_eq_true_eq] at h
  simp only [toLower, ge_iff_le, ite_eq_left_iff]
  intro; contradiction

theorem toUpper_eq_of_not_isLower {c : Char} (h : ¬ c.isLower) : c.toUpper = c := by
  simp only [isLower, ge_iff_le, Bool.and_eq_true, decide_eq_true_eq, not_and] at h
  simp only [toUpper, ge_iff_le, ite_eq_right_iff, and_imp]
  intro h97 h122
  absurd h h97
  exact h122

theorem toUpper_eq_of_isLower {c : Char} (h : c.isLower) : c.toUpper = ofNat (c.toNat - 32) := by
  simp only [isLower, ge_iff_le, Bool.and_eq_true, decide_eq_true_eq] at h
  simp only [toUpper, ge_iff_le, ite_eq_left_iff]
  intro; contradiction

@[simp] theorem isUpper_toLower_eq_false (c : Char) : c.toLower.isUpper = false := by
  simp only [isUpper, toLower, ge_iff_le, UInt32.le_iff_toNat_le, UInt32.reduceToNat, toNat_val,
    Bool.and_eq_false_imp, decide_eq_true_eq, decide_eq_false_iff_not, Nat.not_le]
  intro h
  split at h
  · next h' =>
    rw [if_pos h']
    have : (c.toNat + 32).isValidChar := by omega
    simp only [toNat_ofNat, ↓reduceIte, gt_iff_lt, *]
    omega
  · next h' =>
    rw [if_neg h']
    omega

@[simp] theorem isLower_toUpper_eq_false (c : Char) : c.toUpper.isLower = false := by
  simp only [isLower, toUpper, ge_iff_le, UInt32.le_iff_toNat_le, UInt32.reduceToNat, toNat_val,
    Bool.and_eq_false_imp, decide_eq_true_eq, decide_eq_false_iff_not, Nat.not_le]
  intro h
  split at h
  · next h' =>
    rw [if_pos h']
    have : (c.toNat - 32).isValidChar := by omega
    simp [toNat_ofNat, *] at h ⊢
    omega
  · next h' =>
    rw [if_neg h']
    omega

@[simp] theorem isLower_toLower_eq_isAlpha (c : Char) : c.toLower.isLower = c.isAlpha := by
  rw [Bool.eq_iff_iff]
  by_cases h : c.isUpper
  · simp only [isLower, h, toLower_eq_of_isUpper, ge_iff_le, UInt32.le_iff_toNat_le,
      UInt32.reduceToNat, toNat_val, Bool.and_eq_true, decide_eq_true_eq, isAlpha, Bool.true_or,
      iff_true]
    simp only [isUpper, ge_iff_le, UInt32.le_iff_toNat_le, UInt32.reduceToNat, toNat_val,
      Bool.and_eq_true, decide_eq_true_eq] at h
    have : (c.toNat + 32).isValidChar := by omega
    simp [toNat_ofNat, *]
  · simp [toLower_eq_of_not_isUpper, isAlpha, h]

@[simp] theorem isUpper_toUpper_eq_isAlpha (c : Char) : c.toUpper.isUpper = c.isAlpha := by
  rw [Bool.eq_iff_iff]
  by_cases h : c.isLower
  · simp only [isUpper, h, toUpper_eq_of_isLower, ge_iff_le, UInt32.le_iff_toNat_le,
      UInt32.reduceToNat, toNat_val, Bool.and_eq_true, decide_eq_true_eq, isAlpha, Bool.or_true,
      iff_true]
    simp only [isLower, ge_iff_le, UInt32.le_iff_toNat_le, UInt32.reduceToNat, toNat_val,
      Bool.and_eq_true, decide_eq_true_eq] at h
    have : (c.toNat - 32).isValidChar := by omega
    have : 32 ≤ c.toNat := by omega
    simp [toNat_ofNat, Nat.le_sub_iff_add_le, *]
  · simp [toUpper_eq_of_not_isLower, isAlpha, h]

@[simp] theorem isAlpha_toLower_eq_isAlpha (c : Char) : c.toLower.isAlpha = c.isAlpha := by
  simp [isAlpha]

@[simp] theorem isAlpha_toUpper_eq_isAlpha (c : Char) : c.toUpper.isAlpha = c.isAlpha := by
  simp [isAlpha]

@[simp] theorem toLower_toLower_eq_toLower (c : Char) : c.toLower.toLower = c.toLower := by
  simp [toLower_eq_of_not_isUpper]

@[simp] theorem toLower_toUpper_eq_toLower (c : Char) : c.toUpper.toLower = c.toLower := by
  by_cases hl : c.isLower
  · have hu : ¬ c.isUpper := not_isUpper_of_isLower hl
    have hu' : c.toUpper.isUpper := by simp [isAlpha, hl]
    have hv : (c.toNat - 32).isValidChar := by
      simp only [isLower, ge_iff_le, UInt32.le_iff_toNat_le, UInt32.reduceToNat, toNat_val,
        Bool.and_eq_true, decide_eq_true_eq, isUpper, not_and, Nat.not_le] at hl hu
      omega
    have h : 32 ≤ c.toNat := by
      simp only [isLower, ge_iff_le, UInt32.le_iff_toNat_le, UInt32.reduceToNat, toNat_val,
        Bool.and_eq_true, decide_eq_true_eq, isUpper, not_and, Nat.not_le] at hl hu
      omega
    rw [toLower_eq_of_isUpper hu', toUpper_eq_of_isLower hl, toLower_eq_of_not_isUpper hu,
      toNat_ofNat, if_pos hv, Nat.sub_add_cancel h, ofNat_toNat]
  · rw [toUpper_eq_of_not_isLower hl]

@[simp] theorem toUpper_toUpper_eq_toUpper (c : Char) : c.toUpper.toUpper = c.toUpper := by
  simp [toUpper_eq_of_not_isLower]

@[simp] theorem toUpper_toLower_eq_toUpper (c : Char) : c.toLower.toUpper = c.toUpper := by
  by_cases hu : c.isUpper
  · have hl : ¬ c.isLower := not_isLower_of_isUpper hu
    have hl' : c.toLower.isLower := by simp [isAlpha, hu]
    have hv : (c.toNat + 32).isValidChar := by
      simp only [isUpper, ge_iff_le, UInt32.le_iff_toNat_le, UInt32.reduceToNat, toNat_val,
        Bool.and_eq_true, decide_eq_true_eq, isLower, not_and, Nat.not_le] at hu hl
      omega
    rw [toUpper_eq_of_isLower hl', toLower_eq_of_isUpper hu, toUpper_eq_of_not_isLower hl,
      toNat_ofNat, if_pos hv, Nat.add_sub_cancel, ofNat_toNat]
  · rw [toLower_eq_of_not_isUpper hu]

/-- Case folding for ASCII characters only.

Alphabetic ASCII characters are mapped to their lowercase form, all other characters are left
unchanged. This agrees with the Unicode case folding algorithm for ASCII characters.

```
#eval caseFoldAsciiOnly 'A' == 'a'
#eval caseFoldAsciiOnly 'a' == 'a'
#eval caseFoldAsciiOnly 'À' == 'À'
#eval caseFoldAsciiOnly 'à' == 'à'
#eval caseFoldAsciiOnly '$' == '$'
```
-/
abbrev caseFoldAsciiOnly := Char.toLower

/--
Bool-valued comparison of two `Char`s for *ASCII*-case insensitive equality.

```
#eval beqCaseInsensitiveAsciiOnly 'a' 'A' -- true
#eval beqCaseInsensitiveAsciiOnly 'a' 'a' -- true
#eval beqCaseInsensitiveAsciiOnly '$' '$' -- true
#eval beqCaseInsensitiveAsciiOnly 'a' 'b' -- false
#eval beqCaseInsensitiveAsciiOnly 'γ' 'Γ' -- false
#eval beqCaseInsensitiveAsciiOnly 'ä' 'Ä' -- false
```
-/
def beqCaseInsensitiveAsciiOnly (c₁ c₂ : Char) : Bool :=
  c₁.caseFoldAsciiOnly == c₂.caseFoldAsciiOnly

theorem beqCaseInsensitiveAsciiOnly.eqv : Equivalence (beqCaseInsensitiveAsciiOnly · ·) := {
  refl _ := BEq.rfl
  trans _ _ := by simp_all [beqCaseInsensitiveAsciiOnly]
  symm := by simp_all [beqCaseInsensitiveAsciiOnly]}

/--
Setoid structure on `Char` using `beqCaseInsensitiveAsciiOnly`
-/
def beqCaseInsensitiveAsciiOnly.isSetoid : Setoid Char:=
  ⟨(beqCaseInsensitiveAsciiOnly · ·), beqCaseInsensitiveAsciiOnly.eqv⟩

/--
ASCII-case insensitive implementation comparison returning an `Ordering`. Useful for sorting.

```
#eval cmpCaseInsensitiveAsciiOnly 'a' 'A' -- eq
#eval cmpCaseInsensitiveAsciiOnly 'a' 'a' -- eq
#eval cmpCaseInsensitiveAsciiOnly '$' '$' -- eq
#eval cmpCaseInsensitiveAsciiOnly 'a' 'b' -- lt
#eval cmpCaseInsensitiveAsciiOnly 'γ' 'Γ' -- gt
#eval cmpCaseInsensitiveAsciiOnly 'ä' 'Ä' -- gt
```
-/
def cmpCaseInsensitiveAsciiOnly (c₁ c₂ : Char) : Ordering :=
  compare c₁.caseFoldAsciiOnly c₂.caseFoldAsciiOnly



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/
import Batteries.Classes.Deprecated

namespace Char

theorem le_antisymm_iff {x y : Char} : x = y ↔ x ≤ y ∧ y ≤ x :=
  Char.ext_iff.trans UInt32.le_antisymm_iff

instance : Std.LawfulOrd Char :=
  .compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm
    (fun _ => Nat.lt_irrefl _) Nat.lt_trans Nat.not_lt Char.le_antisymm

@[simp] theorem toNat_val (c : Char) : c.val.toNat = c.toNat := rfl

@[simp] theorem toNat_ofNatAux {n : Nat} (h : n.isValidChar) : toNat (ofNatAux n h) = n := by
  simp [ofNatAux, toNat]

theorem toNat_ofNat (n : Nat) : toNat (ofNat n) = if n.isValidChar then n else 0 := by
  split
  · simp [ofNat, *]
  · simp [ofNat, toNat, *]



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2018 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Leonardo de Moura
-/

namespace Batteries
/--
A difference List is a Function that, given a List, returns the original
contents of the difference List prepended to the given List.
This structure supports `O(1)` `append` and `push` operations on lists, making it
useful for append-heavy uses such as logging and pretty printing.
-/
structure DList (α : Type u) where
  /-- "Run" a `DList` by appending it on the right by a `List α` to get another `List α`. -/
  apply     : List α → List α
  /-- The `apply` function of a `DList` is completely determined by the list `apply []`. -/
  invariant : ∀ l, apply l = apply [] ++ l

attribute [simp] DList.apply

namespace DList
variable {α : Type u}
open List

/-- `O(1)` (`apply` is `O(|l|)`). Convert a `List α` into a `DList α`. -/
def ofList (l : List α) : DList α :=
  ⟨(l ++ ·), fun t => by simp⟩

/-- `O(1)` (`apply` is `O(1)`). Return an empty `DList α`. -/
def empty : DList α :=
  ⟨id, fun _ => rfl⟩

instance : EmptyCollection (DList α) := ⟨DList.empty⟩

instance : Inhabited (DList α) := ⟨DList.empty⟩

/-- `O(apply())`. Convert a `DList α` into a `List α` by running the `apply` function. -/
@[simp] def toList : DList α → List α
  | ⟨f, _⟩ => f []

/-- `O(1)` (`apply` is `O(1)`). A `DList α` corresponding to the list `[a]`. -/
def singleton (a : α) : DList α where
  apply     := fun t => a :: t
  invariant := fun _ => rfl

/-- `O(1)` (`apply` is `O(1)`). Prepend `a` on a `DList α`. -/
def cons : α → DList α → DList α
  | a, ⟨f, h⟩ => {
    apply     := fun t => a :: f t
    invariant := by intro t; simp; rw [h]
  }

/-- `O(1)` (`apply` is `O(1)`). Append two `DList α`. -/
def append : DList α → DList α → DList α
  | ⟨f, h₁⟩, ⟨g, h₂⟩ => {
    apply     := f ∘ g
    invariant := by
      intro t
      show f (g t) = (f (g [])) ++ t
      rw [h₁ (g t), h₂ t, ← append_assoc (f []) (g []) t, ← h₁ (g [])]
    }

/-- `O(1)` (`apply` is `O(1)`). Append an element at the end of a `DList α`. -/
def push : DList α → α → DList α
  | ⟨f, h⟩, a => {
    apply     := fun t => f (a :: t)
    invariant := by
      intro t
      show f (a :: t) = f (a :: nil) ++ t
      rw [h [a], h (a::t), append_assoc (f []) [a] t]
      rfl
  }

instance : Append (DList α) := ⟨DList.append⟩

/-- Convert a lazily-evaluated `List` to a `DList` -/
def ofThunk (l : Thunk (List α)) : DList α :=
  ⟨fun xs => l.get ++ xs, fun t => by simp⟩

/-- Concatenates a list of difference lists to form a single difference list. Similar to
`List.join`. -/
def join {α : Type _} : List (DList α) → DList α
  | [] => DList.empty
  | x :: xs => x ++ DList.join xs



=== LEAN SOURCE: Lemmas.lean ===
/-
Copyright (c) 2017 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Leonardo de Moura
-/
import Batteries.Data.DList.Basic

/-!
# Difference list

This file provides a few results about `DList`.

A difference list is a function that, given a list, returns the original content of the
difference list prepended to the given list. It is useful to represent elements of a given type
as `a₁ + ... + aₙ` where `+ : α → α → α` is any operation, without actually computing.

This structure supports `O(1)` `append` and `push` operations on lists, making it
useful for append-heavy uses such as logging and pretty printing.
-/

namespace Batteries.DList

open Function

theorem toList_ofList (l : List α) : DList.toList (DList.ofList l) = l := by
  cases l; rfl; simp [ofList]

theorem ofList_toList (l : DList α) : DList.ofList (DList.toList l) = l := by
   obtain ⟨app, inv⟩ := l
   simp only [ofList, toList, mk.injEq]
   funext x
   rw [(inv x)]

theorem toList_empty : toList (@empty α) = [] := by simp [empty]

theorem toList_singleton (x : α) : toList (singleton x) = [x] := by simp [singleton]

theorem toList_append (l₁ l₂ : DList α) : toList (l₁ ++ l₂) = toList l₁ ++ toList l₂ := by
  simp only [toList, append, Function.comp]; rw [invariant]

theorem toList_cons (x : α) (l : DList α) : toList (cons x l) = x :: toList l := by
  cases l; simp [cons]

theorem toList_push (x : α) (l : DList α) : toList (push l x) = toList l ++ [x] := by
  simp only [toList, push]; rw [invariant]

@[simp]
theorem singleton_eq_ofThunk {α : Type _} {a : α} : singleton a = ofThunk [a] :=
  rfl

@[simp]
theorem ofThunk_coe {α : Type _} {l : List α} : ofThunk l = ofList l :=
  rfl

end Batteries.DList



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2017 Robert Y. Lewis. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Robert Y. Lewis, Keeley Hoek, Mario Carneiro, François G. Dorais, Quang Dao
-/

namespace Fin

/-- `min n m` as an element of `Fin (m + 1)` -/
def clamp (n m : Nat) : Fin (m + 1) := ⟨min n m, Nat.lt_succ_of_le (Nat.min_le_right ..)⟩

/-- Heterogeneous monadic fold over `Fin n` from right to left:
```
Fin.foldrM n f xₙ = do
  let xₙ₋₁ : α (n-1) ← f (n-1) xₙ
  let xₙ₋₂ : α (n-2) ← f (n-2) xₙ₋₁
  ...
  let x₀ : α 0 ← f 0 x₁
  pure x₀
```
This is the dependent version of `Fin.foldrM`. -/
@[inline] def dfoldrM [Monad m] (n : Nat) (α : Fin (n + 1) → Type _)
    (f : ∀ (i : Fin n), α i.succ → m (α i.castSucc)) (init : α (last n)) : m (α 0) :=
  loop n (Nat.lt_succ_self n) init where
  /--
  Inner loop for `Fin.dfoldrM`.
  ```
  Fin.dfoldrM.loop n f i h xᵢ = do
    let xᵢ₋₁ ← f (i-1) xᵢ
    ...
    let x₁ ← f 1 x₂
    let x₀ ← f 0 x₁
    pure x₀
  ```
  -/
  @[specialize] loop (i : Nat) (h : i < n + 1) (x : α ⟨i, h⟩) : m (α 0) :=
    match i with
    | i + 1 => (f ⟨i, Nat.lt_of_succ_lt_succ h⟩ x) >>= loop i (Nat.lt_of_succ_lt h)
    | 0 => pure x

/-- Heterogeneous fold over `Fin n` from the right: `foldr 3 f x = f 0 (f 1 (f 2 x))`, where
`f 2 : α 3 → α 2`, `f 1 : α 2 → α 1`, etc.

This is the dependent version of `Fin.foldr`. -/
@[inline] def dfoldr (n : Nat) (α : Fin (n + 1) → Type _)
    (f : ∀ (i : Fin n), α i.succ → α i.castSucc) (init : α (last n)) : α 0 :=
  dfoldrM (m := Id) n α f init

/-- Heterogeneous monadic fold over `Fin n` from left to right:
```
Fin.foldlM n f x₀ = do
  let x₁ : α 1 ← f 0 x₀
  let x₂ : α 2 ← f 1 x₁
  ...
  let xₙ : α n ← f (n-1) xₙ₋₁
  pure xₙ
```
This is the dependent version of `Fin.foldlM`. -/
@[inline] def dfoldlM [Monad m] (n : Nat) (α : Fin (n + 1) → Type _)
    (f : ∀ (i : Fin n), α i.castSucc → m (α i.succ)) (init : α 0) : m (α (last n)) :=
  loop 0 (Nat.zero_lt_succ n) init where
  /-- Inner loop for `Fin.dfoldlM`.
    ```
  Fin.foldM.loop n α f i h xᵢ = do
    let xᵢ₊₁ : α (i+1) ← f i xᵢ
    ...
    let xₙ : α n ← f (n-1) xₙ₋₁
    pure xₙ
  ```
  -/
  @[semireducible, specialize] loop (i : Nat) (h : i < n + 1) (x : α ⟨i, h⟩) : m (α (last n)) :=
    if h' : i < n then
      (f ⟨i, h'⟩ x) >>= loop (i + 1) (Nat.succ_lt_succ h')
    else
      haveI : ⟨i, h⟩ = last n := by ext; simp; omega
      _root_.cast (congrArg (fun i => m (α i)) this) (pure x)

/-- Heterogeneous fold over `Fin n` from the left: `foldl 3 f x = f 0 (f 1 (f 2 x))`, where
`f 0 : α 0 → α 1`, `f 1 : α 1 → α 2`, etc.

This is the dependent version of `Fin.foldl`. -/
@[inline] def dfoldl (n : Nat) (α : Fin (n + 1) → Type _)
    (f : ∀ (i : Fin n), α i.castSucc → α i.succ) (init : α 0) : α (last n) :=
  dfoldlM (m := Id) n α f init

/--
`findSome? f` returns `f i` for the first `i` for which `f i` is `some _`, or `none` if no such
element is found. The function `f` is not evaluated on further inputs after the first `i` is found.
-/
@[inline] def findSome? (f : Fin n → Option α) : Option α :=
  foldl n (fun r i => r <|> f i) none

/--
`find? p` returns the first `i` for which `p i = true`, or `none` if no such element is found.
The function `p` is not evaluated on further inputs after the first `i` is found.
-/
@[inline] def find? (p : Fin n → Bool) : Option (Fin n) :=
  findSome? <| Option.guard fun i => p i



=== LEAN SOURCE: Fold.lean ===
/-
Copyright (c) 2024 François G. Dorais. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: François G. Dorais, Quang Dao
-/
import Batteries.Tactic.Alias
import Batteries.Data.Fin.Basic

namespace Fin

/-! ### dfoldrM -/

theorem dfoldrM_loop_zero [Monad m] (f : (i : Fin n) → α i.succ → m (α i.castSucc)) (x) :
    dfoldrM.loop n α f 0 h x = pure x := rfl

theorem dfoldrM_loop_succ [Monad m] (f : (i : Fin n) → α i.succ → m (α i.castSucc)) (x) :
    dfoldrM.loop n α f (i+1) h x = f ⟨i, by omega⟩ x >>= dfoldrM.loop n α f i (by omega) := rfl

theorem dfoldrM_loop [Monad m] [LawfulMonad m] (f : (i : Fin (n+1)) → α i.succ → m (α i.castSucc))
    (x) : dfoldrM.loop (n+1) α f (i+1) h x =
      dfoldrM.loop n (α ∘ succ) (f ·.succ) i (by omega) x >>= f 0 := by
  induction i with
  | zero =>
    rw [dfoldrM_loop_zero, dfoldrM_loop_succ, pure_bind]
    conv => rhs; rw [← bind_pure (f 0 x)]
    rfl
  | succ i ih =>
    rw [dfoldrM_loop_succ, dfoldrM_loop_succ, bind_assoc]
    congr; funext; exact ih ..

@[simp] theorem dfoldrM_zero [Monad m] (f : (i : Fin 0) → α i.succ → m (α i.castSucc)) (x) :
    dfoldrM 0 α f x = pure x := rfl

theorem dfoldrM_succ [Monad m] [LawfulMonad m] (f : (i : Fin (n+1)) → α i.succ → m (α i.castSucc))
    (x) : dfoldrM (n+1) α f x = dfoldrM n (α ∘ succ) (f ·.succ) x >>= f 0 := dfoldrM_loop ..

theorem dfoldrM_eq_foldrM [Monad m] [LawfulMonad m] (f : (i : Fin n) → α → m α) (x) :
    dfoldrM n (fun _ => α) f x = foldrM n f x := by
  induction n with
  | zero => simp only [dfoldrM_zero, foldrM_zero]
  | succ n ih => simp only [dfoldrM_succ, foldrM_succ, Function.comp_def, ih]

theorem dfoldr_eq_dfoldrM (f : (i : Fin n) → α i.succ → α i.castSucc) (x) :
    dfoldr n α f x = dfoldrM (m:=Id) n α f x := rfl

/-! ### dfoldr -/

@[simp] theorem dfoldr_zero (f : (i : Fin 0) → α i.succ → α i.castSucc) (x) :
    dfoldr 0 α f x = x := rfl

theorem dfoldr_succ (f : (i : Fin (n+1)) → α i.succ → α i.castSucc) (x) :
    dfoldr (n+1) α f x = f 0 (dfoldr n (α ∘ succ) (f ·.succ) x) := dfoldrM_succ ..

theorem dfoldr_succ_last {n : Nat} {α : Fin (n+2) → Sort _}
    (f : (i : Fin (n+1)) → α i.succ → α i.castSucc) (x : α (last (n+1))) :
      dfoldr (n+1) α f x = dfoldr n (α ∘ castSucc) (f ·.castSucc) (f (last n) x) := by
  induction n with
  | zero => simp only [dfoldr_succ, dfoldr_zero, last, zero_eta]
  | succ n ih => rw [dfoldr_succ, ih (α := α ∘ succ) (f ·.succ), dfoldr_succ]; congr

theorem dfoldr_eq_foldr (f : (i : Fin n) → α → α) (x) :
    dfoldr n (fun _ => α) f x = foldr n f x := by
  induction n with
  | zero => simp only [dfoldr_zero, foldr_zero]
  | succ n ih => simp only [dfoldr_succ, foldr_succ, Function.comp_def, ih]

/-! ### dfoldlM -/

theorem dfoldlM_loop_lt [Monad m] (f : ∀ (i : Fin n), α i.castSucc → m (α i.succ)) (h : i < n) (x) :
    dfoldlM.loop n α f i (Nat.lt_add_right 1 h) x =
      (f ⟨i, h⟩ x) >>= (dfoldlM.loop n α f (i+1) (Nat.add_lt_add_right h 1)) := by
  rw [dfoldlM.loop, dif_pos h]

theorem dfoldlM_loop_eq [Monad m] (f : ∀ (i : Fin n), α i.castSucc → m (α i.succ)) (x) :
    dfoldlM.loop n α f n (Nat.le_refl _) x = pure x := by
  rw [dfoldlM.loop, dif_neg (Nat.lt_irrefl _), cast_eq]

@[simp] theorem dfoldlM_zero [Monad m] (f : (i : Fin 0) → α i.castSucc → m (α i.succ)) (x) :
    dfoldlM 0 α f x = pure x := rfl

theorem dfoldlM_loop [Monad m] (f : (i : Fin (n+1)) → α i.castSucc → m (α i.succ)) (h : i < n+1)
    (x) : dfoldlM.loop (n+1) α f i (Nat.lt_add_right 1 h) x =
      f ⟨i, h⟩ x >>= (dfoldlM.loop n (α ∘ succ) (f ·.succ ·) i h .) := by
  if h' : i < n then
    rw [dfoldlM_loop_lt _ h _]
    congr; funext
    rw [dfoldlM_loop_lt _ h' _, dfoldlM_loop]; rfl
  else
    cases Nat.le_antisymm (Nat.le_of_lt_succ h) (Nat.not_lt.1 h')
    rw [dfoldlM_loop_lt]
    congr; funext
    rw [dfoldlM_loop_eq, dfoldlM_loop_eq]

theorem dfoldlM_succ [Monad m] (f : (i : Fin (n+1)) → α i.castSucc → m (α i.succ)) (x) :
    dfoldlM (n+1) α f x = f 0 x >>= (dfoldlM n (α ∘ succ) (f ·.succ ·) .) :=
  dfoldlM_loop ..

theorem dfoldlM_eq_foldlM [Monad m] (f : (i : Fin n) → α → m α) (x : α) :
    dfoldlM n (fun _ => α) f x = foldlM n (fun x i => f i x) x := by
  induction n generalizing x with
  | zero => simp only [dfoldlM_zero, foldlM_zero]
  | succ n ih =>
    simp only [dfoldlM_succ, foldlM_succ, Function.comp_apply, Function.comp_def]
    congr; ext; simp only [ih]

/-! ### dfoldl -/

@[simp] theorem dfoldl_zero (f : (i : Fin 0) → α i.castSucc → α i.succ) (x) :
    dfoldl 0 α f x = x := rfl

theorem dfoldl_succ (f : (i : Fin (n+1)) → α i.castSucc → α i.succ) (x) :
    dfoldl (n+1) α f x = dfoldl n (α ∘ succ) (f ·.succ ·) (f 0 x) := dfoldlM_succ ..

theorem dfoldl_succ_last (f : (i : Fin (n+1)) → α i.castSucc → α i.succ) (x) :
    dfoldl (n+1) α f x = f (last n) (dfoldl n (α ∘ castSucc) (f ·.castSucc ·) x) := by
  rw [dfoldl_succ]
  induction n with
  | zero => simp [last]
  | succ n ih => rw [dfoldl_succ, @ih (α ∘ succ) (f ·.succ ·), dfoldl_succ]; congr

theorem dfoldl_eq_dfoldlM (f : (i : Fin n) → α i.castSucc → α i.succ) (x) :
    dfoldl n α f x = dfoldlM (m := Id) n α f x := rfl

theorem dfoldl_eq_foldl (f : Fin n → α → α) (x : α) :
    dfoldl n (fun _ => α) f x = foldl n (fun x i => f i x) x := by
  induction n generalizing x with
  | zero => simp only [dfoldl_zero, foldl_zero]
  | succ n ih =>
    simp only [dfoldl_succ, foldl_succ, Function.comp_apply, Function.comp_def]
    congr; simp only [ih]

/-! ### `Fin.fold{l/r}{M}` equals `List.fold{l/r}{M}` -/

theorem foldl_eq_foldl_finRange (f : α → Fin n → α) (x) :
    foldl n f x = (List.finRange n).foldl f x := by
  induction n generalizing x with
  | zero => rw [foldl_zero, List.finRange_zero, List.foldl_nil]
  | succ n ih => rw [foldl_succ, ih, List.finRange_succ, List.foldl_cons, List.foldl_map]

theorem foldr_eq_foldr_finRange (f : Fin n → α → α) (x) :
    foldr n f x = (List.finRange n).foldr f x := by
  induction n with
  | zero => rw [foldr_zero, List.finRange_zero, List.foldr_nil]
  | succ n ih => rw [foldr_succ, ih, List.finRange_succ, List.foldr_cons, List.foldr_map]



=== LEAN SOURCE: Lemmas.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Batteries.Data.Fin.Basic
import Batteries.Util.ProofWanted

namespace Fin

attribute [norm_cast] val_last

/-! ### clamp -/

@[simp] theorem coe_clamp (n m : Nat) : (clamp n m : Nat) = min n m := rfl

/-! ### findSome? -/

@[simp] theorem findSome?_zero {f : Fin 0 → Option α} : findSome? f = none := rfl

@[simp] theorem findSome?_one {f : Fin 1 → Option α} : findSome? f = f 0 := rfl

theorem findSome?_succ {f : Fin (n+1) → Option α} :
    findSome? f = (f 0 <|> findSome? fun i => f i.succ) := by
  simp only [findSome?, foldl_succ]
  cases f 0
  · rw [Option.orElse_eq_orElse, Option.orElse_none, Option.orElse_none]
  · simp only [Option.orElse_some, Option.orElse_eq_orElse, Option.orElse_none]
    induction n with
    | zero => rfl
    | succ n ih => rw [foldl_succ, Option.orElse_some, ih (f := fun i => f i.succ)]

theorem findSome?_succ_of_some {f : Fin (n+1) → Option α} (h : f 0 = some x) :
    findSome? f = some x := by simp [findSome?_succ, h]

theorem findSome?_succ_of_isSome {f : Fin (n+1) → Option α} (h : (f 0).isSome) :
    findSome? f = f 0 := by cases _h : f 0 <;> simp_all [findSome?_succ_of_some]

theorem findSome?_succ_of_none {f : Fin (n+1) → Option α} (h : f 0 = none) :
    findSome? f = findSome? fun i => f i.succ := by simp [findSome?_succ, h]

theorem findSome?_succ_of_isNone {f : Fin (n+1) → Option α} (h : (f 0).isNone) :
    findSome? f = findSome? fun i => f i.succ := by simp_all [findSome?_succ_of_none]

theorem exists_of_findSome?_eq_some {f : Fin n → Option α} (h : findSome? f = some x) :
    ∃ i, f i = some x := by
  induction n with
  | zero => rw [findSome?_zero] at h; contradiction
  | succ n ih =>
    rw [findSome?_succ] at h
    match heq : f 0 with
    | some x =>
      rw [heq, Option.orElse_eq_orElse, Option.orElse_some] at h
      exists 0
      rw [heq, h]
    | none =>
      rw [heq, Option.orElse_eq_orElse, Option.orElse_none] at h
      match ih h with | ⟨i, _⟩ => exists i.succ

theorem eq_none_of_findSome?_eq_none {f : Fin n → Option α} (h : findSome? f = none) (i) :
    f i = none := by
  induction n with
  | zero => cases i; contradiction
  | succ n ih =>
    rw [findSome?_succ] at h
    match heq : f 0 with
    | some x =>
      rw [heq, Option.orElse_eq_orElse, Option.orElse_some] at h
      contradiction
    | none =>
      rw [heq, Option.orElse_eq_orElse, Option.orElse_none] at h
      cases i using Fin.cases with
      | zero => exact heq
      | succ i => exact ih h i

@[simp] theorem findSome?_isSome_iff {f : Fin n → Option α} :
    (findSome? f).isSome ↔ ∃ i, (f i).isSome := by
  simp only [Option.isSome_iff_exists]
  constructor
  · intro ⟨x, hx⟩
    match exists_of_findSome?_eq_some hx with
    | ⟨i, hi⟩ => exists i, x
  · intro ⟨i, x, hix⟩
    match h : findSome? f with
    | some x => exists x
    | none => rw [eq_none_of_findSome?_eq_none h i] at hix; contradiction

@[simp] theorem findSome?_eq_none_iff {f : Fin n → Option α} :
    findSome? f = none ↔ ∀ i, f i = none := by
  constructor
  · exact eq_none_of_findSome?_eq_none
  · intro hf
    match h : findSome? f with
    | none => rfl
    | some x =>
      match exists_of_findSome?_eq_some h with
      | ⟨i, h⟩ => rw [hf] at h; contradiction

theorem findSome?_isNone_iff {f : Fin n → Option α} :
    (findSome? f).isNone ↔ ∀ i, (f i).isNone := by simp

theorem map_findSome? (f : Fin n → Option α) (g : α → β) :
    (findSome? f).map g = findSome? (Option.map g ∘ f) := by
  induction n with
  | zero => rfl
  | succ n ih => simp [findSome?_succ, Function.comp_def, Option.map_or, ih]

theorem findSome?_guard {p : Fin n → Bool} : findSome? (Option.guard p) = find? p := rfl

theorem findSome?_eq_findSome?_finRange (f : Fin n → Option α) :
    findSome? f = (List.finRange n).findSome? f := by
  induction n with
  | zero => rfl
  | succ n ih =>
    rw [findSome?_succ, List.finRange_succ, List.findSome?_cons]
    cases f 0 <;> simp [ih, List.findSome?_map, Function.comp_def]

/-! ### Fin.find? -/

@[simp] theorem find?_zero {p : Fin 0 → Bool} : find? p = none := rfl

@[simp] theorem find?_one {p : Fin 1 → Bool} : find? p = if p 0 then some 0 else none := rfl

theorem find?_succ {p : Fin (n+1) → Bool} :
    find? p = if p 0 then some 0 else (find? fun i => p i.succ).map Fin.succ := by
  simp only [find?, findSome?_succ, Option.guard]
  split <;> simp [map_findSome?, Function.comp_def, Option.guard]

theorem eq_true_of_find?_eq_some {p : Fin n → Bool} (h : find? p = some i) : p i = true := by
  match exists_of_findSome?_eq_some h with
  | ⟨i, hi⟩ =>
    simp only [Option.guard] at hi
    split at hi
    · cases hi; assumption
    · contradiction

theorem eq_false_of_find?_eq_none {p : Fin n → Bool} (h : find? p = none) (i) : p i = false := by
  have hi := eq_none_of_findSome?_eq_none h i
  simp only [Option.guard] at hi
  split at hi
  · contradiction
  · simp [*]

theorem find?_isSome_iff {p : Fin n → Bool} : (find? p).isSome ↔ ∃ i, p i := by
  simp [find?]

theorem find?_isNone_iff {p : Fin n → Bool} : (find? p).isNone ↔ ∀ i, ¬ p i := by
  simp [find?]

proof_wanted find?_eq_some_iff {p : Fin n → Bool} : find? p = some i ↔ p i ∧ ∀ j, j < i → ¬ p j

theorem find?_eq_none_iff {p : Fin n → Bool} : find? p = none ↔ ∀ i, ¬ p i := by
  rw [← find?_isNone_iff, Option.isNone_iff_eq_none]

theorem find?_eq_find?_finRange {p : Fin n → Bool} : find? p = (List.finRange n).find? p := by
  induction n with
  | zero => rfl
  | succ n ih =>
    rw [find?_succ, List.finRange_succ, List.find?_cons]
    split <;> simp [Function.comp_def, *]



=== LEAN SOURCE: OfBits.lean ===
/-
Copyright (c) 2025 François G. Dorais. All rights reserved.
Released under Apache 2. license as described in the file LICENSE.
Authors: François G. Dorais
-/

import Batteries.Data.Nat.Lemmas

namespace Fin

/--
Construct an element of `Fin (2 ^ n)` from a sequence of bits (little endian).
-/
abbrev ofBits (f : Fin n → Bool) : Fin (2 ^ n) := ⟨Nat.ofBits f, Nat.ofBits_lt_two_pow f⟩

@[simp] theorem val_ofBits (f : Fin n → Bool) : (ofBits f).val = Nat.ofBits f := rfl



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2018 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Leonardo de Moura, Mario Carneiro
-/
import Batteries.Lean.HashMap
import Batteries.Tactic.Alias

namespace Std.HashMap

variable [BEq α] [Hashable α]

/--
Given a key `a`, returns a key-value pair in the map whose key compares equal to `a`.
Note that the returned key may not be identical to the input, if `==` ignores some part
of the value.
```
def hashMap := ofList [("one", 1), ("two", 2)]
hashMap.findEntry? "one" = some ("one", 1)
hashMap.findEntry? "three" = none
```
-/
-- This could be given a more efficient low level implementation.
@[inline]
def findEntry? [BEq α] [Hashable α] (m : Std.HashMap α β) (k : α) : Option (α × β) :=
  if h : k ∈ m then some (m.getKey k h, m.get k h) else none

/--
Variant of `ofList` which accepts a function that combines values of duplicated keys.
```
ofListWith [("one", 1), ("one", 2)] (fun v₁ v₂ => v₁ + v₂) = {"one" => 3}
```
-/
def ofListWith [BEq α] [Hashable α] (l : List (α × β)) (f : β → β → β) : HashMap α β :=
  l.foldl (init := ∅) fun m p =>
    match m[p.1]? with
    | none   => m.insert p.1 p.2
    | some v => m.insert p.1 <| f v p.2

end Std.HashMap

namespace Batteries.HashMap

@[reducible, deprecated (since := "2025-05-31")]
alias LawfulHashable := LawfulHashable

/--
`HashMap α β` is a key-value map which stores elements in an array using a hash function
to find the values. This allows it to have very good performance for lookups
(average `O(1)` for a perfectly random hash function), but it is not a persistent data structure,
meaning that one should take care to use the map linearly when performing updates.
Copies are `O(n)`.
-/
@[deprecated Std.HashMap (since := "2025-04-09")]
structure _root_.Batteries.HashMap (α : Type u) (β : Type v) [BEq α] [Hashable α] where
  /-- The inner `Std.HashMap` powering the `Batteries.HashMap`. -/
  inner : Std.HashMap α β

set_option linter.deprecated false

/-- Make a new hash map with the specified capacity. -/
@[inline] def _root_.Batteries.mkHashMap [BEq α] [Hashable α] (capacity := 0) : HashMap α β :=
  ⟨.emptyWithCapacity capacity, .emptyWithCapacity⟩

instance [BEq α] [Hashable α] : Inhabited (HashMap α β) where
  default := mkHashMap

instance [BEq α] [Hashable α] : EmptyCollection (HashMap α β) := ⟨mkHashMap⟩

/--
Make a new empty hash map.
```
(empty : Batteries.HashMap Int Int).toList = []
```
-/
@[inline] def empty [BEq α] [Hashable α] : HashMap α β := mkHashMap

variable {_ : BEq α} {_ : Hashable α}

/--
The number of elements in the hash map.
```
(ofList [("one", 1), ("two", 2)]).size = 2
```
-/
@[inline] def size (self : HashMap α β) : Nat := self.inner.size

/--
Is the map empty?
```
(empty : Batteries.HashMap Int Int).isEmpty = true
(ofList [("one", 1), ("two", 2)]).isEmpty = false
```
-/
@[inline] def isEmpty (self : HashMap α β) : Bool := self.inner.isEmpty

/--
Inserts key-value pair `a, b` into the map.
If an element equal to `a` is already in the map, it is replaced by `b`.
```
def hashMap := ofList [("one", 1), ("two", 2)]
hashMap.insert "three" 3 = {"one" => 1, "two" => 2, "three" => 3}
hashMap.insert "two" 0 = {"one" => 1, "two" => 0}
```
-/
@[inline] def insert (self : HashMap α β) (a : α) (b : β) : HashMap α β :=
  ⟨Std.HashMap.insert self.inner a b⟩

/--
Similar to `insert`, but also returns a boolean flag indicating whether an existing entry has been
replaced with `a => b`.
```
def hashMap := ofList [("one", 1), ("two", 2)]
hashMap.insert' "three" 3 = ({"one" => 1, "two" => 2, "three" => 3}, false)
hashMap.insert' "two" 0 = ({"one" => 1, "two" => 0}, true)
```
-/
@[inline] def insert' (m : HashMap α β) (a : α) (b : β) : HashMap α β × Bool :=
  let ⟨contains, insert⟩ := m.inner.containsThenInsert a b
  ⟨⟨insert⟩, contains⟩

/--
Removes key `a` from the map. If it does not exist in the map, the map is returned unchanged.
```
def hashMap := ofList [("one", 1), ("two", 2)]
hashMap.erase "one" = {"two" => 2}
hashMap.erase "three" = {"one" => 1, "two" => 2}
```
-/
@[inline] def erase (self : HashMap α β) (a : α) : HashMap α β := ⟨self.inner.erase a⟩

/--
Performs an in-place edit of the value, ensuring that the value is used linearly.
The function `f` is passed the original key of the entry, along with the value in the map.
```
(ofList [("one", 1), ("two", 2)]).modify "one" (fun _ v => v + 1) = {"one" => 2, "two" => 2}
(ofList [("one", 1), ("two", 2)]).modify "three" (fun _ v => v + 1) = {"one" => 1, "two" => 2}
```
-/
@[inline] def modify (self : HashMap α β) (a : α) (f : α → β → β) : HashMap α β :=
  ⟨self.inner.modify a (f a)⟩

/--
Looks up an element in the map with key `a`.
```
def hashMap := ofList [("one", 1), ("two", 2)]
hashMap.find? "one" = some 1
hashMap.find? "three" = none
```
-/
@[inline] def find? (self : HashMap α β) (a : α) : Option β := self.inner[a]?

/--
Looks up an element in the map with key `a`. Returns `b₀` if the element is not found.
```
def hashMap := ofList [("one", 1), ("two", 2)]
hashMap.findD "one" 0 = 1
hashMap.findD "three" 0 = 0
```
-/
@[inline] def findD (self : HashMap α β) (a : α) (b₀ : β) : β := self.inner.getD a b₀

/--
Looks up an element in the map with key `a`. Panics if the element is not found.
```
def hashMap := ofList [("one", 1), ("two", 2)]
hashMap.find! "one" = 1
hashMap.find! "three" => panic!
```
-/
@[inline] def find! [Inhabited β] (self : HashMap α β) (a : α) : β :=
  self.inner.getD a (panic! "key is not in the map")

instance : GetElem (HashMap α β) α (Option β) fun _ _ => True where
  getElem m k _ := m.inner[k]?

/--
Given a key `a`, returns a key-value pair in the map whose key compares equal to `a`.
Note that the returned key may not be identical to the input, if `==` ignores some part
of the value.
```
def hashMap := ofList [("one", 1), ("two", 2)]
hashMap.findEntry? "one" = some ("one", 1)
hashMap.findEntry? "three" = none
```
-/
-- This could be given a more efficient low level implementation.
@[inline]
def findEntry? [BEq α] [Hashable α] (m : HashMap α β) (k : α) : Option (α × β) :=
  m.inner.findEntry? k

/--
Returns true if the element `a` is in the map.
```
def hashMap := ofList [("one", 1), ("two", 2)]
hashMap.contains "one" = true
hashMap.contains "three" = false
```
-/
@[inline] def contains (self : HashMap α β) (a : α) : Bool := self.inner.contains a

/--
Folds a monadic function over the elements in the map (in arbitrary order).
```
def sumEven (sum: Nat) (k : String) (v : Nat) : Except String Nat :=
  if v % 2 == 0 then pure (sum + v) else throw s!"value {v} at key {k} is not even"

foldM sumEven 0 (ofList [("one", 1), ("three", 3)]) =
  Except.error "value 3 at key three is not even"
foldM sumEven 0 (ofList [("two", 2), ("four", 4)]) = Except.ok 6
```
-/
@[inline] def foldM [Monad m] (f : δ → α → β → m δ) (init : δ) (self : HashMap α β) : m δ :=
  Std.HashMap.foldM f init self.inner

/--
Folds a function over the elements in the map (in arbitrary order).
```
fold (fun sum _ v => sum + v) 0 (ofList [("one", 1), ("two", 2)]) = 3
```
-/
@[inline] def fold (f : δ → α → β → δ) (init : δ) (self : HashMap α β) : δ :=
  Std.HashMap.fold f init self.inner

/--
Combines two hashmaps using a monadic function `f` to combine two values at a key.
```
def map1 := ofList [("one", 1), ("two", 2)]
def map2 := ofList [("two", 2), ("three", 3)]
def map3 := ofList [("two", 3), ("three", 3)]
def mergeIfNoConflict? (_ : String) (v₁ v₂ : Nat) : Option Nat :=
  if v₁ != v₂ then none else some v₁


mergeWithM mergeIfNoConflict? map1 map2 = some {"one" => 1, "two" => 2, "three" => 3}
mergeWithM mergeIfNoConflict? map1 map3 = none
```
-/
@[specialize] def mergeWithM [Monad m] (f : α → β → β → m β)
    (self other : HashMap α β) : m (HashMap α β) :=
  HashMap.mk <$> self.inner.mergeWithM f other.inner

/--
Combines two hashmaps using function `f` to combine two values at a key.
```
mergeWith (fun _ v₁ v₂ => v₁ + v₂ )
  (ofList [("one", 1), ("two", 2)]) (ofList [("two", 2), ("three", 3)]) =
    {"one" => 1, "two" => 4, "three" => 3}
```
-/
@[inline] def mergeWith (f : α → β → β → β) (self other : HashMap α β) : HashMap α β :=
  ⟨self.inner.mergeWith f other.inner⟩

/--
Runs a monadic function over the elements in the map (in arbitrary order).
```
def checkEven (k : String) (v : Nat) : Except String Unit :=
  if v % 2 == 0 then pure () else throw s!"value {v} at key {k} is not even"

forM checkEven (ofList [("one", 1), ("three", 3)]) = Except.error "value 3 at key three is not even"
forM checkEven (ofList [("two", 2), ("four", 4)]) = Except.ok ()
```
-/
@[inline] def forM [Monad m] (f : α → β → m PUnit) (self : HashMap α β) : m PUnit :=
  Std.HashMap.forM f self.inner

/--
Converts the map into a list of key-value pairs.
```
open List
(ofList [("one", 1), ("two", 2)]).toList ~ [("one", 1), ("two", 2)]
```
-/
def toList (self : HashMap α β) : List (α × β) := self.inner.toList

/--
Converts the map into an array of key-value pairs.
```
open List
(ofList [("one", 1), ("two", 2)]).toArray.data ~ #[("one", 1), ("two", 2)].data
```
-/
def toArray (self : HashMap α β) : Array (α × β) := self.inner.toArray

/-- The number of buckets in the hash map. -/
def numBuckets (self : HashMap α β) : Nat := Std.HashMap.Internal.numBuckets self.inner

/--
Builds a `HashMap` from a list of key-value pairs.
Values of duplicated keys are replaced by their respective last occurrences.
```
ofList [("one", 1), ("one", 2)] = {"one" => 2}
```
-/
def ofList [BEq α] [Hashable α] (l : List (α × β)) : HashMap α β :=
  ⟨Std.HashMap.ofList l⟩

/--
Variant of `ofList` which accepts a function that combines values of duplicated keys.
```
ofListWith [("one", 1), ("one", 2)] (fun v₁ v₂ => v₁ + v₂) = {"one" => 3}
```
-/
def ofListWith [BEq α] [Hashable α] (l : List (α × β)) (f : β → β → β) : HashMap α β :=
  ⟨Std.HashMap.ofListWith l f⟩



=== LEAN SOURCE: Lemmas.lean ===
/-
Copyright (c) 2023 Lean FRO, LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Batteries.Tactic.Alias

/-!
# Lemmas for `Batteries.HashMap`

Note that Lean core provides an alternative hash map implementation, `Std.HashMap`, which comes with
more lemmas. See the module `Std.Data.HashMap.Lemmas`.
-/

namespace Batteries.HashMap

@[deprecated (since := "2025-03-31")]
alias empty_find? := Std.HashMap.getElem?_empty



=== LEAN SOURCE: ArrayMap.lean ===
/-
Copyright (c) 2024 Michael Rothgang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Michael Rothgang
-/

universe u v w
variable {α : Type u} {β : Type v}

namespace List

/--
This function is provided as a more efficient runtime alternative to `(l.map f).toArray`.
(It avoids the intermediate memory allocation of creating an intermediate list first.)
For verification purposes, we immediately simplify it to that form.
-/
def toArrayMap (l : List α) (f : α → β) : Array β :=
  l.foldl (init := #[]) fun acc x => acc.push (f x)

-- Future: a toArrayMapM version could be useful (e.g. in mathlib's DeriveToExpr)
-- def toArrayMapM {m : Type v → Type w} [Monad m] (l : List α) (f : α → m β) : m (Array β) :=
--   l.foldlM (init := #[]) fun acc x => acc.push (f x)

theorem toArrayMap_toList (l : List α) (f : α → β ) : (l.toArrayMap f).toList = l.map f := by
  suffices ∀ arr : Array β, (l.foldl (init := arr) fun acc x => acc.push (f x)).toList
      = arr.toList ++ l.map f from
    this #[]
  induction l with
  | nil => simp
  | cons head tail tail_ih =>
    intro arr
    have : arr.toList ++ f head :: map f tail = (arr.push (f head)).toList ++ map f tail := by simp
    rw [List.foldl_cons, List.map_cons, this, ← tail_ih]


@[simp, grind =]
theorem toArrayMap_eq_toArray_map (l : List α) (f : α → β) : l.toArrayMap f = (l.map f).toArray :=
  Array.ext' (by simpa using toArrayMap_toList l f)

end List



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2016 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Leonardo de Moura
-/

namespace List

/-! ## New definitions -/

/--
Computes the "bag intersection" of `l₁` and `l₂`, that is,
the collection of elements of `l₁` which are also in `l₂`. As each element
is identified, it is removed from `l₂`, so elements are counted with multiplicity.
-/
protected def bagInter {α} [BEq α] : List α → List α → List α
  | [], _ => []
  | _, [] => []
  | a :: l₁, l₂ => if l₂.elem a then a :: List.bagInter l₁ (l₂.erase a) else List.bagInter l₁ l₂

/-- Computes the difference of `l₁` and `l₂`, by removing each element in `l₂` from `l₁`. -/
protected def diff {α} [BEq α] : List α → List α → List α
  | l, [] => l
  | l₁, a :: l₂ => if l₁.elem a then List.diff (l₁.erase a) l₂ else List.diff l₁ l₂

open Option Nat

/-- Get the head and tail of a list, if it is nonempty. -/
@[inline] def next? : List α → Option (α × List α)
  | [] => none
  | a :: l => some (a, l)

/--
`after p xs` is the suffix of `xs` after the first element that satisfies
`p`, not including that element.
```lean
after      (· == 1) [0, 1, 2, 3] = [2, 3]
drop_while (· != 1) [0, 1, 2, 3] = [1, 2, 3]
```
-/
@[specialize] def after (p : α → Bool) : List α → List α
  | [] => []
  | x :: xs => bif p x then xs else after p xs

/-- Replaces the first element of the list for which `f` returns `some` with the returned value. -/
@[simp] def replaceF (f : α → Option α) : List α → List α
  | [] => []
  | x :: xs => match f x with
    | none => x :: replaceF f xs
    | some a => a :: xs

/-- Tail-recursive version of `replaceF`. -/
@[inline] def replaceFTR (f : α → Option α) (l : List α) : List α := go l #[] where
  /-- Auxiliary for `replaceFTR`: `replaceFTR.go f xs acc = acc.toList ++ replaceF f xs`. -/
  @[specialize] go : List α → Array α → List α
  | [], acc => acc.toList
  | x :: xs, acc => match f x with
    | none => go xs (acc.push x)
    | some a' => acc.toListAppend (a' :: xs)

@[csimp] theorem replaceF_eq_replaceFTR : @replaceF = @replaceFTR := by
  funext α p l; simp [replaceFTR]
  let rec go (acc) : ∀ xs, replaceFTR.go p xs acc = acc.toList ++ xs.replaceF p
  | [] => by simp [replaceFTR.go, replaceF]
  | x::xs => by
    simp [replaceFTR.go, replaceF]; cases p x <;> simp
    · rw [go _ xs]; simp
  exact (go #[] _).symm

/--
Constructs the union of two lists, by inserting the elements of `l₁` in reverse order to `l₂`.
As a result, `l₂` will always be a suffix, but only the last occurrence of each element in `l₁`
will be retained (but order will otherwise be preserved).
-/
@[inline] protected def union [BEq α] (l₁ l₂ : List α) : List α := foldr .insert l₂ l₁

instance [BEq α] : Union (List α) := ⟨List.union⟩

/--
Constructs the intersection of two lists, by filtering the elements of `l₁` that are in `l₂`.
Unlike `bagInter` this does not preserve multiplicity: `[1, 1].inter [1]` is `[1, 1]`.
-/
@[inline] protected def inter [BEq α] (l₁ l₂ : List α) : List α := filter (elem · l₂) l₁

instance [BEq α] : Inter (List α) := ⟨List.inter⟩

/--
Split a list at an index. Ensures the left list always has the specified length
by right padding with the provided default element.
```
splitAtD 2 [a, b, c] x = ([a, b], [c])
splitAtD 4 [a, b, c] x = ([a, b, c, x], [])
```
-/
def splitAtD (n : Nat) (l : List α) (dflt : α) : List α × List α := go n l [] where
  /-- Auxiliary for `splitAtD`: `splitAtD.go dflt n l acc = (acc.reverse ++ left, right)`
  if `splitAtD n l dflt = (left, right)`. -/
  go : Nat → List α → List α → List α × List α
  | n+1, x :: xs, acc => go n xs (x :: acc)
  | 0, xs, acc => (acc.reverse, xs)
  | n, [], acc => (acc.reverseAux (replicate n dflt), [])

/--
Split a list at every element satisfying a predicate. The separators are not in the result.
```
[1, 1, 2, 3, 2, 4, 4].splitOnP (· == 2) = [[1, 1], [3], [4, 4]]
```
-/
def splitOnP (P : α → Bool) (l : List α) : List (List α) := go l [] where
  /-- Auxiliary for `splitOnP`: `splitOnP.go xs acc = res'`
  where `res'` is obtained from `splitOnP P xs` by prepending `acc.reverse` to the first element. -/
  go : List α → List α → List (List α)
  | [], acc => [acc.reverse]
  | a :: t, acc => if P a then acc.reverse :: go t [] else go t (a::acc)

/-- Tail recursive version of `splitOnP`. -/
@[inline] def splitOnPTR (P : α → Bool) (l : List α) : List (List α) := go l #[] #[] where
  /-- Auxiliary for `splitOnP`: `splitOnP.go xs acc r = r.toList ++ res'`
  where `res'` is obtained from `splitOnP P xs` by prepending `acc.toList` to the first element. -/
  @[specialize] go : List α → Array α → Array (List α) → List (List α)
  | [], acc, r => r.toListAppend [acc.toList]
  | a :: t, acc, r => bif P a then go t #[] (r.push acc.toList) else go t (acc.push a) r

@[csimp] theorem splitOnP_eq_splitOnPTR : @splitOnP = @splitOnPTR := by
  funext α P l; simp [splitOnPTR]
  suffices ∀ xs acc r,
    splitOnPTR.go P xs acc r = r.toList ++ splitOnP.go P xs acc.toList.reverse from
      (this l #[] #[]).symm
  intro xs acc r; induction xs generalizing acc r with simp [splitOnP.go, splitOnPTR.go]
  | cons x xs IH => cases P x <;> simp [*]

/--
Split a list at every occurrence of a separator element. The separators are not in the result.
```
[1, 1, 2, 3, 2, 4, 4].splitOn 2 = [[1, 1], [3], [4, 4]]
```
-/
@[inline] def splitOn [BEq α] (a : α) (as : List α) : List (List α) := as.splitOnP (· == a)

/-- Apply `f` to the last element of `l`, if it exists. -/
@[inline] def modifyLast (f : α → α) (l : List α) : List α := go l #[] where
  /-- Auxiliary for `modifyLast`: `modifyLast.go f l acc = acc.toList ++ modifyLast f l`. -/
  @[specialize] go : List α → Array α → List α
  | [], _ => []
  | [x], acc => acc.toListAppend [f x]
  | x :: xs, acc => go xs (acc.push x)

theorem headD_eq_head? (l) (a : α) : headD l a = (head? l).getD a := by cases l <;> rfl

/--
Take `n` elements from a list `l`. If `l` has less than `n` elements, append `n - length l`
elements `x`.
-/
def takeD : Nat → List α → α → List α
  | 0, _, _ => []
  | n+1, l, x => l.headD x :: takeD n l.tail x

@[simp] theorem takeD_zero (l) (a : α) : takeD 0 l a = [] := rfl
@[simp] theorem takeD_succ (l) (a : α) :
    takeD (n+1) l a = l.head?.getD a :: takeD n l.tail a := by simp [takeD]

@[simp] theorem takeD_nil (n) (a : α) : takeD n [] a = replicate n a := by
  induction n <;> simp [*, replicate_succ]

/-- Tail-recursive version of `takeD`. -/
def takeDTR (n : Nat) (l : List α) (dflt : α) : List α := go n l #[] where
  /-- Auxiliary for `takeDTR`: `takeDTR.go dflt n l acc = acc.toList ++ takeD n l dflt`. -/
  go : Nat → List α → Array α → List α
  | n+1, x :: xs, acc => go n xs (acc.push x)
  | 0, _, acc => acc.toList
  | n, [], acc => acc.toListAppend (replicate n dflt)

theorem takeDTR_go_eq : ∀ n l, takeDTR.go dflt n l acc = acc.toList ++ takeD n l dflt
  | 0, _ => by simp [takeDTR.go]
  | _+1, [] => by simp [takeDTR.go, replicate_succ]
  | _+1, _::l => by simp [takeDTR.go, takeDTR_go_eq _ l]

@[csimp] theorem takeD_eq_takeDTR : @takeD = @takeDTR := by
  funext α f n l; simp [takeDTR, takeDTR_go_eq]

/--
Fold a function `f` over the list from the left, returning the list of partial results.
```
scanl (+) 0 [1, 2, 3] = [0, 1, 3, 6]
```
-/
@[simp] def scanl (f : α → β → α) (a : α) : List β → List α
  | [] => [a]
  | b :: l => a :: scanl f (f a b) l

/-- Tail-recursive version of `scanl`. -/
@[inline] def scanlTR (f : α → β → α) (a : α) (l : List β) : List α := go l a #[] where
  /-- Auxiliary for `scanlTR`: `scanlTR.go f l a acc = acc.toList ++ scanl f a l`. -/
  @[specialize] go : List β → α → Array α → List α
  | [], a, acc => acc.toListAppend [a]
  | b :: l, a, acc => go l (f a b) (acc.push a)

theorem scanlTR_go_eq : ∀ l, scanlTR.go f l a acc = acc.toList ++ scanl f a l
  | [] => by simp [scanlTR.go, scanl]
  | a :: l => by simp [scanlTR.go, scanl, scanlTR_go_eq l]

@[csimp] theorem scanl_eq_scanlTR : @scanl = @scanlTR := by
  funext α f n l; simp (config := { unfoldPartialApp := true }) [scanlTR, scanlTR_go_eq]

/--
Fold a function `f` over the list from the right, returning the list of partial results.
```
scanr (+) 0 [1, 2, 3] = [6, 5, 3, 0]
```
-/
def scanr (f : α → β → β) (b : β) (l : List α) : List β :=
  let (b', l') := l.foldr (fun a (b', l') => (f a b', b' :: l')) (b, [])
  b' :: l'

/--
Fold a list from left to right as with `foldl`, but the combining function
also receives each element's index.
-/
@[simp, specialize] def foldlIdx (f : Nat → α → β → α) (init : α) : List β → (start : _ := 0) → α
  | [], _ => init
  | b :: l, i => foldlIdx f (f i init b) l (i+1)

/--
Fold a list from right to left as with `foldr`, but the combining function
also receives each element's index.
-/
-- TODO(Mario): tail recursive / array-based implementation
@[simp, specialize] def foldrIdx (f : Nat → α → β → β) (init : β) :
    (l : List α) → (start : _ := 0) → β
  | [], _ => init
  | a :: l, i => f i a (foldrIdx f init l (i+1))

/-- `findIdxs p l` is the list of indexes of elements of `l` that satisfy `p`. -/
@[inline] def findIdxs (p : α → Bool) (l : List α) : List Nat :=
  foldrIdx (fun i a is => if p a then i :: is else is) [] l

/--
Returns the elements of `l` that satisfy `p` together with their indexes in
`l`. The returned list is ordered by index.
-/
@[inline] def indexesValues (p : α → Bool) (l : List α) : List (Nat × α) :=
  foldrIdx (fun i a l => if p a then (i, a) :: l else l) [] l

/--
`indexesOf a l` is the list of all indexes of `a` in `l`. For example:
```
indexesOf a [a, b, a, a] = [0, 2, 3]
```
-/
@[inline] def indexesOf [BEq α] (a : α) : List α → List Nat := findIdxs (· == a)

/--
`lookmap` is a combination of `lookup` and `filterMap`.
`lookmap f l` will apply `f : α → Option α` to each element of the list,
replacing `a → b` at the first value `a` in the list such that `f a = some b`.
-/
@[inline] def lookmap (f : α → Option α) (l : List α) : List α := go l #[] where
  /-- Auxiliary for `lookmap`: `lookmap.go f l acc = acc.toList ++ lookmap f l`. -/
  @[specialize] go : List α → Array α → List α
  | [], acc => acc.toList
  | a :: l, acc => match f a with
    | some b => acc.toListAppend (b :: l)
    | none => go l (acc.push a)

/--
`inits l` is the list of initial segments of `l`.
```
inits [1, 2, 3] = [[], [1], [1, 2], [1, 2, 3]]
```
-/
@[simp] def inits : List α → List (List α)
  | [] => [[]]
  | a :: l => [] :: map (fun t => a :: t) (inits l)

/-- Tail-recursive version of `inits`. -/
def initsTR (l : List α) : List (List α) :=
  l.foldr (fun a arrs => (arrs.map fun t => a :: t).push []) #[[]] |>.toListRev

@[csimp] theorem inits_eq_initsTR : @inits = @initsTR := by
  funext α l; simp [initsTR]; induction l <;> simp [*, map_reverse]

/--
`tails l` is the list of terminal segments of `l`.
```
tails [1, 2, 3] = [[1, 2, 3], [2, 3], [3], []]
```
-/
@[simp] def tails : List α → List (List α)
  | [] => [[]]
  | a :: l => (a :: l) :: tails l

/-- Tail-recursive version of `tails`. -/
def tailsTR (l : List α) : List (List α) := go l #[] where
  /-- Auxiliary for `tailsTR`: `tailsTR.go l acc = acc.toList ++ tails l`. -/
  go (l : List α) (acc : Array (List α)) : List (List α) :=
    match l with
    | [] => acc.toListAppend [[]]
    | _::xs => go xs (acc.push l)

@[csimp] theorem tails_eq_tailsTR : @tails = @tailsTR := by
  funext α
  have H (l : List α) : ∀ acc, tailsTR.go l acc = acc.toList ++ tails l := by
    induction l <;> simp [*, tailsTR.go]
  simp (config := { unfoldPartialApp := true }) [tailsTR, H]

/--
`sublists' l` is the list of all (non-contiguous) sublists of `l`.
It differs from `sublists` only in the order of appearance of the sublists;
`sublists'` uses the first element of the list as the MSB,
`sublists` uses the first element of the list as the LSB.
```
sublists' [1, 2, 3] = [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]
```
-/
def sublists' (l : List α) : List (List α) :=
  let f a arr := arr.foldl (init := arr) fun r l => r.push (a :: l)
  (l.foldr f #[[]]).toList

/--
`sublists l` is the list of all (non-contiguous) sublists of `l`; cf. `sublists'`
for a different ordering.
```
sublists [1, 2, 3] = [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]
```
-/
def sublists (l : List α) : List (List α) :=
  l.foldr (fun a acc => acc.flatMap fun x => [x, a :: x]) [[]]

/-- A version of `List.sublists` that has faster runtime performance but worse kernel performance -/
def sublistsFast (l : List α) : List (List α) :=
  let f a arr := arr.foldl (init := Array.mkEmpty (arr.size * 2))
    fun r l => (r.push l).push (a :: l)
  (l.foldr f #[[]]).toList

-- The fact that this transformation is safe is proved in mathlib4 as `sublists_eq_sublistsFast`.
-- Using a `csimp` lemma here is impractical as we are missing a lot of lemmas about lists.
-- TODO(batteries#307): upstream the necessary results about `sublists` and put the `csimp` lemma in
-- `Batteries/Data/List/Lemmas.lean`.
attribute [implemented_by sublistsFast] sublists

section Forall₂

variable {r : α → β → Prop} {p : γ → δ → Prop}

/--
`Forall₂ R l₁ l₂` means that `l₁` and `l₂` have the same length,
and whenever `a` is the nth element of `l₁`, and `b` is the nth element of `l₂`,
then `R a b` is satisfied.
-/
inductive Forall₂ (R : α → β → Prop) : List α → List β → Prop
  /-- Two nil lists are `Forall₂`-related -/
  | nil : Forall₂ R [] []
  /-- Two cons lists are related by `Forall₂ R`
  if the heads are related by `R` and the tails are related by `Forall₂ R` -/
  | cons {a b l₁ l₂} : R a b → Forall₂ R l₁ l₂ → Forall₂ R (a :: l₁) (b :: l₂)

attribute [simp] Forall₂.nil

@[simp] theorem forall₂_cons {R : α → β → Prop} {a b l₁ l₂} :
    Forall₂ R (a :: l₁) (b :: l₂) ↔ R a b ∧ Forall₂ R l₁ l₂ :=
  ⟨fun | .cons h tail => ⟨h, tail⟩, fun ⟨head, tail⟩ => .cons head tail⟩

/--
Check for all elements `a`, `b`, where `a` and `b` are the nth element of the first and second
List respectively, that `r a b = true`.
-/
def all₂ (r : α → β → Bool) : List α → List β → Bool
  | [], [] => true
  | a::as, b::bs =>
    if r a b then
      all₂ r as bs
    else false
  | _, _ => false

@[simp] theorem all₂_eq_true {r : α → β → Bool} :
    ∀ l₁ l₂, all₂ r l₁ l₂ ↔ Forall₂ (r · ·) l₁ l₂
  | [], [] => by simp [all₂]
  | a::as, b::bs => by
    by_cases h : r a b
      <;> simp [all₂, h, all₂_eq_true, forall₂_cons]
  | _::_, [] | [], _::_ => by
    simp [all₂]
    exact nofun

instance {R : α → β → Prop} [∀ a b, Decidable (R a b)] : ∀ l₁ l₂, Decidable (Forall₂ R l₁ l₂) :=
  fun l₁ l₂ => decidable_of_iff (all₂ (R · ·) l₁ l₂) (by simp [all₂_eq_true])

end Forall₂

/--
Transpose of a list of lists, treated as a matrix.
```
transpose [[1, 2], [3, 4], [5, 6]] = [[1, 3, 5], [2, 4, 6]]
```
-/
def transpose (l : List (List α)) : List (List α) := (l.foldr go #[]).toList where
  /-- `pop : List α → StateM (List α) (List α)` transforms the input list `old`
  by taking the head of the current state and pushing it on the head of `old`.
  If the state list is empty, then `old` is left unchanged. -/
  pop (old : List α) : StateM (List α) (List α)
    | [] => (old, [])
    | a :: l => (a :: old, l)

  /-- `go : List α → Array (List α) → Array (List α)` handles the insertion of
  a new list into all the lists in the array:
  `go [a, b, c] #[l₁, l₂, l₃] = #[a::l₁, b::l₂, c::l₃]`.
  If the new list is too short, the later lists are unchanged, and if it is too long
  the array is extended:
  ```
  go [a] #[l₁, l₂, l₃] = #[a::l₁, l₂, l₃]
  go [a, b, c, d] #[l₁, l₂, l₃] = #[a::l₁, b::l₂, c::l₃, [d]]
  ```
  -/
  go (l : List α) (acc : Array (List α)) : Array (List α) :=
    let (acc, l) := acc.mapM pop l
    l.foldl (init := acc) fun arr a => arr.push [a]

/--
List of all sections through a list of lists. A section
of `[L₁, L₂, ..., Lₙ]` is a list whose first element comes from
`L₁`, whose second element comes from `L₂`, and so on.
-/
@[simp] def sections : List (List α) → List (List α)
  | [] => [[]]
  | l :: L => (sections L).flatMap fun s => l.map fun a => a :: s

/-- Optimized version of `sections`. -/
def sectionsTR (L : List (List α)) : List (List α) :=
  bif L.any isEmpty then [] else (L.foldr go #[[]]).toList
where
  /-- `go : List α → Array (List α) → Array (List α)` inserts one list into the accumulated
  list of sections `acc`: `go [a, b] #[l₁, l₂] = [a::l₁, b::l₁, a::l₂, b::l₂]`. -/
  go (l : List α) (acc : Array (List α)) : Array (List α) :=
    acc.foldl (init := #[]) fun acc' l' =>
      l.foldl (init := acc') fun acc' a =>
        acc'.push (a :: l')

theorem sections_eq_nil_of_isEmpty : ∀ {L}, L.any isEmpty → @sections α L = []
  | l :: L, h => by
    simp only [any, Bool.or_eq_true] at h
    match l, h with
    | [], .inl rfl => simp
    | l, .inr h => simp [sections, sections_eq_nil_of_isEmpty h]

@[csimp] theorem sections_eq_sectionsTR : @sections = @sectionsTR := by
  funext α L; simp [sectionsTR]
  cases e : L.any isEmpty <;> simp [sections_eq_nil_of_isEmpty, *]
  clear e; induction L with | nil => rfl | cons l L IH => ?_
  simp [IH, sectionsTR.go]
  rfl

/--
`extractP p l` returns a pair of an element `a` of `l` satisfying the predicate
`p`, and `l`, with `a` removed. If there is no such element `a` it returns `(none, l)`.
-/
def extractP (p : α → Bool) (l : List α) : Option α × List α := go l #[] where
  /-- Auxiliary for `extractP`:
  `extractP.go p l xs acc = (some a, acc.toList ++ out)` if `extractP p xs = (some a, out)`,
  and `extractP.go p l xs acc = (none, l)` if `extractP p xs = (none, _)`. -/
  go : List α → Array α → Option α × List α
  | [], _ => (none, l)
  | a :: l, acc => bif p a then (some a, acc.toListAppend l) else go l (acc.push a)

/--
`revzip l` returns a list of pairs of the elements of `l` paired
with the elements of `l` in reverse order.
```
revzip [1, 2, 3, 4, 5] = [(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)]
```
-/
def revzip (l : List α) : List (α × α) := zip l l.reverse

/--
`product l₁ l₂` is the list of pairs `(a, b)` where `a ∈ l₁` and `b ∈ l₂`.
```
product [1, 2] [5, 6] = [(1, 5), (1, 6), (2, 5), (2, 6)]
```
-/
def product (l₁ : List α) (l₂ : List β) : List (α × β) := l₁.flatMap fun a => l₂.map (Prod.mk a)

/-- Optimized version of `product`. -/
def productTR (l₁ : List α) (l₂ : List β) : List (α × β) :=
  l₁.foldl (fun acc a => l₂.foldl (fun acc b => acc.push (a, b)) acc) #[] |>.toList

@[csimp] theorem product_eq_productTR : @product = @productTR := by
  funext α β l₁ l₂; simp only [product, productTR]
  rw [Array.foldl_toList_eq_flatMap]; rfl
  simp

/-- `sigma l₁ l₂` is the list of dependent pairs `(a, b)` where `a ∈ l₁` and `b ∈ l₂ a`.
```
sigma [1, 2] (λ_, [(5 : Nat), 6]) = [(1, 5), (1, 6), (2, 5), (2, 6)]
``` -/
protected def sigma {σ : α → Type _} (l₁ : List α) (l₂ : ∀ a, List (σ a)) : List (Σ a, σ a) :=
  l₁.flatMap fun a => (l₂ a).map (Sigma.mk a)

/-- Optimized version of `sigma`. -/
def sigmaTR {σ : α → Type _} (l₁ : List α) (l₂ : ∀ a, List (σ a)) : List (Σ a, σ a) :=
  l₁.foldl (fun acc a => (l₂ a).foldl (fun acc b => acc.push ⟨a, b⟩) acc) #[] |>.toList

@[csimp] theorem sigma_eq_sigmaTR : @List.sigma = @sigmaTR := by
  funext α β l₁ l₂; simp only [List.sigma, sigmaTR]
  rw [Array.foldl_toList_eq_flatMap]; rfl
  simp

/-- `ofFnNthVal f i` returns `some (f i)` if `i < n` and `none` otherwise. -/
def ofFnNthVal {n} (f : Fin n → α) (i : Nat) : Option α :=
  if h : i < n then some (f ⟨i, h⟩) else none

/-- `Disjoint l₁ l₂` means that `l₁` and `l₂` have no elements in common. -/
def Disjoint (l₁ l₂ : List α) : Prop :=
  ∀ ⦃a⦄, a ∈ l₁ → a ∈ l₂ → False

/--
Returns the longest initial prefix of two lists such that they are pairwise related by `R`.
```
takeWhile₂ (· < ·) [1, 2, 4, 5] [5, 4, 3, 6] = ([1, 2], [5, 4])
```
-/
def takeWhile₂ (R : α → β → Bool) : List α → List β → List α × List β
  | a::as, b::bs => if R a b then
      let (as', bs') := takeWhile₂ R as bs
      (a::as', b::bs')
    else ([], [])
  | _, _ => ([], [])

/-- Tail-recursive version of `takeWhile₂`. -/
@[inline] def takeWhile₂TR (R : α → β → Bool) (as : List α) (bs : List β) : List α × List β :=
  go as bs [] []
where
  /-- Auxiliary for `takeWhile₂TR`:
  `takeWhile₂TR.go R as bs acca accb = (acca.reverse ++ as', acca.reverse ++ bs')`
  if `takeWhile₂ R as bs = (as', bs')`. -/
  @[specialize] go : List α → List β → List α → List β → List α × List β
  | a::as, b::bs, acca, accb =>
    bif R a b then go as bs (a::acca) (b::accb) else (acca.reverse, accb.reverse)
  | _, _, acca, accb => (acca.reverse, accb.reverse)

@[csimp] theorem takeWhile₂_eq_takeWhile₂TR : @takeWhile₂ = @takeWhile₂TR := by
  funext α β R as bs; simp [takeWhile₂TR]
  let rec go (as bs acca accb) : takeWhile₂TR.go R as bs acca accb =
      (acca.reverse ++ (as.takeWhile₂ R bs).1, accb.reverse ++ (as.takeWhile₂ R bs).2) := by
    unfold takeWhile₂TR.go takeWhile₂; split <;> simp
    rename_i a as b bs; unfold cond; cases R a b <;> simp [go as bs]
  exact (go as bs [] []).symm

/--
`pwFilter R l` is a maximal sublist of `l` which is `Pairwise R`.
`pwFilter (·≠·)` is the erase duplicates function (cf. `eraseDup`), and `pwFilter (·<·)` finds
a maximal increasing subsequence in `l`. For example,
```
pwFilter (·<·) [0, 1, 5, 2, 6, 3, 4] = [0, 1, 2, 3, 4]
```
-/
def pwFilter (R : α → α → Prop) [DecidableRel R] (l : List α) : List α :=
  l.foldr (fun x IH => if ∀ y ∈ IH, R x y then x :: IH else IH) []

section Chain

variable (R : α → α → Prop)

/-- `Chain R a l` means that `R` holds between adjacent elements of `a::l`.
```
Chain R a [b, c, d] ↔ R a b ∧ R b c ∧ R c d
``` -/
inductive Chain : α → List α → Prop
  /-- A chain of length 1 is trivially a chain. -/
  | nil {a : α} : Chain a []
  /-- If `a` relates to `b` and `b::l` is a chain, then `a :: b :: l` is also a chain. -/
  | cons : ∀ {a b : α} {l : List α}, R a b → Chain b l → Chain a (b :: l)

/-- `Chain' R l` means that `R` holds between adjacent elements of `l`.
```
Chain' R [a, b, c, d] ↔ R a b ∧ R b c ∧ R c d
``` -/
def Chain' : List α → Prop
  | [] => True
  | a :: l => Chain R a l

end Chain

/-- `eraseDup l` removes duplicates from `l` (taking only the first occurrence).
Defined as `pwFilter (≠)`.

    eraseDup [1, 0, 2, 2, 1] = [0, 2, 1] -/
@[inline] def eraseDup [BEq α] : List α → List α := pwFilter (· != ·)

/--
`rotate l n` rotates the elements of `l` to the left by `n`
```
rotate [0, 1, 2, 3, 4, 5] 2 = [2, 3, 4, 5, 0, 1]
```
-/
@[inline] def rotate (l : List α) (n : Nat) : List α :=
  let (l₁, l₂) := List.splitAt (n % l.length) l
  l₂ ++ l₁

/-- `rotate'` is the same as `rotate`, but slower. Used for proofs about `rotate` -/
@[simp] def rotate' : List α → Nat → List α
  | [], _ => []
  | l, 0 => l
  | a :: l, n+1 => rotate' (l ++ [a]) n

/--
`mapDiagM f l` calls `f` on all elements in the upper triangular part of `l × l`.
That is, for each `e ∈ l`, it will run `f e e` and then `f e e'`
for each `e'` that appears after `e` in `l`.
```
mapDiagM f [1, 2, 3] =
  return [← f 1 1, ← f 1 2, ← f 1 3, ← f 2 2, ← f 2 3, ← f 3 3]
```
-/
def mapDiagM [Monad m] (f : α → α → m β) (l : List α) : m (List β) := go l #[] where
  /-- Auxiliary for `mapDiagM`: `mapDiagM.go as f acc = (acc.toList ++ ·) <$> mapDiagM f as` -/
  go : List α → Array β → m (List β)
  | [], acc => pure acc.toList
  | x::xs, acc => do
    let b ← f x x
    let acc ← xs.foldlM (·.push <$> f x ·) (acc.push b)
    go xs acc

/--
`forDiagM f l` calls `f` on all elements in the upper triangular part of `l × l`.
That is, for each `e ∈ l`, it will run `f e e` and then `f e e'`
for each `e'` that appears after `e` in `l`.
```
forDiagM f [1, 2, 3] = do f 1 1; f 1 2; f 1 3; f 2 2; f 2 3; f 3 3
```
-/
@[simp] def forDiagM [Monad m] (f : α → α → m PUnit) : List α → m PUnit
  | [] => pure ⟨⟩
  | x :: xs => do f x x; xs.forM (f x); xs.forDiagM f

/-- `getRest l l₁` returns `some l₂` if `l = l₁ ++ l₂`.
  If `l₁` is not a prefix of `l`, returns `none` -/
def getRest [DecidableEq α] : List α → List α → Option (List α)
  | l, [] => some l
  | [], _ => none
  | x :: l, y :: l₁ => if x = y then getRest l l₁ else none

/-- `List.dropSlice n m xs` removes a slice of length `m` at index `n` in list `xs`. -/
@[simp] def dropSlice : Nat → Nat → List α → List α
  | _, _, [] => []
  | 0, m, xs => xs.drop m
  | n+1, m, x :: xs => x :: dropSlice n m xs

/-- Optimized version of `dropSlice`. -/
@[inline] def dropSliceTR (n m : Nat) (l : List α) : List α :=
  match m with
  | 0 => l
  | m+1 => go m l n #[]
where
  /-- Auxiliary for `dropSliceTR`: `dropSliceTR.go l m xs n acc = acc.toList ++ dropSlice n m xs`
  unless `n ≥ length xs`, in which case it is `l`. -/
  go (m : Nat) : List α → Nat → Array α → List α
  | [],    _,   _   => l
  | _::xs, 0,   acc => acc.toListAppend (xs.drop m)
  | x::xs, n+1, acc => go m xs n (acc.push x)

theorem dropSlice_zero₂ : ∀ n l, @dropSlice α n 0 l = l
  | 0, [] | 0, _::_ | _+1, [] => rfl
  | n+1, x::xs => by simp [dropSlice, dropSlice_zero₂]

@[csimp] theorem dropSlice_eq_dropSliceTR : @dropSlice = @dropSliceTR := by
  funext α n m l; simp [dropSliceTR]
  split; { rw [dropSlice_zero₂] }
  rename_i m
  let rec go (acc) : ∀ xs n, l = acc.toList ++ xs →
    dropSliceTR.go l m xs n acc = acc.toList ++ xs.dropSlice n (m+1)
  | [],    n
  | _::xs, 0 => fun h => by simp [dropSliceTR.go, dropSlice, h]
  | x::xs, n+1 => by simp [dropSliceTR.go, dropSlice]; intro h; rw [go _ xs]; {simp}; simp [h]
  exact (go #[] _ _ rfl).symm

/--
Left-biased version of `List.zipWith`. `zipWithLeft' f as bs` applies `f` to each
pair of elements `aᵢ ∈ as` and `bᵢ ∈ bs`. If `bs` is shorter than `as`, `f` is
applied to `none` for the remaining `aᵢ`. Returns the results of the `f`
applications and the remaining `bs`.
```
zipWithLeft' prod.mk [1, 2] ['a'] = ([(1, some 'a'), (2, none)], [])
zipWithLeft' prod.mk [1] ['a', 'b'] = ([(1, some 'a')], ['b'])
```
-/
@[simp] def zipWithLeft' (f : α → Option β → γ) : List α → List β → List γ × List β
  | [], bs => ([], bs)
  | a :: as, [] => ((a :: as).map fun a => f a none, [])
  | a :: as, b :: bs => let r := zipWithLeft' f as bs; (f a (some b) :: r.1, r.2)

/-- Tail-recursive version of `zipWithLeft'`. -/
@[inline] def zipWithLeft'TR (f : α → Option β → γ)
    (as : List α) (bs : List β) : List γ × List β := go as bs #[] where
  /-- Auxiliary for `zipWithLeft'TR`: `zipWithLeft'TR.go l acc = acc.toList ++ zipWithLeft' l`. -/
  go : List α → List β → Array γ → List γ × List β
  | [], bs, acc => (acc.toList, bs)
  | as, [], acc => (as.foldl (fun acc a => acc.push (f a none)) acc |>.toList, [])
  | a :: as, b :: bs, acc => go as bs (acc.push (f a (some b)))

@[csimp] theorem zipWithLeft'_eq_zipWithLeft'TR : @zipWithLeft' = @zipWithLeft'TR := by
  funext α β γ f as bs; simp [zipWithLeft'TR]
  let rec go (acc) : ∀ as bs, zipWithLeft'TR.go f as bs acc =
      let (l, r) := as.zipWithLeft' f bs; (acc.toList ++ l, r)
  | [], bs => by simp [zipWithLeft'TR.go]
  | _::_, [] => by simp [zipWithLeft'TR.go]
  | a::as, b::bs => by simp [zipWithLeft'TR.go, go _ as bs]
  simp [go]

/--
Right-biased version of `List.zipWith`. `zipWithRight' f as bs` applies `f` to each
pair of elements `aᵢ ∈ as` and `bᵢ ∈ bs`. If `as` is shorter than `bs`, `f` is
applied to `none` for the remaining `bᵢ`. Returns the results of the `f`
applications and the remaining `as`.
```
zipWithRight' prod.mk [1] ['a', 'b'] = ([(some 1, 'a'), (none, 'b')], [])
zipWithRight' prod.mk [1, 2] ['a'] = ([(some 1, 'a')], [2])
```
-/
@[inline] def zipWithRight' (f : Option α → β → γ) (as : List α) (bs : List β) : List γ × List α :=
  zipWithLeft' (flip f) bs as

/--
Left-biased version of `List.zip`. `zipLeft' as bs` returns the list of
pairs `(aᵢ, bᵢ)` for `aᵢ ∈ as` and `bᵢ ∈ bs`. If `bs` is shorter than `as`, the
remaining `aᵢ` are paired with `none`. Also returns the remaining `bs`.
```
zipLeft' [1, 2] ['a'] = ([(1, some 'a'), (2, none)], [])
zipLeft' [1] ['a', 'b'] = ([(1, some 'a')], ['b'])
zipLeft' = zipWithLeft' prod.mk
```
-/
@[inline] def zipLeft' : List α → List β → List (α × Option β) × List β := zipWithLeft' Prod.mk

/--
Right-biased version of `List.zip`. `zipRight' as bs` returns the list of
pairs `(aᵢ, bᵢ)` for `aᵢ ∈ as` and `bᵢ ∈ bs`. If `as` is shorter than `bs`, the
remaining `bᵢ` are paired with `none`. Also returns the remaining `as`.
```
zipRight' [1] ['a', 'b'] = ([(some 1, 'a'), (none, 'b')], [])
zipRight' [1, 2] ['a'] = ([(some 1, 'a')], [2])
zipRight' = zipWithRight' prod.mk
```
-/
@[inline] def zipRight' : List α → List β → List (Option α × β) × List α := zipWithRight' Prod.mk

/--
Left-biased version of `List.zipWith`. `zipWithLeft f as bs` applies `f` to each pair
`aᵢ ∈ as` and `bᵢ ‌∈ bs`. If `bs` is shorter than `as`, `f` is applied to `none`
for the remaining `aᵢ`.
```
zipWithLeft prod.mk [1, 2] ['a'] = [(1, some 'a'), (2, none)]
zipWithLeft prod.mk [1] ['a', 'b'] = [(1, some 'a')]
zipWithLeft f as bs = (zipWithLeft' f as bs).fst
```
-/
@[simp] def zipWithLeft (f : α → Option β → γ) : List α → List β → List γ
  | [], _ => []
  | a :: as, [] => (a :: as).map fun a => f a none
  | a :: as, b :: bs => f a (some b) :: zipWithLeft f as bs

/-- Tail-recursive version of `zipWithLeft`. -/
@[inline] def zipWithLeftTR (f : α → Option β → γ)
    (as : List α) (bs : List β) : List γ := go as bs #[] where
  /-- Auxiliary for `zipWithLeftTR`: `zipWithLeftTR.go l acc = acc.toList ++ zipWithLeft l`. -/
  go : List α → List β → Array γ → List γ
  | [], _, acc => acc.toList
  | as, [], acc => as.foldl (fun acc a => acc.push (f a none)) acc |>.toList
  | a :: as, b :: bs, acc => go as bs (acc.push (f a (some b)))

@[csimp] theorem zipWithLeft_eq_zipWithLeftTR : @zipWithLeft = @zipWithLeftTR := by
  funext α β γ f as bs; simp [zipWithLeftTR]
  let rec go (acc) : ∀ as bs, zipWithLeftTR.go f as bs acc = acc.toList ++ as.zipWithLeft f bs
  | [], bs => by simp [zipWithLeftTR.go]
  | _::_, [] => by simp [zipWithLeftTR.go]
  | a::as, b::bs => by simp [zipWithLeftTR.go, go _ as bs]
  simp [go]

/--
Right-biased version of `List.zipWith`. `zipWithRight f as bs` applies `f` to each
pair `aᵢ ∈ as` and `bᵢ ‌∈ bs`. If `as` is shorter than `bs`, `f` is applied to
`none` for the remaining `bᵢ`.
```
zipWithRight prod.mk [1, 2] ['a'] = [(some 1, 'a')]
zipWithRight prod.mk [1] ['a', 'b'] = [(some 1, 'a'), (none, 'b')]
zipWithRight f as bs = (zipWithRight' f as bs).fst
```
-/
@[inline] def zipWithRight (f : Option α → β → γ) (as : List α) (bs : List β) : List γ :=
  zipWithLeft (flip f) bs as

/--
Left-biased version of `List.zip`. `zipLeft as bs` returns the list of pairs
`(aᵢ, bᵢ)` for `aᵢ ∈ as` and `bᵢ ∈ bs`. If `bs` is shorter than `as`, the
remaining `aᵢ` are paired with `none`.
```
zipLeft [1, 2] ['a'] = [(1, some 'a'), (2, none)]
zipLeft [1] ['a', 'b'] = [(1, some 'a')]
zipLeft = zipWithLeft prod.mk
```
-/
@[inline] def zipLeft : List α → List β → List (α × Option β) := zipWithLeft Prod.mk

/--
Right-biased version of `List.zip`. `zipRight as bs` returns the list of pairs
`(aᵢ, bᵢ)` for `aᵢ ∈ as` and `bᵢ ∈ bs`. If `as` is shorter than `bs`, the
remaining `bᵢ` are paired with `none`.
```
zipRight [1, 2] ['a'] = [(some 1, 'a')]
zipRight [1] ['a', 'b'] = [(some 1, 'a'), (none, 'b')]
zipRight = zipWithRight prod.mk
```
-/
@[inline] def zipRight : List α → List β → List (Option α × β) := zipWithRight Prod.mk

/--
If all elements of `xs` are `some xᵢ`, `allSome xs` returns the `xᵢ`. Otherwise
it returns `none`.
```
allSome [some 1, some 2] = some [1, 2]
allSome [some 1, none  ] = none
```
-/
@[inline] def allSome (l : List (Option α)) : Option (List α) := l.mapM id

/--
`fillNones xs ys` replaces the `none`s in `xs` with elements of `ys`. If there
are not enough `ys` to replace all the `none`s, the remaining `none`s are
dropped from `xs`.
```
fillNones [none, some 1, none, none] [2, 3] = [2, 1, 3]
```
-/
@[simp] def fillNones {α} : List (Option α) → List α → List α
  | [], _ => []
  | some a :: as, as' => a :: fillNones as as'
  | none :: as, [] => as.reduceOption
  | none :: as, a :: as' => a :: fillNones as as'

/-- Tail-recursive version of `fillNones`. -/
@[inline] def fillNonesTR (as : List (Option α)) (as' : List α) : List α := go as as' #[] where
  /-- Auxiliary for `fillNonesTR`: `fillNonesTR.go as as' acc = acc.toList ++ fillNones as as'`. -/
  go : List (Option α) → List α → Array α → List α
  | [], _, acc => acc.toList
  | some a :: as, as', acc => go as as' (acc.push a)
  | none :: as, [], acc => filterMapTR.go id as acc
  | none :: as, a :: as', acc => go as as' (acc.push a)

@[csimp] theorem fillNones_eq_fillNonesTR : @fillNones = @fillNonesTR := by
  funext α as as'; simp [fillNonesTR]
  let rec go (acc) : ∀ as as', @fillNonesTR.go α as as' acc = acc.toList ++ as.fillNones as'
  | [], _ => by simp [fillNonesTR.go]
  | some a :: as, as' => by simp [fillNonesTR.go, go _ as as']
  | none :: as, [] => by simp [fillNonesTR.go, reduceOption, filterMap_eq_filterMapTR.go]
  | none :: as, a :: as' => by simp [fillNonesTR.go, go _ as as']
  simp [go]

/--
`takeList as ns` extracts successive sublists from `as`. For `ns = n₁ ... nₘ`,
it first takes the `n₁` initial elements from `as`, then the next `n₂` ones,
etc. It returns the sublists of `as` -- one for each `nᵢ` -- and the remaining
elements of `as`. If `as` does not have at least as many elements as the sum of
the `nᵢ`, the corresponding sublists will have less than `nᵢ` elements.
```
takeList ['a', 'b', 'c', 'd', 'e'] [2, 1, 1] = ([['a', 'b'], ['c'], ['d']], ['e'])
takeList ['a', 'b'] [3, 1] = ([['a', 'b'], []], [])
```
-/
def takeList {α} : List α → List Nat → List (List α) × List α
  | xs, [] => ([], xs)
  | xs, n :: ns =>
    let (xs₁, xs₂) := xs.splitAt n
    let (xss, rest) := takeList xs₂ ns
    (xs₁ :: xss, rest)

/-- Tail-recursive version of `takeList`. -/
@[inline] def takeListTR
    (xs : List α) (ns : List Nat) : List (List α) × List α := go ns xs #[] where
  /-- Auxiliary for `takeListTR`: `takeListTR.go as as' acc = acc.toList ++ takeList as as'`. -/
  go : List Nat → List α → Array (List α) → List (List α) × List α
  | [], xs, acc => (acc.toList, xs)
  | n :: ns, xs, acc =>
    let (xs₁, xs₂) := xs.splitAt n
    go ns xs₂ (acc.push xs₁)

@[csimp] theorem takeList_eq_takeListTR : @takeList = @takeListTR := by
  funext α xs ns; simp [takeListTR]
  let rec go (acc) : ∀ ns xs, @takeListTR.go α ns xs acc =
      let (l, r) := xs.takeList ns; (acc.toList ++ l, r)
  | [], xs => by simp [takeListTR.go, takeList]
  | n::ns, xs => by simp [takeListTR.go, takeList, go _ ns]
  simp [go]

/-- Auxliary definition used to define `toChunks`.
  `toChunksAux n xs i` returns `(xs.take i, (xs.drop i).toChunks (n+1))`,
  that is, the first `i` elements of `xs`, and the remaining elements chunked into
  sublists of length `n+1`. -/
def toChunksAux {α} (n : Nat) : List α → Nat → List α × List (List α)
  | [], _ => ([], [])
  | x :: xs, 0 =>
    let (l, L) := toChunksAux n xs n
    ([], (x :: l) :: L)
  | x :: xs, i+1 =>
    let (l, L) := toChunksAux n xs i
    (x :: l, L)

/--
`xs.toChunks n` splits the list into sublists of size at most `n`,
such that `(xs.toChunks n).join = xs`.
```
[1, 2, 3, 4, 5, 6, 7, 8].toChunks 10 = [[1, 2, 3, 4, 5, 6, 7, 8]]
[1, 2, 3, 4, 5, 6, 7, 8].toChunks 3 = [[1, 2, 3], [4, 5, 6], [7, 8]]
[1, 2, 3, 4, 5, 6, 7, 8].toChunks 2 = [[1, 2], [3, 4], [5, 6], [7, 8]]
[1, 2, 3, 4, 5, 6, 7, 8].toChunks 0 = [[1, 2, 3, 4, 5, 6, 7, 8]]
```
-/
def toChunks {α} : Nat → List α → List (List α)
  | _, [] => []
  | 0, xs => [xs]
  | n, x :: xs =>
    let rec
    /-- Auxliary definition used to define `toChunks`.
    `toChunks.go xs acc₁ acc₂` pushes elements into `acc₁` until it reaches size `n`,
    then it pushes the resulting list to `acc₂` and continues until `xs` is exhausted. -/
    go : List α → Array α → Array (List α) → List (List α)
    | [], acc₁, acc₂ => acc₂.push acc₁.toList |>.toList
    | x :: xs, acc₁, acc₂ =>
      if acc₁.size == n then
        go xs ((Array.mkEmpty n).push x) (acc₂.push acc₁.toList)
      else
        go xs (acc₁.push x) acc₂
    go xs #[x] #[]

/-!
We add some n-ary versions of `List.zipWith` for functions with more than two arguments.
These can also be written in terms of `List.zip` or `List.zipWith`.
For example, `zipWith₃ f xs ys zs` could also be written as
`zipWith id (zipWith f xs ys) zs`
or as
`(zip xs <| zip ys zs).map fun ⟨x, y, z⟩ => f x y z`.
-/

-- TODO(Mario): tail recursive
/-- Ternary version of `List.zipWith`. -/
def zipWith₃ (f : α → β → γ → δ) : List α → List β → List γ → List δ
  | x :: xs, y :: ys, z :: zs => f x y z :: zipWith₃ f xs ys zs
  | _, _, _ => []

/-- Quaternary version of `List.zipWith`. -/
def zipWith₄ (f : α → β → γ → δ → ε) : List α → List β → List γ → List δ → List ε
  | x :: xs, y :: ys, z :: zs, u :: us => f x y z u :: zipWith₄ f xs ys zs us
  | _, _, _, _ => []

/-- Quinary version of `List.zipWith`. -/
def zipWith₅ (f : α → β → γ → δ → ε → ζ) : List α → List β → List γ → List δ → List ε → List ζ
  | x :: xs, y :: ys, z :: zs, u :: us, v :: vs => f x y z u v :: zipWith₅ f xs ys zs us vs
  | _, _, _, _, _ => []

/-- An auxiliary function for `List.mapWithPrefixSuffix`. -/
-- TODO(Mario): tail recursive
def mapWithPrefixSuffixAux {α β} (f : List α → α → List α → β) : List α → List α → List β
  | _, [] => []
  | prev, h :: t => f prev h t :: mapWithPrefixSuffixAux f (prev.concat h) t

/--
`List.mapWithPrefixSuffix f l` maps `f` across a list `l`.
For each `a ∈ l` with `l = pref ++ [a] ++ suff`, `a` is mapped to `f pref a suff`.
Example: if `f : list Nat → Nat → list Nat → β`,
`List.mapWithPrefixSuffix f [1, 2, 3]` will produce the list
`[f [] 1 [2, 3], f [1] 2 [3], f [1, 2] 3 []]`.
-/
def mapWithPrefixSuffix {α β} (f : List α → α → List α → β) (l : List α) : List β :=
  mapWithPrefixSuffixAux f [] l

/--
`List.mapWithComplement f l` is a variant of `List.mapWithPrefixSuffix`
that maps `f` across a list `l`.
For each `a ∈ l` with `l = pref ++ [a] ++ suff`, `a` is mapped to `f a (pref ++ suff)`,
i.e., the list input to `f` is `l` with `a` removed.
Example: if `f : Nat → list Nat → β`, `List.mapWithComplement f [1, 2, 3]` will produce the list
`[f 1 [2, 3], f 2 [1, 3], f 3 [1, 2]]`.
-/
def mapWithComplement {α β} (f : α → List α → β) : List α → List β :=
  mapWithPrefixSuffix fun pref a suff => f a (pref ++ suff)

/--
Map each element of a `List` to an action, evaluate these actions in order,
and collect the results.
-/
protected def traverse [Applicative F] (f : α → F β) : List α → F (List β)
  | [] => pure []
  | x :: xs => List.cons <$> f x <*> List.traverse f xs

/--
`Subperm l₁ l₂`, denoted `l₁ <+~ l₂`, means that `l₁` is a sublist of
a permutation of `l₂`. This is an analogue of `l₁ ⊆ l₂` which respects
multiplicities of elements, and is used for the `≤` relation on multisets.
-/
def Subperm (l₁ l₂ : List α) : Prop := ∃ l, l ~ l₁ ∧ l <+ l₂

@[inherit_doc] scoped infixl:50 " <+~ " => Subperm

/--
`O(|l₁| * (|l₁| + |l₂|))`. Computes whether `l₁` is a sublist of a permutation of `l₂`.
See `isSubperm_iff` for a characterization in terms of `List.Subperm`.
-/
def isSubperm [BEq α] (l₁ l₂ : List α) : Bool := ∀ x ∈ l₁, count x l₁ ≤ count x l₂

/--
`O(|l|)`. Inserts `a` in `l` right before the first element such that `p` is true, or at the end of
the list if `p` always false on `l`.
-/
def insertP (p : α → Bool) (a : α) (l : List α) : List α :=
  loop l []
where
  /-- Inner loop for `insertP`. Tail recursive. -/
  loop : List α → List α → List α
  | [], r => reverseAux (a :: r) [] -- Note: `reverseAux` is tail recursive.
  | b :: l, r => bif p b then reverseAux (a :: r) (b :: l) else loop l (b :: r)

/-- `dropPrefix? l p` returns
`some r` if `l = p' ++ r` for some `p'` which is paiwise `==` to `p`,
and `none` otherwise. -/
def dropPrefix? [BEq α] : List α → List α → Option (List α)
  | list, [] => some list
  | [], _ :: _ => none
  | a :: as, b :: bs => if a == b then dropPrefix? as bs else none

/-- `dropSuffix? l s` returns
`some r` if `l = r ++ s'` for some `s'` which is paiwise `==` to `s`,
and `none` otherwise. -/
def dropSuffix? [BEq α] (l s : List α) : Option (List α) :=
  let (r, s') := l.splitAt (l.length - s.length)
  if s' == s then some r else none

/-- `dropInfix? l i` returns
`some (p, s)` if `l = p ++ i' ++ s` for some `i'` which is paiwise `==` to `i`,
and `none` otherwise.

Note that this is an inefficient implementation, and if computation time is a concern you should be
using the Knuth-Morris-Pratt algorithm as implemented in `Batteries.Data.List.Matcher`.
-/
def dropInfix? [BEq α] (l i : List α) : Option (List α × List α) :=
  go l []
where
  /-- Inner loop for `dropInfix?`. -/
  go : List α → List α → Option (List α × List α)
  | [], acc => if i.isEmpty then some (acc.reverse, []) else none
  | a :: as, acc => match (a :: as).dropPrefix? i with
    | none => go as (a :: acc)
    | some s => (acc.reverse, s)



=== LEAN SOURCE: Count.lean ===
/-
Copyright (c) 2014 Parikshit Khanna. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Parikshit Khanna, Jeremy Avigad, Leonardo de Moura, Floris van Doorn, Mario Carneiro
-/

/-!
# Counting in lists

This file proves basic properties of `List.countP` and `List.count`, which count the number of
elements of a list satisfying a predicate and equal to a given element respectively. Their
definitions can be found in `Batteries.Data.List.Basic`.
-/


open Nat

namespace List


/-! ### count -/

section count

variable [DecidableEq α]

theorem count_singleton' (a b : α) : count a [b] = if b = a then 1 else 0 := by simp [count_cons]

theorem count_concat (a : α) (l : List α) : count a (concat l a) = succ (count a l) := by simp



=== LEAN SOURCE: Lemmas.lean ===
/-
Copyright (c) 2014 Parikshit Khanna. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Parikshit Khanna, Jeremy Avigad, Leonardo de Moura, Floris van Doorn, Mario Carneiro
-/
import Batteries.Control.ForInStep.Lemmas
import Batteries.Data.List.Basic
import Batteries.Tactic.Alias

namespace List

/-! ### toArray-/

@[simp] theorem getElem_mk {xs : List α} {i : Nat} (h : i < xs.length) :
    (Array.mk xs)[i] = xs[i] := rfl

/-! ### next? -/

@[simp] theorem next?_nil : @next? α [] = none := rfl
@[simp] theorem next?_cons (a l) : @next? α (a :: l) = some (a, l) := rfl

/-! ### dropLast -/

theorem dropLast_eq_eraseIdx {xs : List α} {i : Nat} (last_idx : i + 1 = xs.length) :
    xs.dropLast = List.eraseIdx xs i := by
  induction i generalizing xs with
  | zero =>
    let ([x]) := xs
    rfl
  | succ n ih =>
    let x::xs := xs
    simp at last_idx
    rw [dropLast, eraseIdx]
    congr
    exact ih last_idx
    exact fun _ => nomatch xs

/-! ### set -/

theorem set_eq_modify (a : α) : ∀ n (l : List α), l.set n a = l.modify n (fun _ => a)
  | 0, l => by cases l <;> rfl
  | _+1, [] => rfl
  | _+1, _ :: _ => congrArg (cons _) (set_eq_modify _ _ _)

theorem set_eq_take_cons_drop (a : α) {n l} (h : n < length l) :
    set l n a = take n l ++ a :: drop (n + 1) l := by
  rw [set_eq_modify, modify_eq_take_cons_drop h]

theorem modify_eq_set_getElem? (f : α → α) :
    ∀ n (l : List α), l.modify n f = ((fun a => l.set n (f a)) <$> l[n]?).getD l
  | 0, l => by cases l <;> simp
  | _+1, [] => rfl
  | n+1, b :: l =>
    (congrArg (cons _) (modify_eq_set_getElem? ..)).trans <| by cases h : l[n]? <;> simp [h]

@[deprecated (since := "2025-02-15")] alias modify_eq_set_get? := modify_eq_set_getElem?

theorem modify_eq_set_get (f : α → α) {n} {l : List α} (h) :
    l.modify n f = l.set n (f (l.get ⟨n, h⟩)) := by
  rw [modify_eq_set_getElem?, getElem?_eq_getElem h]; rfl

theorem getElem?_set_eq_of_lt (a : α) {n} {l : List α} (h : n < length l) :
    (set l n a)[n]? = some a := by rw [getElem?_set_self', getElem?_eq_getElem h]; rfl

theorem getElem?_set_of_lt (a : α) {m n} (l : List α) (h : n < length l) :
    (set l m a)[n]? = if m = n then some a else l[n]? := by
  simp [getElem?_set', getElem?_eq_getElem h]

@[deprecated (since := "2025-02-15")] alias get?_set_of_lt := getElem?_set_of_lt

theorem getElem?_set_of_lt' (a : α) {m n} (l : List α) (h : m < length l) :
    (set l m a)[n]? = if m = n then some a else l[n]? := by
  simp [getElem?_set]; split <;> subst_vars <;> simp [*]

@[deprecated (since := "2025-02-15")] alias get?_set_of_lt' := getElem?_set_of_lt'

/-! ### tail -/

theorem length_tail_add_one (l : List α) (h : 0 < length l) : (length (tail l)) + 1 = length l := by
  simp [Nat.sub_add_cancel h]

/-! ### eraseP -/

@[simp] theorem extractP_eq_find?_eraseP
    (l : List α) : extractP p l = (find? p l, eraseP p l) := by
  let rec go (acc) : ∀ xs, l = acc.toList ++ xs →
    extractP.go p l xs acc = (xs.find? p, acc.toList ++ xs.eraseP p)
  | [] => fun h => by simp [extractP.go, find?, eraseP, h]
  | x::xs => by
    simp [extractP.go, find?, eraseP]; cases p x <;> simp
    · intro h; rw [go _ xs]; {simp}; simp [h]
  exact go #[] _ rfl

/-! ### erase -/

theorem erase_eq_self_iff_forall_bne [BEq α] (a : α) (xs : List α) :
    xs.erase a = xs ↔ ∀ (x : α), x ∈ xs → ¬x == a := by
  rw [erase_eq_eraseP', eraseP_eq_self_iff]

/-! ### findIdx? -/

theorem findIdx_eq_findIdx? (p : α → Bool) (l : List α) :
    l.findIdx p = (match l.findIdx? p with | some i => i | none => l.length) := by
  induction l with
  | nil => rfl
  | cons x xs ih =>
    rw [findIdx_cons, findIdx?_cons]
    if h : p x then
      simp [h]
    else
      cases h' : findIdx? p xs <;> simp [h, h', ih]

/-! ### replaceF -/

theorem replaceF_nil : [].replaceF p = [] := rfl

theorem replaceF_cons (a : α) (l : List α) :
    (a :: l).replaceF p = match p a with
      | none => a :: replaceF p l
      | some a' => a' :: l := rfl

theorem replaceF_cons_of_some {l : List α} (p) (h : p a = some a') :
    (a :: l).replaceF p = a' :: l := by
  simp [h]

theorem replaceF_cons_of_none {l : List α} (p) (h : p a = none) :
    (a :: l).replaceF p = a :: l.replaceF p := by simp [h]

theorem replaceF_of_forall_none {l : List α} (h : ∀ a, a ∈ l → p a = none) : l.replaceF p = l := by
  induction l with
  | nil => rfl
  | cons _ _ ih => simp [h _ (.head ..), ih (forall_mem_cons.1 h).2]

theorem exists_of_replaceF : ∀ {l : List α} {a a'} (_ : a ∈ l) (_ : p a = some a'),
    ∃ a a' l₁ l₂,
      (∀ b ∈ l₁, p b = none) ∧ p a = some a' ∧ l = l₁ ++ a :: l₂ ∧ l.replaceF p = l₁ ++ a' :: l₂
  | b :: l, _, _, al, pa =>
    match pb : p b with
    | some b' => ⟨b, b', [], l, forall_mem_nil _, pb, by simp [pb]⟩
    | none =>
      match al with
      | .head .. => nomatch pb.symm.trans pa
      | .tail _ al =>
        let ⟨c, c', l₁, l₂, h₁, h₂, h₃, h₄⟩ := exists_of_replaceF al pa
        ⟨c, c', b::l₁, l₂, (forall_mem_cons ..).2 ⟨pb, h₁⟩,
          h₂, by rw [h₃, cons_append], by simp [pb, h₄]⟩

theorem exists_or_eq_self_of_replaceF (p) (l : List α) :
    l.replaceF p = l ∨ ∃ a a' l₁ l₂,
      (∀ b ∈ l₁, p b = none) ∧ p a = some a' ∧ l = l₁ ++ a :: l₂ ∧ l.replaceF p = l₁ ++ a' :: l₂ :=
  if h : ∃ a ∈ l, (p a).isSome then
    let ⟨_, ha, pa⟩ := h
    .inr (exists_of_replaceF ha (Option.get_mem pa))
  else
    .inl <| replaceF_of_forall_none fun a ha =>
      Option.not_isSome_iff_eq_none.1 fun h' => h ⟨a, ha, h'⟩

@[simp] theorem length_replaceF : length (replaceF f l) = length l := by
  induction l <;> simp [replaceF]; split <;> simp [*]

/-! ### disjoint -/

theorem disjoint_symm (d : Disjoint l₁ l₂) : Disjoint l₂ l₁ := fun _ i₂ i₁ => d i₁ i₂

theorem disjoint_comm : Disjoint l₁ l₂ ↔ Disjoint l₂ l₁ := ⟨disjoint_symm, disjoint_symm⟩

theorem disjoint_left : Disjoint l₁ l₂ ↔ ∀ ⦃a⦄, a ∈ l₁ → a ∉ l₂ := by simp [Disjoint]

theorem disjoint_right : Disjoint l₁ l₂ ↔ ∀ ⦃a⦄, a ∈ l₂ → a ∉ l₁ := disjoint_comm

theorem disjoint_iff_ne : Disjoint l₁ l₂ ↔ ∀ a ∈ l₁, ∀ b ∈ l₂, a ≠ b :=
  ⟨fun h _ al1 _ bl2 ab => h al1 (ab ▸ bl2), fun h _ al1 al2 => h _ al1 _ al2 rfl⟩

theorem disjoint_of_subset_left (ss : l₁ ⊆ l) (d : Disjoint l l₂) : Disjoint l₁ l₂ :=
  fun _ m => d (ss m)

theorem disjoint_of_subset_right (ss : l₂ ⊆ l) (d : Disjoint l₁ l) : Disjoint l₁ l₂ :=
  fun _ m m₁ => d m (ss m₁)

theorem disjoint_of_disjoint_cons_left {l₁ l₂} : Disjoint (a :: l₁) l₂ → Disjoint l₁ l₂ :=
  disjoint_of_subset_left (subset_cons_self _ _)

theorem disjoint_of_disjoint_cons_right {l₁ l₂} : Disjoint l₁ (a :: l₂) → Disjoint l₁ l₂ :=
  disjoint_of_subset_right (subset_cons_self _ _)

@[simp] theorem disjoint_nil_left (l : List α) : Disjoint [] l := fun _ => not_mem_nil.elim

@[simp] theorem disjoint_nil_right (l : List α) : Disjoint l [] := by
  rw [disjoint_comm]; exact disjoint_nil_left _

@[simp 1100] theorem singleton_disjoint : Disjoint [a] l ↔ a ∉ l := by simp [Disjoint]

@[simp 1100] theorem disjoint_singleton : Disjoint l [a] ↔ a ∉ l := by
  rw [disjoint_comm, singleton_disjoint]

@[simp] theorem disjoint_append_left : Disjoint (l₁ ++ l₂) l ↔ Disjoint l₁ l ∧ Disjoint l₂ l := by
  simp [Disjoint, or_imp, forall_and]

@[simp] theorem disjoint_append_right : Disjoint l (l₁ ++ l₂) ↔ Disjoint l l₁ ∧ Disjoint l l₂ :=
  disjoint_comm.trans <| by rw [disjoint_append_left]; simp [disjoint_comm]

@[simp] theorem disjoint_cons_left : Disjoint (a::l₁) l₂ ↔ (a ∉ l₂) ∧ Disjoint l₁ l₂ :=
  (disjoint_append_left (l₁ := [a])).trans <| by simp [singleton_disjoint]

@[simp] theorem disjoint_cons_right : Disjoint l₁ (a :: l₂) ↔ (a ∉ l₁) ∧ Disjoint l₁ l₂ :=
  disjoint_comm.trans <| by rw [disjoint_cons_left]; simp [disjoint_comm]

theorem disjoint_of_disjoint_append_left_left (d : Disjoint (l₁ ++ l₂) l) : Disjoint l₁ l :=
  (disjoint_append_left.1 d).1

theorem disjoint_of_disjoint_append_left_right (d : Disjoint (l₁ ++ l₂) l) : Disjoint l₂ l :=
  (disjoint_append_left.1 d).2

theorem disjoint_of_disjoint_append_right_left (d : Disjoint l (l₁ ++ l₂)) : Disjoint l l₁ :=
  (disjoint_append_right.1 d).1

theorem disjoint_of_disjoint_append_right_right (d : Disjoint l (l₁ ++ l₂)) : Disjoint l l₂ :=
  (disjoint_append_right.1 d).2

/-! ### union -/

section union

variable [BEq α]

theorem union_def (l₁ l₂ : List α)  : l₁ ∪ l₂ = foldr .insert l₂ l₁ := rfl

@[simp] theorem nil_union (l : List α) : nil ∪ l = l := by simp [List.union_def, foldr]

@[simp] theorem cons_union (a : α) (l₁ l₂ : List α) :
    (a :: l₁) ∪ l₂ = (l₁ ∪ l₂).insert a := by simp [List.union_def, foldr]

@[simp] theorem mem_union_iff [LawfulBEq α] {x : α} {l₁ l₂ : List α} :
    x ∈ l₁ ∪ l₂ ↔ x ∈ l₁ ∨ x ∈ l₂ := by induction l₁ <;> simp [*, or_assoc]

end union

/-! ### inter -/

theorem inter_def [BEq α] (l₁ l₂ : List α)  : l₁ ∩ l₂ = filter (elem · l₂) l₁ := rfl

@[simp] theorem mem_inter_iff [BEq α] [LawfulBEq α] {x : α} {l₁ l₂ : List α} :
    x ∈ l₁ ∩ l₂ ↔ x ∈ l₁ ∧ x ∈ l₂ := by
  cases l₁ <;> simp [List.inter_def, mem_filter]

/-! ### product -/

/-- List.prod satisfies a specification of cartesian product on lists. -/
@[simp]
theorem pair_mem_product {xs : List α} {ys : List β} {x : α} {y : β} :
    (x, y) ∈ product xs ys ↔ x ∈ xs ∧ y ∈ ys := by
  simp only [product, mem_map, Prod.mk.injEq,
    exists_eq_right_right, mem_flatMap, iff_self]

/-! ### monadic operations -/

theorem forIn_eq_bindList [Monad m] [LawfulMonad m]
    (f : α → β → m (ForInStep β)) (l : List α) (init : β) :
    forIn l init f = ForInStep.run <$> (ForInStep.yield init).bindList f l := by
  induction l generalizing init <;> simp [*]
  congr; ext (b | b) <;> simp

/-! ### diff -/

section Diff
variable [BEq α]

@[simp] theorem diff_nil (l : List α) : l.diff [] = l := rfl

variable [LawfulBEq α]

@[simp] theorem diff_cons (l₁ l₂ : List α) (a : α) : l₁.diff (a :: l₂) = (l₁.erase a).diff l₂ := by
  simp_all [List.diff, erase_of_not_mem]

theorem diff_cons_right (l₁ l₂ : List α) (a : α) : l₁.diff (a :: l₂) = (l₁.diff l₂).erase a := by
  apply Eq.symm; induction l₂ generalizing l₁ <;> simp [erase_comm, *]

theorem diff_erase (l₁ l₂ : List α) (a : α) : (l₁.diff l₂).erase a = (l₁.erase a).diff l₂ := by
  rw [← diff_cons_right, diff_cons]

@[simp] theorem nil_diff (l : List α) : [].diff l = [] := by
  induction l <;> simp [*, erase_of_not_mem]

theorem cons_diff (a : α) (l₁ l₂ : List α) :
    (a :: l₁).diff l₂ = if a ∈ l₂ then l₁.diff (l₂.erase a) else a :: l₁.diff l₂ := by
  induction l₂ generalizing l₁ with
  | nil => rfl
  | cons b l₂ ih =>
    by_cases h : a = b
    next => simp [*]
    next =>
      have := Ne.symm h
      simp[*]

theorem cons_diff_of_mem {a : α} {l₂ : List α} (h : a ∈ l₂) (l₁ : List α) :
    (a :: l₁).diff l₂ = l₁.diff (l₂.erase a) := by rw [cons_diff, if_pos h]

theorem cons_diff_of_not_mem {a : α} {l₂ : List α} (h : a ∉ l₂) (l₁ : List α) :
    (a :: l₁).diff l₂ = a :: l₁.diff l₂ := by rw [cons_diff, if_neg h]

theorem diff_eq_foldl : ∀ l₁ l₂ : List α, l₁.diff l₂ = foldl List.erase l₁ l₂
  | _, [] => rfl
  | l₁, a :: l₂ => (diff_cons l₁ l₂ a).trans (diff_eq_foldl _ _)

@[simp] theorem diff_append (l₁ l₂ l₃ : List α) : l₁.diff (l₂ ++ l₃) = (l₁.diff l₂).diff l₃ := by
  simp only [diff_eq_foldl, foldl_append]

theorem diff_sublist : ∀ l₁ l₂ : List α, l₁.diff l₂ <+ l₁
  | _, [] => .refl _
  | l₁, a :: l₂ =>
    calc
      l₁.diff (a :: l₂) = (l₁.erase a).diff l₂ := diff_cons ..
      _ <+ l₁.erase a := diff_sublist ..
      _ <+ l₁ := erase_sublist ..

theorem diff_subset (l₁ l₂ : List α) : l₁.diff l₂ ⊆ l₁ := (diff_sublist ..).subset

theorem mem_diff_of_mem {a : α} : ∀ {l₁ l₂ : List α}, a ∈ l₁ → a ∉ l₂ → a ∈ l₁.diff l₂
  | _, [], h₁, _ => h₁
  | l₁, b :: l₂, h₁, h₂ => by
    rw [diff_cons]
    exact mem_diff_of_mem ((mem_erase_of_ne <| ne_of_not_mem_cons h₂).2 h₁) (mt (.tail _) h₂)

theorem Sublist.diff_right : ∀ {l₁ l₂ l₃ : List α}, l₁ <+ l₂ → l₁.diff l₃ <+ l₂.diff l₃
  | _,  _, [], h => h
  | l₁, l₂, a :: l₃, h => by simp only [diff_cons, (h.erase _).diff_right]

theorem Sublist.erase_diff_erase_sublist {a : α} :
    ∀ {l₁ l₂ : List α}, l₁ <+ l₂ → (l₂.erase a).diff (l₁.erase a) <+ l₂.diff l₁
  | [], _, _ => erase_sublist
  | b :: l₁, l₂, h => by
    if heq : b = a then
      simp [heq]
    else
      simp [heq, erase_comm a]
      exact (erase_cons_head b _ ▸ h.erase b).erase_diff_erase_sublist

end Diff

/-! ### drop -/

theorem disjoint_take_drop : ∀ {l : List α}, l.Nodup → m ≤ n → Disjoint (l.take m) (l.drop n)
  | [], _, _ => by simp
  | x :: xs, hl, h => by
    cases m <;> cases n <;> simp only [disjoint_cons_left, drop, disjoint_nil_left,
      take]
    · case succ.zero => cases h
    · cases hl with | cons h₀ h₁ =>
      refine ⟨fun h => h₀ _ (mem_of_mem_drop h) rfl, ?_⟩
      exact disjoint_take_drop h₁ (Nat.le_of_succ_le_succ h)

/-! ### Chain -/

attribute [simp] Chain.nil

@[simp]
theorem chain_cons {a b : α} {l : List α} : Chain R a (b :: l) ↔ R a b ∧ Chain R b l :=
  ⟨fun p => by cases p with | cons n p => exact ⟨n, p⟩,
   fun ⟨n, p⟩ => p.cons n⟩

theorem rel_of_chain_cons {a b : α} {l : List α} (p : Chain R a (b :: l)) : R a b :=
  (chain_cons.1 p).1

theorem chain_of_chain_cons {a b : α} {l : List α} (p : Chain R a (b :: l)) : Chain R b l :=
  (chain_cons.1 p).2

theorem Chain.imp' {R S : α → α → Prop} (HRS : ∀ ⦃a b⦄, R a b → S a b) {a b : α}
    (Hab : ∀ ⦃c⦄, R a c → S b c) {l : List α} (p : Chain R a l) : Chain S b l := by
  induction p generalizing b with
  | nil => constructor
  | cons r _ ih =>
    constructor
    · exact Hab r
    · exact ih (@HRS _)

theorem Chain.imp {R S : α → α → Prop} (H : ∀ a b, R a b → S a b) {a : α} {l : List α}
    (p : Chain R a l) : Chain S a l :=
  p.imp' H (H a)

protected theorem Pairwise.chain (p : Pairwise R (a :: l)) : Chain R a l := by
  let ⟨r, p'⟩ := pairwise_cons.1 p; clear p
  induction p' generalizing a with
  | nil => exact Chain.nil
  | @cons b l r' _ IH =>
    simp only [forall_mem_cons] at r
    exact chain_cons.2 ⟨r.1, IH r'⟩

/-! ### range', range -/

theorem chain_succ_range' : ∀ s n step : Nat,
    Chain (fun a b => b = a + step) s (range' (s + step) n step)
  | _, 0, _ => Chain.nil
  | s, n + 1, step => (chain_succ_range' (s + step) n step).cons rfl

theorem chain_lt_range' (s n : Nat) {step} (h : 0 < step) :
    Chain (· < ·) s (range' (s + step) n step) :=
  (chain_succ_range' s n step).imp fun _ _ e => e.symm ▸ Nat.lt_add_of_pos_right h

/-! ### indexOf and indexesOf -/

theorem foldrIdx_start :
    (xs : List α).foldrIdx f i s = (xs : List α).foldrIdx (fun i => f (i + s)) i := by
  induction xs generalizing f i s with
  | nil => rfl
  | cons h t ih =>
    dsimp [foldrIdx]
    simp only [@ih f]
    simp only [@ih (fun i => f (i + s))]
    simp [Nat.add_assoc, Nat.add_comm 1 s]

@[simp] theorem foldrIdx_cons :
    (x :: xs : List α).foldrIdx f i s = f s x (foldrIdx f i xs (s + 1)) := rfl

theorem findIdxs_cons_aux (p : α → Bool) :
    foldrIdx (fun i a is => if p a = true then (i + 1) :: is else is) [] xs s =
      map (· + 1) (foldrIdx (fun i a is => if p a = true then i :: is else is) [] xs s) := by
  induction xs generalizing s with
  | nil => rfl
  | cons x xs ih =>
    simp only [foldrIdx]
    split <;> simp [ih]

theorem findIdxs_cons :
    (x :: xs : List α).findIdxs p =
      bif p x then 0 :: (xs.findIdxs p).map (· + 1) else (xs.findIdxs p).map (· + 1) := by
  dsimp [findIdxs]
  rw [cond_eq_if]
  split <;>
  · simp only [foldrIdx_start, Nat.add_zero, cons.injEq, true_and]
    apply findIdxs_cons_aux

@[simp] theorem indexesOf_nil [BEq α] : ([] : List α).indexesOf x = [] := rfl

theorem indexesOf_cons [BEq α] : (x :: xs : List α).indexesOf y =
    bif x == y then 0 :: (xs.indexesOf y).map (· + 1) else (xs.indexesOf y).map (· + 1) := by
  simp [indexesOf, findIdxs_cons]

@[simp] theorem eraseIdx_idxOf_eq_erase [BEq α] (a : α) (l : List α) :
    l.eraseIdx (l.idxOf a) = l.erase a := by
  induction l with
  | nil => rfl
  | cons x xs ih =>
    rw [List.erase, idxOf_cons]
    cases x == a <;> simp [ih]

theorem idxOf_mem_indexesOf [BEq α] [LawfulBEq α] {xs : List α} (m : x ∈ xs) :
    xs.idxOf x ∈ xs.indexesOf x := by
  induction xs with
  | nil => simp_all
  | cons h t ih =>
    simp [idxOf_cons, indexesOf_cons, cond_eq_if]
    split <;> rename_i w
    · apply mem_cons_self
    · cases m
      case _ => simp_all
      case tail m =>
        specialize ih m
        simpa

theorem idxOf_eq_idxOf? [BEq α] (a : α) (l : List α) :
    l.idxOf a = (match l.idxOf? a with | some i => i | none => l.length) := by
  simp [idxOf, idxOf?, findIdx_eq_findIdx?]

/-! ### insertP -/

theorem insertP_loop (a : α) (l r : List α) :
    insertP.loop p a l r = reverseAux r (insertP p a l) := by
  induction l generalizing r with simp [insertP, insertP.loop, cond]
  | cons b l ih => rw [ih (b :: r), ih [b]]; split <;> simp

@[simp] theorem insertP_nil (p : α → Bool) (a) : insertP p a [] = [a] := rfl

@[simp] theorem insertP_cons_pos (p : α → Bool) (a b l) (h : p b) :
    insertP p a (b :: l) = a :: b :: l := by
  simp only [insertP, insertP.loop, cond, h]; rfl

@[simp] theorem insertP_cons_neg (p : α → Bool) (a b l) (h : ¬ p b) :
    insertP p a (b :: l) = b :: insertP p a l := by
  simp only [insertP, insertP.loop, cond, h]; exact insertP_loop ..

@[simp] theorem length_insertP (p : α → Bool) (a l) : (insertP p a l).length = l.length + 1 := by
  induction l with simp [insertP, insertP.loop, cond]
  | cons _ _ ih => split <;> simp [insertP_loop, ih]

@[simp] theorem mem_insertP (p : α → Bool) (a l) : a ∈ insertP p a l := by
  induction l with simp [insertP, insertP.loop, cond]
  | cons _ _ ih => split <;> simp [insertP_loop, ih]

/-! ### dropPrefix?, dropSuffix?, dropInfix?-/

open Option

@[simp] theorem dropPrefix?_nil [BEq α] {p : List α} : dropPrefix? p [] = some p := by
  simp [dropPrefix?]

theorem dropPrefix?_eq_some_iff [BEq α] {l p s : List α} :
    dropPrefix? l p = some s ↔ ∃ p', l = p' ++ s ∧ p' == p := by
  unfold dropPrefix?
  split
  · simp
  · simp
  · rename_i a as b bs
    simp only [ite_none_right_eq_some]
    constructor
    · rw [dropPrefix?_eq_some_iff]
      rintro ⟨w, p', rfl, h⟩
      refine ⟨a :: p', by simp_all⟩
    · rw [dropPrefix?_eq_some_iff]
      rintro ⟨p, h, w⟩
      rw [cons_eq_append_iff] at h
      obtain (⟨rfl, rfl⟩ | ⟨a', rfl, rfl⟩) := h
      · simp at w
      · simp only [cons_beq_cons, Bool.and_eq_true] at w
        refine ⟨w.1, a', rfl, w.2⟩

theorem dropPrefix?_append_of_beq [BEq α] {l₁ l₂ : List α} (p : List α) (h : l₁ == l₂) :
    dropPrefix? (l₁ ++ p) l₂ = some p := by
  simp [dropPrefix?_eq_some_iff, h]

theorem dropSuffix?_eq_some_iff [BEq α] {l p s : List α} :
    dropSuffix? l s = some p ↔ ∃ s', l = p ++ s' ∧ s' == s := by
  unfold dropSuffix?
  rw [splitAt_eq]
  simp only [ite_none_right_eq_some, some.injEq]
  constructor
  · rintro ⟨w, rfl⟩
    refine ⟨_, by simp, w⟩
  · rintro ⟨s', rfl, w⟩
    simp [length_eq_of_beq w, w]

@[simp] theorem dropSuffix?_nil [BEq α] {s : List α} : dropSuffix? s [] = some s := by
  simp [dropSuffix?_eq_some_iff]

theorem dropInfix?_go_eq_some_iff [BEq α] {i l acc p s : List α} :
    dropInfix?.go i l acc = some (p, s) ↔ ∃ p',
      p = acc.reverse ++ p' ∧
      -- `i` is an infix up to `==`
      (∃ i', l = p' ++ i' ++ s ∧ i' == i) ∧
        -- and there is no shorter prefix for which that is the case
        (∀ p'' i'' s'', l = p'' ++ i'' ++ s'' → i'' == i → p''.length ≥ p'.length) := by
  unfold dropInfix?.go
  split
  · simp only [isEmpty_iff, ite_none_right_eq_some, some.injEq, Prod.mk.injEq, nil_eq,
      append_assoc, append_eq_nil_iff, ge_iff_le, and_imp]
    constructor
    · rintro ⟨rfl, rfl, rfl⟩
      simp
    · rintro ⟨p', rfl, ⟨_, ⟨rfl, rfl, rfl⟩, h⟩, w⟩
      simp_all
  · rename_i a t
    split <;> rename_i h
    · rw [dropInfix?_go_eq_some_iff]
      constructor
      · rintro ⟨p', rfl, ⟨i', rfl, h₂⟩, w⟩
        refine ⟨a :: p', ?_⟩
        simp [h₂]
        intro p'' i'' s'' h₁ h₂
        rw [cons_eq_append_iff] at h₁
        obtain (⟨rfl, h₁⟩ | ⟨p'', rfl, h₁⟩) := h₁
        · rw [append_assoc, ← h₁] at h
          have := dropPrefix?_append_of_beq s'' h₂
          simp_all
        · simpa using w p'' i'' s'' (by simpa using h₁) h₂
      · rintro ⟨p', rfl, ⟨i', h₁, h₂⟩, w⟩
        rw [cons_eq_append_iff] at h₁
        simp at h₁
        obtain (⟨⟨rfl, rfl⟩, rfl⟩ | ⟨a', h₁, rfl⟩) := h₁
        · simp only [nil_beq_eq, isEmpty_iff] at h₂
          simp only [h₂] at h
          simp at h
        · rw [append_eq_cons_iff] at h₁
          obtain (⟨rfl, rfl⟩ | ⟨p', rfl, rfl⟩) := h₁
          · rw [← cons_append] at h
            have := dropPrefix?_append_of_beq s h₂
            simp_all
          · refine ⟨p', ?_⟩
            simp only [reverse_cons, append_assoc, singleton_append, append_cancel_left_eq,
              append_cancel_right_eq, exists_eq_left', ge_iff_le, true_and]
            refine ⟨h₂, ?_⟩
            intro p'' i'' s'' h₃ h₄
            rw [← append_assoc] at h₃
            rw [h₃] at w
            simpa using w (a :: p'') i'' s'' (by simp) h₄
    · rename_i s'
      simp only [some.injEq, Prod.mk.injEq, append_assoc, ge_iff_le]
      rw [dropPrefix?_eq_some_iff] at h
      obtain ⟨p', h, w⟩ := h
      constructor
      · rintro ⟨rfl, rfl⟩
        simpa using ⟨p', by simp_all⟩
      · rintro ⟨p'', rfl, ⟨i', h₁, h₂⟩, w'⟩
        specialize w' [] p' s' (by simpa using h) w
        simp at w'
        simp [w'] at h₁ ⊢
        rw [h] at h₁
        apply append_inj_right h₁
        replace w := length_eq_of_beq w
        replace h₂ := length_eq_of_beq h₂
        simp_all

theorem dropInfix?_eq_some_iff [BEq α] {l i p s : List α} :
    dropInfix? l i = some (p, s) ↔
      -- `i` is an infix up to `==`
      (∃ i', l = p ++ i' ++ s ∧ i' == i) ∧
        -- and there is no shorter prefix for which that is the case
        (∀ p' i' s', l = p' ++ i' ++ s' → i' == i → p'.length ≥ p.length) := by
  unfold dropInfix?
  rw [dropInfix?_go_eq_some_iff]
  simp

@[simp] theorem dropInfix?_nil [BEq α] {s : List α} : dropInfix? s [] = some ([], s) := by
  simp [dropInfix?_eq_some_iff]

/-! ### IsPrefixOf?, IsSuffixOf? -/

@[simp] theorem isSome_isPrefixOf?_eq_isPrefixOf [BEq α] (xs ys : List α) :
    (xs.isPrefixOf? ys).isSome = xs.isPrefixOf ys := by
  match xs, ys with
  | [], _ => simp [List.isPrefixOf?]
  | _::_, [] => rfl
  | _::_, _::_ =>
    simp only [List.isPrefixOf?, List.isPrefixOf]
    split <;> simp [*, isSome_isPrefixOf?_eq_isPrefixOf]

@[simp] theorem isPrefixOf?_eq_some_iff_append_eq [BEq α] [LawfulBEq α] {xs ys zs : List α} :
    xs.isPrefixOf? ys = some zs ↔ xs ++ zs = ys := by
  induction xs generalizing ys with
  | nil => simp [isPrefixOf?, Eq.comm]
  | cons => cases ys <;> simp [isPrefixOf?, *]

theorem append_eq_of_isPrefixOf?_eq_some [BEq α] [LawfulBEq α] {xs ys zs : List α}
    (h : xs.isPrefixOf? ys = some zs) : xs ++ zs = ys := by simp_all

@[simp] theorem isSome_isSuffixOf?_eq_isSuffixOf [BEq α] (xs ys : List α) :
    (xs.isSuffixOf? ys).isSome = xs.isSuffixOf ys := by
  simp [List.isSuffixOf?, isSuffixOf]

@[simp] theorem isSuffixOf?_eq_some_iff_append_eq [BEq α] [LawfulBEq α] {xs ys zs : List α} :
    xs.isSuffixOf? ys = some zs ↔ zs ++ xs = ys := by
  simp only [isSuffixOf?, map_eq_some_iff, isPrefixOf?_eq_some_iff_append_eq]
  constructor
  · intro
    | ⟨_, h, heq⟩ =>
      rw [List.reverse_eq_iff] at heq
      rw [heq] at h
      rw [← reverse_inj, reverse_append, h]
  · intro h
    exists zs.reverse
    simp [← h]

theorem append_eq_of_isSuffixOf?_eq_some [BEq α] [LawfulBEq α] {xs ys zs : List α}
    (h : xs.isSuffixOf? ys = some zs) : zs ++ xs = ys := by simp_all



=== LEAN SOURCE: Matcher.lean ===
/-
Copyright (c) 2024 François G. Dorais. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: François G. Dorais
-/
import Batteries.Data.Array.Match

namespace List

/-- Knuth-Morris-Pratt matcher type

This type is used to keep data for running the Knuth-Morris-Pratt (KMP) list matching algorithm.
KMP is a linear time algorithm to locate all contiguous sublists of a list that match a given
pattern. Generating the algorithm data is also linear in the length of the pattern but the data can
be re-used to match the same pattern over multiple lists.

The KMP data for a pattern can be generated using `Matcher.ofList`. Then `Matcher.find?` and
`Matcher.findAll` can be used to run the algorithm on an input list.
```
def m := Matcher.ofList [0,1,1,0]

#eval Option.isSome <| m.find? [2,1,1,0,1,1,2] -- false
#eval Option.isSome <| m.find? [0,0,1,1,0,0] -- true

#eval Array.size <| m.findAll [0,1,1,0,1,1,0] -- 2
#eval Array.size <| m.findAll [0,1,1,0,1,1,0,1,1,0] -- 3
```
-/
structure Matcher (α : Type _) extends Array.Matcher α where
  /-- The pattern for the matcher -/
  pattern : List α

/-- Make KMP matcher from list pattern. -/
@[inline] def Matcher.ofList [BEq α] (pattern : List α) : Matcher α where
  toMatcher := Array.Matcher.ofStream pattern
  pattern := pattern

/-- List stream that keeps count of items read. -/
local instance (α) : Stream (List α × Nat) α where
  next?
  | ([], _) => none
  | (x::xs, n) => (x, xs, n+1)

/--
Find all start and end positions of all infix sublists of `l` matching `m.pattern`.
The sublists may be overlapping.
-/
partial def Matcher.findAll [BEq α] (m : Matcher α) (l : List α) : Array (Nat × Nat) :=
  loop (l, 0) m.toMatcher #[]
where
  /-- Accumulator loop for `List.Matcher.findAll` -/
  loop (l : List α × Nat) (am : Array.Matcher α) (occs : Array (Nat × Nat)) : Array (Nat × Nat) :=
    match am.next? l with
    | none => occs
    | some (l, am) => loop l am (occs.push (l.snd - m.table.size, l.snd))

/--
Find the start and end positions of the first infix sublist of `l` matching `m.pattern`,
or `none` if there is no such sublist.
-/
def Matcher.find? [BEq α] (m : Matcher α) (l : List α) : Option (Nat × Nat) :=
  match m.next? (l, 0) with
  | none => none
  | some (l, _) => some (l.snd - m.table.size, l.snd)

/--
Returns all the start and end positions of all infix sublists of of `l` that match `pattern`.
The sublists may be overlapping.
-/
@[inline] def findAllInfix [BEq α] (l pattern : List α) : Array (Nat × Nat) :=
  (Matcher.ofList pattern).findAll l

/--
Returns the start and end positions of the first infix sublist of `l` that matches `pattern`,
or `none` if there is no such sublist.
-/
@[inline] def findInfix? [BEq α] (l pattern : List α) : Option (Nat × Nat) :=
  (Matcher.ofList pattern).find? l

/--
Returns true iff `pattern` occurs as an infix sublist of `l`.
-/
@[inline] def containsInfix [BEq α] (l pattern : List α) : Bool :=
  findInfix? l pattern |>.isSome



=== LEAN SOURCE: Monadic.lean ===
/-
Copyright (c) 2024 Lean FRO, LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Batteries.Classes.SatisfiesM

/-!
# Results about monadic operations on `List`, in terms of `SatisfiesM`.

-/

namespace List

theorem satisfiesM_foldlM [Monad m] [LawfulMonad m] {f : β → α → m β} (h₀ : motive b)
    (h₁ : ∀ (b) (_ : motive b) (a : α) (_ : a ∈ l), SatisfiesM motive (f b a)) :
    SatisfiesM motive (List.foldlM f b l) := by
  induction l generalizing b with
  | nil => exact SatisfiesM.pure h₀
  | cons hd tl ih =>
    simp only [foldlM_cons]
    apply SatisfiesM.bind_pre
    let ⟨q, qh⟩ := h₁ b h₀ hd mem_cons_self
    exact ⟨(fun ⟨b, bh⟩ => ⟨b, ih bh (fun b bh a am => h₁ b bh a (mem_cons_of_mem hd am))⟩) <$> q,
      by simpa using qh⟩

theorem satisfiesM_foldrM [Monad m] [LawfulMonad m] {f : α → β → m β} (h₀ : motive b)
    (h₁ : ∀ (a : α) (_ : a ∈ l) (b) (_ : motive b), SatisfiesM motive (f a b)) :
    SatisfiesM motive (List.foldrM f b l) := by
  induction l with
  | nil => exact SatisfiesM.pure h₀
  | cons hd tl ih =>
    simp only [foldrM_cons]
    apply SatisfiesM.bind_pre
    let ⟨q, qh⟩ := ih (fun a am b hb => h₁ a (mem_cons_of_mem hd am) b hb)
    exact ⟨(fun ⟨b, bh⟩ => ⟨b, h₁ hd mem_cons_self b bh⟩) <$> q,
      by simpa using qh⟩

end List



=== LEAN SOURCE: OfFn.lean ===
/-
Copyright (c) 2024 Lean FRO. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Batteries.Data.List.Lemmas
import Batteries.Data.Fin.Lemmas

/-!
# Theorems about `List.ofFn`
-/

namespace List

end List



=== LEAN SOURCE: Pairwise.lean ===
/-
Copyright (c) 2018 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro, James Gallicchio
-/
import Batteries.Data.List.Basic

/-!
# Pairwise relations on a list

This file provides basic results about `List.Pairwise` and `List.pwFilter` (definitions are in
`Batteries.Data.List.Basic`).
`Pairwise r [a 0, ..., a (n - 1)]` means `∀ i j, i < j → r (a i) (a j)`. For example,
`Pairwise (≠) l` means that all elements of `l` are distinct, and `Pairwise (<) l` means that `l`
is strictly increasing.
`pwFilter r l` is the list obtained by iteratively adding each element of `l` that doesn't break
the pairwiseness of the list we have so far. It thus yields `l'` a maximal sublist of `l` such that
`Pairwise r l'`.

## Tags

sorted, nodup
-/


open Nat Function

namespace List

/-! ### Pairwise -/

theorem pairwise_iff_get : Pairwise R l ↔ ∀ (i j) (_hij : i < j), R (get l i) (get l j) := by
  rw [pairwise_iff_getElem]
  constructor <;> intro h
  · intros i j h'
    exact h _ _ _ _ h'
  · intros i j hi hj h'
    exact h ⟨i, hi⟩ ⟨j, hj⟩ h'

/-! ### Pairwise filtering -/

@[simp] theorem pwFilter_nil [DecidableRel R] : pwFilter R [] = [] := rfl

@[simp] theorem pwFilter_cons_of_pos [DecidableRel (α := α) R] {a : α} {l : List α}
    (h : ∀ b ∈ pwFilter R l, R a b) : pwFilter R (a :: l) = a :: pwFilter R l := if_pos h

@[simp] theorem pwFilter_cons_of_neg [DecidableRel (α := α) R] {a : α} {l : List α}
    (h : ¬∀ b ∈ pwFilter R l, R a b) : pwFilter R (a :: l) = pwFilter R l := if_neg h

theorem pwFilter_map [DecidableRel (α := α) R] (f : β → α) :
    ∀ l : List β, pwFilter R (map f l) = map f (pwFilter (fun x y => R (f x) (f y)) l)
  | [] => rfl
  | x :: xs => by
    if h : ∀ b ∈ pwFilter R (map f xs), R (f x) b then
      have h' : ∀ b : β, b ∈ pwFilter (fun x y : β => R (f x) (f y)) xs → R (f x) (f b) :=
        fun b hb => h _ (by rw [pwFilter_map f xs]; apply mem_map_of_mem hb)
      rw [map, pwFilter_cons_of_pos h, pwFilter_cons_of_pos h', pwFilter_map f xs, map]
    else
      rw [map, pwFilter_cons_of_neg h, pwFilter_cons_of_neg ?_, pwFilter_map f xs]
      refine fun hh => h fun a ha => ?_
      rw [pwFilter_map f xs, mem_map] at ha
      let ⟨b, hb₀, hb₁⟩ := ha; exact hb₁ ▸ hh _ hb₀

theorem pwFilter_sublist [DecidableRel (α := α) R] : ∀ l : List α, pwFilter R l <+ l
  | [] => nil_sublist _
  | x :: l =>
    if h : ∀ y ∈ pwFilter R l, R x y then
      pwFilter_cons_of_pos h ▸ (pwFilter_sublist l).cons₂ _
    else
      pwFilter_cons_of_neg h ▸ Sublist.cons _ (pwFilter_sublist l)

theorem pwFilter_subset [DecidableRel (α := α) R] (l : List α) : pwFilter R l ⊆ l :=
  (pwFilter_sublist _).subset

theorem pairwise_pwFilter [DecidableRel (α := α) R] : ∀ l : List α, Pairwise R (pwFilter R l)
  | [] => Pairwise.nil
  | x :: l =>
    if h : ∀ y ∈ pwFilter R l, R x y then
      pwFilter_cons_of_pos h ▸ pairwise_cons.2 ⟨h, pairwise_pwFilter l⟩
    else
      pwFilter_cons_of_neg h ▸ pairwise_pwFilter l

theorem pwFilter_eq_self [DecidableRel (α := α) R] {l : List α} :
    pwFilter R l = l ↔ Pairwise R l := by
  refine ⟨fun e => e ▸ pairwise_pwFilter l, fun p => ?_⟩
  induction l with
  | nil => rfl
  | cons x l IH =>
    let ⟨al, p⟩ := pairwise_cons.1 p
    rw [pwFilter_cons_of_pos fun b hb => ?_, IH p]
    rw [IH p] at hb
    exact al _ hb

@[simp] theorem pwFilter_idem [DecidableRel (α := α) R] :
    pwFilter R (pwFilter R l) = pwFilter R l := pwFilter_eq_self.2 (pairwise_pwFilter ..)

theorem forall_mem_pwFilter [DecidableRel (α := α) R]
    (neg_trans : ∀ {x y z}, R x z → R x y ∨ R y z) (a : α) (l : List α) :
    (∀ b ∈ pwFilter R l, R a b) ↔ ∀ b ∈ l, R a b := by
  refine ⟨?_, fun h b hb => h _ <| pwFilter_subset (R := R) _ hb⟩
  induction l with
  | nil => exact fun _ _ h => (not_mem_nil h).elim
  | cons x l IH =>
    simp only [forall_mem_cons]
    if h : ∀ y ∈ pwFilter R l, R x y then
      simpa [pwFilter_cons_of_pos h] using fun r H => ⟨r, IH H⟩
    else
      refine pwFilter_cons_of_neg h ▸ fun H => ⟨?_, IH H⟩
      match e : find? (fun y => ¬R x y) (pwFilter R l) with
      | none => exact h.elim fun y hy => by simpa using find?_eq_none.1 e y hy
      | some k =>
        have := find?_some e
        apply (neg_trans (H k (mem_of_find?_eq_some e))).resolve_right
        rw [decide_eq_true_iff] at this; exact this



=== LEAN SOURCE: Perm.lean ===
/-
Copyright (c) 2015 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Leonardo de Moura, Jeremy Avigad, Mario Carneiro
-/
import Batteries.Tactic.Alias
import Batteries.Data.List.Lemmas

/-!
# List Permutations

This file introduces the `List.Perm` relation, which is true if two lists are permutations of one
another.

## Notation

The notation `~` is used for permutation equivalence.
-/

open Nat

namespace List

open Perm (swap)

section Subperm

@[simp] theorem nil_subperm {l : List α} : [] <+~ l := ⟨[], Perm.nil, by simp⟩

theorem Perm.subperm_left {l l₁ l₂ : List α} (p : l₁ ~ l₂) : l <+~ l₁ ↔ l <+~ l₂ :=
  suffices ∀ {l₁ l₂ : List α}, l₁ ~ l₂ → l <+~ l₁ → l <+~ l₂ from ⟨this p, this p.symm⟩
  fun p ⟨_u, pu, su⟩ =>
  let ⟨v, pv, sv⟩ := exists_perm_sublist su p
  ⟨v, pv.trans pu, sv⟩

theorem Perm.subperm_right {l₁ l₂ l : List α} (p : l₁ ~ l₂) : l₁ <+~ l ↔ l₂ <+~ l :=
  ⟨fun ⟨u, pu, su⟩ => ⟨u, pu.trans p, su⟩, fun ⟨u, pu, su⟩ => ⟨u, pu.trans p.symm, su⟩⟩

theorem Sublist.subperm {l₁ l₂ : List α} (s : l₁ <+ l₂) : l₁ <+~ l₂ := ⟨l₁, .rfl, s⟩

theorem Perm.subperm {l₁ l₂ : List α} (p : l₁ ~ l₂) : l₁ <+~ l₂ := ⟨l₂, p.symm, Sublist.refl _⟩

@[refl] theorem Subperm.refl (l : List α) : l <+~ l := Perm.rfl.subperm

theorem Subperm.trans {l₁ l₂ l₃ : List α} (s₁₂ : l₁ <+~ l₂) (s₂₃ : l₂ <+~ l₃) : l₁ <+~ l₃ :=
  let ⟨_l₂', p₂, s₂⟩ := s₂₃
  let ⟨l₁', p₁, s₁⟩ := p₂.subperm_left.2 s₁₂
  ⟨l₁', p₁, s₁.trans s₂⟩

theorem Subperm.cons_self : l <+~ a :: l := ⟨l, .refl _, sublist_cons_self ..⟩

theorem Subperm.cons_right {α : Type _} {l l' : List α} (x : α) (h : l <+~ l') : l <+~ x :: l' :=
  h.trans (sublist_cons_self x l').subperm

theorem Subperm.length_le {l₁ l₂ : List α} : l₁ <+~ l₂ → length l₁ ≤ length l₂
  | ⟨_l, p, s⟩ => p.length_eq ▸ s.length_le

theorem Subperm.perm_of_length_le {l₁ l₂ : List α} : l₁ <+~ l₂ → length l₂ ≤ length l₁ → l₁ ~ l₂
  | ⟨_l, p, s⟩, h => (s.eq_of_length_le <| p.symm.length_eq ▸ h) ▸ p.symm

theorem Subperm.antisymm {l₁ l₂ : List α} (h₁ : l₁ <+~ l₂) (h₂ : l₂ <+~ l₁) : l₁ ~ l₂ :=
  h₁.perm_of_length_le h₂.length_le

theorem Subperm.subset {l₁ l₂ : List α} : l₁ <+~ l₂ → l₁ ⊆ l₂
  | ⟨_l, p, s⟩ => Subset.trans p.symm.subset s.subset

theorem Subperm.filter (p : α → Bool) ⦃l l' : List α⦄ (h : l <+~ l') :
    filter p l <+~ filter p l' := by
  let ⟨xs, hp, h⟩ := h
  exact ⟨_, hp.filter p, h.filter p⟩

@[simp] theorem subperm_nil : l <+~ [] ↔ l = [] :=
  ⟨fun h => length_eq_zero_iff.1 $ Nat.le_zero.1 h.length_le, by rintro rfl; rfl⟩

@[simp] theorem singleton_subperm_iff {α} {l : List α} {a : α} : [a] <+~ l ↔ a ∈ l := by
  refine ⟨fun ⟨s, hla, h⟩ => ?_, fun h => ⟨[a], .rfl, singleton_sublist.mpr h⟩⟩
  rwa [perm_singleton.mp hla, singleton_sublist] at h

end Subperm

theorem Subperm.countP_le (p : α → Bool) {l₁ l₂ : List α} : l₁ <+~ l₂ → countP p l₁ ≤ countP p l₂
  | ⟨_l, p', s⟩ => p'.countP_eq p ▸ s.countP_le

theorem Subperm.count_le [DecidableEq α] {l₁ l₂ : List α} (s : l₁ <+~ l₂) (a) :
    count a l₁ ≤ count a l₂ := s.countP_le _

theorem subperm_cons (a : α) {l₁ l₂ : List α} : a :: l₁ <+~ a :: l₂ ↔ l₁ <+~ l₂ := by
  refine ⟨fun ⟨l, p, s⟩ => ?_, fun ⟨l, p, s⟩ => ⟨a :: l, p.cons a, s.cons₂ _⟩⟩
  match s with
  | .cons _ s' => exact (p.subperm_left.2 <| (sublist_cons_self _ _).subperm).trans s'.subperm
  | .cons₂ _ s' => exact ⟨_, p.cons_inv, s'⟩

/-- Weaker version of `Subperm.cons_left` -/
theorem cons_subperm_of_not_mem_of_mem {a : α} {l₁ l₂ : List α} (h₁ : a ∉ l₁) (h₂ : a ∈ l₂)
    (s : l₁ <+~ l₂) : a :: l₁ <+~ l₂ := by
  obtain ⟨l, p, s⟩ := s
  induction s generalizing l₁ with
  | slnil => cases h₂
  | @cons r₁ _ b s' ih =>
    simp at h₂
    match h₂ with
    | .inl e => subst_vars; exact ⟨_ :: r₁, p.cons _, s'.cons₂ _⟩
    | .inr m => let ⟨t, p', s'⟩ := ih h₁ m p; exact ⟨t, p', s'.cons _⟩
  | @cons₂ _ r₂ b _ ih =>
    have bm : b ∈ l₁ := p.subset mem_cons_self
    have am : a ∈ r₂ := by
      simp only [mem_cons] at h₂
      exact h₂.resolve_left fun e => h₁ <| e.symm ▸ bm
    obtain ⟨t₁, t₂, rfl⟩ := append_of_mem bm
    have st : t₁ ++ t₂ <+ t₁ ++ b :: t₂ := by simp
    obtain ⟨t, p', s'⟩ := ih (mt (st.subset ·) h₁) am (.cons_inv <| p.trans perm_middle)
    exact ⟨b :: t, (p'.cons b).trans <| (swap ..).trans (perm_middle.symm.cons a), s'.cons₂ _⟩

theorem subperm_append_left {l₁ l₂ : List α} : ∀ l, l ++ l₁ <+~ l ++ l₂ ↔ l₁ <+~ l₂
  | [] => .rfl
  | a :: l => (subperm_cons a).trans (subperm_append_left l)

theorem subperm_append_right {l₁ l₂ : List α} (l) : l₁ ++ l <+~ l₂ ++ l ↔ l₁ <+~ l₂ :=
  (perm_append_comm.subperm_left.trans perm_append_comm.subperm_right).trans (subperm_append_left l)

theorem Subperm.exists_of_length_lt {l₁ l₂ : List α} (s : l₁ <+~ l₂) (h : length l₁ < length l₂) :
    ∃ a, a :: l₁ <+~ l₂ := by
  obtain ⟨l, p, s⟩ := s
  suffices length l < length l₂ → ∃ a : α, a :: l <+~ l₂ from
    (this <| p.symm.length_eq ▸ h).imp fun a => (p.cons a).subperm_right.1
  clear h p l₁
  induction s with intro h
  | slnil => cases h
  | cons a s IH =>
    match Nat.lt_or_eq_of_le (Nat.le_of_lt_succ h) with
    | .inl h => exact (IH h).imp fun a s => s.trans (sublist_cons_self _ _).subperm
    | .inr h => exact ⟨a, s.eq_of_length h ▸ .refl _⟩
  | cons₂ b _ IH =>
    exact (IH <| Nat.lt_of_succ_lt_succ h).imp fun a s =>
      (swap ..).subperm_right.1 <| (subperm_cons _).2 s

theorem subperm_of_subset (d : Nodup l₁) (H : l₁ ⊆ l₂) : l₁ <+~ l₂ := by
  induction d with
  | nil => exact ⟨nil, .nil, nil_sublist _⟩
  | cons h _ IH =>
    have ⟨H₁, H₂⟩ := forall_mem_cons.1 H
    exact cons_subperm_of_not_mem_of_mem (h _ · rfl) H₁ (IH H₂)

theorem perm_ext_iff_of_nodup {l₁ l₂ : List α} (d₁ : Nodup l₁) (d₂ : Nodup l₂) :
    l₁ ~ l₂ ↔ ∀ a, a ∈ l₁ ↔ a ∈ l₂ := by
  refine ⟨fun p _ => p.mem_iff, fun H => ?_⟩
  exact (subperm_of_subset d₁ fun a => (H a).1).antisymm <| subperm_of_subset d₂ fun a => (H a).2

theorem Nodup.perm_iff_eq_of_sublist {l₁ l₂ l : List α} (d : Nodup l)
    (s₁ : l₁ <+ l) (s₂ : l₂ <+ l) : l₁ ~ l₂ ↔ l₁ = l₂ := by
  refine ⟨fun h => ?_, fun h => by rw [h]⟩
  induction s₂ generalizing l₁ with simp [Nodup, List.forall_mem_ne] at d
  | slnil => exact h.eq_nil
  | cons a s₂ IH =>
    match s₁ with
    | .cons _ s₁ => exact IH d.2 s₁ h
    | .cons₂ _ s₁ =>
      have := Subperm.subset ⟨_, h.symm, s₂⟩ (.head _)
      exact (d.1 this).elim
  | cons₂ a _ IH =>
    match s₁ with
    | .cons _ s₁ =>
      have := Subperm.subset ⟨_, h, s₁⟩ (.head _)
      exact (d.1 this).elim
    | .cons₂ _ s₁ => rw [IH d.2 s₁ h.cons_inv]

section DecidableEq

variable [DecidableEq α]

theorem subperm_cons_erase (a : α) (l : List α) : l <+~ a :: l.erase a :=
  if h : a ∈ l then
    (perm_cons_erase h).subperm
  else
    (erase_of_not_mem h).symm ▸ (sublist_cons_self _ _).subperm

theorem erase_subperm (a : α) (l : List α) : l.erase a <+~ l := erase_sublist.subperm

theorem Subperm.erase {l₁ l₂ : List α} (a : α) (h : l₁ <+~ l₂) : l₁.erase a <+~ l₂.erase a :=
  let ⟨l, hp, hs⟩ := h
  ⟨l.erase a, hp.erase _, hs.erase _⟩

theorem Perm.diff_right {l₁ l₂ : List α} (t : List α) (h : l₁ ~ l₂) : l₁.diff t ~ l₂.diff t := by
  induction t generalizing l₁ l₂ h with simp only [List.diff]
  | nil => exact h
  | cons x t ih =>
    simp only [elem_eq_mem, decide_eq_true_eq, Perm.mem_iff h]
    split
    · exact ih (h.erase _)
    · exact ih h

theorem Perm.diff_left (l : List α) {t₁ t₂ : List α} (h : t₁ ~ t₂) : l.diff t₁ = l.diff t₂ := by
  induction h generalizing l with try simp [List.diff]
  | cons x _ ih => apply ite_congr rfl <;> (intro; apply ih)
  | swap x y =>
    if h : x = y then
      simp [h]
    else
      simp [mem_erase_of_ne h, mem_erase_of_ne (Ne.symm h), erase_comm x y]
      split <;> simp
  | trans => simp only [*]

theorem Perm.diff {l₁ l₂ t₁ t₂ : List α} (hl : l₁ ~ l₂) (ht : t₁ ~ t₂) : l₁.diff t₁ ~ l₂.diff t₂ :=
  ht.diff_left l₂ ▸ hl.diff_right _

theorem Subperm.diff_right {l₁ l₂ : List α} (h : l₁ <+~ l₂) (t : List α) :
    l₁.diff t <+~ l₂.diff t := by
  induction t generalizing l₁ l₂ h with simp [List.diff, *]
  | cons x t ih =>
    split <;> rename_i hx1
    · simp [h.subset hx1]
      exact ih (h.erase _)
    · split
      · rw [← erase_of_not_mem hx1]
        exact ih (h.erase _)
      · exact ih h

theorem erase_cons_subperm_cons_erase (a b : α) (l : List α) :
    (a :: l).erase b <+~ a :: l.erase b := by
  if h : a = b then
    rw [h, erase_cons_head]; apply subperm_cons_erase
  else
    have : ¬(a == b) = true := by simp only [beq_false_of_ne h, not_false_eq_true, reduceCtorEq]
    rw [erase_cons_tail this]

theorem subperm_cons_diff {a : α} {l₁ l₂ : List α} : (a :: l₁).diff l₂ <+~ a :: l₁.diff l₂ := by
  induction l₂ with
  | nil => exact ⟨a :: l₁, by simp [List.diff]⟩
  | cons b l₂ ih =>
    rw [diff_cons, diff_cons, ← diff_erase, ← diff_erase]
    exact Subperm.trans (.erase _ ih) (erase_cons_subperm_cons_erase ..)

theorem subset_cons_diff {a : α} {l₁ l₂ : List α} : (a :: l₁).diff l₂ ⊆ a :: l₁.diff l₂ :=
  subperm_cons_diff.subset

/-- The list version of `add_tsub_cancel_of_le` for multisets. -/
theorem subperm_append_diff_self_of_count_le {l₁ l₂ : List α}
    (h : ∀ x ∈ l₁, count x l₁ ≤ count x l₂) : l₁ ++ l₂.diff l₁ ~ l₂ := by
  induction l₁ generalizing l₂ with
  | nil => simp
  | cons hd tl IH =>
    have : hd ∈ l₂ := by
      rw [← count_pos_iff]
      exact Nat.lt_of_lt_of_le (count_pos_iff.mpr (.head _)) (h hd (.head _))
    have := perm_cons_erase this
    refine Perm.trans ?_ this.symm
    rw [cons_append, diff_cons, perm_cons]
    refine IH fun x hx => ?_
    specialize h x (.tail _ hx)
    rw [perm_iff_count.mp this] at h
    if hx : hd = x then subst hd; simpa [Nat.succ_le_succ_iff] using h
    else simpa [hx] using h

/-- The list version of `Multiset.le_iff_count`. -/
theorem subperm_ext_iff {l₁ l₂ : List α} : l₁ <+~ l₂ ↔ ∀ x ∈ l₁, count x l₁ ≤ count x l₂ := by
  refine ⟨fun h x _ => h.count_le x, fun h => ?_⟩
  have : l₁ <+~ l₂.diff l₁ ++ l₁ := (subperm_append_right l₁).mpr nil_subperm
  refine this.trans (Perm.subperm ?_)
  exact perm_append_comm.trans (subperm_append_diff_self_of_count_le h)

theorem isSubperm_iff {l₁ l₂ : List α} : l₁.isSubperm l₂ ↔ l₁ <+~ l₂ := by
  simp [isSubperm, subperm_ext_iff]

instance decidableSubperm : DecidableRel ((· <+~ ·) : List α → List α → Prop) := fun _ _ =>
  decidable_of_iff _ isSubperm_iff

theorem Subperm.cons_left {l₁ l₂ : List α} (h : l₁ <+~ l₂) (x : α) (hx : count x l₁ < count x l₂) :
    x :: l₁ <+~ l₂ := by
  rw [subperm_ext_iff] at h ⊢
  intro y hy
  if hy' : y = x then
    subst x; simpa using Nat.succ_le_of_lt hx
  else
    rw [count_cons_of_ne (Ne.symm hy')]
    refine h y ?_
    simpa [hy'] using hy

theorem Perm.union_right {l₁ l₂ : List α} (t₁ : List α) (h : l₁ ~ l₂) : l₁ ∪ t₁ ~ l₂ ∪ t₁ := by
  induction h with
  | nil => rfl
  | cons a _ ih => exact ih.insert a
  | swap => apply perm_insert_swap
  | trans _ _ ih_1 ih_2 => exact ih_1.trans ih_2

theorem Perm.union_left (l : List α) {t₁ t₂ : List α} (h : t₁ ~ t₂) : l ∪ t₁ ~ l ∪ t₂ := by
  induction l with
  | nil => simp only [nil_union, h]
  | cons _ _ ih => simp only [cons_union, Perm.insert _ ih]

theorem Perm.union {l₁ l₂ t₁ t₂ : List α} (p₁ : l₁ ~ l₂) (p₂ : t₁ ~ t₂) : l₁ ∪ t₁ ~ l₂ ∪ t₂ :=
  (p₁.union_right t₁).trans (p₂.union_left l₂)

theorem Perm.inter_right {l₁ l₂ : List α} (t₁ : List α) : l₁ ~ l₂ → l₁ ∩ t₁ ~ l₂ ∩ t₁ := .filter _

theorem Perm.inter_left (l : List α) {t₁ t₂ : List α} (p : t₁ ~ t₂) : l ∩ t₁ = l ∩ t₂ :=
  filter_congr fun a _ => by simpa using p.mem_iff (a := a)

theorem Perm.inter {l₁ l₂ t₁ t₂ : List α} (p₁ : l₁ ~ l₂) (p₂ : t₁ ~ t₂) : l₁ ∩ t₁ ~ l₂ ∩ t₂ :=
  p₂.inter_left l₂ ▸ p₁.inter_right t₁

end DecidableEq

theorem Perm.flatten_congr :
    ∀ {l₁ l₂ : List (List α)} (_ : List.Forall₂ (· ~ ·) l₁ l₂), l₁.flatten ~ l₂.flatten
  | _, _, .nil => .rfl
  | _ :: _, _ :: _, .cons h₁ h₂ => h₁.append (Perm.flatten_congr h₂)

theorem perm_insertP (p : α → Bool) (a l) : insertP p a l ~ a :: l := by
  induction l with simp [insertP, insertP.loop, cond]
  | cons _ _ ih =>
    split
    · exact Perm.refl ..
    · rw [insertP_loop, reverseAux, reverseAux]
      exact Perm.trans (Perm.cons _ ih) (Perm.swap ..)

theorem Perm.insertP (p : α → Bool) (a) (h : l₁ ~ l₂) : insertP p a l₁ ~ insertP p a l₂ :=
  Perm.trans (perm_insertP ..) <| Perm.trans (Perm.cons _ h) <| Perm.symm (perm_insertP ..)



=== LEAN SOURCE: Lemmas.lean ===
/-
Copyright (c) 2024 Kim Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.

Authors: Kim Morrison
-/

/-!
While this file is currently empty, it is intended as a home for any lemmas which are required for
definitions in `Batteries.Data.List.Basic`, but which are not provided by Lean.
-/



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2018 Kim Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro, Keeley Hoek, Simon Hudon, Kim Morrison
-/

/-! # Monadic lazy lists.

Lazy lists with "laziness" controlled by an arbitrary monad.
-/


/-!
In an initial section we describe the specification of `MLList`,
and provide a private unsafe implementation,
and then a public `opaque` wrapper of this implementation, satisfying the specification.
-/
namespace MLList

private structure Spec (m : Type u → Type u) where
  listM : Type u → Type u
  nil : listM α
  cons : α → listM α → listM α
  thunk : (Unit → listM α) → listM α
  squash : (Unit → m (listM α)) → listM α
  uncons : [Monad m] → listM α → m (Option (α × listM α))
  uncons? : listM α → Option (Option (α × listM α))

instance : Nonempty (Spec m) := .intro
  { listM := fun _ => PUnit
    nil := ⟨⟩
    cons := fun _ _ => ⟨⟩
    thunk := fun _ => ⟨⟩
    squash := fun _ => ⟨⟩
    uncons := fun _ => pure none
    uncons? := fun _ => none }

private unsafe inductive MLListImpl (m : Type u → Type u) (α : Type u) : Type u
  | nil : MLListImpl m α
  | cons : α → MLListImpl m α → MLListImpl m α
  | thunk : Thunk (MLListImpl m α) → MLListImpl m α
  | squash : (Unit → m (MLListImpl m α)) → MLListImpl m α

private unsafe def unconsImpl {m : Type u → Type u} [Monad m] :
    MLListImpl m α → m (Option (α × MLListImpl m α))
  | .nil => pure none
  | .thunk t => unconsImpl t.get
  | .squash t => t () >>= unconsImpl
  | .cons x xs => return (x, xs)

private unsafe def uncons?Impl : MLListImpl m α → Option (Option (α × MLListImpl m α))
  | .nil => pure none
  | .cons x xs => pure (x, xs)
  | _ => none

@[inline] private unsafe def specImpl (m) : Spec m where
  listM := MLListImpl m
  nil := .nil
  cons := .cons
  thunk f := .thunk (.mk f)
  squash := .squash
  uncons := unconsImpl
  uncons? := uncons?Impl

@[implemented_by specImpl]
private opaque spec (m) : MLList.Spec m

end MLList

/-- A monadic lazy list, controlled by an arbitrary monad. -/
def MLList (m : Type u → Type u) (α : Type u) : Type u := (MLList.spec m).listM α

namespace MLList

/-- The empty `MLList`. -/
@[inline] def nil : MLList m α := (MLList.spec m).nil

/--
Constructs a `MLList` from head and tail.
-/
@[inline] def cons : α → MLList m α → MLList m α := (MLList.spec m).cons

/-- Embed a non-monadic thunk as a lazy list. -/
@[inline] def thunk : (Unit → MLList m α) → MLList m α := (MLList.spec m).thunk

/-- Lift a monadic lazy list inside the monad to a monadic lazy list. -/
def squash : (Unit → m (MLList m α)) → MLList m α := (MLList.spec m).squash

/-- Deconstruct a `MLList`, returning inside the monad an optional pair `α × MLList m α`
representing the head and tail of the list. -/
@[inline] def uncons [Monad m] : MLList.{u} m α → m (Option (α × MLList m α)) :=
  (MLList.spec m).uncons

/-- Try to deconstruct a `MLList`, returning an optional pair `α × MLList m α`
representing the head and tail of the list if it is already evaluated, and `none` otherwise. -/
@[inline] def uncons? : MLList.{u} m α → Option (Option (α × MLList m α)) :=
  (MLList.spec m).uncons?

instance : EmptyCollection (MLList m α) := ⟨nil⟩
instance : Inhabited (MLList m α) := ⟨nil⟩

private local instance [Monad n] : Inhabited (δ → (α → δ → n (ForInStep δ)) → n δ) where
  default d _ := pure d in
/-- The implementation of `ForIn`, which enables `for a in L do ...` notation. -/
@[specialize] protected partial def forIn [Monad m] [Monad n] [MonadLiftT m n]
    (as : MLList m α) (init : δ) (f : α → δ → n (ForInStep δ)) : n δ := do
  match ← as.uncons with
  | none => pure init
  | some (a, t) => match (← f a init) with
      | ForInStep.done d  => pure d
      | ForInStep.yield d => t.forIn d f

instance [Monad m] [MonadLiftT m n] : ForIn n (MLList m α) α where
  forIn := MLList.forIn

/-- Construct a singleton monadic lazy list from a single monadic value. -/
def singletonM [Monad m] (x : m α) : MLList m α :=
  .squash fun _ => do return .cons (← x) .nil

/-- Construct a singleton monadic lazy list from a single value. -/
def singleton [Monad m] (x : α) : MLList m α :=
  .singletonM (pure x)

/-- Construct a `MLList` recursively. Failures from `f` will result in `uncons` failing.  -/
partial def fix [Monad m] (f : α → m α) (x : α) : MLList m α :=
  cons x <| squash fun _ => fix f <$> f x

/--
Constructs an `MLList` recursively, with state in `α`, recording terms from `β`.
If `f` returns `none` the list will terminate.

Variant of `MLList.fix?` that allows returning values of a different type.
-/
partial def fix?' [Monad m] (f : α → m (Option (β × α))) (init : α) : MLList m β :=
  squash fun _ => do
    match ← f init with
    | none => pure .nil
    | some (b, a) => pure (.cons b (fix?' f a))

/--
Constructs an `MLList` recursively. If `f` returns `none` the list will terminate.

Returns the initial value as the first element.
-/
partial def fix? [Monad m] (f : α → m (Option α)) (x : α) : MLList m α :=
  cons x <| squash fun _ => do
    match ← f x with
    | none => return nil
    | some x' => return fix? f x'

/-- Construct a `MLList` by iteration. (`m` must be a stateful monad for this to be useful.) -/
partial def iterate [Monad m] (f : m α) : MLList m α :=
  squash fun _ => return cons (← f) (iterate f)

/-- Repeatedly apply a function `f : α → m (α × List β)` to an initial `a : α`,
accumulating the elements of the resulting `List β` as a single monadic lazy list.

(This variant allows starting with a specified `List β` of elements, as well. )-/
partial def fixlWith [Monad m] {α β : Type u} (f : α → m (α × List β))
    (s : α) (l : List β) : MLList m β :=
  thunk fun _ =>
    match l with
    | b :: rest => cons b (fixlWith f s rest)
    | [] => squash fun _ => do
      let (s', l) ← f s
      match l with
      | b :: rest => pure <| cons b (fixlWith f s' rest)
      | [] => pure <| fixlWith f s' []

/-- Repeatedly apply a function `f : α → m (α × List β)` to an initial `a : α`,
accumulating the elements of the resulting `List β` as a single monadic lazy list. -/
def fixl [Monad m] {α β : Type u} (f : α → m (α × List β)) (s : α) : MLList m β :=
  fixlWith f s []

/-- Compute, inside the monad, whether a `MLList` is empty. -/
def isEmpty [Monad m] (xs : MLList m α) : m (ULift Bool) :=
  (ULift.up ∘ Option.isNone) <$> uncons xs

/-- Convert a `List` to a `MLList`. -/
def ofList : List α → MLList m α
  | [] => nil
  | h :: t => cons h (thunk fun _ => ofList t)

/-- Convert a `List` of values inside the monad into a `MLList`. -/
def ofListM [Monad m] : List (m α) → MLList m α
  | [] => nil
  | h :: t => squash fun _ => return cons (← h) (ofListM t)

/-- Extract a list inside the monad from a `MLList`. -/
partial def force [Monad m] (L : MLList m α) : m (List α) := do
  match ← L.uncons with
  | none => pure []
  | some (x, xs) => return x :: (← xs.force)

/-- Extract an array inside the monad from a `MLList`. -/
def asArray [Monad m] (L : MLList m α) : m (Array α) := do
  let mut r := #[]
  for a in L do
    r := r.push a
  return r

/-- Performs a monadic case distinction on a `MLList` when the motive is a `MLList` as well. -/
@[specialize]
def casesM [Monad m] (xs : MLList m α)
    (hnil : Unit → m (MLList m β)) (hcons : α → MLList m α → m (MLList m β)) : MLList m β :=
  squash fun _ => do
    match ← xs.uncons with
    | none => hnil ()
    | some (x, xs) => hcons x xs

/--
Performs a case distinction on a `MLList` when the motive is a `MLList` as well.
(We need to be in a monadic context to distinguish a nil from a cons.)
-/
@[specialize]
def cases [Monad m] (xs : MLList m α)
    (hnil : Unit → MLList m β) (hcons : α → MLList m α → MLList m β) : MLList m β :=
  match xs.uncons? with
  | none => xs.casesM (fun _ => return hnil ()) (fun x xs => return hcons x xs)
  | some none => thunk hnil
  | some (some (x, xs)) => thunk fun _ => hcons x xs

/-- Gives the monadic lazy list consisting all of folds of a function on a given initial element.
Thus `[a₀, a₁, ...].foldsM f b` will give `[b, ← f b a₀, ← f (← f b a₀) a₁, ...]`. -/
partial def foldsM [Monad m] (f : β → α → m β) (init : β) (L : MLList m α) : MLList m β :=
  cons init <| squash fun _ => do
    match ← L.uncons with
    | none => return nil
    | some (x, xs) => return foldsM f (← f init x) xs

/-- Gives the monadic lazy list consisting all of folds of a function on a given initial element.
Thus `[a₀, a₁, ...].foldsM f b` will give `[b, f b a₀, f (f b a₀) a₁, ...]`. -/
def folds [Monad m] (f : β → α → β) (init : β) (L : MLList m α) : MLList m β :=
  L.foldsM (fun b a => pure (f b a)) init

/-- Take the first `n` elements, as a list inside the monad. -/
partial def takeAsList [Monad m] (xs : MLList m α) (n : Nat) : m (List α) :=
  go n [] xs
where
  /-- Implementation of `MLList.takeAsList`. -/
  go (r : Nat) (acc : List α) (xs : MLList m α) : m (List α) :=
    match r with
    | 0 => pure acc.reverse
    | r+1 => do match ← xs.uncons with
      | none => pure acc.reverse
      | some (x, xs) => go r (x :: acc) xs

/-- Take the first `n` elements, as an array inside the monad. -/
partial def takeAsArray [Monad m] (xs : MLList m α) (n : Nat) : m (Array α) :=
  go n #[] xs
where
  /-- Implementation of `MLList.takeAsArray`. -/
  go (r : Nat) (acc : Array α) (xs : MLList m α) : m (Array α) :=
    match r with
    | 0 => pure acc
    | r+1 => do match ← xs.uncons with
      | none => pure acc
      | some (x, xs) => go r (acc.push x) xs

/-- Take the first `n` elements. -/
partial def take [Monad m] (xs : MLList m α) : Nat → MLList m α
  | 0 => nil
  | n+1 => xs.cases (fun _ => nil) fun h l => cons h (l.take n)

/-- Drop the first `n` elements. -/
def drop [Monad m] (xs : MLList m α) : Nat → MLList m α
  | 0 => xs
  | n+1 => xs.cases (fun _ => nil) fun _ l => l.drop n

/-- Apply a function which returns values in the monad to every element of a `MLList`. -/
partial def mapM [Monad m] (f : α → m β) (xs : MLList m α) : MLList m β :=
  xs.cases (fun _ => nil) fun x xs => squash fun _ => return cons (← f x) (xs.mapM f)

/-- Apply a function to every element of a `MLList`. -/
def map [Monad m] (f : α → β) (L : MLList m α) : MLList m β :=
  L.mapM fun a => pure (f a)

/-- Filter a `MLList` using a monadic function. -/
partial def filterM [Monad m] (p : α → m (ULift Bool)) (L : MLList m α) : MLList m α :=
  L.casesM (fun _ => pure nil) fun x xs =>
    return if (← p x).down then cons x (filterM p xs) else filterM p xs

/-- Filter a `MLList`. -/
def filter [Monad m] (p : α → Bool) (L : MLList m α) : MLList m α :=
  L.filterM fun a => pure <| .up (p a)

/-- Filter and transform a `MLList` using a function that returns values inside the monad. -/
-- Note that the type signature has changed since Lean 3, when we allowed `f` to fail.
-- Use `try?` from `Mathlib.Control.Basic` to lift a possibly failing function to `Option`.
partial def filterMapM [Monad m] (f : α → m (Option β)) (xs : MLList m α) : MLList m β :=
  xs.casesM (fun _ => pure nil) fun x xs => do
    match ← f x with
    | none => return xs.filterMapM f
    | some a => return cons a (xs.filterMapM f)

/-- Filter and transform a `MLList` using an `Option` valued function. -/
def filterMap [Monad m] (f : α → Option β) : MLList m α → MLList m β :=
  filterMapM fun a => do pure (f a)

/-- Take the initial segment of the lazy list, until the function `f` first returns `false`. -/
partial def takeWhileM [Monad m] (f : α → m (ULift Bool)) (L : MLList m α) : MLList m α :=
  L.casesM (fun _ => pure nil) fun x xs =>
    return if !(← f x).down then nil else cons x (xs.takeWhileM f)

/-- Take the initial segment of the lazy list, until the function `f` first returns `false`. -/
def takeWhile [Monad m] (f : α → Bool) : MLList m α → MLList m α :=
  takeWhileM fun a => pure (.up (f a))

/-- Concatenate two monadic lazy lists. -/
partial def append [Monad m] (xs : MLList m α) (ys : Unit → MLList m α) : MLList m α :=
  xs.cases ys fun x xs => cons x (append xs ys)

/-- Join a monadic lazy list of monadic lazy lists into a single monadic lazy list. -/
partial def join [Monad m] (xs : MLList m (MLList m α)) : MLList m α :=
  xs.cases (fun _ => nil) fun x xs => append x (fun _ => join xs)

/-- Enumerate the elements of a monadic lazy list, starting at a specified offset. -/
partial def enumFrom [Monad m] (n : Nat) (xs : MLList m α) : MLList m (Nat × α) :=
  xs.cases (fun _ => nil) fun x xs => cons (n, x) (xs.enumFrom (n+1))

/-- Enumerate the elements of a monadic lazy list. -/
def enum [Monad m] : MLList m α → MLList m (Nat × α) := enumFrom 0

/-- The infinite monadic lazy list of natural numbers.-/
def range [Monad m] : MLList m Nat := MLList.fix (fun n => pure (n + 1)) 0

/-- Iterate through the elements of `Fin n`. -/
partial def fin (n : Nat) : MLList m (Fin n) := go 0 where
  /-- Implementation of `MLList.fin`. -/
  go (i : Nat) : MLList m (Fin n) :=
    if h : i < n then cons ⟨i, h⟩ (thunk fun _ => go (i+1)) else nil

/-- Convert an array to a monadic lazy list. -/
partial def ofArray {α : Type} (L : Array α) : MLList m α := go 0 where
  /-- Implementation of `MLList.ofArray`. -/
  go (i : Nat) : MLList m α :=
    if h : i < L.size then cons L[i] (thunk fun _ => go (i+1)) else nil

/-- Group the elements of a lazy list into chunks of a given size.
If the lazy list is finite, the last chunk may be smaller (possibly even length 0). -/
partial def chunk [Monad m] (L : MLList m α) (n : Nat) : MLList m (Array α) := go n #[] L where
  /-- Implementation of `MLList.chunk`. -/
  go (r : Nat) (acc : Array α) (M : MLList m α) : MLList m (Array α) :=
    match r with
    | 0 => cons acc (thunk fun _ => go n #[] M)
    | r+1 => squash fun _ => do
      match ← M.uncons with
      | none => return cons acc nil
      | some (a, M') => return go r (acc.push a) M'

/-- Add one element to the end of a monadic lazy list. -/
def concat [Monad m] (L : MLList m α) (a : α) : MLList m α := L.append (fun _ => cons a nil)

/-- Take the product of two monadic lazy lists. -/
partial def zip [Monad m] (L : MLList m α) (M : MLList m β) : MLList.{u} m (α × β) :=
  L.cases (fun _ => nil) fun a L =>
  M.cases (fun _ => nil) fun b M =>
  cons (a, b) (L.zip M)

/-- Apply a function returning a monadic lazy list to each element of a monadic lazy list,
joining the results. -/
partial def bind [Monad m] (xs : MLList m α) (f : α → MLList m β) : MLList m β :=
  xs.cases (fun _ => nil) fun x xs =>
    match xs.uncons? with
    | some none => f x
    | _ => append (f x) (fun _ => bind xs f)

/-- Convert any value in the monad to the singleton monadic lazy list. -/
def monadLift [Monad m] (x : m α) : MLList m α :=
  squash fun _ => return cons (← x) nil

/-- Lift the monad of a lazy list. -/
partial def liftM [Monad m] [Monad n] [MonadLiftT m n] (L : MLList m α) : MLList n α :=
  squash fun _ =>
    return match ← (uncons L : m _) with
    | none => nil
    | some (a, L') => cons a L'.liftM

/-- Given a lazy list in a state monad, run it on some initial state, recording the states. -/
partial def runState [Monad m] (L : MLList (StateT.{u} σ m) α) (s : σ) : MLList m (α × σ) :=
  squash fun _ =>
    return match ← (uncons L).run s with
    | (none, _) => nil
    | (some (a, L'), s') => cons (a, s') (L'.runState s')

/-- Given a lazy list in a state monad, run it on some initial state. -/
def runState' [Monad m] (L : MLList (StateT.{u} σ m) α) (s : σ) : MLList m α :=
  L.runState s |>.map (·.1)

/-- Run a lazy list in a `ReaderT` monad on some fixed state. -/
partial def runReader [Monad m] (L : MLList (ReaderT.{u, u} ρ m) α) (r : ρ) :
    MLList m α :=
  squash fun _ =>
    return match ← (uncons L).run r with
    | none => nil
    | some (a, L') => cons a (L'.runReader r)

/-- Run a lazy list in a `StateRefT'` monad on some initial state. -/
partial def runStateRef [Monad m] [MonadLiftT (ST ω) m] (L : MLList (StateRefT' ω σ m) α) (s : σ) :
    MLList m α :=
  squash fun _ =>
    return match ← (uncons L).run s with
    | (none, _) => nil
    | (some (a, L'), s') => cons a (L'.runStateRef s')

/-- Return the head of a monadic lazy list if it exists, as an `Option` in the monad. -/
def head? [Monad m] (L : MLList m α) : m (Option α) := return (← L.uncons).map (·.1)

/-- Take the initial segment of the lazy list,
up to and including the first place where `f` gives `true`. -/
partial def takeUpToFirstM [Monad m] (L : MLList m α) (f : α → m (ULift Bool)) : MLList m α :=
  L.casesM (fun _ => pure nil) fun x xs =>
    return cons x <| if (← (f x)).down then nil else xs.takeUpToFirstM f

/-- Take the initial segment of the lazy list,
up to and including the first place where `f` gives `true`. -/
def takeUpToFirst [Monad m] (L : MLList m α) (f : α → Bool) : MLList m α :=
  L.takeUpToFirstM fun a => pure (.up (f a))

/-- Gets the last element of a monadic lazy list, as an option in the monad.
This will run forever if the list is infinite. -/
partial def getLast? [Monad m] (L : MLList m α) : m (Option α) := do
  match ← uncons L with
  | none => return none
  | some (x, xs) => aux x xs
where
  /-- Implementation of `MLList.aux`. -/
  aux (x : α) (L : MLList m α) : m (Option α) := do
    match ← uncons L with
    | none => return some x
    | some (y, ys) => aux y ys

/-- Gets the last element of a monadic lazy list, or the default value if the list is empty.
This will run forever if the list is infinite. -/
partial def getLast! [Monad m] [Inhabited α] (L : MLList m α) : m α := Option.get! <$> L.getLast?

/-- Folds a binary function across a monadic lazy list, from an initial starting value.
This will run forever if the list is infinite. -/
partial def foldM [Monad m] (f : β → α → m β) (init : β) (L : MLList m α) : m β :=
  return (← L.foldsM f init |>.getLast?).getD init -- `foldsM` is always non-empty, anyway.

/-- Folds a binary function across a monadic lazy list, from an initial starting value.
This will run forever if the list is infinite. -/
partial def fold [Monad m] (f : β → α → β) (init : β) (L : MLList m α) : m β :=
  L.foldM (fun b a => pure (f b a)) init

/--
Return the head of a monadic lazy list, as a value in the monad.
Fails if the list is empty.
-/
def head [Monad m] [Alternative m] (L : MLList m α) : m α := do
  let some (r, _) ← L.uncons | failure
  return r

/--
Apply a function returning values inside the monad to a monadic lazy list,
returning only the first successful result.
-/
def firstM [Monad m] [Alternative m] (L : MLList m α) (f : α → m (Option β)) : m β :=
  (L.filterMapM f).head

/-- Return the first value on which a predicate returns true. -/
def first [Monad m] [Alternative m] (L : MLList m α) (p : α → Bool) : m α := (L.filter p).head

instance [Monad m] : Monad (MLList m) where
  pure a := cons a nil
  map := map
  bind := bind

instance [Monad m] : Alternative (MLList m) where
  failure := nil
  orElse := MLList.append

instance [Monad m] : MonadLift m (MLList m) where
  monadLift := monadLift



=== LEAN SOURCE: Heartbeats.lean ===
/-
Copyright (c) 2023 Kim Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Batteries.Data.MLList.Basic
import Lean.Util.Heartbeats

/-!
# Truncate a `MLList` when running out of available heartbeats.
-/

open Lean
open Lean.Core (CoreM)

/-- Take an initial segment of a monadic lazy list,
stopping when there is less than `percent` of the remaining allowed heartbeats.

If `getMaxHeartbeats` returns `0`, then this passes through the original list unmodified.

The `initial` heartbeat counter is recorded when the first element of the list is requested.
Then each time an element is requested from the wrapped list the heartbeat counter is checked, and
if `current * 100 / initial < percent` then that element is returned,
but no further elements.
-/
def MLList.whileAtLeastHeartbeatsPercent [Monad m] [MonadLiftT CoreM m]
    (L : MLList m α) (percent : Nat := 10) : MLList m α :=
  MLList.squash fun _ => do
    if (← getMaxHeartbeats) = 0 then do
      return L
    let initialHeartbeats ← getRemainingHeartbeats
    return L.takeUpToFirstM fun _ => do
      pure <| .up <| (← getRemainingHeartbeats) * 100 / initialHeartbeats < percent



=== LEAN SOURCE: IO.lean ===
/-
Copyright (c) 2023 Kim Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Batteries.Lean.System.IO
import Batteries.Data.MLList.Basic

/-!
# IO operations using monadic lazy lists.
-/

namespace MLList

/--
Give a list of tasks, return the monadic lazy list which
returns the values as they become available.
-/
def ofTaskList (tasks : List (Task α)) : MLList BaseIO α :=
  fix?' (init := tasks) fun t => do
    if h : 0 < t.length then
      some <$> IO.waitAny' t h
    else
      pure none



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2016 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Leonardo de Moura, Jeremy Avigad, Mario Carneiro
-/

namespace Nat

/--
  Recursor identical to `Nat.recOn` but uses notations `0` for `Nat.zero` and `·+1` for `Nat.succ`
-/
@[elab_as_elim]
protected def recAuxOn {motive : Nat → Sort _} (t : Nat) (zero : motive 0)
  (succ : ∀ n, motive n → motive (n+1)) : motive t := Nat.recAux zero succ t

/--
  Strong recursor for `Nat`
-/
@[elab_as_elim]
protected def strongRec {motive : Nat → Sort _} (ind : ∀ n, (∀ m, m < n → motive m) → motive n)
  (t : Nat) : motive t := ind t fun m _ => Nat.strongRec ind m

/--
  Strong recursor via a `Nat`-valued measure
-/
@[elab_as_elim]
def strongRecMeasure (f : α → Nat) {motive : α → Sort _}
    (ind : ∀ x, (∀ y, f y < f x → motive y) → motive x) (x : α) : motive x :=
  ind x fun y _ => strongRecMeasure f ind y
termination_by f x

/--
  Simple diagonal recursor for `Nat`
-/
@[elab_as_elim]
protected def recDiagAux {motive : Nat → Nat → Sort _}
  (zero_left : ∀ n, motive 0 n)
  (zero_right : ∀ m, motive m 0)
  (succ_succ : ∀ m n, motive m n → motive (m+1) (n+1)) :
    (m n : Nat) → motive m n
  | 0, _ => zero_left _
  | _, 0 => zero_right _
  | _+1, _+1 => succ_succ _ _ (Nat.recDiagAux zero_left zero_right succ_succ _ _)

/--
  Diagonal recursor for `Nat`
-/
@[elab_as_elim]
protected def recDiag {motive : Nat → Nat → Sort _}
  (zero_zero : motive 0 0)
  (zero_succ : ∀ n, motive 0 n → motive 0 (n+1))
  (succ_zero : ∀ m, motive m 0 → motive (m+1) 0)
  (succ_succ : ∀ m n, motive m n → motive (m+1) (n+1)) :
    (m n : Nat) → motive m n := Nat.recDiagAux left right succ_succ
where
  /-- Left leg for `Nat.recDiag` -/
  left : ∀ n, motive 0 n
  | 0 => zero_zero
  | _+1 => zero_succ _ (left _)
  /-- Right leg for `Nat.recDiag` -/
  right : ∀ m, motive m 0
  | 0 => zero_zero
  | _+1 => succ_zero _ (right _)

/--
  Diagonal recursor for `Nat`
-/
@[elab_as_elim]
protected def recDiagOn {motive : Nat → Nat → Sort _} (m n : Nat)
  (zero_zero : motive 0 0)
  (zero_succ : ∀ n, motive 0 n → motive 0 (n+1))
  (succ_zero : ∀ m, motive m 0 → motive (m+1) 0)
  (succ_succ : ∀ m n, motive m n → motive (m+1) (n+1)) :
    motive m n := Nat.recDiag zero_zero zero_succ succ_zero succ_succ m n

/--
  Diagonal recursor for `Nat`
-/
@[elab_as_elim]
protected def casesDiagOn {motive : Nat → Nat → Sort _} (m n : Nat)
  (zero_zero : motive 0 0)
  (zero_succ : ∀ n, motive 0 (n+1))
  (succ_zero : ∀ m, motive (m+1) 0)
  (succ_succ : ∀ m n, motive (m+1) (n+1)) :
    motive m n :=
  Nat.recDiag zero_zero (fun _ _ => zero_succ _) (fun _ _ => succ_zero _)
    (fun _ _ _ => succ_succ _ _) m n

/--
Integer square root function. Implemented via Newton's method.
-/
def sqrt (n : Nat) : Nat :=
  if n ≤ 1 then n else
  iter n (n / 2)
where
  /-- Auxiliary for `sqrt`. If `guess` is greater than the integer square root of `n`,
  returns the integer square root of `n`.

  By default this well-founded recursion would be irreducible.
  This prevents use `decide` to resolve `Nat.sqrt n` for small values of `n`,
  so we mark this as `@[semireducible]`. -/
  @[semireducible] iter (n guess : Nat) : Nat :=
    let next := (guess + n / guess) / 2
    if _h : next < guess then
      iter n next
    else
      guess
  termination_by guess

/--
Construct a natural number from a sequence of bits using little endian convention.
-/
@[inline] def ofBits (f : Fin n → Bool) : Nat :=
  Fin.foldr n (fun i v => 2 * v + (f i).toNat) 0



=== LEAN SOURCE: Bisect.lean ===
/-
Copyright (c) 2024 François G. Dorais. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: François G. Dorais
-/
import Batteries.Tactic.Basic

namespace Nat

/-- Average of two natural numbers rounded toward zero. -/
abbrev avg (a b : Nat) := (a + b) / 2

theorem avg_comm (a b : Nat) : avg a b = avg b a := by
  rw [avg, Nat.add_comm]

theorem avg_le_left (h : b ≤ a) : avg a b ≤ a := by
  apply Nat.div_le_of_le_mul; simp +arith [*]

theorem avg_le_right (h : a ≤ b) : avg a b ≤ b := by
  apply Nat.div_le_of_le_mul; simp +arith [*]

theorem avg_lt_left (h : b < a) : avg a b < a := by
  apply Nat.div_lt_of_lt_mul; omega

theorem avg_lt_right (h : a < b) : avg a b < b := by
  apply Nat.div_lt_of_lt_mul; omega

theorem le_avg_left (h : a ≤ b) : a ≤ avg a b := by
  apply (Nat.le_div_iff_mul_le Nat.zero_lt_two).mpr; simp +arith [*]

theorem le_avg_right (h : b ≤ a) : b ≤ avg a b := by
  apply (Nat.le_div_iff_mul_le Nat.zero_lt_two).mpr; simp +arith [*]

theorem le_add_one_of_avg_eq_left (h : avg a b = a) : b ≤ a + 1 := by
  cases Nat.lt_or_ge b (a+2) with
  | inl hlt => exact Nat.le_of_lt_add_one hlt
  | inr hge =>
    absurd Nat.lt_irrefl a
    conv => rhs; rw [← h]
    rw [← Nat.add_one_le_iff, Nat.le_div_iff_mul_le Nat.zero_lt_two]
    omega

theorem le_add_one_of_avg_eq_right (h : avg a b = b) : a ≤ b + 1 := by
  cases Nat.lt_or_ge a (b+2) with
  | inl hlt => exact Nat.le_of_lt_add_one hlt
  | inr hge =>
    absurd Nat.lt_irrefl b
    conv => rhs; rw [← h]
    rw [← Nat.add_one_le_iff, Nat.le_div_iff_mul_le Nat.zero_lt_two]
    omega

/--
Given natural numbers `a < b` such that `p a = true` and `p b = false`, `bisect` finds a natural
number `a ≤ c < b` such that `p c = true` and `p (c+1) = false`.
-/
def bisect {p : Nat → Bool} (h : start < stop) (hstart : p start = true) (hstop : p stop = false) :=
  let mid := avg start stop
  have hmidstop : mid < stop := by apply Nat.div_lt_of_lt_mul; omega
  if hstartmid : start < mid then
    match hmid : p mid with
    | false => bisect hstartmid hstart hmid
    | true => bisect hmidstop hmid hstop
  else
    mid
termination_by stop - start

theorem bisect_lt_stop {p : Nat → Bool} (h : start < stop) (hstart : p start = true)
    (hstop : p stop = false) : bisect h hstart hstop < stop := by
  unfold bisect
  simp only; split
  · split
    · next h' _ =>
      have : avg start stop - start < stop - start := by
        apply Nat.sub_lt_sub_right
        · exact Nat.le_of_lt h'
        · exact Nat.avg_lt_right h
      apply Nat.lt_trans
      · exact bisect_lt_stop ..
      · exact avg_lt_right h
    · exact bisect_lt_stop ..
  · exact avg_lt_right h

theorem start_le_bisect {p : Nat → Bool} (h : start < stop) (hstart : p start = true)
    (hstop : p stop = false) : start ≤ bisect h hstart hstop := by
  unfold bisect
  simp only; split
  · split
    · next h' _ =>
      have : avg start stop - start < stop - start := by
        apply Nat.sub_lt_sub_right
        · exact Nat.le_of_lt h'
        · exact avg_lt_right h
      exact start_le_bisect ..
    · next h' _ =>
      apply Nat.le_trans
      · exact Nat.le_of_lt h'
      · exact start_le_bisect ..
  · exact le_avg_left (Nat.le_of_lt h)

theorem bisect_true {p : Nat → Bool} (h : start < stop) (hstart : p start = true)
    (hstop : p stop = false) : p (bisect h hstart hstop) = true := by
  unfold bisect
  simp only; split
  · split
    · have : avg start stop - start < stop - start := by
        apply Nat.sub_lt_sub_right
        · exact Nat.le_avg_left (Nat.le_of_lt h)
        · exact Nat.avg_lt_right h
      exact bisect_true ..
    · exact bisect_true ..
  · next h' =>
    rw [← hstart]; congr
    apply Nat.le_antisymm
    · exact Nat.le_of_not_gt h'
    · exact Nat.le_avg_left (Nat.le_of_lt h)

theorem bisect_add_one_false {p : Nat → Bool} (h : start < stop) (hstart : p start = true)
    (hstop : p stop = false) : p (bisect h hstart hstop + 1) = false := by
  unfold bisect
  simp only; split
  · split
    · have : avg start stop - start < stop - start := by
        apply Nat.sub_lt_sub_right
        · exact Nat.le_avg_left (Nat.le_of_lt h)
        · exact Nat.avg_lt_right h
      exact bisect_add_one_false ..
    · exact bisect_add_one_false ..
  · next h' =>
    have heq : avg start stop = start := by
      apply Nat.le_antisymm
      · exact Nat.le_of_not_gt h'
      · exact Nat.le_avg_left (Nat.le_of_lt h)
    rw [← hstop, heq]; congr
    apply Nat.le_antisymm
    · exact Nat.succ_le_of_lt h
    · exact Nat.le_add_one_of_avg_eq_left heq



=== LEAN SOURCE: Digits.lean ===
/-
Copyright (c) 2025 Marcus Rossel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Marcus Rossel
-/

namespace Nat

@[simp]
theorem isDigit_digitChar : n.digitChar.isDigit = decide (n < 10) :=
  match n with
  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 => by simp [digitChar]
  | _ + 10 => by
    simp only [digitChar, ↓reduceIte, Nat.reduceEqDiff]
    (repeat' split) <;> simp

private theorem isDigit_of_mem_toDigitsCore
    (hc : c ∈ cs → c.isDigit) (hb₁ : 0 < b) (hb₂ : b ≤ 10) (h : c ∈ toDigitsCore b fuel n cs) :
    c.isDigit := by
  induction fuel generalizing n cs with rw [toDigitsCore] at h
  | zero => exact hc h
  | succ _ ih =>
    split at h
    case' isFalse => apply ih (fun h => ?_) h
    all_goals
      cases h with
      | head      => simp [Nat.lt_of_lt_of_le (mod_lt _ hb₁) hb₂]
      | tail _ hm => exact hc hm

theorem isDigit_of_mem_toDigits (hb₁ : 0 < b) (hb₂ : b ≤ 10) (hc : c ∈ toDigits b n) : c.isDigit :=
  isDigit_of_mem_toDigitsCore (fun _ => by contradiction) hb₁ hb₂ hc

private theorem toDigitsCore_of_lt_base (hb : n < b) (hf : n < fuel) :
    toDigitsCore b fuel n cs = n.digitChar :: cs := by
  unfold toDigitsCore
  split <;> simp_all [mod_eq_of_lt]

theorem toDigits_of_lt_base (h : n < b) : toDigits b n = [n.digitChar] :=
  toDigitsCore_of_lt_base h (lt_succ_self _)

theorem toDigits_zero : (b : Nat) → toDigits b 0 = ['0']
  | 0     => rfl
  | _ + 1 => toDigits_of_lt_base (zero_lt_succ _)

private theorem toDigitsCore_append :
    toDigitsCore b fuel n cs₁ ++ cs₂ = toDigitsCore b fuel n (cs₁ ++ cs₂) := by
  induction fuel generalizing n cs₁ with simp only [toDigitsCore]
  | succ => split <;> simp_all

private theorem toDigitsCore_eq_of_lt_fuel (hb : 1 < b) (h₁ : n < fuel₁) (h₂ : n < fuel₂) :
    toDigitsCore b fuel₁ n cs = toDigitsCore b fuel₂ n cs := by
  cases fuel₁ <;> cases fuel₂ <;> try contradiction
  simp only [toDigitsCore, Nat.div_eq_zero_iff]
  split
  · simp
  · have := Nat.div_lt_self (by omega : 0 < n) hb
    exact toDigitsCore_eq_of_lt_fuel hb (by omega) (by omega)

private theorem toDigitsCore_toDigitsCore
    (hb : 1 < b) (hn : 0 < n) (hd : d < b) (hf : b * n + d < fuel) (hnf : n < nf) (hdf : d < df) :
    toDigitsCore b nf n (toDigitsCore b df d cs) = toDigitsCore b fuel (b * n + d) cs := by
  cases fuel with
  | zero => contradiction
  | succ fuel =>
    rw [toDigitsCore]
    split
    case isTrue h =>
      have : b ≤ b * n + d := Nat.le_trans (Nat.le_mul_of_pos_right _ hn) (le_add_right _ _)
      cases Nat.div_eq_zero_iff.mp h <;> omega
    case isFalse =>
      have h : (b * n + d) / b = n := by
        rw [mul_add_div (by omega), Nat.div_eq_zero_iff.mpr (.inr hd), Nat.add_zero]
      have := (Nat.lt_mul_iff_one_lt_left hn).mpr hb
      simp only [toDigitsCore_of_lt_base hd hdf, mul_add_mod_self_left, mod_eq_of_lt hd, h]
      apply toDigitsCore_eq_of_lt_fuel hb hnf (by omega)

theorem toDigits_append_toDigits (hb : 1 < b) (hn : 0 < n) (hd : d < b) :
    (toDigits b n) ++ (toDigits b d) = toDigits b (b * n + d) := by
  rw [toDigits, toDigitsCore_append]
  exact toDigitsCore_toDigitsCore hb hn hd (lt_succ_self _) (lt_succ_self _) (lt_succ_self _)



=== LEAN SOURCE: Gcd.lean ===
/-
Copyright (c) 2014 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad, Leonardo de Moura, Mario Carneiro
-/

/-!
# Definitions and properties of `coprime`
-/

namespace Nat

/-!
### `coprime`

See also `nat.coprime_of_dvd` and `nat.coprime_of_dvd'` to prove `nat.Coprime m n`.
-/

/-- `m` and `n` are coprime, or relatively prime, if their `gcd` is 1. -/
@[reducible] def Coprime (m n : Nat) : Prop := gcd m n = 1

-- if we don't inline this, then the compiler computes the GCD even if it already has it
@[inline] instance (m n : Nat) : Decidable (Coprime m n) := inferInstanceAs (Decidable (_ = 1))

theorem coprime_iff_gcd_eq_one : Coprime m n ↔ gcd m n = 1 := .rfl

theorem Coprime.gcd_eq_one : Coprime m n → gcd m n = 1 := id

theorem Coprime.symm : Coprime n m → Coprime m n := (gcd_comm m n).trans

theorem coprime_comm : Coprime n m ↔ Coprime m n := ⟨Coprime.symm, Coprime.symm⟩

theorem Coprime.dvd_of_dvd_mul_right (H1 : Coprime k n) (H2 : k ∣ m * n) : k ∣ m := by
  let t := dvd_gcd (Nat.dvd_mul_left k m) H2
  rwa [gcd_mul_left, H1.gcd_eq_one, Nat.mul_one] at t

theorem Coprime.dvd_of_dvd_mul_left (H1 : Coprime k m) (H2 : k ∣ m * n) : k ∣ n :=
  H1.dvd_of_dvd_mul_right (by rwa [Nat.mul_comm])

theorem Coprime.gcd_mul_left_cancel (m : Nat) (H : Coprime k n) : gcd (k * m) n = gcd m n :=
  have H1 : Coprime (gcd (k * m) n) k := by
    rw [Coprime, Nat.gcd_assoc, H.symm.gcd_eq_one, gcd_one_right]
  Nat.dvd_antisymm
    (dvd_gcd (H1.dvd_of_dvd_mul_left (gcd_dvd_left _ _)) (gcd_dvd_right _ _))
    (gcd_dvd_gcd_mul_left_left _ _ _)

theorem Coprime.gcd_mul_right_cancel (m : Nat) (H : Coprime k n) : gcd (m * k) n = gcd m n := by
  rw [Nat.mul_comm m k, H.gcd_mul_left_cancel m]

theorem Coprime.gcd_mul_left_cancel_right (n : Nat)
    (H : Coprime k m) : gcd m (k * n) = gcd m n := by
  rw [gcd_comm m n, gcd_comm m (k * n), H.gcd_mul_left_cancel n]

theorem Coprime.gcd_mul_right_cancel_right (n : Nat)
    (H : Coprime k m) : gcd m (n * k) = gcd m n := by
  rw [Nat.mul_comm n k, H.gcd_mul_left_cancel_right n]

theorem coprime_div_gcd_div_gcd
    (H : 0 < gcd m n) : Coprime (m / gcd m n) (n / gcd m n) := by
  rw [coprime_iff_gcd_eq_one, gcd_div (gcd_dvd_left m n) (gcd_dvd_right m n), Nat.div_self H]

theorem not_coprime_of_dvd_of_dvd (dgt1 : 1 < d) (Hm : d ∣ m) (Hn : d ∣ n) : ¬ Coprime m n :=
  fun co => Nat.not_le_of_gt dgt1 <| Nat.le_of_dvd Nat.zero_lt_one <| by
    rw [← co.gcd_eq_one]; exact dvd_gcd Hm Hn

theorem exists_coprime (m n : Nat) :
    ∃ m' n', Coprime m' n' ∧ m = m' * gcd m n ∧ n = n' * gcd m n := by
  cases eq_zero_or_pos (gcd m n) with
  | inl h0 =>
    rw [gcd_eq_zero_iff] at h0
    refine ⟨1, 1, gcd_one_left 1, ?_⟩
    simp [h0]
  | inr hpos =>
    exact ⟨_, _, coprime_div_gcd_div_gcd hpos,
      (Nat.div_mul_cancel (gcd_dvd_left m n)).symm,
      (Nat.div_mul_cancel (gcd_dvd_right m n)).symm⟩

theorem exists_coprime' (H : 0 < gcd m n) :
    ∃ g m' n', 0 < g ∧ Coprime m' n' ∧ m = m' * g ∧ n = n' * g :=
  let ⟨m', n', h⟩ := exists_coprime m n; ⟨_, m', n', H, h⟩

theorem Coprime.mul (H1 : Coprime m k) (H2 : Coprime n k) : Coprime (m * n) k :=
  (H1.gcd_mul_left_cancel n).trans H2

theorem Coprime.mul_right (H1 : Coprime k m) (H2 : Coprime k n) : Coprime k (m * n) :=
  (H1.symm.mul H2.symm).symm

theorem Coprime.coprime_dvd_left (H1 : m ∣ k) (H2 : Coprime k n) : Coprime m n := by
  apply eq_one_of_dvd_one
  rw [Coprime] at H2
  have := Nat.gcd_dvd_gcd_of_dvd_left n H1
  rwa [← H2]

theorem Coprime.coprime_dvd_right (H1 : n ∣ m) (H2 : Coprime k m) : Coprime k n :=
  (H2.symm.coprime_dvd_left H1).symm

theorem Coprime.coprime_mul_left (H : Coprime (k * m) n) : Coprime m n :=
  H.coprime_dvd_left (Nat.dvd_mul_left _ _)

theorem Coprime.coprime_mul_right (H : Coprime (m * k) n) : Coprime m n :=
  H.coprime_dvd_left (Nat.dvd_mul_right _ _)

theorem Coprime.coprime_mul_left_right (H : Coprime m (k * n)) : Coprime m n :=
  H.coprime_dvd_right (Nat.dvd_mul_left _ _)

theorem Coprime.coprime_mul_right_right (H : Coprime m (n * k)) : Coprime m n :=
  H.coprime_dvd_right (Nat.dvd_mul_right _ _)

theorem Coprime.coprime_div_left (cmn : Coprime m n) (dvd : a ∣ m) : Coprime (m / a) n := by
  match eq_zero_or_pos a with
  | .inl h0 =>
    rw [h0] at dvd
    rw [Nat.eq_zero_of_zero_dvd dvd] at cmn ⊢
    simp; assumption
  | .inr hpos =>
    let ⟨k, hk⟩ := dvd
    rw [hk, Nat.mul_div_cancel_left _ hpos]
    rw [hk] at cmn
    exact cmn.coprime_mul_left

theorem Coprime.coprime_div_right (cmn : Coprime m n) (dvd : a ∣ n) : Coprime m (n / a) :=
  (cmn.symm.coprime_div_left dvd).symm

theorem coprime_mul_iff_left : Coprime (m * n) k ↔ Coprime m k ∧ Coprime n k :=
  ⟨fun h => ⟨h.coprime_mul_right, h.coprime_mul_left⟩,
   fun ⟨h, _⟩ => by rwa [coprime_iff_gcd_eq_one, h.gcd_mul_left_cancel n]⟩

theorem coprime_mul_iff_right : Coprime k (m * n) ↔ Coprime k m ∧ Coprime k n := by
  rw [@coprime_comm k, @coprime_comm k, @coprime_comm k, coprime_mul_iff_left]

theorem Coprime.gcd_left (k : Nat) (hmn : Coprime m n) : Coprime (gcd k m) n :=
  hmn.coprime_dvd_left <| gcd_dvd_right k m

theorem Coprime.gcd_right (k : Nat) (hmn : Coprime m n) : Coprime m (gcd k n) :=
  hmn.coprime_dvd_right <| gcd_dvd_right k n

theorem Coprime.gcd_both (k l : Nat) (hmn : Coprime m n) : Coprime (gcd k m) (gcd l n) :=
  (hmn.gcd_left k).gcd_right l

theorem Coprime.mul_dvd_of_dvd_of_dvd (hmn : Coprime m n) (hm : m ∣ a) (hn : n ∣ a) : m * n ∣ a :=
  let ⟨_, hk⟩ := hm
  hk.symm ▸ Nat.mul_dvd_mul_left _ (hmn.symm.dvd_of_dvd_mul_left (hk ▸ hn))

@[simp] theorem coprime_zero_left (n : Nat) : Coprime 0 n ↔ n = 1 := by simp [Coprime]

@[simp] theorem coprime_zero_right (n : Nat) : Coprime n 0 ↔ n = 1 := by simp [Coprime]

theorem coprime_one_left : ∀ n, Coprime 1 n := gcd_one_left

theorem coprime_one_right : ∀ n, Coprime n 1 := gcd_one_right

@[simp] theorem coprime_one_left_eq_true (n) : Coprime 1 n = True := eq_true (coprime_one_left _)

@[simp] theorem coprime_one_right_eq_true (n) : Coprime n 1 = True := eq_true (coprime_one_right _)

@[simp] theorem coprime_self (n : Nat) : Coprime n n ↔ n = 1 := by simp [Coprime]

theorem Coprime.pow_left (n : Nat) (H1 : Coprime m k) : Coprime (m ^ n) k := by
  induction n with
  | zero => exact coprime_one_left _
  | succ n ih => have hm := H1.mul ih; rwa [Nat.pow_succ, Nat.mul_comm]

theorem Coprime.pow_right (n : Nat) (H1 : Coprime k m) : Coprime k (m ^ n) :=
  (H1.symm.pow_left n).symm

theorem Coprime.pow {k l : Nat} (m n : Nat) (H1 : Coprime k l) : Coprime (k ^ m) (l ^ n) :=
  (H1.pow_left _).pow_right _

theorem Coprime.eq_one_of_dvd {k m : Nat} (H : Coprime k m) (d : k ∣ m) : k = 1 := by
  rw [← H.gcd_eq_one, gcd_eq_left d]

theorem Coprime.gcd_mul (k : Nat) (h : Coprime m n) : gcd k (m * n) = gcd k m * gcd k n :=
  Nat.dvd_antisymm
    (gcd_mul_right_dvd_mul_gcd k m n)
    ((h.gcd_both k k).mul_dvd_of_dvd_of_dvd
      (gcd_dvd_gcd_mul_right_right ..)
      (gcd_dvd_gcd_mul_left_right ..))

theorem gcd_mul_gcd_of_coprime_of_mul_eq_mul
    (cop : Coprime c d) (h : a * b = c * d) : a.gcd c * b.gcd c = c := by
  apply Nat.dvd_antisymm
  · apply ((cop.gcd_left _).mul (cop.gcd_left _)).dvd_of_dvd_mul_right
    rw [← h]
    apply Nat.mul_dvd_mul (gcd_dvd ..).1 (gcd_dvd ..).1
  · rw [gcd_comm a, gcd_comm b]
    refine Nat.dvd_trans ?_ (gcd_mul_right_dvd_mul_gcd ..)
    rw [h, gcd_mul_right_right d c]; apply Nat.dvd_refl



=== LEAN SOURCE: Lemmas.lean ===
/-
Copyright (c) 2016 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Leonardo de Moura, Jeremy Avigad, Mario Carneiro
-/
import Batteries.Data.Nat.Basic

/-! # Basic lemmas about natural numbers

The primary purpose of the lemmas in this file is to assist with reasoning
about sizes of objects, array indices and such. For a more thorough development
of the theory of natural numbers, we recommend using Mathlib.
-/

namespace Nat

/-! ### rec/cases -/

@[simp] theorem recAux_zero {motive : Nat → Sort _} (zero : motive 0)
    (succ : ∀ n, motive n → motive (n+1)) :
    Nat.recAux zero succ 0 = zero := rfl

theorem recAux_succ {motive : Nat → Sort _} (zero : motive 0)
    (succ : ∀ n, motive n → motive (n+1)) (n) :
    Nat.recAux zero succ (n+1) = succ n (Nat.recAux zero succ n) := rfl

@[simp] theorem recAuxOn_zero {motive : Nat → Sort _} (zero : motive 0)
    (succ : ∀ n, motive n → motive (n+1)) :
    Nat.recAuxOn 0 zero succ = zero := rfl

theorem recAuxOn_succ {motive : Nat → Sort _} (zero : motive 0)
    (succ : ∀ n, motive n → motive (n+1)) (n) :
    Nat.recAuxOn (n+1) zero succ = succ n (Nat.recAuxOn n zero succ) := rfl

@[simp] theorem casesAuxOn_zero {motive : Nat → Sort _} (zero : motive 0)
    (succ : ∀ n, motive (n+1)) :
    Nat.casesAuxOn 0 zero succ = zero := rfl

theorem casesAuxOn_succ {motive : Nat → Sort _} (zero : motive 0)
    (succ : ∀ n, motive (n+1)) (n) :
    Nat.casesAuxOn (n+1) zero succ = succ n := rfl

theorem strongRec_eq {motive : Nat → Sort _} (ind : ∀ n, (∀ m, m < n → motive m) → motive n)
    (t : Nat) : Nat.strongRec ind t = ind t fun m _ => Nat.strongRec ind m := by
  conv => lhs; unfold Nat.strongRec

theorem strongRecOn_eq {motive : Nat → Sort _} (ind : ∀ n, (∀ m, m < n → motive m) → motive n)
    (t : Nat) : Nat.strongRecOn t ind = ind t fun m _ => Nat.strongRecOn m ind :=
  WellFounded.fix_eq WellFoundedRelation.wf ind t

@[simp] theorem recDiagAux_zero_left {motive : Nat → Nat → Sort _}
    (zero_left : ∀ n, motive 0 n) (zero_right : ∀ m, motive m 0)
    (succ_succ : ∀ m n, motive m n → motive (m+1) (n+1)) (n) :
    Nat.recDiagAux zero_left zero_right succ_succ 0 n = zero_left n := by cases n <;> rfl

@[simp] theorem recDiagAux_zero_right {motive : Nat → Nat → Sort _}
    (zero_left : ∀ n, motive 0 n) (zero_right : ∀ m, motive m 0)
    (succ_succ : ∀ m n, motive m n → motive (m+1) (n+1)) (m)
    (h : zero_left 0 = zero_right 0 := by first | assumption | trivial) :
    Nat.recDiagAux zero_left zero_right succ_succ m 0 = zero_right m := by cases m; exact h; rfl

theorem recDiagAux_succ_succ {motive : Nat → Nat → Sort _}
    (zero_left : ∀ n, motive 0 n) (zero_right : ∀ m, motive m 0)
    (succ_succ : ∀ m n, motive m n → motive (m+1) (n+1)) (m n) :
    Nat.recDiagAux zero_left zero_right succ_succ (m+1) (n+1)
      = succ_succ m n (Nat.recDiagAux zero_left zero_right succ_succ m n) := rfl

@[simp] theorem recDiag_zero_zero {motive : Nat → Nat → Sort _} (zero_zero : motive 0 0)
    (zero_succ : ∀ n, motive 0 n → motive 0 (n+1)) (succ_zero : ∀ m, motive m 0 → motive (m+1) 0)
    (succ_succ : ∀ m n, motive m n → motive (m+1) (n+1)) :
    Nat.recDiag (motive:=motive) zero_zero zero_succ succ_zero succ_succ 0 0 = zero_zero := rfl

theorem recDiag_zero_succ {motive : Nat → Nat → Sort _} (zero_zero : motive 0 0)
    (zero_succ : ∀ n, motive 0 n → motive 0 (n+1)) (succ_zero : ∀ m, motive m 0 → motive (m+1) 0)
    (succ_succ : ∀ m n, motive m n → motive (m+1) (n+1)) (n) :
    Nat.recDiag zero_zero zero_succ succ_zero succ_succ 0 (n+1)
      = zero_succ n (Nat.recDiag zero_zero zero_succ succ_zero succ_succ 0 n) := by
  simp [Nat.recDiag]; rfl

theorem recDiag_succ_zero {motive : Nat → Nat → Sort _} (zero_zero : motive 0 0)
    (zero_succ : ∀ n, motive 0 n → motive 0 (n+1)) (succ_zero : ∀ m, motive m 0 → motive (m+1) 0)
    (succ_succ : ∀ m n, motive m n → motive (m+1) (n+1)) (m) :
    Nat.recDiag zero_zero zero_succ succ_zero succ_succ (m+1) 0
      = succ_zero m (Nat.recDiag zero_zero zero_succ succ_zero succ_succ m 0) := by
  simp [Nat.recDiag]; cases m <;> rfl

theorem recDiag_succ_succ {motive : Nat → Nat → Sort _} (zero_zero : motive 0 0)
    (zero_succ : ∀ n, motive 0 n → motive 0 (n+1)) (succ_zero : ∀ m, motive m 0 → motive (m+1) 0)
    (succ_succ : ∀ m n, motive m n → motive (m+1) (n+1)) (m n) :
    Nat.recDiag zero_zero zero_succ succ_zero succ_succ (m+1) (n+1)
      = succ_succ m n (Nat.recDiag zero_zero zero_succ succ_zero succ_succ m n) := rfl

@[simp] theorem recDiagOn_zero_zero {motive : Nat → Nat → Sort _} (zero_zero : motive 0 0)
    (zero_succ : ∀ n, motive 0 n → motive 0 (n+1)) (succ_zero : ∀ m, motive m 0 → motive (m+1) 0)
    (succ_succ : ∀ m n, motive m n → motive (m+1) (n+1)) :
    Nat.recDiagOn (motive:=motive) 0 0 zero_zero zero_succ succ_zero succ_succ = zero_zero := rfl

theorem recDiagOn_zero_succ {motive : Nat → Nat → Sort _} (zero_zero : motive 0 0)
    (zero_succ : ∀ n, motive 0 n → motive 0 (n+1)) (succ_zero : ∀ m, motive m 0 → motive (m+1) 0)
    (succ_succ : ∀ m n, motive m n → motive (m+1) (n+1)) (n) :
    Nat.recDiagOn 0 (n+1) zero_zero zero_succ succ_zero succ_succ
      = zero_succ n (Nat.recDiagOn 0 n zero_zero zero_succ succ_zero succ_succ) :=
  Nat.recDiag_zero_succ ..

theorem recDiagOn_succ_zero {motive : Nat → Nat → Sort _} (zero_zero : motive 0 0)
    (zero_succ : ∀ n, motive 0 n → motive 0 (n+1)) (succ_zero : ∀ m, motive m 0 → motive (m+1) 0)
    (succ_succ : ∀ m n, motive m n → motive (m+1) (n+1)) (m) :
    Nat.recDiagOn (m+1) 0 zero_zero zero_succ succ_zero succ_succ
      = succ_zero m (Nat.recDiagOn m 0 zero_zero zero_succ succ_zero succ_succ) :=
  Nat.recDiag_succ_zero ..

theorem recDiagOn_succ_succ {motive : Nat → Nat → Sort _} (zero_zero : motive 0 0)
    (zero_succ : ∀ n, motive 0 n → motive 0 (n+1)) (succ_zero : ∀ m, motive m 0 → motive (m+1) 0)
    (succ_succ : ∀ m n, motive m n → motive (m+1) (n+1)) (m n) :
    Nat.recDiagOn (m+1) (n+1) zero_zero zero_succ succ_zero succ_succ
      = succ_succ m n (Nat.recDiagOn m n zero_zero zero_succ succ_zero succ_succ) := rfl

@[simp] theorem casesDiagOn_zero_zero {motive : Nat → Nat → Sort _} (zero_zero : motive 0 0)
    (zero_succ : ∀ n, motive 0 (n+1)) (succ_zero : ∀ m, motive (m+1) 0)
    (succ_succ : ∀ m n, motive (m+1) (n+1)) :
    Nat.casesDiagOn 0 0 (motive:=motive) zero_zero zero_succ succ_zero succ_succ = zero_zero := rfl

@[simp] theorem casesDiagOn_zero_succ {motive : Nat → Nat → Sort _} (zero_zero : motive 0 0)
    (zero_succ : ∀ n, motive 0 (n+1)) (succ_zero : ∀ m, motive (m+1) 0)
    (succ_succ : ∀ m n, motive (m+1) (n+1)) (n) :
    Nat.casesDiagOn 0 (n+1) zero_zero zero_succ succ_zero succ_succ = zero_succ n := rfl

@[simp] theorem casesDiagOn_succ_zero {motive : Nat → Nat → Sort _} (zero_zero : motive 0 0)
    (zero_succ : ∀ n, motive 0 (n+1)) (succ_zero : ∀ m, motive (m+1) 0)
    (succ_succ : ∀ m n, motive (m+1) (n+1)) (m) :
    Nat.casesDiagOn (m+1) 0 zero_zero zero_succ succ_zero succ_succ = succ_zero m := rfl

@[simp] theorem casesDiagOn_succ_succ {motive : Nat → Nat → Sort _} (zero_zero : motive 0 0)
    (zero_succ : ∀ n, motive 0 (n+1)) (succ_zero : ∀ m, motive (m+1) 0)
    (succ_succ : ∀ m n, motive (m+1) (n+1)) (m n) :
    Nat.casesDiagOn (m+1) (n+1) zero_zero zero_succ succ_zero succ_succ = succ_succ m n := rfl

/-! ## strong case -/

/-- Strong case analysis on `a < b ∨ b ≤ a` -/
protected def lt_sum_ge (a b : Nat) : a < b ⊕' b ≤ a :=
  if h : a < b then .inl h else .inr (Nat.not_lt.1 h)

/-- Strong case analysis on `a < b ∨ a = b ∨ b < a` -/
protected def sum_trichotomy (a b : Nat) : a < b ⊕' a = b ⊕' b < a :=
  match h : compare a b with
  | .lt => .inl (Nat.compare_eq_lt.1 h)
  | .eq => .inr (.inl (Nat.compare_eq_eq.1 h))
  | .gt => .inr (.inr (Nat.compare_eq_gt.1 h))

/-! ### div/mod -/

-- TODO mod_core_congr, mod_def

-- TODO div_core_congr, div_def

-- TODO cont_to_bool_mod_two

/-! ### sum -/


@[simp] theorem sum_append {l₁ l₂ : List Nat}: (l₁ ++ l₂).sum = l₁.sum + l₂.sum := by
  induction l₁ <;> simp [*, Nat.add_assoc]

/-! ### ofBits -/

@[simp] theorem ofBits_zero (f : Fin 0 → Bool) : ofBits f = 0 := rfl

theorem ofBits_succ (f : Fin (n+1) → Bool) : ofBits f = 2 * ofBits (f ∘ Fin.succ) + (f 0).toNat :=
  Fin.foldr_succ ..

theorem ofBits_lt_two_pow (f : Fin n → Bool) : ofBits f < 2 ^ n := by
  induction n with
  | zero => simp
  | succ n ih =>
    calc ofBits f
        = 2 * ofBits (f ∘ Fin.succ) + (f 0).toNat := ofBits_succ ..
      _ < 2 * (ofBits (f ∘ Fin.succ) + 1) := Nat.add_lt_add_left (Bool.toNat_lt _) ..
      _ ≤ 2 * 2 ^ n := Nat.mul_le_mul_left 2 (ih ..)
      _ = 2 ^ (n + 1) := Nat.pow_add_one' .. |>.symm

@[simp] theorem testBit_ofBits_lt (f : Fin n → Bool) (i : Nat) (h : i < n) :
    (ofBits f).testBit i = f ⟨i, h⟩ := by
  induction n generalizing i with
  | zero => contradiction
  | succ n ih =>
    simp only [ofBits_succ]
    match i with
    | 0 => simp [mod_eq_of_lt (Bool.toNat_lt _)]
    | i+1 =>
      rw [testBit_add_one, mul_add_div Nat.zero_lt_two, Nat.div_eq_of_lt (Bool.toNat_lt _)]
      exact ih (f ∘ Fin.succ) i (Nat.lt_of_succ_lt_succ h)

@[simp] theorem testBit_ofBits_ge (f : Fin n → Bool) (i : Nat) (h : n ≤ i) :
    (ofBits f).testBit i = false := by
  apply testBit_lt_two_pow
  apply Nat.lt_of_lt_of_le
  · exact ofBits_lt_two_pow f
  · exact Nat.pow_le_pow_right Nat.zero_lt_two h

theorem testBit_ofBits (f : Fin n → Bool) :
    (ofBits f).testBit i = if h : i < n then f ⟨i, h⟩ else false := by
  cases Nat.lt_or_ge i n with
  | inl h => simp [h]
  | inr h => simp [h, Nat.not_lt_of_ge h]



=== LEAN SOURCE: MersenneTwister.lean ===
/-
Copyright (c) 2024 François G. Dorais. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: François G. Dorais
-/

/-! # Mersenne Twister

Generic implementation for the Mersenne Twister pseudorandom number generator.

All choices of parameters from Matsumoto and Nishimura (1998) are supported, along with later
refinements. Parameters for the standard 32-bit MT19937 and 64-bit MT19937-64 algorithms are
provided. Both `RandomGen` and `Stream` interfaces are provided.

Use `mt19937.init seed` to create a MT19937 PRNG with a 32 bit seed value; use
`mt19937_64.init seed` to create a MT19937-64 PRNG with a 64 bit seed value. If omitted, default
seed choices will be used.

Sample usage:
```
import Batteries.Data.Random.MersenneTwister

open Batteries.Random.MersenneTwister

def mtgen := mt19937.init -- default seed 4357

#eval (Stream.take mtgen 5).fst -- [874448474, 2424656266, 2174085406, 1265871120, 3155244894]
```

### References:

- Matsumoto, Makoto and Nishimura, Takuji (1998),
  [**Mersenne twister: A 623-dimensionally equidistributed uniform pseudo-random number generator**](https://doi.org/10.1145/272991.272995),
  ACM Trans. Model. Comput. Simul. 8, No. 1, 3-30.
  [ZBL0917.65005](https://zbmath.org/?q=an:0917.65005).

- Nishimura, Takuji (2000),
  [**Tables of 64-bit Mersenne twisters**](https://doi.org/10.1145/369534.369540),
  ACM Trans. Model. Comput. Simul. 10, No. 4, 348-357.
  [ZBL1390.65014](https://zbmath.org/?q=an:1390.65014).
-/

namespace Batteries.Random.MersenneTwister

/--
Mersenne Twister configuration.

Letters in parentheses correspond to variable names used by Matsumoto and Nishimura (1998) and
Nishimura (2000).
-/
structure Config where
  /-- Word size (`w`). -/
  wordSize : Nat
  /-- Degree of recurrence (`n`). -/
  stateSize : Nat
  /-- Middle word (`m`). -/
  shiftSize : Fin stateSize
  /-- Twist value (`r`). -/
  maskBits : Fin wordSize
  /-- Coefficients of the twist matrix (`a`). -/
  xorMask : BitVec wordSize
  /-- Tempering shift parameters (`u`, `s`, `t`, `l`). -/
  temperingShifts : Nat × Nat × Nat × Nat
  /-- Tempering mask parameters (`d`, `b`, `c`). -/
  temperingMasks : BitVec wordSize × BitVec wordSize × BitVec wordSize
  /-- Initialization multiplier (`f`). -/
  initMult : BitVec wordSize
  /-- Default initialization seed value. -/
  initSeed : BitVec wordSize

private abbrev Config.uMask (cfg : Config) : BitVec cfg.wordSize :=
  BitVec.allOnes cfg.wordSize <<< cfg.maskBits.val

private abbrev Config.lMask (cfg : Config) : BitVec cfg.wordSize :=
  BitVec.allOnes cfg.wordSize >>> (cfg.wordSize - cfg.maskBits.val)

@[simp] theorem Config.zero_lt_wordSize (cfg : Config) : 0 < cfg.wordSize :=
  Nat.zero_lt_of_lt cfg.maskBits.is_lt

@[simp] theorem Config.zero_lt_stateSize (cfg : Config) : 0 < cfg.stateSize :=
  Nat.zero_lt_of_lt cfg.shiftSize.is_lt

/-- Mersenne Twister State. -/
structure State (cfg : Config) where
  /-- Data for current state. -/
  data : Vector (BitVec cfg.wordSize) cfg.stateSize
  /-- Current data index. -/
  index : Fin cfg.stateSize

/-- Mersenne Twister initialization given an optional seed. -/
@[specialize cfg] protected def Config.init (cfg : MersenneTwister.Config)
    (seed : BitVec cfg.wordSize := cfg.initSeed) : State cfg :=
  ⟨loop seed (.mkEmpty cfg.stateSize) (Nat.zero_le _), 0, cfg.zero_lt_stateSize⟩
where
  /-- Inner loop for Mersenne Twister initalization. -/
  loop (w : BitVec cfg.wordSize) (v : Array (BitVec cfg.wordSize)) (h : v.size ≤ cfg.stateSize) :=
    if heq : v.size = cfg.stateSize then ⟨v, heq⟩ else
      let v := v.push w
      let w := cfg.initMult * (w ^^^ (w >>> cfg.wordSize - 2)) + v.size
      loop w v (by simp only [v, Array.size_push]; omega)

/-- Apply the twisting transformation to the given state. -/
@[specialize cfg] protected def State.twist (state : State cfg) : State cfg :=
  let i := state.index
  let i' : Fin cfg.stateSize :=
    if h : i.val+1 < cfg.stateSize then ⟨i.val+1, h⟩ else ⟨0, cfg.zero_lt_stateSize⟩
  let y := state.data[i] &&& cfg.uMask ||| state.data[i'] &&& cfg.lMask
  let x := state.data[i+cfg.shiftSize] ^^^ bif y[0] then y >>> 1 ^^^ cfg.xorMask else y >>> 1
  ⟨state.data.set i x, i'⟩

/-- Update the state by a number of generation steps (default 1). -/
-- TODO: optimize to `O(log(steps))` using the minimal polynomial
protected def State.update (state : State cfg) : (steps : Nat := 1) → State cfg
  | 0 => state
  | steps+1 => state.twist.update steps

/-- Mersenne Twister iteration. -/
@[specialize cfg] protected def State.next (state : State cfg) : BitVec cfg.wordSize × State cfg :=
  let i := state.index
  let s := state.twist
  (temper s.data[i], s)
where
  /-- Tempering step for Mersenne Twister. -/
  @[inline] temper (x : BitVec cfg.wordSize) :=
    match cfg.temperingShifts, cfg.temperingMasks with
    | (u, s, t, l), (d, b, c) =>
      let x := x ^^^ x >>> u &&& d
      let x := x ^^^ x <<< s &&& b
      let x := x ^^^ x <<< t &&& c
      x ^^^ x >>> l

instance (cfg) : Stream (State cfg) (BitVec cfg.wordSize) where
  next? s := s.next

/-- 32 bit Mersenne Twister (MT19937) configuration. -/
def mt19937 : Config where
  wordSize := 32
  stateSize := 624
  shiftSize := 397
  maskBits := 31
  xorMask := 0x9908b0df
  temperingShifts := (11, 7, 15, 18)
  temperingMasks := (0xffffffff, 0x9d2c5680, 0xefc60000)
  initMult := 1812433253
  initSeed := 4357

/-- 64 bit Mersenne Twister (MT19937-64) configuration. -/
def mt19937_64 : Config where
  wordSize := 64
  stateSize := 312
  shiftSize := 156
  maskBits := 31
  xorMask := 0xb5026f5aa96619e9
  temperingShifts := (29, 17, 37, 43)
  temperingMasks := (0x5555555555555555, 0x71d67fffeda60000, 0xfff7eee000000000)
  initMult := 6364136223846793005
  initSeed := 19650218



=== LEAN SOURCE: Lemmas.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Batteries.Tactic.SeqFocus
import Batteries.Tactic.Alias

namespace Std.Range

theorem size_stop_le_start : ∀ r : Range, r.stop ≤ r.start → r.size = 0
  | ⟨start, stop, step, _⟩, h => by
    simp_all [size]
    omega

theorem size_step_1 (start stop) : size ⟨start, stop, 1, by decide⟩ = stop - start := by
  simp [size]



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Batteries.Data.Nat.Gcd

/-! # Basics for the Rational Numbers -/

/--
Rational numbers, implemented as a pair of integers `num / den` such that the
denominator is positive and the numerator and denominator are coprime.
-/
-- `Rat` is not tagged with the `ext` attribute, since this is more often than not undesirable
structure Rat where
  /-- Constructs a rational number from components.
  We rename the constructor to `mk'` to avoid a clash with the smart constructor. -/
  mk' ::
  /-- The numerator of the rational number is an integer. -/
  num : Int
  /-- The denominator of the rational number is a natural number. -/
  den : Nat := 1
  /-- The denominator is nonzero. -/
  den_nz : den ≠ 0 := by decide
  /-- The numerator and denominator are coprime: it is in "reduced form". -/
  reduced : num.natAbs.Coprime den := by decide
  deriving DecidableEq

instance : Inhabited Rat := ⟨{ num := 0 }⟩

instance : ToString Rat where
  toString a := if a.den = 1 then toString a.num else s!"{a.num}/{a.den}"

instance : Repr Rat where
  reprPrec a _ := if a.den = 1 then repr a.num else s!"({a.num} : Rat)/{a.den}"

theorem Rat.den_pos (self : Rat) : 0 < self.den := Nat.pos_of_ne_zero self.den_nz

/--
Auxiliary definition for `Rat.normalize`. Constructs `num / den` as a rational number,
dividing both `num` and `den` by `g` (which is the gcd of the two) if it is not 1.
-/
@[inline] def Rat.maybeNormalize (num : Int) (den g : Nat)
    (dvd_num : ↑g ∣ num) (dvd_den : g ∣ den) (den_nz : den / g ≠ 0)
    (reduced : (num / g).natAbs.Coprime (den / g)) : Rat :=
  if hg : g = 1 then
    { num, den
      den_nz := by simp [hg] at den_nz; exact den_nz
      reduced := by simp [hg] at reduced; exact reduced }
  else { num := num.divExact g dvd_num, den := den.divExact g dvd_den, den_nz, reduced }

theorem Rat.normalize.dvd_num {num : Int} {den g : Nat}
    (e : g = num.natAbs.gcd den) : ↑g ∣ num := by
  rw [e, ← Int.dvd_natAbs, Int.ofNat_dvd]
  exact Nat.gcd_dvd_left num.natAbs den

theorem Rat.normalize.dvd_den {num : Int} {den g : Nat}
    (e : g = num.natAbs.gcd den) : g ∣ den :=
  e ▸ Nat.gcd_dvd_right ..

theorem Rat.normalize.den_nz {num : Int} {den g : Nat} (den_nz : den ≠ 0)
    (e : g = num.natAbs.gcd den) : den / g ≠ 0 :=
  e ▸ Nat.ne_of_gt (Nat.div_gcd_pos_of_pos_right _ (Nat.pos_of_ne_zero den_nz))

theorem Rat.normalize.reduced {num : Int} {den g : Nat} (den_nz : den ≠ 0)
    (e : g = num.natAbs.gcd den) : (num / g).natAbs.Coprime (den / g) :=
  have : Int.natAbs (num / ↑g) = num.natAbs / g := by
    rw [Int.natAbs_ediv_of_dvd (dvd_num e), Int.natAbs_natCast]
  this ▸ e ▸ Nat.coprime_div_gcd_div_gcd (Nat.gcd_pos_of_pos_right _ (Nat.pos_of_ne_zero den_nz))

/--
Construct a normalized `Rat` from a numerator and nonzero denominator.
This is a "smart constructor" that divides the numerator and denominator by
the gcd to ensure that the resulting rational number is normalized.
-/
@[inline] def Rat.normalize (num : Int) (den : Nat := 1) (den_nz : den ≠ 0 := by decide) : Rat :=
  Rat.maybeNormalize num den (num.natAbs.gcd den)
    (normalize.dvd_num rfl) (normalize.dvd_den rfl)
    (normalize.den_nz den_nz rfl) (normalize.reduced den_nz rfl)

/--
Construct a rational number from a numerator and denominator.
This is a "smart constructor" that divides the numerator and denominator by
the gcd to ensure that the resulting rational number is normalized, and returns
zero if `den` is zero.
-/
def mkRat (num : Int) (den : Nat) : Rat :=
  if den_nz : den = 0 then { num := 0 } else Rat.normalize num den den_nz

namespace Rat

/-- Embedding of `Int` in the rational numbers. -/
def ofInt (num : Int) : Rat := { num, reduced := Nat.coprime_one_right _ }

instance : NatCast Rat where
  natCast n := ofInt n
instance : IntCast Rat := ⟨ofInt⟩

instance : OfNat Rat n := ⟨n⟩

/-- Is this rational number integral? -/
@[inline] protected def isInt (a : Rat) : Bool := a.den == 1

/-- Form the quotient `n / d` where `n d : Int`. -/
def divInt : Int → Int → Rat
  | n, .ofNat d => inline (mkRat n d)
  | n, .negSucc d => normalize (-n) d.succ nofun

@[inherit_doc] scoped infixl:70 " /. " => Rat.divInt

/-- Implements "scientific notation" `123.4e-5` for rational numbers. (This definition is
`@[irreducible]` because you don't want to unfold it. Use `Rat.ofScientific_def`,
`Rat.ofScientific_true_def`, or `Rat.ofScientific_false_def` instead.) -/
@[irreducible] protected def ofScientific (m : Nat) (s : Bool) (e : Nat) : Rat :=
  if s then
    Rat.normalize m (10 ^ e) <| Nat.ne_of_gt <| Nat.pow_pos (by decide)
  else
    (m * 10 ^ e : Nat)

instance : OfScientific Rat where
  ofScientific m s e := Rat.ofScientific (OfNat.ofNat m) s (OfNat.ofNat e)

/-- Rational number strictly less than relation, as a `Bool`. -/
protected def blt (a b : Rat) : Bool :=
  if a.num < 0 && 0 ≤ b.num then
    true
  else if a.num = 0 then
    0 < b.num
  else if 0 < a.num && b.num ≤ 0 then
    false
  else
    -- `a` and `b` must have the same sign
   a.num * b.den < b.num * a.den

instance : LT Rat := ⟨(·.blt ·)⟩

instance (a b : Rat) : Decidable (a < b) :=
  inferInstanceAs (Decidable (_ = true))

instance : LE Rat := ⟨fun a b => b.blt a = false⟩

instance (a b : Rat) : Decidable (a ≤ b) :=
  inferInstanceAs (Decidable (_ = false))

/-- Multiplication of rational numbers. (This definition is `@[irreducible]` because you don't
want to unfold it. Use `Rat.mul_def` instead.) -/
@[irreducible] protected def mul (a b : Rat) : Rat :=
  let g1 := Nat.gcd a.num.natAbs b.den
  let g2 := Nat.gcd b.num.natAbs a.den
  { num := a.num.divExact g1 (normalize.dvd_num rfl) * b.num.divExact g2 (normalize.dvd_num rfl)
    den := a.den.divExact g2 (normalize.dvd_den rfl) * b.den.divExact g1 (normalize.dvd_den rfl)
    den_nz := Nat.ne_of_gt <| Nat.mul_pos
      (Nat.div_gcd_pos_of_pos_right _ a.den_pos) (Nat.div_gcd_pos_of_pos_right _ b.den_pos)
    reduced := by
      simp only [Int.divExact_eq_tdiv, Int.natAbs_mul, Int.natAbs_tdiv, Nat.coprime_mul_iff_left]
      refine ⟨Nat.coprime_mul_iff_right.2 ⟨?_, ?_⟩, Nat.coprime_mul_iff_right.2 ⟨?_, ?_⟩⟩
      · exact a.reduced.coprime_div_left (Nat.gcd_dvd_left ..)
          |>.coprime_div_right (Nat.gcd_dvd_right ..)
      · exact Nat.coprime_div_gcd_div_gcd (Nat.gcd_pos_of_pos_right _ b.den_pos)
      · exact Nat.coprime_div_gcd_div_gcd (Nat.gcd_pos_of_pos_right _ a.den_pos)
      · exact b.reduced.coprime_div_left (Nat.gcd_dvd_left ..)
          |>.coprime_div_right (Nat.gcd_dvd_right ..) }

instance : Mul Rat := ⟨Rat.mul⟩

/--
The inverse of a rational number. Note: `inv 0 = 0`. (This definition is `@[irreducible]`
because you don't want to unfold it. Use `Rat.inv_def` instead.)
-/
@[irreducible] protected def inv (a : Rat) : Rat :=
  if h : a.num < 0 then
    { num := -a.den, den := a.num.natAbs
      den_nz := Nat.ne_of_gt (Int.natAbs_pos.2 (Int.ne_of_lt h))
      reduced := Int.natAbs_neg a.den ▸ a.reduced.symm }
  else if h : a.num > 0 then
    { num := a.den, den := a.num.natAbs
      den_nz := Nat.ne_of_gt (Int.natAbs_pos.2 (Int.ne_of_gt h))
      reduced := a.reduced.symm }
  else
    a

/-- Division of rational numbers. Note: `div a 0 = 0`. -/
protected def div : Rat → Rat → Rat := (· * ·.inv)

/-- Division of rational numbers. Note: `div a 0 = 0`.  Written with a separate function `Rat.div`
as a wrapper so that the definition is not unfolded at `.instance` transparency. -/
instance : Div Rat := ⟨Rat.div⟩

theorem add.aux (a b : Rat) {g ad bd} (hg : g = a.den.gcd b.den)
    (had : ad = a.den / g) (hbd : bd = b.den / g) :
    let den := ad * b.den; let num := a.num * bd + b.num * ad
    num.natAbs.gcd g = num.natAbs.gcd den := by
  intro den num
  have ae : ad * g = a.den := had ▸ Nat.div_mul_cancel (hg ▸ Nat.gcd_dvd_left ..)
  have be : bd * g = b.den := hbd ▸ Nat.div_mul_cancel (hg ▸ Nat.gcd_dvd_right ..)
  have hden : den = ad * bd * g := by rw [Nat.mul_assoc, be]
  rw [hden, Nat.Coprime.gcd_mul_left_cancel_right]
  have cop : ad.Coprime bd := had ▸ hbd ▸ hg ▸
    Nat.coprime_div_gcd_div_gcd (Nat.gcd_pos_of_pos_left _ a.den_pos)
  have H1 (d : Nat) :
      d.gcd num.natAbs ∣ a.num.natAbs * bd ↔ d.gcd num.natAbs ∣ b.num.natAbs * ad := by
    have := d.gcd_dvd_right num.natAbs
    rw [← Int.ofNat_dvd, Int.dvd_natAbs] at this
    have := Int.dvd_iff_dvd_of_dvd_add this
    rwa [← Int.dvd_natAbs, Int.ofNat_dvd, Int.natAbs_mul,
      ← Int.dvd_natAbs, Int.ofNat_dvd, Int.natAbs_mul] at this
  apply Nat.Coprime.mul
  · have := (H1 ad).2 <| Nat.dvd_trans (Nat.gcd_dvd_left ..) (Nat.dvd_mul_left ..)
    have := (cop.coprime_dvd_left <| Nat.gcd_dvd_left ..).dvd_of_dvd_mul_right this
    exact Nat.eq_one_of_dvd_one <| a.reduced.gcd_eq_one ▸ Nat.dvd_gcd this <|
      Nat.dvd_trans (Nat.gcd_dvd_left ..) (ae ▸ Nat.dvd_mul_right ..)
  · have := (H1 bd).1 <| Nat.dvd_trans (Nat.gcd_dvd_left ..) (Nat.dvd_mul_left ..)
    have := (cop.symm.coprime_dvd_left <| Nat.gcd_dvd_left ..).dvd_of_dvd_mul_right this
    exact Nat.eq_one_of_dvd_one <| b.reduced.gcd_eq_one ▸ Nat.dvd_gcd this <|
      Nat.dvd_trans (Nat.gcd_dvd_left ..) (be ▸ Nat.dvd_mul_right ..)

/--
Addition of rational numbers. (This definition is `@[irreducible]` because you don't want to
unfold it. Use `Rat.add_def` instead.)
-/
@[irreducible] protected def add (a b : Rat) : Rat :=
  let g := a.den.gcd b.den
  if hg : g = 1 then
    have den_nz := Nat.ne_of_gt <| Nat.mul_pos a.den_pos b.den_pos
    have reduced := add.aux a b hg.symm (Nat.div_one _).symm (Nat.div_one _).symm
      |>.symm.trans (Nat.gcd_one_right _)
    { num := a.num * b.den + b.num * a.den, den := a.den * b.den, den_nz, reduced }
  else
    let den := (a.den / g) * b.den
    let num := a.num * ↑(b.den / g) + b.num * ↑(a.den / g)
    let g1  := num.natAbs.gcd g
    have den_nz := Nat.ne_of_gt <| Nat.mul_pos (Nat.div_gcd_pos_of_pos_left _ a.den_pos) b.den_pos
    have e : g1 = num.natAbs.gcd den := add.aux a b rfl rfl rfl
    Rat.maybeNormalize num den g1 (normalize.dvd_num e) (normalize.dvd_den e)
      (normalize.den_nz den_nz e) (normalize.reduced den_nz e)

instance : Add Rat := ⟨Rat.add⟩

/-- Negation of rational numbers. -/
protected def neg (a : Rat) : Rat :=
  { a with num := -a.num, reduced := by rw [Int.natAbs_neg]; exact a.reduced }

instance : Neg Rat := ⟨Rat.neg⟩

theorem sub.aux (a b : Rat) {g ad bd} (hg : g = a.den.gcd b.den)
    (had : ad = a.den / g) (hbd : bd = b.den / g) :
    let den := ad * b.den; let num := a.num * bd - b.num * ad
    num.natAbs.gcd g = num.natAbs.gcd den := by
  have := add.aux a (-b) hg had hbd
  simp only [show (-b).num = -b.num from rfl, Int.neg_mul] at this
  exact this

/-- Subtraction of rational numbers. (This definition is `@[irreducible]` because you don't want to
unfold it. Use `Rat.sub_def` instead.)
-/
@[irreducible] protected def sub (a b : Rat) : Rat :=
  let g := a.den.gcd b.den
  if hg : g = 1 then
    have den_nz := Nat.ne_of_gt <| Nat.mul_pos a.den_pos b.den_pos
    have reduced := sub.aux a b hg.symm (Nat.div_one _).symm (Nat.div_one _).symm
      |>.symm.trans (Nat.gcd_one_right _)
    { num := a.num * b.den - b.num * a.den, den := a.den * b.den, den_nz, reduced }
  else
    let den := (a.den / g) * b.den
    let num := a.num * ↑(b.den / g) - b.num * ↑(a.den / g)
    let g1  := num.natAbs.gcd g
    have den_nz := Nat.ne_of_gt <| Nat.mul_pos (Nat.div_gcd_pos_of_pos_left _ a.den_pos) b.den_pos
    have e : g1 = num.natAbs.gcd den := sub.aux a b rfl rfl rfl
    Rat.maybeNormalize num den g1 (normalize.dvd_num e) (normalize.dvd_den e)
      (normalize.den_nz den_nz e) (normalize.reduced den_nz e)

instance : Sub Rat := ⟨Rat.sub⟩

/-- The floor of a rational number `a` is the largest integer less than or equal to `a`. -/
protected def floor (a : Rat) : Int :=
  if a.den = 1 then
    a.num
  else
    a.num / a.den

/-- The ceiling of a rational number `a` is the smallest integer greater than or equal to `a`. -/
protected def ceil (a : Rat) : Int :=
  if a.den = 1 then
    a.num
  else
    a.num / a.den + 1

end Rat



=== LEAN SOURCE: Float.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Batteries.Data.Rat.Basic
import Batteries.Lean.Float

/-! # Rational Numbers and Float -/

namespace Rat

/-- Convert this rational number to a `Float` value. -/
protected def toFloat (a : Rat) : Float := a.num.divFloat a.den

/-- Convert this floating point number to a rational value. -/
protected def _root_.Float.toRat? (a : Float) : Option Rat :=
  a.toRatParts.map fun (v, exp) =>
    mkRat (v.sign * v.natAbs <<< exp.toNat) (1 <<< (-exp).toNat)

/--
Convert this floating point number to a rational value,
mapping non-finite values (`inf`, `-inf`, `nan`) to 0.
-/
protected def _root_.Float.toRat0 (a : Float) : Rat := a.toRat?.getD 0

instance : Coe Rat Float := ⟨Rat.toFloat⟩

end Rat



=== LEAN SOURCE: Lemmas.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Batteries.Data.Rat.Basic
import Batteries.Tactic.SeqFocus

/-! # Additional lemmas about the Rational Numbers -/

namespace Rat

theorem ext : {p q : Rat} → p.num = q.num → p.den = q.den → p = q
  | ⟨_,_,_,_⟩, ⟨_,_,_,_⟩, rfl, rfl => rfl

@[simp] theorem mk_den_one {r : Int} :
    ⟨r, 1, Nat.one_ne_zero, (Nat.coprime_one_right _)⟩ = (r : Rat) := rfl

@[simp] theorem zero_num : (0 : Rat).num = 0 := rfl
@[simp] theorem zero_den : (0 : Rat).den = 1 := rfl
@[simp] theorem one_num : (1 : Rat).num = 1 := rfl
@[simp] theorem one_den : (1 : Rat).den = 1 := rfl

@[simp] theorem maybeNormalize_eq {num den g} (dvd_num dvd_den den_nz reduced) :
    maybeNormalize num den g dvd_num dvd_den den_nz reduced =
    { num := num.divExact g dvd_num, den := den / g, den_nz, reduced } := by
  unfold maybeNormalize; split
  · subst g; simp
  · rfl

theorem normalize_eq {num den} (den_nz) : normalize num den den_nz =
    { num := num / num.natAbs.gcd den
      den := den / num.natAbs.gcd den
      den_nz := normalize.den_nz den_nz rfl
      reduced := normalize.reduced den_nz rfl } := by
  simp only [normalize, maybeNormalize_eq, Int.divExact_eq_ediv]

@[simp] theorem normalize_zero (nz) : normalize 0 d nz = 0 := by
  simp [normalize, Int.natAbs_zero, Nat.div_self (Nat.pos_of_ne_zero nz)]; rfl

theorem mk_eq_normalize (num den nz c) : ⟨num, den, nz, c⟩ = normalize num den nz := by
  simp [normalize_eq, c.gcd_eq_one]

theorem normalize_self (r : Rat) : normalize r.num r.den r.den_nz = r := (mk_eq_normalize ..).symm

theorem normalize_mul_left {a : Nat} (d0 : d ≠ 0) (a0 : a ≠ 0) :
    normalize (↑a * n) (a * d) (Nat.mul_ne_zero a0 d0) = normalize n d d0 := by
  simp [normalize_eq, Int.natAbs_mul, Nat.gcd_mul_left,
    Nat.mul_div_mul_left _ _ (Nat.pos_of_ne_zero a0), Int.natCast_mul,
    Int.mul_ediv_mul_of_pos _ _ (Int.natCast_pos.2 <| Nat.pos_of_ne_zero a0)]

theorem normalize_mul_right {a : Nat} (d0 : d ≠ 0) (a0 : a ≠ 0) :
    normalize (n * a) (d * a) (Nat.mul_ne_zero d0 a0) = normalize n d d0 := by
  rw [← normalize_mul_left (d0 := d0) a0]; congr 1 <;> [apply Int.mul_comm; apply Nat.mul_comm]

theorem normalize_eq_iff (z₁ : d₁ ≠ 0) (z₂ : d₂ ≠ 0) :
    normalize n₁ d₁ z₁ = normalize n₂ d₂ z₂ ↔ n₁ * d₂ = n₂ * d₁ := by
  constructor <;> intro h
  · simp only [normalize_eq, mk'.injEq] at h
    have hn₁ := Int.ofNat_dvd_left.2 <| Nat.gcd_dvd_left n₁.natAbs d₁
    have hn₂ := Int.ofNat_dvd_left.2 <| Nat.gcd_dvd_left n₂.natAbs d₂
    have hd₁ := Int.ofNat_dvd.2 <| Nat.gcd_dvd_right n₁.natAbs d₁
    have hd₂ := Int.ofNat_dvd.2 <| Nat.gcd_dvd_right n₂.natAbs d₂
    rw [← Int.ediv_mul_cancel (Int.dvd_trans hd₂ (Int.dvd_mul_left ..)),
      Int.mul_ediv_assoc _ hd₂, ← Int.natCast_ediv, ← h.2, Int.natCast_ediv,
      ← Int.mul_ediv_assoc _ hd₁, Int.mul_ediv_assoc' _ hn₁,
      Int.mul_right_comm, h.1, Int.ediv_mul_cancel hn₂]
  · rw [← normalize_mul_right _ z₂, ← normalize_mul_left z₂ z₁, Int.mul_comm d₁, h]

theorem maybeNormalize_eq_normalize {num : Int} {den g : Nat} (dvd_num dvd_den den_nz reduced)
    (hn : ↑g ∣ num) (hd : g ∣ den) :
    maybeNormalize num den g dvd_num dvd_den den_nz reduced =
      normalize num den (mt (by simp [·]) den_nz) := by
  simp only [maybeNormalize_eq, mk_eq_normalize, Int.divExact_eq_ediv]
  have : g ≠ 0 := mt (by simp [·]) den_nz
  rw [← normalize_mul_right _ this, Int.ediv_mul_cancel hn]
  congr 1; exact Nat.div_mul_cancel hd

@[simp] theorem normalize_eq_zero (d0 : d ≠ 0) : normalize n d d0 = 0 ↔ n = 0 := by
  have' := normalize_eq_iff d0 Nat.one_ne_zero
  rw [normalize_zero (d := 1)] at this; rw [this]; simp

theorem normalize_num_den' (num den nz) : ∃ d : Nat, d ≠ 0 ∧
    num = (normalize num den nz).num * d ∧ den = (normalize num den nz).den * d := by
  refine ⟨num.natAbs.gcd den, Nat.gcd_ne_zero_right nz, ?_⟩
  simp [normalize_eq, Int.ediv_mul_cancel (Int.ofNat_dvd_left.2 <| Nat.gcd_dvd_left ..),
    Nat.div_mul_cancel (Nat.gcd_dvd_right ..)]

theorem normalize_num_den (h : normalize n d z = ⟨n', d', z', c⟩) :
    ∃ m : Nat, m ≠ 0 ∧ n = n' * m ∧ d = d' * m := by
  have := normalize_num_den' n d z; rwa [h] at this

theorem normalize_eq_mkRat {num den} (den_nz) : normalize num den den_nz = mkRat num den := by
  simp [mkRat, den_nz]

theorem mkRat_num_den (z : d ≠ 0) (h : mkRat n d = ⟨n', d', z', c⟩) :
    ∃ m : Nat, m ≠ 0 ∧ n = n' * m ∧ d = d' * m :=
  normalize_num_den ((normalize_eq_mkRat z).symm ▸ h)

theorem mkRat_def (n d) : mkRat n d = if d0 : d = 0 then 0 else normalize n d d0 := rfl

theorem mkRat_self (a : Rat) : mkRat a.num a.den = a := by
  rw [← normalize_eq_mkRat a.den_nz, normalize_self]

theorem mk_eq_mkRat (num den nz c) : ⟨num, den, nz, c⟩ = mkRat num den := by
  simp [mk_eq_normalize, normalize_eq_mkRat]

@[simp] theorem zero_mkRat (n) : mkRat 0 n = 0 := by simp [mkRat_def]

@[simp] theorem mkRat_zero (n) : mkRat n 0 = 0 := by simp [mkRat_def]

theorem mkRat_eq_zero (d0 : d ≠ 0) : mkRat n d = 0 ↔ n = 0 := by simp [mkRat_def, d0]

theorem mkRat_ne_zero (d0 : d ≠ 0) : mkRat n d ≠ 0 ↔ n ≠ 0 := not_congr (mkRat_eq_zero d0)

theorem mkRat_mul_left {a : Nat} (a0 : a ≠ 0) : mkRat (↑a * n) (a * d) = mkRat n d := by
  if d0 : d = 0 then simp [d0] else
  rw [← normalize_eq_mkRat d0, ← normalize_mul_left d0 a0, normalize_eq_mkRat]

theorem mkRat_mul_right {a : Nat} (a0 : a ≠ 0) : mkRat (n * a) (d * a) = mkRat n d := by
  rw [← mkRat_mul_left (d := d) a0]; congr 1 <;> [apply Int.mul_comm; apply Nat.mul_comm]

theorem mkRat_eq_iff (z₁ : d₁ ≠ 0) (z₂ : d₂ ≠ 0) :
    mkRat n₁ d₁ = mkRat n₂ d₂ ↔ n₁ * d₂ = n₂ * d₁ := by
  rw [← normalize_eq_mkRat z₁, ← normalize_eq_mkRat z₂, normalize_eq_iff]

@[simp] theorem divInt_ofNat (num den) : num /. (den : Nat) = mkRat num den := by
  simp [divInt]

theorem mk_eq_divInt (num den nz c) : ⟨num, den, nz, c⟩ = num /. (den : Nat) := by
  simp [mk_eq_mkRat]

theorem divInt_self (a : Rat) : a.num /. a.den = a := by rw [divInt_ofNat, mkRat_self]

@[simp] theorem zero_divInt (n) : 0 /. n = 0 := by cases n <;> simp [divInt]

@[simp] theorem divInt_zero (n) : n /. 0 = 0 := mkRat_zero n

theorem neg_divInt_neg (num den) : -num /. -den = num /. den := by
  match den with
  | Nat.succ n =>
    simp only [divInt, Int.neg_ofNat_succ]
    simp [normalize_eq_mkRat, Int.neg_neg]
  | 0 => rfl
  | Int.negSucc n =>
    simp only [divInt, Int.neg_negSucc]
    simp [normalize_eq_mkRat]

theorem divInt_neg' (num den) : num /. -den = -num /. den := by rw [← neg_divInt_neg, Int.neg_neg]

theorem divInt_eq_iff (z₁ : d₁ ≠ 0) (z₂ : d₂ ≠ 0) :
    n₁ /. d₁ = n₂ /. d₂ ↔ n₁ * d₂ = n₂ * d₁ := by
  rcases Int.eq_nat_or_neg d₁ with ⟨_, rfl | rfl⟩ <;>
  rcases Int.eq_nat_or_neg d₂ with ⟨_, rfl | rfl⟩ <;>
  simp_all [divInt_neg', Int.neg_eq_zero,
    mkRat_eq_iff, Int.neg_mul, Int.mul_neg, Int.eq_neg_comm, eq_comm]

theorem divInt_mul_left {a : Int} (a0 : a ≠ 0) : (a * n) /. (a * d) = n /. d := by
  if d0 : d = 0 then simp [d0] else
  simp [divInt_eq_iff (Int.mul_ne_zero a0 d0) d0, Int.mul_assoc, Int.mul_left_comm]

theorem divInt_mul_right {a : Int} (a0 : a ≠ 0) : (n * a) /. (d * a) = n /. d := by
  simp [← divInt_mul_left (d := d) a0, Int.mul_comm]

theorem divInt_num_den (z : d ≠ 0) (h : n /. d = ⟨n', d', z', c⟩) :
    ∃ m, m ≠ 0 ∧ n = n' * m ∧ d = d' * m := by
  rcases Int.eq_nat_or_neg d with ⟨_, rfl | rfl⟩ <;>
    simp_all [divInt_neg', Int.neg_eq_zero]
  · have ⟨m, h₁, h₂⟩ := mkRat_num_den z h; exists m
    simp [Int.natCast_mul, h₁, h₂]
  · have ⟨m, h₁, h₂⟩ := mkRat_num_den z h; exists -m
    rw [← Int.neg_inj, Int.neg_neg] at h₂
    simp [Int.natCast_mul, h₁, h₂, Int.mul_neg, Int.neg_eq_zero]

@[simp] theorem ofInt_ofNat : ofInt (OfNat.ofNat n) = OfNat.ofNat n := rfl

@[simp] theorem ofInt_num : (ofInt n : Rat).num = n := rfl
@[simp] theorem ofInt_den : (ofInt n : Rat).den = 1 := rfl

@[simp] theorem ofNat_num : (OfNat.ofNat n : Rat).num = OfNat.ofNat n := rfl
@[simp] theorem ofNat_den : (OfNat.ofNat n : Rat).den = 1 := rfl

theorem add_def (a b : Rat) :
    a + b = normalize (a.num * b.den + b.num * a.den) (a.den * b.den)
      (Nat.mul_ne_zero a.den_nz b.den_nz) := by
  show Rat.add .. = _; delta Rat.add; dsimp only; split
  · exact (normalize_self _).symm
  · have : a.den.gcd b.den ≠ 0 := Nat.gcd_ne_zero_left a.den_nz
    rw [maybeNormalize_eq_normalize _ _ _ _
        (Int.ofNat_dvd_left.2 <| Nat.gcd_dvd_left ..)
        (Nat.dvd_trans (Nat.gcd_dvd_right ..) <|
         Nat.dvd_trans (Nat.gcd_dvd_right ..) (Nat.dvd_mul_left ..)),
      ← normalize_mul_right _ this]; congr 1
    · simp only [Int.add_mul, Int.mul_assoc, Int.ofNat_mul_ofNat,
        Nat.div_mul_cancel (Nat.gcd_dvd_left ..), Nat.div_mul_cancel (Nat.gcd_dvd_right ..)]
    · rw [Nat.mul_right_comm, Nat.div_mul_cancel (Nat.gcd_dvd_left ..)]

theorem add_def' (a b : Rat) : a + b = mkRat (a.num * b.den + b.num * a.den) (a.den * b.den) := by
  rw [add_def, normalize_eq_mkRat]

theorem normalize_add_normalize (n₁ n₂) {d₁ d₂} (z₁ z₂) :
    normalize n₁ d₁ z₁ + normalize n₂ d₂ z₂ =
    normalize (n₁ * d₂ + n₂ * d₁) (d₁ * d₂) (Nat.mul_ne_zero z₁ z₂) := by
  cases e₁ : normalize n₁ d₁ z₁; rcases normalize_num_den e₁ with ⟨g₁, zg₁, rfl, rfl⟩
  cases e₂ : normalize n₂ d₂ z₂; rcases normalize_num_den e₂ with ⟨g₂, zg₂, rfl, rfl⟩
  simp only [add_def]; rw [← normalize_mul_right _ (Nat.mul_ne_zero zg₁ zg₂)]; congr 1
  · rw [Int.add_mul]; simp [Int.natCast_mul, Int.mul_assoc, Int.mul_left_comm, Int.mul_comm]
  · simp [Nat.mul_left_comm, Nat.mul_comm]

theorem mkRat_add_mkRat (n₁ n₂ : Int) {d₁ d₂} (z₁ : d₁ ≠ 0) (z₂ : d₂ ≠ 0) :
    mkRat n₁ d₁ + mkRat n₂ d₂ = mkRat (n₁ * d₂ + n₂ * d₁) (d₁ * d₂) := by
  rw [← normalize_eq_mkRat z₁, ← normalize_eq_mkRat z₂, normalize_add_normalize, normalize_eq_mkRat]

theorem divInt_add_divInt (n₁ n₂ : Int) {d₁ d₂} (z₁ : d₁ ≠ 0) (z₂ : d₂ ≠ 0) :
    n₁ /. d₁ + n₂ /. d₂ = (n₁ * d₂ + n₂ * d₁) /. (d₁ * d₂) := by
  rcases Int.eq_nat_or_neg d₁ with ⟨_, rfl | rfl⟩ <;>
  rcases Int.eq_nat_or_neg d₂ with ⟨_, rfl | rfl⟩ <;>
  simp_all [← Int.natCast_mul, Int.neg_eq_zero, divInt_neg', Int.mul_neg,
    Int.neg_add, Int.neg_mul, mkRat_add_mkRat]

@[simp] theorem neg_num (a : Rat) : (-a).num = -a.num := rfl
@[simp] theorem neg_den (a : Rat) : (-a).den = a.den := rfl

theorem neg_normalize (n d z) : -normalize n d z = normalize (-n) d z := by
  simp only [normalize, maybeNormalize_eq, Int.divExact_eq_tdiv, Int.natAbs_neg, Int.neg_tdiv]
  rfl

theorem neg_mkRat (n d) : -mkRat n d = mkRat (-n) d := by
  if z : d = 0 then simp [z]; rfl else simp [← normalize_eq_mkRat z, neg_normalize]

theorem neg_divInt (n d) : -(n /. d) = -n /. d := by
  rcases Int.eq_nat_or_neg d with ⟨_, rfl | rfl⟩ <;> simp [divInt_neg', neg_mkRat]

theorem sub_def (a b : Rat) :
    a - b = normalize (a.num * b.den - b.num * a.den) (a.den * b.den)
      (Nat.mul_ne_zero a.den_nz b.den_nz) := by
  show Rat.sub .. = _; delta Rat.sub; dsimp only; split
  · exact (normalize_self _).symm
  · have : a.den.gcd b.den ≠ 0 := Nat.gcd_ne_zero_left a.den_nz
    rw [maybeNormalize_eq_normalize _ _ _ _
        (Int.ofNat_dvd_left.2 <| Nat.gcd_dvd_left ..)
        (Nat.dvd_trans (Nat.gcd_dvd_right ..) <|
         Nat.dvd_trans (Nat.gcd_dvd_right ..) (Nat.dvd_mul_left ..)),
      ← normalize_mul_right _ this]; congr 1
    · simp only [Int.sub_mul, Int.mul_assoc, ← Int.natCast_mul,
        Nat.div_mul_cancel (Nat.gcd_dvd_left ..), Nat.div_mul_cancel (Nat.gcd_dvd_right ..)]
    · rw [Nat.mul_right_comm, Nat.div_mul_cancel (Nat.gcd_dvd_left ..)]

theorem sub_def' (a b : Rat) : a - b = mkRat (a.num * b.den - b.num * a.den) (a.den * b.den) := by
  rw [sub_def, normalize_eq_mkRat]

protected theorem sub_eq_add_neg (a b : Rat) : a - b = a + -b := by
  simp [add_def, sub_def, Int.neg_mul, Int.sub_eq_add_neg]

theorem divInt_sub_divInt (n₁ n₂ : Int) {d₁ d₂} (z₁ : d₁ ≠ 0) (z₂ : d₂ ≠ 0) :
    n₁ /. d₁ - n₂ /. d₂ = (n₁ * d₂ - n₂ * d₁) /. (d₁ * d₂) := by
  simp only [Rat.sub_eq_add_neg, neg_divInt,
    divInt_add_divInt _ _ z₁ z₂, Int.neg_mul, Int.sub_eq_add_neg]

theorem mul_def (a b : Rat) :
    a * b = normalize (a.num * b.num) (a.den * b.den) (Nat.mul_ne_zero a.den_nz b.den_nz) := by
  show Rat.mul .. = _; delta Rat.mul; dsimp only
  have H1 : a.num.natAbs.gcd b.den ≠ 0 := Nat.gcd_ne_zero_right b.den_nz
  have H2 : b.num.natAbs.gcd a.den ≠ 0 := Nat.gcd_ne_zero_right a.den_nz
  simp only [Int.divExact_eq_tdiv, Nat.divExact_eq_div]
  rw [mk_eq_normalize, ← normalize_mul_right _ (Nat.mul_ne_zero H1 H2)]; congr 1
  · rw [Int.natCast_mul, ← Int.mul_assoc, Int.mul_right_comm (Int.tdiv ..),
      Int.tdiv_mul_cancel (Int.ofNat_dvd_left.2 <| Nat.gcd_dvd_left ..), Int.mul_assoc,
      Int.tdiv_mul_cancel (Int.ofNat_dvd_left.2 <| Nat.gcd_dvd_left ..)]
  · rw [← Nat.mul_assoc, Nat.mul_right_comm, Nat.mul_right_comm (_/_),
      Nat.div_mul_cancel (Nat.gcd_dvd_right ..), Nat.mul_assoc,
      Nat.div_mul_cancel (Nat.gcd_dvd_right ..)]

protected theorem mul_comm (a b : Rat) : a * b = b * a := by
  simp [mul_def, normalize_eq_mkRat, Int.mul_comm, Nat.mul_comm]

@[simp] protected theorem zero_mul (a : Rat) : 0 * a = 0 := by simp [mul_def]
@[simp] protected theorem mul_zero (a : Rat) : a * 0 = 0 := by simp [mul_def]
@[simp] protected theorem one_mul (a : Rat) : 1 * a = a := by simp [mul_def, normalize_self]
@[simp] protected theorem mul_one (a : Rat) : a * 1 = a := by simp [mul_def, normalize_self]

theorem normalize_mul_normalize (n₁ n₂) {d₁ d₂} (z₁ z₂) :
    normalize n₁ d₁ z₁ * normalize n₂ d₂ z₂ =
    normalize (n₁ * n₂) (d₁ * d₂) (Nat.mul_ne_zero z₁ z₂) := by
  cases e₁ : normalize n₁ d₁ z₁; rcases normalize_num_den e₁ with ⟨g₁, zg₁, rfl, rfl⟩
  cases e₂ : normalize n₂ d₂ z₂; rcases normalize_num_den e₂ with ⟨g₂, zg₂, rfl, rfl⟩
  simp only [mul_def]; rw [← normalize_mul_right _ (Nat.mul_ne_zero zg₁ zg₂)]; congr 1
  · simp [Int.natCast_mul, Int.mul_assoc, Int.mul_left_comm]
  · simp [Nat.mul_left_comm, Nat.mul_comm]

theorem mkRat_mul_mkRat (n₁ n₂ : Int) (d₁ d₂) :
    mkRat n₁ d₁ * mkRat n₂ d₂ = mkRat (n₁ * n₂) (d₁ * d₂) := by
  if z₁ : d₁ = 0 then simp [z₁] else if z₂ : d₂ = 0 then simp [z₂] else
  rw [← normalize_eq_mkRat z₁, ← normalize_eq_mkRat z₂, normalize_mul_normalize, normalize_eq_mkRat]

theorem divInt_mul_divInt (n₁ n₂ : Int) {d₁ d₂} (z₁ : d₁ ≠ 0) (z₂ : d₂ ≠ 0) :
    (n₁ /. d₁) * (n₂ /. d₂) = (n₁ * n₂) /. (d₁ * d₂) := by
  rcases Int.eq_nat_or_neg d₁ with ⟨_, rfl | rfl⟩ <;>
  rcases Int.eq_nat_or_neg d₂ with ⟨_, rfl | rfl⟩ <;>
  simp_all [← Int.natCast_mul, divInt_neg', Int.mul_neg, Int.neg_mul, mkRat_mul_mkRat]

theorem inv_def (a : Rat) : a.inv = a.den /. a.num := by
  unfold Rat.inv; split
  · next h => rw [mk_eq_divInt, ← Int.natAbs_neg,
      Int.natAbs_of_nonneg (Int.le_of_lt <| Int.neg_pos_of_neg h), neg_divInt_neg]
  split
  · next h => rw [mk_eq_divInt, Int.natAbs_of_nonneg (Int.le_of_lt h)]
  · next h₁ h₂ =>
    apply (divInt_self _).symm.trans
    simp [Int.le_antisymm (Int.not_lt.1 h₂) (Int.not_lt.1 h₁)]

@[simp] protected theorem inv_zero : (0 : Rat).inv = 0 := by unfold Rat.inv; rfl

@[simp] theorem inv_divInt (n d : Int) : (n /. d).inv = d /. n := by
  if z : d = 0 then simp [z] else
  cases e : n /. d; rcases divInt_num_den z e with ⟨g, zg, rfl, rfl⟩
  simp [inv_def, divInt_mul_right zg]

theorem div_def (a b : Rat) : a / b = a * b.inv := rfl

theorem ofScientific_true_def : Rat.ofScientific m true e = mkRat m (10 ^ e) := by
  unfold Rat.ofScientific; rw [normalize_eq_mkRat]; rfl

theorem ofScientific_false_def : Rat.ofScientific m false e = (m * 10 ^ e : Nat) := by
  unfold Rat.ofScientific; rfl

theorem ofScientific_def : Rat.ofScientific m s e =
    if s then mkRat m (10 ^ e) else (m * 10 ^ e : Nat) := by
  cases s; exact ofScientific_false_def; exact ofScientific_true_def

/-- `Rat.ofScientific` applied to numeric literals is the same as a scientific literal. -/
@[simp]
theorem ofScientific_ofNat_ofNat :
    Rat.ofScientific (no_index (OfNat.ofNat m)) s (no_index (OfNat.ofNat e))
      = OfScientific.ofScientific m s e := rfl

@[simp] theorem intCast_den (a : Int) : (a : Rat).den = 1 := rfl

@[simp] theorem intCast_num (a : Int) : (a : Rat).num = a := rfl

/-!
The following lemmas are later subsumed by e.g. `Int.cast_add` and `Int.cast_mul` in Mathlib
but it is convenient to have these earlier, for users who only need `Int` and `Rat`.
-/

@[simp, norm_cast] theorem intCast_inj {a b : Int} : (a : Rat) = (b : Rat) ↔ a = b := by
  constructor
  · rintro ⟨⟩; rfl
  · simp_all

theorem intCast_zero : ((0 : Int) : Rat) = (0 : Rat) := rfl

theorem intCast_one : ((1 : Int) : Rat) = (1 : Rat) := rfl

@[simp, norm_cast] theorem intCast_add (a b : Int) :
    ((a + b : Int) : Rat) = (a : Rat) + (b : Rat) := by
  rw [add_def]
  simp [normalize_eq]

@[simp, norm_cast] theorem intCast_neg (a : Int) : ((-a : Int) : Rat) = -(a : Rat) := rfl

@[simp, norm_cast] theorem intCast_sub (a b : Int) :
    ((a - b : Int) : Rat) = (a : Rat) - (b : Rat) := by
  rw [sub_def]
  simp [normalize_eq]

@[simp, norm_cast] theorem intCast_mul (a b : Int) :
    ((a * b : Int) : Rat) = (a : Rat) * (b : Rat) := by
  rw [mul_def]
  simp [normalize_eq]



=== LEAN SOURCE: Alter.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Batteries.Data.RBMap.WF

/-!
# Path operations; `modify` and `alter`

This develops the necessary theorems to construct the `modify` and `alter` functions on `RBSet`
using path operations for in-place modification of an `RBTree`.
-/

namespace Batteries

namespace RBNode
open RBColor

attribute [simp] Path.fill

/-! ## path balance -/

/-- Asserts that property `p` holds on the root of the tree, if any. -/
def OnRoot (p : α → Prop) : RBNode α → Prop
  | nil => True
  | node _ _ x _ => p x

namespace Path

/-- Same as `fill` but taking its arguments in a pair for easier composition with `zoom`. -/
@[inline] def fill' : RBNode α × Path α → RBNode α := fun (t, path) => path.fill t

theorem zoom_fill' (cut : α → Ordering) (t : RBNode α) (path : Path α) :
    fill' (zoom cut t path) = path.fill t := by
  induction t generalizing path with
  | nil => rfl
  | node _ _ _ _ iha ihb => unfold zoom; split <;> [apply iha; apply ihb; rfl]

theorem zoom_fill (H : zoom cut t path = (t', path')) : path.fill t = path'.fill t' :=
  (H ▸ zoom_fill' cut t path).symm

variable (c₀ : RBColor) (n₀ : Nat) in
/--
The balance invariant for a path. `path.Balanced c₀ n₀ c n` means that `path` is a red-black tree
with balance invariant `c₀, n₀`, but it has a "hole" where a tree with balance invariant `c, n`
has been removed. The defining property is `Balanced.fill`: if `path.Balanced c₀ n₀ c n` and you
fill the hole with a tree satisfying `t.Balanced c n`, then `(path.fill t).Balanced c₀ n₀` .
-/
protected inductive Balanced : Path α → RBColor → Nat → Prop where
  /-- The root of the tree is `c₀, n₀`-balanced by assumption. -/
  | protected root : Path.root.Balanced c₀ n₀
  /-- Descend into the left subtree of a red node. -/
  | redL : Balanced y black n → parent.Balanced red n →
    (Path.left red parent v y).Balanced black n
  /-- Descend into the right subtree of a red node. -/
  | redR : Balanced x black n → parent.Balanced red n →
    (Path.right red x v parent).Balanced black n
  /-- Descend into the left subtree of a black node. -/
  | blackL : Balanced y c₂ n → parent.Balanced black (n + 1) →
    (Path.left black parent v y).Balanced c₁ n
  /-- Descend into the right subtree of a black node. -/
  | blackR : Balanced x c₁ n → parent.Balanced black (n + 1) →
    (Path.right black x v parent).Balanced c₂ n

/--
The defining property of a balanced path: If `path` is a `c₀,n₀` tree with a `c,n` hole,
then filling the hole with a `c,n` tree yields a `c₀,n₀` tree.
-/
protected theorem Balanced.fill {path : Path α} {t} :
    path.Balanced c₀ n₀ c n → t.Balanced c n → (path.fill t).Balanced c₀ n₀
  | .root, h => h
  | .redL hb H, ha | .redR ha H, hb => H.fill (.red ha hb)
  | .blackL hb H, ha | .blackR ha H, hb => H.fill (.black ha hb)

protected theorem _root_.Batteries.RBNode.Balanced.zoom : t.Balanced c n → path.Balanced c₀ n₀ c n →
    zoom cut t path = (t', path') → ∃ c n, t'.Balanced c n ∧ path'.Balanced c₀ n₀ c n
  | .nil, hp => fun e => by cases e; exact ⟨_, _, .nil, hp⟩
  | .red ha hb, hp => by
    unfold zoom; split
    · exact ha.zoom (.redL hb hp)
    · exact hb.zoom (.redR ha hp)
    · intro e; cases e; exact ⟨_, _, .red ha hb, hp⟩
  | .black ha hb, hp => by
    unfold zoom; split
    · exact ha.zoom (.blackL hb hp)
    · exact hb.zoom (.blackR ha hp)
    · intro e; cases e; exact ⟨_, _, .black ha hb, hp⟩

protected theorem Balanced.ins {path : Path α}
    (hp : path.Balanced c₀ n₀ c n) (ht : t.RedRed (c = red) n) :
    ∃ n, (path.ins t).Balanced black n := by
  induction hp generalizing t with
  | root => exact ht.setBlack
  | redL hr hp ih => match ht with
    | .balanced .nil => exact ih (.balanced (.red .nil hr))
    | .balanced (.red ha hb) => exact ih (.redred rfl (.red ha hb) hr)
    | .balanced (.black ha hb) => exact ih (.balanced (.red (.black ha hb) hr))
  | redR hl hp ih => match ht with
    | .balanced .nil => exact ih (.balanced (.red hl .nil))
    | .balanced (.red ha hb) => exact ih (.redred rfl hl (.red ha hb))
    | .balanced (.black ha hb) => exact ih (.balanced (.red hl (.black ha hb)))
  | blackL hr _hp ih => exact have ⟨c, h⟩ := ht.balance1 hr; ih (.balanced h)
  | blackR hl _hp ih => exact have ⟨c, h⟩ := ht.balance2 hl; ih (.balanced h)

protected theorem Balanced.insertNew {path : Path α} (H : path.Balanced c n black 0) :
    ∃ n, (path.insertNew v).Balanced black n := H.ins (.balanced (.red .nil .nil))

protected theorem Balanced.del {path : Path α}
    (hp : path.Balanced c₀ n₀ c n) (ht : t.DelProp c' n) (hc : c = black → c' ≠ red) :
    ∃ n, (path.del t c').Balanced black n := by
  induction hp generalizing t c' with
  | root => match c', ht with
    | red, ⟨_, h⟩ | black, ⟨_, _, h⟩ => exact h.setBlack
  | @redL _ n _ _ hb hp ih => match c', n, ht with
    | red, _, _ => cases hc rfl rfl
    | black, _, ⟨_, rfl, ha⟩ => exact ih ((hb.balLeft ha).of_false nofun) nofun
  | @redR _ n _ _ ha hp ih => match c', n, ht with
    | red, _, _ => cases hc rfl rfl
    | black, _, ⟨_, rfl, hb⟩ => exact ih ((ha.balRight hb).of_false nofun) nofun
  | @blackL _ _ n _ _ _ hb hp ih => match c', n, ht with
    | red, _, ⟨_, ha⟩ => exact ih ⟨_, rfl, .redred ⟨⟩ ha hb⟩ nofun
    | black, _, ⟨_, rfl, ha⟩ => exact ih ⟨_, rfl, (hb.balLeft ha).imp fun _ => ⟨⟩⟩ nofun
  | @blackR _ _ n _ _ _ ha hp ih =>  match c', n, ht with
    | red, _, ⟨_, hb⟩ => exact ih ⟨_, rfl, .redred ⟨⟩ ha hb⟩ nofun
    | black, _, ⟨_, rfl, hb⟩ => exact ih ⟨_, rfl, (ha.balRight hb).imp fun _ => ⟨⟩⟩ nofun

/--
The property of a path returned by `t.zoom cut`. Each of the parents visited along the path have
the appropriate ordering relation to the cut.
-/
def Zoomed (cut : α → Ordering) : Path α → Prop
  | .root => True
  | .left _ parent x _ => cut x = .lt ∧ parent.Zoomed cut
  | .right _ _ x parent => cut x = .gt ∧ parent.Zoomed cut

theorem zoom_zoomed₂ (e : zoom cut t path = (t', path'))
    (hp : path.Zoomed cut) : path'.Zoomed cut :=
  match t, e with
  | nil, rfl => hp
  | node .., e => by
    revert e; unfold zoom; split
    · next h => exact fun e => zoom_zoomed₂ e ⟨h, hp⟩
    · next h => exact fun e => zoom_zoomed₂ e ⟨h, hp⟩
    · intro e; cases e; exact hp

/--
`path.RootOrdered cmp v` is true if `v` would be able to fit into the hole
without violating the ordering invariant.
-/
def RootOrdered (cmp : α → α → Ordering) : Path α → α → Prop
  | .root, _ => True
  | .left _ parent x _, v => cmpLT cmp v x ∧ parent.RootOrdered cmp v
  | .right _ _ x parent, v => cmpLT cmp x v ∧ parent.RootOrdered cmp v

theorem _root_.Batteries.RBNode.cmpEq.RootOrdered_congr
    {cmp : α → α → Ordering} (h : cmpEq cmp a b) :
    ∀ {t : Path α}, t.RootOrdered cmp a ↔ t.RootOrdered cmp b
  | .root => .rfl
  | .left .. => and_congr h.lt_congr_left h.RootOrdered_congr
  | .right .. => and_congr h.lt_congr_right h.RootOrdered_congr

theorem Zoomed.toRootOrdered {cmp} :
    ∀ {path : Path α}, path.Zoomed (cmp v) → path.RootOrdered cmp v
  | .root, h => h
  | .left .., ⟨h, hp⟩ => ⟨⟨h⟩, hp.toRootOrdered⟩
  | .right .., ⟨h, hp⟩ => ⟨⟨Std.OrientedCmp.gt_iff_lt.1 h⟩, hp.toRootOrdered⟩

/-- The ordering invariant for a `Path`. -/
def Ordered (cmp : α → α → Ordering) : Path α → Prop
  | .root => True
  | .left _ parent x b => parent.Ordered cmp ∧
    b.All (cmpLT cmp x ·) ∧ parent.RootOrdered cmp x ∧
    b.All (parent.RootOrdered cmp) ∧ b.Ordered cmp
  | .right _ a x parent => parent.Ordered cmp ∧
    a.All (cmpLT cmp · x) ∧ parent.RootOrdered cmp x ∧
    a.All (parent.RootOrdered cmp) ∧ a.Ordered cmp

protected theorem Ordered.fill : ∀ {path : Path α} {t},
    (path.fill t).Ordered cmp ↔ path.Ordered cmp ∧ t.Ordered cmp ∧ t.All (path.RootOrdered cmp)
  | .root, _ => ⟨fun H => ⟨⟨⟩, H, .trivial ⟨⟩⟩, (·.2.1)⟩
  | .left .., _ => by
    simp [Ordered.fill, RBNode.Ordered, Ordered, RootOrdered, All_and]
    exact ⟨
      fun ⟨hp, ⟨ax, xb, ha, hb⟩, ⟨xp, ap, bp⟩⟩ => ⟨⟨hp, xb, xp, bp, hb⟩, ha, ⟨ax, ap⟩⟩,
      fun ⟨⟨hp, xb, xp, bp, hb⟩, ha, ⟨ax, ap⟩⟩ => ⟨hp, ⟨ax, xb, ha, hb⟩, ⟨xp, ap, bp⟩⟩⟩
  | .right .., _ => by
    simp [Ordered.fill, RBNode.Ordered, Ordered, RootOrdered, All_and]
    exact ⟨
      fun ⟨hp, ⟨ax, xb, ha, hb⟩, ⟨xp, ap, bp⟩⟩ => ⟨⟨hp, ax, xp, ap, ha⟩, hb, ⟨xb, bp⟩⟩,
      fun ⟨⟨hp, ax, xp, ap, ha⟩, hb, ⟨xb, bp⟩⟩ => ⟨hp, ⟨ax, xb, ha, hb⟩, ⟨xp, ap, bp⟩⟩⟩

theorem _root_.Batteries.RBNode.Ordered.zoom' {t : RBNode α} {path : Path α}
    (ht : t.Ordered cmp) (hp : path.Ordered cmp) (tp : t.All (path.RootOrdered cmp))
    (pz : path.Zoomed cut) (eq : t.zoom cut path = (t', path')) :
    t'.Ordered cmp ∧ path'.Ordered cmp ∧ t'.All (path'.RootOrdered cmp) ∧ path'.Zoomed cut :=
  have ⟨hp', ht', tp'⟩ := Ordered.fill.1 <| zoom_fill eq ▸ Ordered.fill.2 ⟨hp, ht, tp⟩
  ⟨ht', hp', tp', zoom_zoomed₂ eq pz⟩

theorem _root_.Batteries.RBNode.Ordered.zoom {t : RBNode α}
    (ht : t.Ordered cmp) (eq : t.zoom cut = (t', path')) :
    t'.Ordered cmp ∧ path'.Ordered cmp ∧ t'.All (path'.RootOrdered cmp) ∧ path'.Zoomed cut :=
  ht.zoom' (path := .root) ⟨⟩ (.trivial ⟨⟩) ⟨⟩ eq

theorem Ordered.ins : ∀ {path : Path α} {t : RBNode α},
    t.Ordered cmp → path.Ordered cmp → t.All (path.RootOrdered cmp) → (path.ins t).Ordered cmp
  | .root, _, ht, _, _ => Ordered.setBlack.2 ht
  | .left red parent x b, a, ha, ⟨hp, xb, xp, bp, hb⟩, H => by
    unfold Path.ins
    have ⟨ax, ap⟩ := All_and.1 H
    exact hp.ins ⟨ax, xb, ha, hb⟩ ⟨xp, ap, bp⟩
  | .right red a x parent, b, hb, ⟨hp, ax, xp, ap, ha⟩, H => by
    unfold Path.ins
    have ⟨xb, bp⟩ := All_and.1 H
    exact hp.ins ⟨ax, xb, ha, hb⟩ ⟨xp, ap, bp⟩
  | .left black parent x b, a, ha, ⟨hp, xb, xp, bp, hb⟩, H => by
    unfold Path.ins
    have ⟨ax, ap⟩ := All_and.1 H
    exact hp.ins (ha.balance1 ax xb hb) (balance1_All.2 ⟨xp, ap, bp⟩)
  | .right black a x parent, b, hb, ⟨hp, ax, xp, ap, ha⟩, H => by
    unfold Path.ins
    have ⟨xb, bp⟩ := All_and.1 H
    exact hp.ins (ha.balance2 ax xb hb) (balance2_All.2 ⟨xp, ap, bp⟩)

theorem Ordered.insertNew {path : Path α} (hp : path.Ordered cmp) (vp : path.RootOrdered cmp v) :
    (path.insertNew v).Ordered cmp :=
  hp.ins ⟨⟨⟩, ⟨⟩, ⟨⟩, ⟨⟩⟩ ⟨vp, ⟨⟩, ⟨⟩⟩

theorem Ordered.del : ∀ {path : Path α} {t : RBNode α} {c},
    t.Ordered cmp → path.Ordered cmp → t.All (path.RootOrdered cmp) → (path.del t c).Ordered cmp
  | .root, _, _, ht, _, _ => Ordered.setBlack.2 ht
  | .left _ parent x b, a, red, ha, ⟨hp, xb, xp, bp, hb⟩, H => by
    unfold Path.del
    have ⟨ax, ap⟩ := All_and.1 H
    exact hp.del ⟨ax, xb, ha, hb⟩ ⟨xp, ap, bp⟩
  | .right _ a x parent, b, red, hb, ⟨hp, ax, xp, ap, ha⟩, H => by
    unfold Path.del
    have ⟨xb, bp⟩ := All_and.1 H
    exact hp.del ⟨ax, xb, ha, hb⟩ ⟨xp, ap, bp⟩
  | .left _ parent x b, a, black, ha, ⟨hp, xb, xp, bp, hb⟩, H => by
    unfold Path.del
    have ⟨ax, ap⟩ := All_and.1 H
    exact hp.del (ha.balLeft ax xb hb) (ap.balLeft xp bp)
  | .right _ a x parent, b, black, hb, ⟨hp, ax, xp, ap, ha⟩, H => by
    unfold Path.del
    have ⟨xb, bp⟩ := All_and.1 H
    exact hp.del (ha.balRight ax xb hb) (ap.balRight xp bp)

end Path

/-! ## alter -/

/-- The `alter` function preserves the ordering invariants. -/
protected theorem Ordered.alter {t : RBNode α}
    (H : ∀ {x t' p}, t.zoom cut = (t', p) → f t'.root? = some x →
      p.RootOrdered cmp x ∧ t'.OnRoot (cmpEq cmp x))
    (h : t.Ordered cmp) : (alter cut f t).Ordered cmp := by
  simp [alter]; split
  · next path eq =>
    have ⟨_, hp, _, _⟩ := h.zoom eq; split
    · exact h
    · next hf => exact hp.insertNew (H eq hf).1
  · next path eq =>
    have ⟨⟨ax, xb, ha, hb⟩, hp, ⟨_, ap, bp⟩, _⟩ := h.zoom eq; split
    · exact hp.del (ha.append ax xb hb) (ap.append bp)
    · next hf =>
      have ⟨yp, xy⟩ := H eq hf
      apply Path.Ordered.fill.2
      exact ⟨hp, ⟨ax.imp xy.lt_congr_right.2, xb.imp xy.lt_congr_left.2, ha, hb⟩, yp, ap, bp⟩

/-- The `alter` function preserves the balance invariants. -/
protected theorem Balanced.alter {t : RBNode α}
    (h : t.Balanced c n) : ∃ c n, (t.alter cut f).Balanced c n := by
  simp [alter]; split
  · next path eq =>
    split
    · exact ⟨_, _, h⟩
    · have ⟨_, _, .nil, h⟩ := h.zoom .root eq
      exact ⟨_, h.insertNew⟩
  · next path eq =>
    have ⟨_, _, h, hp⟩ := h.zoom .root eq
    split
    · match h with
      | .red ha hb => exact ⟨_, hp.del ((ha.append hb).of_false (· rfl rfl)) nofun⟩
      | .black ha hb => exact ⟨_, hp.del ⟨_, rfl, (ha.append hb).imp fun _ => ⟨⟩⟩ nofun⟩
    · match h with
      | .red ha hb => exact ⟨_, _, hp.fill (.red ha hb)⟩
      | .black ha hb => exact ⟨_, _, hp.fill (.black ha hb)⟩

theorem modify_eq_alter (t : RBNode α) : t.modify cut f = t.alter cut (.map f) := by
  simp [modify, alter]

/-- The `modify` function preserves the ordering invariants. -/
protected theorem Ordered.modify {t : RBNode α}
    (H : (t.zoom cut).1.OnRoot fun x => cmpEq cmp (f x) x)
    (h : t.Ordered cmp) : (modify cut f t).Ordered cmp :=
  modify_eq_alter _ ▸ h.alter @fun
    | _, .node .., _, eq, rfl => by
      rw [eq] at H; exact ⟨H.RootOrdered_congr.2 (h.zoom eq).2.2.1.1, H⟩

/-- The `modify` function preserves the balance invariants. -/
protected theorem Balanced.modify {t : RBNode α}
    (h : t.Balanced c n) : ∃ c n, (t.modify cut f).Balanced c n := modify_eq_alter _ ▸ h.alter

theorem WF.alter {t : RBNode α}
    (H : ∀ {x t' p}, t.zoom cut = (t', p) → f t'.root? = some x →
      p.RootOrdered cmp x ∧ t'.OnRoot (cmpEq cmp x))
    (h : WF cmp t) : WF cmp (alter cut f t) :=
  let ⟨h₁, _, _, h₂⟩ := h.out; WF_iff.2 ⟨h₁.alter H, h₂.alter⟩

theorem WF.modify {t : RBNode α}
    (H : (t.zoom cut).1.OnRoot fun x => cmpEq cmp (f x) x)
    (h : WF cmp t) : WF cmp (t.modify cut f) :=
  let ⟨h₁, _, _, h₂⟩ := h.out; WF_iff.2 ⟨h₁.modify H, h₂.modify⟩

theorem find?_eq_zoom : ∀ {t : RBNode α} (p := .root), t.find? cut = (t.zoom cut p).1.root?
  | .nil, _ => rfl
  | .node .., _ => by unfold find? zoom; split <;> [apply find?_eq_zoom; apply find?_eq_zoom; rfl]

end RBNode

namespace RBSet
open RBNode

/--
A sufficient condition for `ModifyWF` is that the new element compares equal to the original.
-/
theorem ModifyWF.of_eq {t : RBSet α cmp}
    (H : ∀ {x}, RBNode.find? cut t.val = some x → cmpEq cmp (f x) x) : ModifyWF t cut f := by
  refine ⟨.modify ?_ t.2⟩
  revert H; rw [find?_eq_zoom]
  cases (t.1.zoom cut).1 <;> intro H <;> [trivial; exact H rfl]

end RBSet

namespace RBMap

/--
`O(log n)`. In-place replace the corresponding to key `k`.
This takes the element out of the tree while `f` runs,
so it uses the element linearly if `t` is unshared.
-/
def modify (t : RBMap α β cmp) (k : α) (f : β → β) : RBMap α β cmp :=
  @RBSet.modifyP _ _ t (cmp k ·.1) (fun (a, b) => (a, f b))
    (.of_eq fun _ => ⟨Std.ReflCmp.compare_self (cmp := Ordering.byKey Prod.fst cmp)⟩)

/-- Auxiliary definition for `alter`. -/
def alter.adapt (k : α) (f : Option β → Option β) : Option (α × β) → Option (α × β)
  | none =>
    match f none with
    | none => none
    | some v => some (k, v)
  | some (k', v') =>
    match f (some v') with
    | none => none
    | some v => some (k', v)

/--
`O(log n)`. `alterP cut f t` simultaneously handles inserting, erasing and replacing an element
using a function `f : Option α → Option α`. It is passed the result of `t.findP? cut`
and can either return `none` to remove the element or `some a` to replace/insert
the element with `a` (which must have the same ordering properties as the original element).

The element is used linearly if `t` is unshared.

The `AlterWF` assumption is required because `f` may change
the ordering properties of the element, which would break the invariants.
-/
@[specialize] def alter
    (t : RBMap α β cmp) (k : α) (f : Option β → Option β) : RBMap α β cmp := by
  refine @RBSet.alterP _ _ t (cmp k ·.1) (alter.adapt k f) ⟨.alter (@fun _ t' p eq => ?_) t.2⟩
  cases t' <;> simp [alter.adapt, RBNode.root?] <;> split <;> intro h <;> cases h
  · exact ⟨(t.2.out.1.zoom eq).2.2.2.toRootOrdered, ⟨⟩⟩
  · refine ⟨(?a).RootOrdered_congr.2 (t.2.out.1.zoom eq).2.2.1.1, ?a⟩
    exact ⟨Std.ReflCmp.compare_self (cmp := Ordering.byKey Prod.fst cmp)⟩

end RBMap



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2017 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Leonardo de Moura, Mario Carneiro
-/
import Batteries.Classes.Order
import Batteries.Control.ForInStep.Basic
import Batteries.Tactic.Lint.Misc

/-!
# Red-black trees

Note: users are recommended to use `Std.TreeMap` instead of `Batteries.RBMap`.
`Std.TreeMap` is a mostly drop-in replacement (notably, there is no `ToStream` instance yet),
and has more complete and consistent API. This implementation will eventually be deprecated.

This module implements a type `RBMap α β cmp` which is a functional data structure for
storing a key-value store in a binary search tree.

It is built on the simpler `RBSet α cmp` type, which stores a set of values of type `α`
using the function `cmp : α → α → Ordering` for determining the ordering relation.
The tree will never store two elements that compare `.eq` under the `cmp` function,
but the function does not have to satisfy `cmp x y = .eq → x = y`, and in the map case
`α` is a key-value pair and the `cmp` function only compares the keys.
-/

namespace Batteries

/--
In a red-black tree, every node has a color which is either "red" or "black"
(this particular choice of colors is conventional). A nil node is considered black.
-/
inductive RBColor where
  /-- A red node is required to have black children. -/
  | red
  /-- Every path from the root to a leaf must pass through the same number of black nodes. -/
  | black
  deriving Repr

/--
A red-black tree. (This is an internal implementation detail of the `RBSet` type,
which includes the invariants of the tree.) This is a binary search tree augmented with
a "color" field which is either red or black for each node and used to implement
the re-balancing operations.
See: [Red–black tree](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)
-/
inductive RBNode (α : Type u) where
  /-- An empty tree. -/
  | nil
  /-- A node consists of a value `v`, a subtree `l` of smaller items,
  and a subtree `r` of larger items. The color `c` is either `red` or `black`
  and participates in the red-black balance invariant (see `Balanced`). -/
  | node (c : RBColor) (l : RBNode α) (v : α) (r : RBNode α)
  deriving Repr

namespace RBNode
open RBColor

instance : EmptyCollection (RBNode α) := ⟨nil⟩

/-- The minimum element of a tree is the left-most value. -/
protected def min? : RBNode α → Option α
  | nil            => none
  | node _ nil v _ => some v
  | node _ l _ _   => l.min?

/-- The maximum element of a tree is the right-most value. -/
protected def max? : RBNode α → Option α
  | nil            => none
  | node _ _ v nil => some v
  | node _ _ _ r   => r.max?

/--
Fold a function in tree order along the nodes. `v₀` is used at `nil` nodes and
`f` is used to combine results at branching nodes.
-/
@[specialize] def fold (v₀ : σ) (f : σ → α → σ → σ) : RBNode α → σ
  | nil          => v₀
  | node _ l v r => f (l.fold v₀ f) v (r.fold v₀ f)

/-- Fold a function on the values from left to right (in increasing order). -/
@[specialize] def foldl (f : σ → α → σ) : (init : σ) → RBNode α → σ
  | b, nil          => b
  | b, node _ l v r => foldl f (f (foldl f b l) v) r

/-- Fold a function on the values from right to left (in decreasing order). -/
@[specialize] def foldr (f : α → σ → σ) : RBNode α → (init : σ) → σ
  | nil,          b => b
  | node _ l v r, b => l.foldr f <| f v <| r.foldr f b

/-- `O(n)`. Convert the tree to a list in ascending order. -/
def toList (t : RBNode α) : List α := t.foldr (·::·) []

/-- Run monadic function `f` on each element of the tree (in increasing order). -/
@[specialize] def forM [Monad m] (f : α → m PUnit) : RBNode α → m PUnit
  | nil          => pure ⟨⟩
  | node _ l v r => do forM f l; f v; forM f r

/-- Fold a monadic function on the values from left to right (in increasing order). -/
@[specialize] def foldlM [Monad m] (f : σ → α → m σ) : (init : σ) → RBNode α → m σ
  | b, nil          => pure b
  | b, node _ l v r => do foldlM f (← f (← foldlM f b l) v) r

/-- Implementation of `for x in t` loops over a `RBNode` (in increasing order). -/
@[inline] protected def forIn [Monad m]
    (as : RBNode α) (init : σ) (f : α → σ → m (ForInStep σ)) : m σ := do
  ForInStep.run <$> visit as init
where
  /-- Inner loop of `forIn`. -/
  @[specialize] visit : RBNode α → σ → m (ForInStep σ)
    | nil,          b => return ForInStep.yield b
    | node _ l v r, b => ForInStep.bindM (visit l b) fun b => ForInStep.bindM (f v b) (visit r ·)

instance : ForIn m (RBNode α) α where
  forIn := RBNode.forIn

/--
An auxiliary data structure (an iterator) over an `RBNode` which lazily
pulls elements from the left.
-/
protected inductive Stream (α : Type _)
  /-- The stream is empty. -/
  | nil
  /-- We are ready to deliver element `v` with right child `r`,
  and where `tail` represents all the subtrees we have yet to destructure. -/
  | cons (v : α) (r : RBNode α) (tail : RBNode.Stream α)

/-- `O(log n)`. Turn a node into a stream, by descending along the left spine. -/
def toStream : RBNode α → (_ : RBNode.Stream α := .nil) → RBNode.Stream α
  | nil, acc => acc
  | node _ l v r, acc => toStream l (.cons v r acc)

namespace Stream

/-- `O(1)` amortized, `O(log n)` worst case: Get the next element from the stream. -/
def next? : RBNode.Stream α → Option (α × RBNode.Stream α)
  | nil => none
  | cons v r tail => some (v, toStream r tail)

/-- Fold a function on the values from left to right (in increasing order). -/
@[specialize] def foldl (f : σ → α → σ) : (init : σ) → RBNode.Stream α → σ
  | b, nil           => b
  | b, cons v r tail => foldl f (r.foldl f (f b v)) tail

/-- Fold a function on the values from right to left (in decreasing order). -/
@[specialize] def foldr (f : α → σ → σ) : RBNode.Stream α → (init : σ) → σ
  | nil,           b => b
  | cons v r tail, b => f v <| r.foldr f <| tail.foldr f b

/-- `O(n)`. Convert the stream to a list in ascending order. -/
def toList (t : RBNode.Stream α) : List α := t.foldr (·::·) []

end Stream

instance : ToStream (RBNode α) (RBNode.Stream α) := ⟨(·.toStream)⟩
instance : Stream (RBNode.Stream α) α := ⟨Stream.next?⟩

/-- Returns `true` iff every element of the tree satisfies `p`. -/
@[specialize] def all (p : α → Bool) : RBNode α → Bool
  | nil          => true
  | node _ l v r => p v && all p l && all p r

/-- Returns `true` iff any element of the tree satisfies `p`. -/
@[specialize] def any (p : α → Bool) : RBNode α → Bool
  | nil          => false
  | node _ l v r => p v || any p l || any p r

/-- Asserts that `p` holds on every element of the tree. -/
def All (p : α → Prop) : RBNode α → Prop
  | nil          => True
  | node _ l v r => p v ∧ All p l ∧ All p r

theorem All.imp (H : ∀ {x : α}, p x → q x) : ∀ {t : RBNode α}, t.All p → t.All q
  | nil => id
  | node .. => fun ⟨h, hl, hr⟩ => ⟨H h, hl.imp H, hr.imp H⟩

theorem all_iff {t : RBNode α} : t.all p ↔ t.All (p ·) := by
  induction t <;> simp [*, all, All, and_assoc]

instance {t : RBNode α} [DecidablePred p] : Decidable (t.All p) :=
  decidable_of_iff (t.all p) (by simp [all_iff])

/-- Asserts that `p` holds on some element of the tree. -/
def Any (p : α → Prop) : RBNode α → Prop
  | nil          => False
  | node _ l v r => p v ∨ Any p l ∨ Any p r

theorem any_iff {t : RBNode α} : t.any p ↔ t.Any (p ·) := by
  induction t <;> simp [*, any, Any, or_assoc]

instance {t : RBNode α} [DecidablePred p] : Decidable (t.Any p) :=
  decidable_of_iff (t.any p) (by simp [any_iff])

/-- True if `x` is an element of `t` "exactly", i.e. up to equality, not the `cmp` relation. -/
def EMem (x : α) (t : RBNode α) : Prop := t.Any (x = ·)

instance : Membership α (RBNode α) where
  mem t x := EMem x t

/-- True if the specified `cut` matches at least one element of of `t`. -/
def MemP (cut : α → Ordering) (t : RBNode α) : Prop := t.Any (cut · = .eq)

/-- True if `x` is equivalent to an element of `t`. -/
@[reducible] def Mem (cmp : α → α → Ordering) (x : α) (t : RBNode α) : Prop := MemP (cmp x) t

-- These instances are put in a special namespace because they are usually not what users want
-- when deciding membership in a RBSet, since this does a naive linear search through the tree.
-- The real `O(log n)` instances are defined in `Data.RBMap.Lemmas`.
@[nolint docBlame] scoped instance Slow.instDecidableEMem [DecidableEq α] {t : RBNode α} :
    Decidable (EMem x t) := inferInstanceAs (Decidable (Any ..))

@[nolint docBlame] scoped instance Slow.instDecidableMemP {t : RBNode α} :
    Decidable (MemP cut t) := inferInstanceAs (Decidable (Any ..))

@[nolint docBlame] scoped instance Slow.instDecidableMem {t : RBNode α} :
    Decidable (Mem cmp x t) := inferInstanceAs (Decidable (Any ..))

/--
Asserts that `t₁` and `t₂` have the same number of elements in the same order,
and `R` holds pairwise between them. The tree structure is ignored.
-/
@[specialize] def all₂ (R : α → β → Bool) (t₁ : RBNode α) (t₂ : RBNode β) : Bool :=
  let result := StateT.run (s := t₂.toStream) <| t₁.forM fun a s => do
    let (b, s) ← s.next?
    bif R a b then pure (⟨⟩, s) else none
  result matches some (_, .nil)

instance [BEq α] : BEq (RBNode α) where
  beq a b := a.all₂ (· == ·) b

/--
We say that `x < y` under the comparator `cmp` if `cmp x y = .lt`.

* In order to avoid assuming the comparator is always lawful, we use a
  local `∀ [Std.TransCmp cmp]` binder in the relation so that the ordering
  properties of the tree only need to hold if the comparator is lawful.
* The `Nonempty` wrapper is a no-op because this is already a proposition,
  but it prevents the `[Std.TransCmp cmp]` binder from being introduced when we don't want it.
-/
def cmpLT (cmp : α → α → Ordering) (x y : α) : Prop :=
  Nonempty (∀ [Std.TransCmp cmp], cmp x y = .lt)

theorem cmpLT_iff [Std.TransCmp cmp] : cmpLT cmp x y ↔ cmp x y = .lt :=
  ⟨fun ⟨h⟩ => h, (⟨·⟩)⟩

instance (cmp) [Std.TransCmp cmp] : Decidable (cmpLT cmp x y) := decidable_of_iff' _ cmpLT_iff

/-- We say that `x ≈ y` under the comparator `cmp` if `cmp x y = .eq`. See also `cmpLT`. -/
def cmpEq (cmp : α → α → Ordering) (x y : α) : Prop :=
  Nonempty (∀ [Std.TransCmp cmp], cmp x y = .eq)

theorem cmpEq_iff [Std.TransCmp cmp] : cmpEq cmp x y ↔ cmp x y = .eq := ⟨fun ⟨h⟩ => h, (⟨·⟩)⟩

instance (cmp) [Std.TransCmp cmp] : Decidable (cmpEq cmp x y) := decidable_of_iff' _ cmpEq_iff

/-- `O(n)`. Verifies an ordering relation on the nodes of the tree. -/
def isOrdered (cmp : α → α → Ordering)
    (t : RBNode α) (l : Option α := none) (r : Option α := none) : Bool :=
  match t with
  | nil =>
    match l, r with
    | some l, some r => cmp l r = .lt
    | _, _ => true
  | node _ a v b => isOrdered cmp a l v && isOrdered cmp b v r

/-- The first half of Okasaki's `balance`, concerning red-red sequences in the left child. -/
@[inline] def balance1 : RBNode α → α → RBNode α → RBNode α
  | node red (node red a x b) y c, z, d
  | node red a x (node red b y c), z, d => node red (node black a x b) y (node black c z d)
  | a,                             x, b => node black a x b

/-- The second half of Okasaki's `balance`, concerning red-red sequences in the right child. -/
@[inline] def balance2 : RBNode α → α → RBNode α → RBNode α
  | a, x, node red b y (node red c z d)
  | a, x, node red (node red b y c) z d => node red (node black a x b) y (node black c z d)
  | a, x, b                             => node black a x b

/-- Returns `red` if the node is red, otherwise `black`. (Nil nodes are treated as `black`.) -/
@[inline] def isRed : RBNode α → RBColor
  | node c .. => c
  | _         => black

/--
Returns `black` if the node is black, otherwise `red`.
(Nil nodes are treated as `red`, which is not the usual convention but useful for deletion.)
-/
@[inline] def isBlack : RBNode α → RBColor
  | node c .. => c
  | _         => red

/-- Changes the color of the root to `black`. -/
def setBlack : RBNode α → RBNode α
  | nil          => nil
  | node _ l v r => node black l v r

/-- `O(n)`. Reverses the ordering of the tree without any rebalancing. -/
@[simp] def reverse : RBNode α → RBNode α
  | nil          => nil
  | node c l v r => node c r.reverse v l.reverse

section Insert

/--
The core of the `insert` function. This adds an element `x` to a balanced red-black tree.
Importantly, the result of calling `ins` is not a proper red-black tree,
because it has a broken balance invariant.
(See `Balanced.ins` for the balance invariant of `ins`.)
The `insert` function does the final fixup needed to restore the invariant.
-/
@[specialize] def ins (cmp : α → α → Ordering) (x : α) : RBNode α → RBNode α
  | nil => node red nil x nil
  | node red a y b =>
    match cmp x y with
    | Ordering.lt => node red (ins cmp x a) y b
    | Ordering.gt => node red a y (ins cmp x b)
    | Ordering.eq => node red a x b
  | node black a y b =>
    match cmp x y with
    | Ordering.lt => balance1 (ins cmp x a) y b
    | Ordering.gt => balance2 a y (ins cmp x b)
    | Ordering.eq => node black a x b

/--
`insert cmp t v` inserts element `v` into the tree, using the provided comparator
`cmp` to put it in the right place and automatically rebalancing the tree as necessary.
-/
@[specialize] def insert (cmp : α → α → Ordering) (t : RBNode α) (v : α) : RBNode α :=
  match isRed t with
  | red => (ins cmp v t).setBlack
  | black => ins cmp v t

end Insert

/-- Recolor the root of the tree to `red` if possible. -/
def setRed : RBNode α → RBNode α
  | node _ a v b => node red a v b
  | nil          => nil

/-- Rebalancing a tree which has shrunk on the left. -/
def balLeft (l : RBNode α) (v : α) (r : RBNode α) : RBNode α :=
  match l with
  | node red a x b                    => node red (node black a x b) v r
  | l => match r with
    | node black a y b                => balance2 l v (node red a y b)
    | node red (node black a y b) z c => node red (node black l v a) y (balance2 b z (setRed c))
    | r                               => node red l v r -- unreachable

/-- Rebalancing a tree which has shrunk on the right. -/
def balRight (l : RBNode α) (v : α) (r : RBNode α) : RBNode α :=
  match r with
  | node red b y c                    => node red l v (node black b y c)
  | r => match l with
    | node black a x b                => balance1 (node red a x b) v r
    | node red a x (node black b y c) => node red (balance1 (setRed a) x b) y (node black c v r)
    | l                               => node red l v r -- unreachable

/-- The number of nodes in the tree. -/
@[simp] def size : RBNode α → Nat
  | nil => 0
  | node _ x _ y => x.size + y.size + 1

/-- Concatenate two trees with the same black-height. -/
def append : RBNode α → RBNode α → RBNode α
  | nil, x | x, nil => x
  | node red a x b, node red c y d =>
    match append b c with
    | node red b' z c' => node red (node red a x b') z (node red c' y d)
    | bc               => node red a x (node red bc y d)
  | node black a x b, node black c y d =>
    match append b c with
    | node red b' z c' => node red (node black a x b') z (node black c' y d)
    | bc               => balLeft a x (node black bc y d)
  | a@(node black ..), node red b x c => node red (append a b) x c
  | node red a x b, c@(node black ..) => node red a x (append b c)
termination_by x y => x.size + y.size

/-! ## erase -/

/--
The core of the `erase` function. The tree returned from this function has a broken invariant,
which is restored in `erase`.
-/
@[specialize] def del (cut : α → Ordering) : RBNode α → RBNode α
  | nil          => nil
  | node _ a y b =>
    match cut y with
    | .lt => match a.isBlack with
      | black => balLeft (del cut a) y b
      | red => node red (del cut a) y b
    | .gt => match b.isBlack with
      | black => balRight a y (del cut b)
      | red => node red a y (del cut b)
    | .eq => append a b

/--
The `erase cut t` function removes an element from the tree `t`.
The `cut` function is used to locate an element in the tree:
it returns `.gt` if we go too high and `.lt` if we go too low;
if it returns `.eq` we will remove the element.
(The function `cmp k` for some key `k` is a valid cut function, but we can also use cuts that
are not of this form as long as they are suitably monotonic.)
-/
@[specialize] def erase (cut : α → Ordering) (t : RBNode α) : RBNode α := (del cut t).setBlack

/-- Finds an element in the tree satisfying the `cut` function. -/
@[specialize] def find? (cut : α → Ordering) : RBNode α → Option α
  | nil => none
  | node _ a y b =>
    match cut y with
    | .lt => find? cut a
    | .gt => find? cut b
    | .eq => some y

/-- `upperBound? cut` retrieves the smallest entry larger than or equal to `cut`, if it exists. -/
@[specialize] def upperBound? (cut : α → Ordering) : RBNode α → (ub : Option α := .none) → Option α
  | nil,          ub => ub
  | node _ a y b, ub =>
    match cut y with
    | .lt => upperBound? cut a (some y)
    | .gt => upperBound? cut b ub
    | .eq => some y

/-- `lowerBound? cut` retrieves the largest entry smaller than or equal to `cut`, if it exists. -/
@[specialize] def lowerBound? (cut : α → Ordering) : RBNode α → (lb : Option α := .none) → Option α
  | nil,          lb => lb
  | node _ a y b, lb =>
    match cut y with
    | .lt => lowerBound? cut a lb
    | .gt => lowerBound? cut b (some y)
    | .eq => some y

/-- Returns the root of the tree, if any. -/
def root? : RBNode α → Option α
  | nil => none
  | node _ _ v _ => some v

/--
`O(n)`. Map a function on every value in the tree.
This requires `IsMonotone` on the function in order to preserve the order invariant.
-/
@[specialize] def map (f : α → β) : RBNode α → RBNode β
  | nil => nil
  | node c l v r => node c (l.map f) (f v) (r.map f)

/-- Converts the tree into an array in increasing sorted order. -/
def toArray (n : RBNode α) : Array α := n.foldl (init := #[]) (·.push ·)

/--
A `RBNode.Path α` is a "cursor" into an `RBNode` which represents the path
from the root to a subtree. Note that the path goes from the target subtree
up to the root, which is reversed from the normal way data is stored in the tree.
See [Zipper](https://en.wikipedia.org/wiki/Zipper_(data_structure)) for more information.
-/
inductive Path (α : Type u) where
  /-- The root of the tree, which is the end of the path of parents. -/
  | root
  /-- A path that goes down the left subtree. -/
  | left (c : RBColor) (parent : Path α) (v : α) (r : RBNode α)
  /-- A path that goes down the right subtree. -/
  | right (c : RBColor) (l : RBNode α) (v : α) (parent : Path α)

/-- Fills the `Path` with a subtree. -/
def Path.fill : Path α → RBNode α → RBNode α
  | .root, t => t
  | .left c parent y b, a
  | .right c a y parent, b => parent.fill (node c a y b)

/--
Like `find?`, but instead of just returning the element, it returns the entire subtree
at the element and a path back to the root for reconstructing the tree.
-/
@[specialize] def zoom (cut : α → Ordering) : RBNode α → (e : Path α := .root) → RBNode α × Path α
  | nil, path => (nil, path)
  | n@(node c a y b), path =>
    match cut y with
    | .lt => zoom cut a (.left c path y b)
    | .gt => zoom cut b (.right c a y path)
    | .eq => (n, path)

/--
This function does the second part of `RBNode.ins`,
which unwinds the stack and rebuilds the tree.
-/
def Path.ins : Path α → RBNode α → RBNode α
  | .root, t => t.setBlack
  | .left red parent y b, a
  | .right red a y parent, b => parent.ins (node red a y b)
  | .left black parent y b, a => parent.ins (balance1 a y b)
  | .right black a y parent, b => parent.ins (balance2 a y b)

/--
`path.insertNew v` inserts element `v` into the tree, assuming that `path` is zoomed in
on a `nil` node such that inserting a new element at this position is valid.
-/
@[inline] def Path.insertNew (path : Path α) (v : α) : RBNode α :=
  path.ins (node red nil v nil)

/--
`path.insert t v` inserts element `v` into the tree, assuming that `(t, path)` was the result of a
previous `zoom` operation (so either the root of `t` is equivalent to `v` or it is empty).
-/
def Path.insert (path : Path α) (t : RBNode α) (v : α) : RBNode α :=
  match t with
  | nil => path.insertNew v
  | node c a _ b => path.fill (node c a v b)

/--
`path.del t c` does the second part of `RBNode.del`, which unwinds the stack
and rebuilds the tree. The `c` argument is the color of the node before the deletion
(we used `t₀.isBlack` for this in `RBNode.del` but the original tree is no longer
available in this formulation).
-/
def Path.del : Path α → RBNode α → RBColor → RBNode α
  | .root, t, _ => t.setBlack
  | .left c parent y b, a, red
  | .right c a y parent, b, red => parent.del (node red a y b) c
  | .left c parent y b, a, black => parent.del (balLeft a y b) c
  | .right c a y parent, b, black => parent.del (balRight a y b) c

/--
`path.erase t v` removes the root element of `t` from the tree, assuming that `(t, path)` was
the result of a previous `zoom` operation.
-/
def Path.erase (path : Path α) (t : RBNode α) : RBNode α :=
  match t with
  | nil => path.fill nil
  | node c a _ b => path.del (a.append b) c

/--
`modify cut f t` uses `cut` to find an element,
then modifies the element using `f` and reinserts it into the tree.

Because the tree structure is not modified,
`f` must not modify the ordering properties of the element.

The element in `t` is used linearly if `t` is unshared.
-/
@[specialize] def modify (cut : α → Ordering) (f : α → α) (t : RBNode α) : RBNode α :=
  match zoom cut t with
  | (nil, _) => t -- TODO: profile whether it would be better to use `path.fill nil` here
  | (node c a x b, path) => path.fill (node c a (f x) b)

/--
`alter cut f t` simultaneously handles inserting, erasing and replacing an element
using a function `f : Option α → Option α`. It is passed the result of `t.find? cut`
and can either return `none` to remove the element or `some a` to replace/insert
the element with `a` (which must have the same ordering properties as the original element).

The element is used linearly if `t` is unshared.
-/
@[specialize] def alter (cut : α → Ordering) (f : Option α → Option α) (t : RBNode α) : RBNode α :=
  match zoom cut t with
  | (nil, path) =>
    match f none with
    | none => t -- TODO: profile whether it would be better to use `path.fill nil` here
    | some y => path.insertNew y
  | (node c a x b, path) =>
    match f (some x) with
    | none => path.del (a.append b) c
    | some y => path.fill (node c a y b)

/--
The ordering invariant of a red-black tree, which is a binary search tree.
This says that every element of a left subtree is less than the root, and
every element in the right subtree is greater than the root, where the
less than relation `x < y` is understood to mean `cmp x y = .lt`.

Because we do not assume that `cmp` is lawful when stating this property,
we write it in such a way that if `cmp` is not lawful then the condition holds trivially.
That way we can prove the ordering invariants without assuming `cmp` is lawful.
-/
def Ordered (cmp : α → α → Ordering) : RBNode α → Prop
  | nil => True
  | node _ a x b => a.All (cmpLT cmp · x) ∧ b.All (cmpLT cmp x ·) ∧ a.Ordered cmp ∧ b.Ordered cmp

-- This is in the Slow namespace because it is `O(n^2)` where a `O(n)` algorithm exists
-- (see `isOrdered_iff` in `Data.RBMap.Lemmas`). Prefer `isOrdered` or the other instance.
@[nolint docBlame] scoped instance Slow.instDecidableOrdered (cmp) [Std.TransCmp cmp] :
    ∀ t : RBNode α, Decidable (Ordered cmp t)
  | nil => inferInstanceAs (Decidable True)
  | node _ a _ b =>
    haveI := instDecidableOrdered cmp a
    haveI := instDecidableOrdered cmp b
    inferInstanceAs (Decidable (And ..))

/--
The red-black balance invariant. `Balanced t c n` says that the color of the root node is `c`,
and the black-height (the number of black nodes on any path from the root) of the tree is `n`.
Additionally, every red node must have black children.
-/
inductive Balanced : RBNode α → RBColor → Nat → Prop where
  /-- A nil node is balanced with black-height 0, and it is considered black. -/
  | protected nil : Balanced nil black 0
  /-- A red node is balanced with black-height `n`
  if its children are both black with with black-height `n`. -/
  | protected red : Balanced x black n → Balanced y black n → Balanced (node red x v y) red n
  /-- A black node is balanced with black-height `n + 1`
  if its children both have black-height `n`. -/
  | protected black : Balanced x c₁ n → Balanced y c₂ n → Balanced (node black x v y) black (n + 1)

/--
The well-formedness invariant for a red-black tree. The first constructor is the real invariant,
and the others allow us to "cheat" in this file and define `insert` and `erase`,
which have more complex proofs that are delayed to `Batteries.Data.RBMap.Lemmas`.
-/
inductive WF (cmp : α → α → Ordering) : RBNode α → Prop
  /-- The actual well-formedness invariant: a red-black tree has the
  ordering and balance invariants. -/
  | mk : t.Ordered cmp → t.Balanced c n → WF cmp t
  /-- Inserting into a well-formed tree yields another well-formed tree.
  (See `Ordered.insert` and `Balanced.insert` for the actual proofs.) -/
  | insert : WF cmp t → WF cmp (t.insert cmp a)
  /-- Erasing from a well-formed tree yields another well-formed tree.
  (See `Ordered.erase` and `Balanced.erase` for the actual proofs.) -/
  | erase : WF cmp t → WF cmp (t.erase cut)

end RBNode

open RBNode

/--
An `RBSet` is a self-balancing binary search tree.
The `cmp` function is the comparator that will be used for performing searches;
it should satisfy the requirements of `TransCmp` for it to have sensible behavior.
-/
def RBSet (α : Type u) (cmp : α → α → Ordering) : Type u := {t : RBNode α // t.WF cmp}

/-- `O(1)`. Construct a new empty tree. -/
@[inline] def mkRBSet (α : Type u) (cmp : α → α → Ordering) : RBSet α cmp := ⟨.nil, .mk ⟨⟩ .nil⟩

namespace RBSet

/-- `O(1)`. Construct a new empty tree. -/
@[inline] def empty : RBSet α cmp := mkRBSet ..

instance (α : Type u) (cmp : α → α → Ordering) : EmptyCollection (RBSet α cmp) := ⟨empty⟩

instance (α : Type u) (cmp : α → α → Ordering) : Inhabited (RBSet α cmp) := ⟨∅⟩

/-- `O(1)`. Construct a new tree with one element `v`. -/
@[inline] def single (v : α) : RBSet α cmp :=
  ⟨.node .red .nil v .nil, .mk ⟨⟨⟩, ⟨⟩, ⟨⟩, ⟨⟩⟩ (.red .nil .nil)⟩

/-- `O(n)`. Fold a function on the values from left to right (in increasing order). -/
@[inline] def foldl (f : σ → α → σ) (init : σ) (t : RBSet α cmp) : σ := t.1.foldl f init

/-- `O(n)`. Fold a function on the values from right to left (in decreasing order). -/
@[inline] def foldr (f : α → σ → σ) (init : σ) (t : RBSet α cmp) : σ := t.1.foldr f init

/-- `O(n)`. Fold a monadic function on the values from left to right (in increasing order). -/
@[inline] def foldlM [Monad m] (f : σ → α → m σ) (init : σ) (t : RBSet α cmp) : m σ :=
  t.1.foldlM f init

/-- `O(n)`. Run monadic function `f` on each element of the tree (in increasing order). -/
@[inline] def forM [Monad m] (f : α → m PUnit) (t : RBSet α cmp) : m PUnit := t.1.forM f

instance : ForIn m (RBSet α cmp) α where
  forIn t := t.1.forIn

instance : ToStream (RBSet α cmp) (RBNode.Stream α) := ⟨fun x => x.1.toStream .nil⟩

/-- `O(1)`. Is the tree empty? -/
@[inline] def isEmpty : RBSet α cmp → Bool
  | ⟨nil, _⟩ => true
  | _        => false

/-- `O(n)`. Convert the tree to a list in ascending order. -/
@[inline] def toList (t : RBSet α cmp) : List α := t.1.toList

/-- `O(log n)`. Returns the entry `a` such that `a ≤ k` for all keys in the RBSet. -/
@[inline] protected def min? (t : RBSet α cmp) : Option α := t.1.min?

/-- `O(log n)`. Returns the entry `a` such that `a ≥ k` for all keys in the RBSet. -/
@[inline] protected def max? (t : RBSet α cmp) : Option α := t.1.max?

instance [Repr α] : Repr (RBSet α cmp) where
  reprPrec m prec := Repr.addAppParen ("RBSet.ofList " ++ repr m.toList) prec

/-- `O(log n)`. Insert element `v` into the tree. -/
@[inline] def insert (t : RBSet α cmp) (v : α) : RBSet α cmp := ⟨t.1.insert cmp v, t.2.insert⟩

/--
Insert all elements from a collection into a `RBSet α cmp`.
-/
def insertMany [ForIn Id ρ α] (s : RBSet α cmp) (as : ρ) :
    RBSet α cmp := Id.run do
  let mut s := s
  for a in as do
    s := s.insert a
  return s

/--
`O(log n)`. Remove an element from the tree using a cut function.
The `cut` function is used to locate an element in the tree:
it returns `.gt` if we go too high and `.lt` if we go too low;
if it returns `.eq` we will remove the element.
(The function `cmp k` for some key `k` is a valid cut function, but we can also use cuts that
are not of this form as long as they are suitably monotonic.)
-/
@[inline] def erase (t : RBSet α cmp) (cut : α → Ordering) : RBSet α cmp :=
  ⟨t.1.erase cut, t.2.erase⟩

/-- `O(log n)`. Find an element in the tree using a cut function. -/
@[inline] def findP? (t : RBSet α cmp) (cut : α → Ordering) : Option α := t.1.find? cut

/-- `O(log n)`. Returns an element in the tree equivalent to `x` if one exists. -/
@[inline] def find? (t : RBSet α cmp) (x : α) : Option α := t.1.find? (cmp x)

/-- `O(log n)`. Find an element in the tree, or return a default value `v₀`. -/
@[inline] def findPD (t : RBSet α cmp) (cut : α → Ordering) (v₀ : α) : α := (t.findP? cut).getD v₀

/--
`O(log n)`. `upperBoundP cut` retrieves the smallest entry comparing `gt` or `eq` under `cut`,
if it exists. If multiple keys in the map return `eq` under `cut`, any of them may be returned.
-/
@[inline] def upperBoundP? (t : RBSet α cmp) (cut : α → Ordering) : Option α := t.1.upperBound? cut

/--
`O(log n)`. `upperBound? k` retrieves the largest entry smaller than or equal to `k`,
if it exists.
-/
@[inline] def upperBound? (t : RBSet α cmp) (k : α) : Option α := t.upperBoundP? (cmp k)

/--
`O(log n)`. `lowerBoundP cut` retrieves the largest entry comparing `lt` or `eq` under `cut`,
if it exists. If multiple keys in the map return `eq` under `cut`, any of them may be returned.
-/
@[inline] def lowerBoundP? (t : RBSet α cmp) (cut : α → Ordering) : Option α := t.1.lowerBound? cut

/--
`O(log n)`. `lowerBound? k` retrieves the largest entry smaller than or equal to `k`,
if it exists.
-/
@[inline] def lowerBound? (t : RBSet α cmp) (k : α) : Option α := t.lowerBoundP? (cmp k)

/-- `O(log n)`. Returns true if the given cut returns `eq` for something in the RBSet. -/
@[inline] def containsP (t : RBSet α cmp) (cut : α → Ordering) : Bool := (t.findP? cut).isSome

/-- `O(log n)`. Returns true if the given key `a` is in the RBSet. -/
@[inline] def contains (t : RBSet α cmp) (a : α) : Bool := (t.find? a).isSome

/-- `O(n log n)`. Build a tree from an unsorted list by inserting them one at a time. -/
@[inline] def ofList (l : List α) (cmp : α → α → Ordering) : RBSet α cmp :=
  l.foldl (fun r p => r.insert p) (mkRBSet α cmp)

/-- `O(n log n)`. Build a tree from an unsorted array by inserting them one at a time. -/
@[inline] def ofArray (l : Array α) (cmp : α → α → Ordering) : RBSet α cmp :=
  l.foldl (fun r p => r.insert p) (mkRBSet α cmp)

/-- `O(n)`. Returns true if the given predicate is true for all items in the RBSet. -/
@[inline] def all (t : RBSet α cmp) (p : α → Bool) : Bool := t.1.all p

/-- `O(n)`. Returns true if the given predicate is true for any item in the RBSet. -/
@[inline] def any (t : RBSet α cmp) (p : α → Bool) : Bool := t.1.any p

/--
Asserts that `t₁` and `t₂` have the same number of elements in the same order,
and `R` holds pairwise between them. The tree structure is ignored.
-/
@[inline] def all₂ (R : α → β → Bool) (t₁ : RBSet α cmpα) (t₂ : RBSet β cmpβ) : Bool :=
  t₁.1.all₂ R t₂.1

/-- True if `x` is an element of `t` "exactly", i.e. up to equality, not the `cmp` relation. -/
def EMem (x : α) (t : RBSet α cmp) : Prop := t.1.EMem x

/-- True if the specified `cut` matches at least one element of of `t`. -/
def MemP (cut : α → Ordering) (t : RBSet α cmp) : Prop := t.1.MemP cut

/-- True if `x` is equivalent to an element of `t`. -/
def Mem (x : α) (t : RBSet α cmp) : Prop := MemP (cmp x) t

instance : Membership α (RBSet α cmp) where
  mem t x := Mem x t

-- These instances are put in a special namespace because they are usually not what users want
-- when deciding membership in a RBSet, since this does a naive linear search through the tree.
-- The real `O(log n)` instances are defined in `Data.RBMap.Lemmas`.
@[nolint docBlame] scoped instance Slow.instDecidableEMem [DecidableEq α] {t : RBSet α cmp} :
    Decidable (EMem x t) := inferInstanceAs (Decidable (Any ..))

@[nolint docBlame] scoped instance Slow.instDecidableMemP {t : RBSet α cmp} :
    Decidable (MemP cut t) := inferInstanceAs (Decidable (Any ..))

@[nolint docBlame] scoped instance Slow.instDecidableMem {t : RBSet α cmp} :
    Decidable (Mem x t) := inferInstanceAs (Decidable (Any ..))

/--
Returns true if `t₁` and `t₂` are equal as sets (assuming `cmp` and `==` are compatible),
ignoring the internal tree structure.
-/
instance [BEq α] : BEq (RBSet α cmp) where
  beq a b := a.all₂ (· == ·) b

/-- `O(n)`. The number of items in the RBSet. -/
def size (m : RBSet α cmp) : Nat := m.1.size

/-- `O(log n)`. Returns the minimum element of the tree, or panics if the tree is empty. -/
@[inline] def min! [Inhabited α] (t : RBSet α cmp) : α := t.min?.getD (panic! "tree is empty")

/-- `O(log n)`. Returns the maximum element of the tree, or panics if the tree is empty. -/
@[inline] def max! [Inhabited α] (t : RBSet α cmp) : α := t.max?.getD (panic! "tree is empty")

/--
`O(log n)`. Attempts to find the value with key `k : α` in `t` and panics if there is no such key.
-/
@[inline] def findP! [Inhabited α] (t : RBSet α cmp) (cut : α → Ordering) : α :=
  (t.findP? cut).getD (panic! "key is not in the tree")

/--
`O(log n)`. Attempts to find the value with key `k : α` in `t` and panics if there is no such key.
-/
@[inline] def find! [Inhabited α] (t : RBSet α cmp) (k : α) : α :=
  (t.find? k).getD (panic! "key is not in the tree")

/-- The predicate asserting that the result of `modifyP` is safe to construct. -/
class ModifyWF (t : RBSet α cmp) (cut : α → Ordering) (f : α → α) : Prop where
  /-- The resulting tree is well formed. -/
  wf : (t.1.modify cut f).WF cmp

/--
`O(log n)`. In-place replace an element found by `cut`.
This takes the element out of the tree while `f` runs,
so it uses the element linearly if `t` is unshared.

The `ModifyWF` assumption is required because `f` may change
the ordering properties of the element, which would break the invariants.
-/
def modifyP (t : RBSet α cmp) (cut : α → Ordering) (f : α → α)
    [wf : ModifyWF t cut f] : RBSet α cmp := ⟨t.1.modify cut f, wf.wf⟩

/-- The predicate asserting that the result of `alterP` is safe to construct. -/
class AlterWF (t : RBSet α cmp) (cut : α → Ordering) (f : Option α → Option α) : Prop where
  /-- The resulting tree is well formed. -/
  wf : (t.1.alter cut f).WF cmp

/--
`O(log n)`. `alterP cut f t` simultaneously handles inserting, erasing and replacing an element
using a function `f : Option α → Option α`. It is passed the result of `t.findP? cut`
and can either return `none` to remove the element or `some a` to replace/insert
the element with `a` (which must have the same ordering properties as the original element).

The element is used linearly if `t` is unshared.

The `AlterWF` assumption is required because `f` may change
the ordering properties of the element, which would break the invariants.
-/
def alterP (t : RBSet α cmp) (cut : α → Ordering) (f : Option α → Option α)
    [wf : AlterWF t cut f] : RBSet α cmp := ⟨t.1.alter cut f, wf.wf⟩

/--
`O(n₂ * log (n₁ + n₂))`. Merges the maps `t₁` and `t₂`.
If equal keys exist in both, the key from `t₂` is preferred.
-/
def union (t₁ t₂ : RBSet α cmp) : RBSet α cmp :=
  t₂.foldl .insert t₁

instance : Union (RBSet α cmp) := ⟨RBSet.union⟩

/--
`O(n₂ * log (n₁ + n₂))`. Merges the maps `t₁` and `t₂`. If equal keys exist in both,
then use `mergeFn a₁ a₂` to produce the new merged value.
-/
def mergeWith (mergeFn : α → α → α) (t₁ t₂ : RBSet α cmp) : RBSet α cmp :=
  t₂.foldl (init := t₁) fun t₁ a₂ =>
    t₁.insert <| match t₁.find? a₂ with | some a₁ => mergeFn a₁ a₂ | none => a₂

/--
`O(n₁ * log (n₁ + n₂))`. Intersects the maps `t₁` and `t₂`
using `mergeFn a b` to produce the new value.
-/
def intersectWith (cmp : α → β → Ordering) (mergeFn : α → β → γ)
    (t₁ : RBSet α cmpα) (t₂ : RBSet β cmpβ) : RBSet γ cmpγ :=
  t₁.foldl (init := ∅) fun acc a =>
    match t₂.findP? (cmp a) with
    | some b => acc.insert <| mergeFn a b
    | none => acc

/-- `O(n * log n)`. Constructs the set of all elements satisfying `p`. -/
def filter (t : RBSet α cmp) (p : α → Bool) : RBSet α cmp :=
  t.foldl (init := ∅) fun acc a => bif p a then acc.insert a else acc

/--
`O(n * log n)`. Map a function on every value in the set.
If the function is monotone, consider using the more efficient `RBSet.mapMonotone` instead.
-/
def map (t : RBSet α cmpα) (f : α → β) : RBSet β cmpβ :=
  t.foldl (init := ∅) fun acc a => acc.insert <| f a

/--
`O(n₁ * (log n₁ + log n₂))`. Constructs the set of all elements of `t₁` that are not in `t₂`.
-/
def sdiff (t₁ t₂ : RBSet α cmp) : RBSet α cmp := t₁.filter (!t₂.contains ·)

instance : SDiff (Batteries.RBSet α cmp) := ⟨RBSet.sdiff⟩

end RBSet

/- TODO(Leo): define dRBMap -/

/--
An `RBMap` is a self-balancing binary search tree, used to store a key-value map.
The `cmp` function is the comparator that will be used for performing searches;
it should satisfy the requirements of `TransCmp` for it to have sensible behavior.
-/
def RBMap (α : Type u) (β : Type v) (cmp : α → α → Ordering) : Type (max u v) :=
  RBSet (α × β) (Ordering.byKey Prod.fst cmp)

/-- `O(1)`. Construct a new empty map. -/
@[inline] def mkRBMap (α : Type u) (β : Type v) (cmp : α → α → Ordering) : RBMap α β cmp :=
  mkRBSet ..

/-- `O(1)`. Construct a new empty map. -/
@[inline] def RBMap.empty {α : Type u} {β : Type v} {cmp : α → α → Ordering} : RBMap α β cmp :=
  mkRBMap ..

instance (α : Type u) (β : Type v) (cmp : α → α → Ordering) : EmptyCollection (RBMap α β cmp) :=
  ⟨RBMap.empty⟩

instance (α : Type u) (β : Type v) (cmp : α → α → Ordering) : Inhabited (RBMap α β cmp) := ⟨∅⟩

/-- `O(1)`. Construct a new tree with one key-value pair `k, v`. -/
@[inline] def RBMap.single (k : α) (v : β) : RBMap α β cmp := RBSet.single (k, v)

namespace RBMap
variable {α : Type u} {β : Type v} {σ : Type w} {cmp : α → α → Ordering}

/-- `O(n)`. Fold a function on the values from left to right (in increasing order). -/
@[inline] def foldl (f : σ → α → β → σ) : (init : σ) → RBMap α β cmp → σ
  | b, ⟨t, _⟩ => t.foldl (fun s (a, b) => f s a b) b

/-- `O(n)`. Fold a function on the values from right to left (in decreasing order). -/
@[inline] def foldr (f : α → β → σ → σ) : (init : σ) → RBMap α β cmp → σ
  | b, ⟨t, _⟩ => t.foldr (fun (a, b) s => f a b s) b

/-- `O(n)`. Fold a monadic function on the values from left to right (in increasing order). -/
@[inline] def foldlM [Monad m] (f : σ → α → β → m σ) : (init : σ) → RBMap α β cmp → m σ
  | b, ⟨t, _⟩ => t.foldlM (fun s (a, b) => f s a b) b

/-- `O(n)`. Run monadic function `f` on each element of the tree (in increasing order). -/
@[inline] def forM [Monad m] (f : α → β → m PUnit) (t : RBMap α β cmp) : m PUnit :=
  t.1.forM (fun (a, b) => f a b)

instance : ForIn m (RBMap α β cmp) (α × β) := inferInstanceAs (ForIn _ (RBSet ..) _)

instance : ToStream (RBMap α β cmp) (RBNode.Stream (α × β)) :=
  inferInstanceAs (ToStream (RBSet ..) _)

/-- `O(n)`. Constructs the array of keys of the map. -/
@[inline] def keysArray (t : RBMap α β cmp) : Array α :=
  t.1.foldl (init := #[]) (·.push ·.1)

/-- `O(n)`. Constructs the list of keys of the map. -/
@[inline] def keysList (t : RBMap α β cmp) : List α :=
  t.1.foldr (init := []) (·.1 :: ·)

/--
An "iterator" over the keys of the map. This is a trivial wrapper over the underlying map,
but it comes with a small API to use it in a `for` loop or convert it to an array or list.
-/
def Keys (α β cmp) := RBMap α β cmp

/--
The keys of the map. This is an `O(1)` wrapper operation, which
can be used in `for` loops or converted to an array or list.
-/
@[inline] def keys (t : RBMap α β cmp) : Keys α β cmp := t

@[inline, inherit_doc keysArray] def Keys.toArray := @keysArray

@[inline, inherit_doc keysList] def Keys.toList := @keysList

instance : CoeHead (Keys α β cmp) (Array α) := ⟨keysArray⟩

instance : CoeHead (Keys α β cmp) (List α) := ⟨keysList⟩

instance : ForIn m (Keys α β cmp) α where
  forIn t init f := t.val.forIn init (f ·.1)

instance : ForM m (Keys α β cmp) α where
  forM t f := t.val.forM (f ·.1)

/-- The result of `toStream` on a `Keys`. -/
def Keys.Stream (α β) := RBNode.Stream (α × β)

/-- A stream over the iterator. -/
def Keys.toStream (t : Keys α β cmp) : Keys.Stream α β := t.1.toStream

/-- `O(1)` amortized, `O(log n)` worst case: Get the next element from the stream. -/
def Keys.Stream.next? (t : Stream α β) : Option (α × Stream α β) :=
  match inline (RBNode.Stream.next? t) with
  | none => none
  | some ((a, _), t) => some (a, t)

instance : ToStream (Keys α β cmp) (Keys.Stream α β) := ⟨Keys.toStream⟩
instance : Stream (Keys.Stream α β) α := ⟨Keys.Stream.next?⟩

/-- `O(n)`. Constructs the array of values of the map. -/
@[inline] def valuesArray (t : RBMap α β cmp) : Array β :=
  t.1.foldl (init := #[]) (·.push ·.2)

/-- `O(n)`. Constructs the list of values of the map. -/
@[inline] def valuesList (t : RBMap α β cmp) : List β :=
  t.1.foldr (init := []) (·.2 :: ·)

/--
An "iterator" over the values of the map. This is a trivial wrapper over the underlying map,
but it comes with a small API to use it in a `for` loop or convert it to an array or list.
-/
def Values (α β cmp) := RBMap α β cmp

/--
The "keys" of the map. This is an `O(1)` wrapper operation, which
can be used in `for` loops or converted to an array or list.
-/
@[inline] def values (t : RBMap α β cmp) : Values α β cmp := t

@[inline, inherit_doc valuesArray] def Values.toArray := @valuesArray

@[inline, inherit_doc valuesList] def Values.toList := @valuesList

instance : CoeHead (Values α β cmp) (Array β) := ⟨valuesArray⟩

instance : CoeHead (Values α β cmp) (List β) := ⟨valuesList⟩

instance : ForIn m (Values α β cmp) β where
  forIn t init f := t.val.forIn init (f ·.2)

instance : ForM m (Values α β cmp) β where
  forM t f := t.val.forM (f ·.2)

/-- The result of `toStream` on a `Values`. -/
def Values.Stream (α β) := RBNode.Stream (α × β)

/-- A stream over the iterator. -/
def Values.toStream (t : Values α β cmp) : Values.Stream α β := t.1.toStream

/-- `O(1)` amortized, `O(log n)` worst case: Get the next element from the stream. -/
def Values.Stream.next? (t : Stream α β) : Option (β × Stream α β) :=
  match inline (RBNode.Stream.next? t) with
  | none => none
  | some ((_, b), t) => some (b, t)

instance : ToStream (Values α β cmp) (Values.Stream α β) := ⟨Values.toStream⟩
instance : Stream (Values.Stream α β) β := ⟨Values.Stream.next?⟩

/-- `O(1)`. Is the tree empty? -/
@[inline] def isEmpty : RBMap α β cmp → Bool := RBSet.isEmpty

/-- `O(n)`. Convert the tree to a list in ascending order. -/
@[inline] def toList : RBMap α β cmp → List (α × β) := RBSet.toList

/-- `O(log n)`. Returns the key-value pair `(a, b)` such that `a ≤ k` for all keys in the RBMap. -/
@[inline] protected def min? : RBMap α β cmp → Option (α × β) := RBSet.min?

/-- `O(log n)`. Returns the key-value pair `(a, b)` such that `a ≥ k` for all keys in the RBMap. -/
@[inline] protected def max? : RBMap α β cmp → Option (α × β) := RBSet.max?

instance [Repr α] [Repr β] : Repr (RBMap α β cmp) where
  reprPrec m prec := Repr.addAppParen ("RBMap.ofList " ++ repr m.toList) prec

/-- `O(log n)`. Insert key-value pair `(k, v)` into the tree. -/
@[inline] def insert (t : RBMap α β cmp) (k : α) (v : β) : RBMap α β cmp := RBSet.insert t (k, v)

/-- `O(log n)`. Remove an element `k` from the map. -/
@[inline] def erase (t : RBMap α β cmp) (k : α) : RBMap α β cmp := RBSet.erase t (cmp k ·.1)

/-- `O(n log n)`. Build a tree from an unsorted list by inserting them one at a time. -/
@[inline] def ofList (l : List (α × β)) (cmp : α → α → Ordering) : RBMap α β cmp :=
  RBSet.ofList l _

/-- `O(n log n)`. Build a tree from an unsorted array by inserting them one at a time. -/
@[inline] def ofArray (l : Array (α × β)) (cmp : α → α → Ordering) : RBMap α β cmp :=
  RBSet.ofArray l _

/-- `O(log n)`. Find an entry in the tree with key equal to `k`. -/
@[inline] def findEntry? (t : RBMap α β cmp) (k : α) : Option (α × β) := t.findP? (cmp k ·.1)

/-- `O(log n)`. Find the value corresponding to key `k`. -/
@[inline] def find? (t : RBMap α β cmp) (k : α) : Option β := t.findEntry? k |>.map (·.2)

/-- `O(log n)`. Find the value corresponding to key `k`, or return `v₀` if it is not in the map. -/
@[inline] def findD (t : RBMap α β cmp) (k : α) (v₀ : β) : β := (t.find? k).getD v₀

/--
`O(log n)`. `lowerBound? k` retrieves the key-value pair of the largest key
smaller than or equal to `k`, if it exists.
-/
@[inline] def lowerBound? (t : RBMap α β cmp) (k : α) : Option (α × β) :=
   RBSet.lowerBoundP? t (cmp k ·.1)

/-- `O(log n)`. Returns true if the given key `a` is in the RBMap. -/
@[inline] def contains (t : RBMap α β cmp) (a : α) : Bool := (t.findEntry? a).isSome

/-- `O(n)`. Returns true if the given predicate is true for all items in the RBMap. -/
@[inline] def all (t : RBMap α β cmp) (p : α → β → Bool) : Bool := RBSet.all t fun (a, b) => p a b

/-- `O(n)`. Returns true if the given predicate is true for any item in the RBMap. -/
@[inline] def any (t : RBMap α β cmp) (p : α → β → Bool) : Bool := RBSet.any t fun (a, b) => p a b

/--
Asserts that `t₁` and `t₂` have the same number of elements in the same order,
and `R` holds pairwise between them. The tree structure is ignored.
-/
@[inline] def all₂ (R : α × β → γ × δ → Bool) (t₁ : RBMap α β cmpα) (t₂ : RBMap γ δ cmpγ) : Bool :=
  RBSet.all₂ R t₁ t₂

/-- Asserts that `t₁` and `t₂` have the same set of keys (up to equality). -/
@[inline] def eqKeys (t₁ : RBMap α β cmp) (t₂ : RBMap α γ cmp) : Bool :=
  t₁.all₂ (cmp ·.1 ·.1 = .eq) t₂

/--
Returns true if `t₁` and `t₂` have the same keys and values
(assuming `cmp` and `==` are compatible), ignoring the internal tree structure.
-/
instance [BEq α] [BEq β] : BEq (RBMap α β cmp) := inferInstanceAs (BEq (RBSet ..))

/-- `O(n)`. The number of items in the RBMap. -/
def size : RBMap α β cmp → Nat := RBSet.size

/-- `O(log n)`. Returns the minimum element of the map, or panics if the map is empty. -/
@[inline] def min! [Inhabited α] [Inhabited β] : RBMap α β cmp → α × β := RBSet.min!

/-- `O(log n)`. Returns the maximum element of the map, or panics if the map is empty. -/
@[inline] def max! [Inhabited α] [Inhabited β] : RBMap α β cmp → α × β := RBSet.max!

/-- Attempts to find the value with key `k : α` in `t` and panics if there is no such key. -/
@[inline] def find! [Inhabited β] (t : RBMap α β cmp) (k : α) : β :=
  (t.find? k).getD (panic! "key is not in the map")

/--
`O(n₂ * log (n₁ + n₂))`. Merges the maps `t₁` and `t₂`, if a key `a : α` exists in both,
then use `mergeFn a b₁ b₂` to produce the new merged value.
-/
def mergeWith (mergeFn : α → β → β → β) (t₁ t₂ : RBMap α β cmp) : RBMap α β cmp :=
  RBSet.mergeWith (fun (_, b₁) (a, b₂) => (a, mergeFn a b₁ b₂)) t₁ t₂

/--
`O(n₁ * log (n₁ + n₂))`. Intersects the maps `t₁` and `t₂`
using `mergeFn a b` to produce the new value.
-/
def intersectWith (mergeFn : α → β → γ → δ)
    (t₁ : RBMap α β cmp) (t₂ : RBMap α γ cmp) : RBMap α δ cmp :=
  RBSet.intersectWith (cmp ·.1 ·.1) (fun (a, b₁) (_, b₂) => (a, mergeFn a b₁ b₂)) t₁ t₂

/-- `O(n * log n)`. Constructs the set of all elements satisfying `p`. -/
def filter (t : RBMap α β cmp) (p : α → β → Bool) : RBMap α β cmp :=
  RBSet.filter t fun (a, b) => p a b

/--
`O(n₁ * (log n₁ + log n₂))`. Constructs the set of all elements of `t₁` that are not in `t₂`.
-/
def sdiff (t₁ t₂ : RBMap α β cmp) : RBMap α β cmp := t₁.filter fun a _ => !t₂.contains a

end RBMap
end Batteries
open Batteries

@[inherit_doc RBMap.ofList]
abbrev List.toRBMap (l : List (α × β)) (cmp : α → α → Ordering) : RBMap α β cmp :=
  RBMap.ofList l cmp



=== LEAN SOURCE: Depth.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Batteries.Data.RBMap.WF

/-!
# RBNode depth bounds
-/

namespace Batteries.RBNode
open RBColor

/--
`O(n)`. `depth t` is the maximum number of nodes on any path to a leaf.
It is an upper bound on most tree operations.
-/
def depth : RBNode α → Nat
  | nil => 0
  | node _ a _ b => max a.depth b.depth + 1

theorem size_lt_depth : ∀ t : RBNode α, t.size < 2 ^ t.depth
  | .nil => (by decide : 0 < 1)
  | .node _ a _ b => by
    rw [size, depth, Nat.add_right_comm, Nat.pow_succ, Nat.mul_two]
    refine Nat.add_le_add
      (Nat.lt_of_lt_of_le a.size_lt_depth ?_) (Nat.lt_of_lt_of_le b.size_lt_depth ?_)
    · exact Nat.pow_le_pow_right (by decide) (Nat.le_max_left ..)
    · exact Nat.pow_le_pow_right (by decide) (Nat.le_max_right ..)

/--
`depthLB c n` is the best upper bound on the depth of any balanced red-black tree
with root colored `c` and black-height `n`.
-/
def depthLB : RBColor → Nat → Nat
  | red, n => n + 1
  | black, n => n

theorem depthLB_le : ∀ c n, n ≤ depthLB c n
  | red, _ => Nat.le_succ _
  | black, _ => Nat.le_refl _

/--
`depthUB c n` is the best upper bound on the depth of any balanced red-black tree
with root colored `c` and black-height `n`.
-/
def depthUB : RBColor → Nat → Nat
  | red, n => 2 * n + 1
  | black, n => 2 * n

theorem depthUB_le : ∀ c n, depthUB c n ≤ 2 * n + 1
  | red, _ => Nat.le_refl _
  | black, _ => Nat.le_succ _

theorem depthUB_le_two_depthLB : ∀ c n, depthUB c n ≤ 2 * depthLB c n
  | red, _ => Nat.le_succ _
  | black, _ => Nat.le_refl _

theorem Balanced.depth_le : @Balanced α t c n → t.depth ≤ depthUB c n
  | .nil => Nat.le_refl _
  | .red hl hr => Nat.succ_le_succ <| Nat.max_le.2 ⟨hl.depth_le, hr.depth_le⟩
  | .black hl hr => Nat.succ_le_succ <| Nat.max_le.2
    ⟨Nat.le_trans hl.depth_le (depthUB_le ..), Nat.le_trans hr.depth_le (depthUB_le ..)⟩

theorem Balanced.le_size : @Balanced α t c n → 2 ^ depthLB c n ≤ t.size + 1
  | .nil => Nat.le_refl _
  | .red hl hr => by
    rw [size, Nat.add_right_comm (size _), Nat.add_assoc, depthLB, Nat.pow_succ, Nat.mul_two]
    exact Nat.add_le_add hl.le_size hr.le_size
  | .black hl hr => by
    rw [size, Nat.add_right_comm (size _), Nat.add_assoc, depthLB, Nat.pow_succ, Nat.mul_two]
    refine Nat.add_le_add (Nat.le_trans ?_ hl.le_size) (Nat.le_trans ?_ hr.le_size) <;>
      exact Nat.pow_le_pow_right (by decide) (depthLB_le ..)

theorem Balanced.depth_bound (h : @Balanced α t c n) : t.depth ≤ 2 * (t.size + 1).log2 :=
  Nat.le_trans h.depth_le <| Nat.le_trans (depthUB_le_two_depthLB ..) <|
    Nat.mul_le_mul_left _ <| (Nat.le_log2 (Nat.succ_ne_zero _)).2 h.le_size

/--
A well formed tree has `t.depth ∈ O(log t.size)`, that is, it is well balanced.
This justifies the `O(log n)` bounds on most searching operations of `RBSet`.
-/
theorem WF.depth_bound {t : RBNode α} (h : t.WF cmp) : t.depth ≤ 2 * (t.size + 1).log2 :=
  let ⟨_, _, h⟩ := h.out.2; h.depth_bound



=== LEAN SOURCE: Lemmas.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Batteries.Tactic.Basic
import Batteries.Data.RBMap.Alter
import Batteries.Data.List.Lemmas

/-!
# Additional lemmas for Red-black trees
-/

namespace Batteries
namespace RBNode
open RBColor

attribute [simp] fold foldl foldr Any forM foldlM Ordered

@[simp] theorem min?_reverse (t : RBNode α) : t.reverse.min? = t.max? := by
  unfold RBNode.max?; split <;> simp [RBNode.min?]
  unfold RBNode.min?; rw [min?.match_1.eq_3]
  · apply min?_reverse
  · simpa [reverse_eq_iff]

@[simp] theorem max?_reverse (t : RBNode α) : t.reverse.max? = t.min? := by
  rw [← min?_reverse, reverse_reverse]

@[simp] theorem mem_nil {x} : ¬x ∈ (.nil : RBNode α) := by simp [Membership.mem, EMem]
@[simp] theorem mem_node {y c a x b} :
    y ∈ (.node c a x b : RBNode α) ↔ y = x ∨ y ∈ a ∨ y ∈ b := by simp [Membership.mem, EMem]

theorem All_def {t : RBNode α} : t.All p ↔ ∀ x ∈ t, p x := by
  induction t <;> simp [or_imp, forall_and, *]

theorem Any_def {t : RBNode α} : t.Any p ↔ ∃ x ∈ t, p x := by
  induction t <;> simp [or_and_right, exists_or, *]

theorem memP_def : MemP cut t ↔ ∃ x ∈ t, cut x = .eq := Any_def

theorem mem_def : Mem cmp x t ↔ ∃ y ∈ t, cmp x y = .eq := Any_def

theorem mem_congr [Std.TransCmp (α := α) cmp] {t : RBNode α} (h : cmp x y = .eq) :
    Mem cmp x t ↔ Mem cmp y t := by
  rw [Mem, Mem, iff_iff_eq]; congr; funext; rw [Std.TransCmp.congr_left h]

theorem isOrdered_iff' [Std.TransCmp (α := α) cmp] {t : RBNode α} :
    isOrdered cmp t L R ↔
    (∀ a ∈ L, t.All (cmpLT cmp a ·)) ∧
    (∀ a ∈ R, t.All (cmpLT cmp · a)) ∧
    (∀ a ∈ L, ∀ b ∈ R, cmpLT cmp a b) ∧
    Ordered cmp t := by
  induction t generalizing L R with
  | nil =>
    simp [isOrdered]; split <;> simp [cmpLT_iff]
    next h => intro _ ha _ hb; cases h _ _ ha hb
  | node _ l v r =>
    simp [isOrdered, *]
    exact ⟨
      fun ⟨⟨Ll, lv, Lv, ol⟩, ⟨vr, rR, vR, or⟩⟩ => ⟨
        fun _ h => ⟨Lv _ h, Ll _ h, (Lv _ h).trans_l vr⟩,
        fun _ h => ⟨vR _ h, (vR _ h).trans_r lv, rR _ h⟩,
        fun _ hL _ hR => (Lv _ hL).trans (vR _ hR),
        lv, vr, ol, or⟩,
      fun ⟨hL, hR, _, lv, vr, ol, or⟩ => ⟨
        ⟨fun _ h => (hL _ h).2.1, lv, fun _ h => (hL _ h).1, ol⟩,
        ⟨vr, fun _ h => (hR _ h).2.2, fun _ h => (hR _ h).1, or⟩⟩⟩

theorem isOrdered_iff [Std.TransCmp (α := α) cmp] {t : RBNode α} :
    isOrdered cmp t ↔ Ordered cmp t := by simp [isOrdered_iff']

instance (cmp) [Std.TransCmp (α := α) cmp] (t) : Decidable (Ordered cmp t) :=
  decidable_of_iff _ isOrdered_iff

/--
A cut is like a homomorphism of orderings: it is a monotonic predicate with respect to `cmp`,
but it can make things that are distinguished by `cmp` equal.
This is sufficient for `find?` to locate an element on which `cut` returns `.eq`,
but there may be other elements, not returned by `find?`, on which `cut` also returns `.eq`.
-/
class IsCut (cmp : α → α → Ordering) (cut : α → Ordering) : Prop where
  /-- The set `{x | cut x = .lt}` is downward-closed. -/
  le_lt_trans [Std.TransCmp cmp] : cmp x y ≠ .gt → cut x = .lt → cut y = .lt
  /-- The set `{x | cut x = .gt}` is upward-closed. -/
  le_gt_trans [Std.TransCmp cmp] : cmp x y ≠ .gt → cut y = .gt → cut x = .gt

theorem IsCut.lt_trans [IsCut cmp cut] [Std.TransCmp cmp]
    (H : cmp x y = .lt) : cut x = .lt → cut y = .lt :=
  IsCut.le_lt_trans <| Std.OrientedCmp.not_gt_of_gt <| Std.OrientedCmp.gt_iff_lt.2 H

theorem IsCut.gt_trans [IsCut cmp cut] [Std.TransCmp cmp]
    (H : cmp x y = .lt) : cut y = .gt → cut x = .gt :=
  IsCut.le_gt_trans <| Std.OrientedCmp.not_gt_of_gt <| Std.OrientedCmp.gt_iff_lt.2 H

theorem IsCut.congr [IsCut cmp cut] [Std.TransCmp cmp] (H : cmp x y = .eq) :
    cut x = cut y := by
  cases ey : cut y
  · exact IsCut.le_lt_trans (fun h => nomatch H.symm.trans <| Std.OrientedCmp.gt_iff_lt.1 h) ey
  · cases ex : cut x
    · exact IsCut.le_lt_trans (fun h => nomatch H.symm.trans h) ex |>.symm.trans ey
    · rfl
    · refine IsCut.le_gt_trans (cmp := cmp) (fun h => ?_) ex |>.symm.trans ey
      cases H.symm.trans <| Std.OrientedCmp.gt_iff_lt.1 h
  · exact IsCut.le_gt_trans (fun h => nomatch H.symm.trans h) ey

instance (cmp cut) [@IsCut α cmp cut] : IsCut (flip cmp) (cut · |>.swap) where
  le_lt_trans h₁ h₂ := by
    have : Std.TransCmp cmp := inferInstanceAs (Std.TransCmp (flip (flip cmp)))
    rw [IsCut.le_gt_trans (cmp := cmp) h₁ (Ordering.swap_inj.1 h₂)]; rfl
  le_gt_trans h₁ h₂ := by
    have : Std.TransCmp cmp := inferInstanceAs (Std.TransCmp (flip (flip cmp)))
    rw [IsCut.le_lt_trans (cmp := cmp) h₁ (Ordering.swap_inj.1 h₂)]; rfl

/--
`IsStrictCut` upgrades the `IsCut` property to ensure that at most one element of the tree
can match the cut, and hence `find?` will return the unique such element if one exists.
-/
class IsStrictCut (cmp : α → α → Ordering) (cut : α → Ordering) : Prop extends IsCut cmp cut where
  /-- If `cut = x`, then `cut` and `x` have compare the same with respect to other elements. -/
  exact [Std.TransCmp cmp] : cut x = .eq → cmp x y = cut y

/-- A "representable cut" is one generated by `cmp a` for some `a`. This is always a valid cut. -/
instance (cmp) (a : α) : IsStrictCut cmp (cmp a) where
  le_lt_trans h₁ h₂ := Std.TransCmp.lt_of_lt_of_le h₂ h₁
  le_gt_trans h₁ := Decidable.not_imp_not.1 (Std.TransCmp.le_trans · h₁)
  exact h := (Std.TransCmp.congr_left h).symm

instance (cmp cut) [@IsStrictCut α cmp cut] : IsStrictCut (flip cmp) (cut · |>.swap) where
  exact h := by
    have : Std.TransCmp cmp := inferInstanceAs (Std.TransCmp (flip (flip cmp)))
    rw [← IsStrictCut.exact (cmp := cmp) (Ordering.swap_inj.1 h), ← Std.OrientedCmp.eq_swap]; rfl

section fold

theorem foldr_cons (t : RBNode α) (l) : t.foldr (·::·) l = t.toList ++ l := by
  unfold toList
  induction t generalizing l with
  | nil => rfl
  | node _ a _ b iha ihb => rw [foldr, foldr, iha, iha (_::_), ihb]; simp

@[simp] theorem toList_nil : (.nil : RBNode α).toList = [] := rfl

@[simp] theorem toList_node : (.node c a x b : RBNode α).toList = a.toList ++ x :: b.toList := by
  rw [toList, foldr, foldr_cons]; rfl

@[simp] theorem toList_reverse (t : RBNode α) : t.reverse.toList = t.toList.reverse := by
  induction t <;> simp [*]

@[simp] theorem mem_toList {t : RBNode α} : x ∈ t.toList ↔ x ∈ t := by
  induction t <;> simp [*, or_left_comm]

@[simp] theorem mem_reverse {t : RBNode α} : a ∈ t.reverse ↔ a ∈ t := by rw [← mem_toList]; simp

theorem min?_eq_toList_head? {t : RBNode α} : t.min? = t.toList.head? := by
  induction t with
  | nil => rfl
  | node _ l _ _ ih =>
    cases l <;> simp [RBNode.min?, ih]

theorem max?_eq_toList_getLast? {t : RBNode α} : t.max? = t.toList.getLast? := by
  rw [← min?_reverse, min?_eq_toList_head?]; simp

theorem foldr_eq_foldr_toList {t : RBNode α} : t.foldr f init = t.toList.foldr f init := by
  induction t generalizing init <;> simp [*]

theorem foldl_eq_foldl_toList {t : RBNode α} : t.foldl f init = t.toList.foldl f init := by
  induction t generalizing init <;> simp [*]

theorem foldl_reverse {α β : Type _} {t : RBNode α} {f : β → α → β} {init : β} :
    t.reverse.foldl f init = t.foldr (flip f) init := by
  simp (config := {unfoldPartialApp := true})
    [foldr_eq_foldr_toList, foldl_eq_foldl_toList, flip]

theorem foldr_reverse {α β : Type _} {t : RBNode α} {f : α → β → β} {init : β} :
    t.reverse.foldr f init = t.foldl (flip f) init :=
  foldl_reverse.symm.trans (by simp; rfl)

theorem forM_eq_forM_toList [Monad m] [LawfulMonad m] {t : RBNode α} :
    t.forM (m := m) f = t.toList.forM f := by induction t <;> simp [*]

theorem foldlM_eq_foldlM_toList [Monad m] [LawfulMonad m] {t : RBNode α} :
    t.foldlM (m := m) f init = t.toList.foldlM f init := by
  induction t generalizing init <;> simp [*]

theorem forIn_visit_eq_bindList [Monad m] [LawfulMonad m] {t : RBNode α} :
    forIn.visit (m := m) f t init = (ForInStep.yield init).bindList f t.toList := by
  induction t generalizing init <;> simp [*, forIn.visit]

theorem forIn_eq_forIn_toList [Monad m] [LawfulMonad m] {t : RBNode α} :
    forIn (m := m) t init f = forIn t.toList init f := by
  conv => lhs; simp only [forIn, RBNode.forIn]
  rw [List.forIn_eq_bindList, forIn_visit_eq_bindList]

end fold

namespace Stream

attribute [simp] foldl foldr

theorem foldr_cons (t : RBNode.Stream α) (l) : t.foldr (·::·) l = t.toList ++ l := by
  unfold toList; apply Eq.symm; induction t <;> simp [*, foldr, RBNode.foldr_cons]

@[simp] theorem toList_nil : (.nil : RBNode.Stream α).toList = [] := rfl

@[simp] theorem toList_cons :
    (.cons x r s : RBNode.Stream α).toList = x :: r.toList ++ s.toList := by
  rw [toList, toList, foldr, RBNode.foldr_cons]; rfl

theorem foldr_eq_foldr_toList {s : RBNode.Stream α} : s.foldr f init = s.toList.foldr f init := by
  induction s <;> simp [*, RBNode.foldr_eq_foldr_toList]

theorem foldl_eq_foldl_toList {t : RBNode.Stream α} : t.foldl f init = t.toList.foldl f init := by
  induction t generalizing init <;> simp [*, RBNode.foldl_eq_foldl_toList]

theorem forIn_eq_forIn_toList [Monad m] [LawfulMonad m] {t : RBNode α} :
    forIn (m := m) t init f = forIn t.toList init f := by
  conv => lhs; simp only [forIn, RBNode.forIn]
  rw [List.forIn_eq_bindList, forIn_visit_eq_bindList]

end Stream

theorem toStream_toList' {t : RBNode α} {s} : (t.toStream s).toList = t.toList ++ s.toList := by
  induction t generalizing s <;> simp [*, toStream]

@[simp] theorem toStream_toList {t : RBNode α} : t.toStream.toList = t.toList := by
  simp [toStream_toList']

theorem Stream.next?_toList {s : RBNode.Stream α} :
    (s.next?.map fun (a, b) => (a, b.toList)) = s.toList.next? := by
  cases s <;> simp [next?, toStream_toList']

theorem ordered_iff {t : RBNode α} :
    t.Ordered cmp ↔ t.toList.Pairwise (cmpLT cmp) := by
  induction t with
  | nil => simp
  | node c l v r ihl ihr =>
    simp [*, List.pairwise_append, Ordered, All_def,
      and_assoc, and_left_comm, and_comm, imp_and, forall_and]
    exact fun _ _ hl hr a ha b hb => (hl _ ha).trans (hr _ hb)

theorem Ordered.toList_sorted {t : RBNode α} : t.Ordered cmp → t.toList.Pairwise (cmpLT cmp) :=
  ordered_iff.1

theorem min?_mem {t : RBNode α} (h : t.min? = some a) : a ∈ t := by
  rw [min?_eq_toList_head?] at h
  rw [← mem_toList]
  revert h; cases toList t <;> rintro ⟨⟩; constructor

theorem Ordered.min?_le {t : RBNode α} [Std.TransCmp cmp] (ht : t.Ordered cmp)
    (h : t.min? = some a) (x) (hx : x ∈ t) : cmp a x ≠ .gt := by
  rw [min?_eq_toList_head?] at h
  rw [← mem_toList] at hx
  have := ht.toList_sorted
  revert h hx this; cases toList t <;> rintro ⟨⟩ (_ | ⟨_, hx⟩) (_ | ⟨h1,h2⟩)
  · rw [Std.ReflCmp.compare_self (cmp := cmp)]; decide
  · rw [(h1 _ hx).1]; decide

theorem max?_mem {t : RBNode α} (h : t.max? = some a) : a ∈ t := by
  simpa using min?_mem ((min?_reverse _).trans h)

theorem Ordered.le_max? {t : RBNode α} [Std.TransCmp cmp] (ht : t.Ordered cmp)
    (h : t.max? = some a) (x) (hx : x ∈ t) : cmp x a ≠ .gt :=
  ht.reverse.min?_le ((min?_reverse _).trans h) _ (by simpa using hx)

@[simp] theorem setBlack_toList {t : RBNode α} : t.setBlack.toList = t.toList := by
  cases t <;> simp [setBlack]

@[simp] theorem setRed_toList {t : RBNode α} : t.setRed.toList = t.toList := by
  cases t <;> simp [setRed]

@[simp] theorem balance1_toList {l : RBNode α} {v r} :
    (l.balance1 v r).toList = l.toList ++ v :: r.toList := by
  unfold balance1; split <;> simp

@[simp] theorem balance2_toList {l : RBNode α} {v r} :
    (l.balance2 v r).toList = l.toList ++ v :: r.toList := by
  unfold balance2; split <;> simp

@[simp] theorem balLeft_toList {l : RBNode α} {v r} :
    (l.balLeft v r).toList = l.toList ++ v :: r.toList := by
  unfold balLeft; split <;> (try simp); split <;> simp

@[simp] theorem balRight_toList {l : RBNode α} {v r} :
    (l.balRight v r).toList = l.toList ++ v :: r.toList := by
  unfold balRight; split <;> (try simp); split <;> simp

theorem size_eq {t : RBNode α} : t.size = t.toList.length := by
  induction t <;> simp [*, size]; rfl

@[simp] theorem reverse_size (t : RBNode α) : t.reverse.size = t.size := by simp [size_eq]

@[simp] theorem Any_reverse {t : RBNode α} : t.reverse.Any p ↔ t.Any p := by simp [Any_def]

@[simp] theorem memP_reverse {t : RBNode α} : MemP cut t.reverse ↔ MemP (cut · |>.swap) t := by
  simp [MemP]

theorem Mem_reverse [Std.OrientedCmp (α := α) cmp] {t : RBNode α} :
    Mem cmp x t.reverse ↔ Mem (flip cmp) x t := by
  simp [Mem]; apply Iff.of_eq; congr; funext x; rw [← Std.OrientedCmp.eq_swap]; rfl

section find?

theorem find?_some_eq_eq {t : RBNode α} : x ∈ t.find? cut → cut x = .eq := by
  induction t <;> simp [find?]; split <;> try assumption
  intro | rfl => assumption

theorem find?_some_mem {t : RBNode α} : x ∈ t.find? cut → x ∈ t := by
  induction t <;> simp [find?]; split <;> simp (config := {contextual := true}) [*]

theorem find?_some_memP {t : RBNode α} (h : x ∈ t.find? cut) : MemP cut t :=
  memP_def.2 ⟨_, find?_some_mem h, find?_some_eq_eq h⟩

theorem Ordered.memP_iff_find? [Std.TransCmp (α := α) cmp] [IsCut cmp cut]
    (ht : Ordered cmp t) : MemP cut t ↔ ∃ x, t.find? cut = some x := by
  refine ⟨fun H => ?_, fun ⟨x, h⟩ => find?_some_memP h⟩
  induction t with simp [find?] at H ⊢
  | nil => cases H
  | node _ l _ r ihl ihr =>
    let ⟨lx, xr, hl, hr⟩ := ht
    split
    · next ev =>
      refine ihl hl ?_
      rcases H with ev' | hx | hx
      · cases ev.symm.trans ev'
      · exact hx
      · have ⟨z, hz, ez⟩ := Any_def.1 hx
        cases ez.symm.trans <| IsCut.lt_trans (All_def.1 xr _ hz).1 ev
    · next ev =>
      refine ihr hr ?_
      rcases H with ev' | hx | hx
      · cases ev.symm.trans ev'
      · have ⟨z, hz, ez⟩ := Any_def.1 hx
        cases ez.symm.trans <| IsCut.gt_trans (All_def.1 lx _ hz).1 ev
      · exact hx
    · exact ⟨_, rfl⟩

theorem Ordered.unique [Std.TransCmp (α := α) cmp] (ht : Ordered cmp t)
    (hx : x ∈ t) (hy : y ∈ t) (e : cmp x y = .eq) : x = y := by
  induction t with
  | nil => cases hx
  | node _ l _ r ihl ihr =>
    let ⟨lx, xr, hl, hr⟩ := ht
    rcases hx, hy with ⟨rfl | hx | hx, rfl | hy | hy⟩
    · rfl
    · cases e.symm.trans <| Std.OrientedCmp.gt_iff_lt.2 (All_def.1 lx _ hy).1
    · cases e.symm.trans (All_def.1 xr _ hy).1
    · cases e.symm.trans (All_def.1 lx _ hx).1
    · exact ihl hl hx hy
    · cases e.symm.trans ((All_def.1 lx _ hx).trans (All_def.1 xr _ hy)).1
    · cases e.symm.trans <| Std.OrientedCmp.gt_iff_lt.2 (All_def.1 xr _ hx).1
    · cases e.symm.trans <| Std.OrientedCmp.gt_iff_lt.2
        ((All_def.1 lx _ hy).trans (All_def.1 xr _ hx)).1
    · exact ihr hr hx hy

theorem Ordered.find?_some [Std.TransCmp (α := α) cmp] [IsStrictCut cmp cut]
    (ht : Ordered cmp t) : t.find? cut = some x ↔ x ∈ t ∧ cut x = .eq := by
  refine ⟨fun h => ⟨find?_some_mem h, find?_some_eq_eq h⟩, fun ⟨hx, e⟩ => ?_⟩
  have ⟨y, hy⟩ := ht.memP_iff_find?.1 (memP_def.2 ⟨_, hx, e⟩)
  exact ht.unique hx (find?_some_mem hy) ((IsStrictCut.exact e).trans (find?_some_eq_eq hy)) ▸ hy

@[simp] theorem find?_reverse (t : RBNode α) (cut : α → Ordering) :
    t.reverse.find? cut = t.find? (cut · |>.swap) := by
  induction t <;> simp [*, find?]
  cases cut _ <;> simp [Ordering.swap]

/--
Auxiliary definition for `zoom_ins`: set the root of the tree to `v`, creating a node if necessary.
-/
def setRoot (v : α) : RBNode α → RBNode α
  | nil => node red nil v nil
  | node c a _ b => node c a v b

/--
Auxiliary definition for `zoom_ins`: set the root of the tree to `v`, creating a node if necessary.
-/
def delRoot : RBNode α → RBNode α
  | nil => nil
  | node _ a _ b => a.append b

end find?

section «upperBound? and lowerBound?»

@[simp] theorem upperBound?_reverse (t : RBNode α) (cut ub) :
    t.reverse.upperBound? cut ub = t.lowerBound? (cut · |>.swap) ub := by
  induction t generalizing ub <;> simp [lowerBound?, upperBound?]
  split <;> simp [*, Ordering.swap]

@[simp] theorem lowerBound?_reverse (t : RBNode α) (cut lb) :
    t.reverse.lowerBound? cut lb = t.upperBound? (cut · |>.swap) lb := by
  simpa using (upperBound?_reverse t.reverse (cut · |>.swap) lb).symm

theorem upperBound?_eq_find? {t : RBNode α} {cut} (ub) (H : t.find? cut = some x) :
    t.upperBound? cut ub = some x := by
  induction t generalizing ub with simp [find?] at H
  | node c a y b iha ihb =>
    simp [upperBound?]; split at H
    · apply iha _ H
    · apply ihb _ H
    · exact H

theorem lowerBound?_eq_find? {t : RBNode α} {cut} (lb) (H : t.find? cut = some x) :
    t.lowerBound? cut lb = some x := by
  rw [← reverse_reverse t] at H ⊢; rw [lowerBound?_reverse]; rw [find?_reverse] at H
  exact upperBound?_eq_find? _ H

/-- The value `x` returned by `upperBound?` is greater or equal to the `cut`. -/
theorem upperBound?_ge' {t : RBNode α} (H : ∀ {x}, x ∈ ub → cut x ≠ .gt) :
    t.upperBound? cut ub = some x → cut x ≠ .gt := by
  induction t generalizing ub with
  | nil => exact H
  | node _ _ _ _ ihl ihr =>
    simp [upperBound?]; split
    · next hv => exact ihl fun | rfl, e => nomatch hv.symm.trans e
    · exact ihr H
    · next hv => intro | rfl, e => cases hv.symm.trans e

/-- The value `x` returned by `upperBound?` is greater or equal to the `cut`. -/
theorem upperBound?_ge {t : RBNode α} : t.upperBound? cut = some x → cut x ≠ .gt :=
  upperBound?_ge' nofun

/-- The value `x` returned by `lowerBound?` is less or equal to the `cut`. -/
theorem lowerBound?_le' {t : RBNode α} (H : ∀ {x}, x ∈ lb → cut x ≠ .lt) :
    t.lowerBound? cut lb = some x → cut x ≠ .lt := by
  rw [← reverse_reverse t, lowerBound?_reverse, Ne, ← Ordering.swap_inj]
  exact upperBound?_ge' fun h => by specialize H h; rwa [Ne, ← Ordering.swap_inj] at H

/-- The value `x` returned by `lowerBound?` is less or equal to the `cut`. -/
theorem lowerBound?_le {t : RBNode α} : t.lowerBound? cut = some x → cut x ≠ .lt :=
  lowerBound?_le' nofun

theorem All.upperBound?_ub {t : RBNode α} (hp : t.All p) (H : ∀ {x}, ub = some x → p x) :
    t.upperBound? cut ub = some x → p x := by
  induction t generalizing ub with
  | nil => exact H
  | node _ _ _ _ ihl ihr =>
    simp [upperBound?]; split
    · exact ihl hp.2.1 fun | rfl => hp.1
    · exact ihr hp.2.2 H
    · exact fun | rfl => hp.1

theorem All.upperBound? {t : RBNode α} (hp : t.All p) : t.upperBound? cut = some x → p x :=
  hp.upperBound?_ub nofun

theorem All.lowerBound?_lb {t : RBNode α} (hp : t.All p) (H : ∀ {x}, lb = some x → p x) :
    t.lowerBound? cut lb = some x → p x := by
  rw [← reverse_reverse t, lowerBound?_reverse]
  exact All.upperBound?_ub (All.reverse.2 hp) H

theorem All.lowerBound? {t : RBNode α} (hp : t.All p) : t.lowerBound? cut = some x → p x :=
  hp.lowerBound?_lb nofun

theorem upperBound?_mem_ub {t : RBNode α}
    (h : t.upperBound? cut ub = some x) : x ∈ t ∨ ub = some x :=
  All.upperBound?_ub (p := fun x => x ∈ t ∨ ub = some x) (All_def.2 fun _ => .inl) Or.inr h

theorem upperBound?_mem {t : RBNode α} (h : t.upperBound? cut = some x) : x ∈ t :=
  (upperBound?_mem_ub h).resolve_right nofun

theorem lowerBound?_mem_lb {t : RBNode α}
    (h : t.lowerBound? cut lb = some x) : x ∈ t ∨ lb = some x :=
  All.lowerBound?_lb (p := fun x => x ∈ t ∨ lb = some x) (All_def.2 fun _ => .inl) Or.inr h

theorem lowerBound?_mem {t : RBNode α} (h : t.lowerBound? cut = some x) : x ∈ t :=
  (lowerBound?_mem_lb h).resolve_right nofun

theorem upperBound?_of_some {t : RBNode α} : ∃ x, t.upperBound? cut (some y) = some x := by
  induction t generalizing y <;> simp [upperBound?]; split <;> simp [*]

theorem lowerBound?_of_some {t : RBNode α} : ∃ x, t.lowerBound? cut (some y) = some x := by
  rw [← reverse_reverse t, lowerBound?_reverse]; exact upperBound?_of_some

theorem Ordered.upperBound?_exists [Std.TransCmp (α := α) cmp] [IsCut cmp cut]
    (h : Ordered cmp t) : (∃ x, t.upperBound? cut = some x) ↔ ∃ x ∈ t, cut x ≠ .gt := by
  refine ⟨fun ⟨x, hx⟩ => ⟨_, upperBound?_mem hx, upperBound?_ge hx⟩, fun H => ?_⟩
  obtain ⟨x, hx, e⟩ := H
  induction t generalizing x with
  | nil => cases hx
  | node _ _ _ _ _ ihr =>
    simp [upperBound?]; split
    · exact upperBound?_of_some
    · rcases hx with rfl | hx | hx
      · contradiction
      · next hv => cases e <| IsCut.gt_trans (All_def.1 h.1 _ hx).1 hv
      · exact ihr h.2.2.2 _ hx e
    · exact ⟨_, rfl⟩

theorem Ordered.lowerBound?_exists [Std.TransCmp (α := α) cmp] [IsCut cmp cut]
    (h : Ordered cmp t) : (∃ x, t.lowerBound? cut = some x) ↔ ∃ x ∈ t, cut x ≠ .lt := by
  conv => enter [2, 1, x]; rw [Ne, ← Ordering.swap_inj]
  rw [← reverse_reverse t, lowerBound?_reverse]
  simpa [-Ordering.swap_inj] using h.reverse.upperBound?_exists (cut := (cut · |>.swap))

theorem Ordered.upperBound?_least_ub [Std.TransCmp (α := α) cmp] [IsCut cmp cut]
    (h : Ordered cmp t) (hub : ∀ {x}, ub = some x → t.All (cmpLT cmp · x)) :
    t.upperBound? cut ub = some x → y ∈ t → cut x = .lt → cmp y x = .lt → cut y = .gt := by
  induction t generalizing ub with
  | nil => nofun
  | node _ _ _ _ ihl ihr =>
    simp [upperBound?]; split <;> rename_i hv <;> rintro h₁ (rfl | hy' | hy') hx h₂
    · rcases upperBound?_mem_ub h₁ with h₁ | ⟨⟨⟩⟩
      · cases Std.OrientedCmp.not_lt_of_lt h₂ (All_def.1 h.1 _ h₁).1
      · cases Std.OrientedCmp.not_lt_of_lt h₂ h₂
    · exact ihl h.2.2.1 (by rintro _ ⟨⟨⟩⟩; exact h.1) h₁ hy' hx h₂
    · refine (Std.OrientedCmp.not_lt_of_lt h₂ ?_).elim; have := (All_def.1 h.2.1 _ hy').1
      rcases upperBound?_mem_ub h₁ with h₁ | ⟨⟨⟩⟩
      · exact Std.TransCmp.lt_trans (All_def.1 h.1 _ h₁).1 this
      · exact this
    · exact hv
    · exact IsCut.gt_trans (cut := cut) (cmp := cmp) (All_def.1 h.1 _ hy').1 hv
    · exact ihr h.2.2.2 (fun h => (hub h).2.2) h₁ hy' hx h₂
    · cases h₁; cases Std.OrientedCmp.not_lt_of_lt h₂ h₂
    · cases h₁; cases hx.symm.trans hv
    · cases h₁; cases hx.symm.trans hv

theorem Ordered.lowerBound?_greatest_lb [Std.TransCmp (α := α) cmp] [IsCut cmp cut]
    (h : Ordered cmp t) (hlb : ∀ {x}, lb = some x → t.All (cmpLT cmp x ·)) :
    t.lowerBound? cut lb = some x → y ∈ t → cut x = .gt → cmp x y = .lt → cut y = .lt := by
  intro h1 h2 h3 h4
  rw [← reverse_reverse t, lowerBound?_reverse] at h1
  rw [← Ordering.swap_inj] at h3 ⊢
  revert h2 h3 h4
  simpa [-Ordering.swap_inj] using
    h.reverse.upperBound?_least_ub (fun h => All.reverse.2 <| (hlb h).imp .flip) h1

/--
A statement of the least-ness of the result of `upperBound?`. If `x` is the return value of
`upperBound?` and it is strictly greater than the cut, then any other `y < x` in the tree is in fact
strictly less than the cut (so there is no exact match, and nothing closer to the cut).
-/
theorem Ordered.upperBound?_least [Std.TransCmp (α := α) cmp] [IsCut cmp cut]
    (ht : Ordered cmp t) (H : t.upperBound? cut = some x) (hy : y ∈ t)
    (xy : cmp y x = .lt) (hx : cut x = .lt) : cut y = .gt :=
  ht.upperBound?_least_ub (by nofun) H hy hx xy

/--
A statement of the greatest-ness of the result of `lowerBound?`. If `x` is the return value of
`lowerBound?` and it is strictly less than the cut, then any other `y > x` in the tree is in fact
strictly greater than the cut (so there is no exact match, and nothing closer to the cut).
-/
theorem Ordered.lowerBound?_greatest [Std.TransCmp (α := α) cmp] [IsCut cmp cut]
    (ht : Ordered cmp t) (H : t.lowerBound? cut none = some x) (hy : y ∈ t)
    (xy : cmp x y = .lt) (hx : cut x = .gt) : cut y = .lt :=
  ht.lowerBound?_greatest_lb (by nofun) H hy hx xy

theorem Ordered.memP_iff_upperBound? [Std.TransCmp (α := α) cmp] [IsCut cmp cut]
    (ht : Ordered cmp t) : t.MemP cut ↔ ∃ x, t.upperBound? cut = some x ∧ cut x = .eq := by
  refine memP_def.trans ⟨fun ⟨y, hy, ey⟩ => ?_, fun ⟨x, hx, e⟩ => ⟨_, upperBound?_mem hx, e⟩⟩
  have ⟨x, hx⟩ := ht.upperBound?_exists.2 ⟨_, hy, fun h => nomatch ey.symm.trans h⟩
  refine ⟨x, hx, ?_⟩; cases ex : cut x
  · cases e : cmp x y
    · cases ey.symm.trans <| IsCut.lt_trans e ex
    · cases ey.symm.trans <| IsCut.congr e |>.symm.trans ex
    · cases ey.symm.trans <| ht.upperBound?_least hx hy (Std.OrientedCmp.gt_iff_lt.1 e) ex
  · rfl
  · cases upperBound?_ge hx ex

theorem Ordered.memP_iff_lowerBound? [Std.TransCmp (α := α) cmp] [IsCut cmp cut]
    (ht : Ordered cmp t) : t.MemP cut ↔ ∃ x, t.lowerBound? cut = some x ∧ cut x = .eq := by
  refine memP_def.trans ⟨fun ⟨y, hy, ey⟩ => ?_, fun ⟨x, hx, e⟩ => ⟨_, lowerBound?_mem hx, e⟩⟩
  have ⟨x, hx⟩ := ht.lowerBound?_exists.2 ⟨_, hy, fun h => nomatch ey.symm.trans h⟩
  refine ⟨x, hx, ?_⟩; cases ex : cut x
  · cases lowerBound?_le hx ex
  · rfl
  · cases e : cmp x y
    · cases ey.symm.trans <| ht.lowerBound?_greatest hx hy e ex
    · cases ey.symm.trans <| IsCut.congr e |>.symm.trans ex
    · cases ey.symm.trans <| IsCut.gt_trans (Std.OrientedCmp.gt_iff_lt.1 e) ex

/-- A stronger version of `lowerBound?_greatest` that holds when the cut is strict. -/
theorem Ordered.lowerBound?_lt [Std.TransCmp (α := α) cmp] [IsStrictCut cmp cut]
    (ht : Ordered cmp t) (H : t.lowerBound? cut = some x) (hy : y ∈ t) :
    cmp x y = .lt ↔ cut y = .lt := by
  refine ⟨fun h => ?_, fun h => Std.OrientedCmp.gt_iff_lt.1 ?_⟩
  · cases e : cut x
    · cases lowerBound?_le H e
    · exact IsStrictCut.exact e |>.symm.trans h
    · exact ht.lowerBound?_greatest H hy h e
  · by_contra h'; exact lowerBound?_le H <| IsCut.le_lt_trans (cmp := cmp) (cut := cut) h' h

/-- A stronger version of `upperBound?_least` that holds when the cut is strict. -/
theorem Ordered.lt_upperBound? [Std.TransCmp (α := α) cmp] [IsStrictCut cmp cut]
    (ht : Ordered cmp t) (H : t.upperBound? cut = some x) (hy : y ∈ t) :
    cmp y x = .lt ↔ cut y = .gt := by
  rw [← reverse_reverse t, upperBound?_reverse] at H
  rw [← Ordering.swap_inj (o₂ := .gt)]
  revert hy; simpa [-Ordering.swap_inj] using ht.reverse.lowerBound?_lt H

end «upperBound? and lowerBound?»

namespace Path

attribute [simp] RootOrdered Ordered

/-- The list of elements to the left of the hole.
(This function is intended for specification purposes only.) -/
@[simp] def listL : Path α → List α
  | .root => []
  | .left _ parent _ _ => parent.listL
  | .right _ l v parent => parent.listL ++ (l.toList ++ [v])

/-- The list of elements to the right of the hole.
(This function is intended for specification purposes only.) -/
@[simp] def listR : Path α → List α
  | .root => []
  | .left _ parent v r => v :: r.toList ++ parent.listR
  | .right _ _ _ parent => parent.listR

/-- Wraps a list of elements with the left and right elements of the path. -/
abbrev withList (p : Path α) (l : List α) : List α := p.listL ++ l ++ p.listR

theorem rootOrdered_iff {p : Path α} (hp : p.Ordered cmp) :
    p.RootOrdered cmp v ↔ (∀ a ∈ p.listL, cmpLT cmp a v) ∧ (∀ a ∈ p.listR, cmpLT cmp v a) := by
  induction p with
    (simp [All_def] at hp; simp [*, and_assoc, and_left_comm, and_comm, or_imp, forall_and])
  | left _ _ x _ ih => exact fun vx _ _ _ ha => vx.trans (hp.2.1 _ ha)
  | right _ _ x _ ih => exact fun xv _ _ _ ha => (hp.2.1 _ ha).trans xv

theorem ordered_iff {p : Path α} :
    p.Ordered cmp ↔ p.listL.Pairwise (cmpLT cmp) ∧ p.listR.Pairwise (cmpLT cmp) ∧
      ∀ x ∈ p.listL, ∀ y ∈ p.listR, cmpLT cmp x y := by
  induction p with
  | root => simp
  | left _ _ x _ ih | right _ _ x _ ih => ?_
  all_goals
    rw [Ordered, and_congr_right_eq fun h => by simp [All_def, rootOrdered_iff h]; rfl]
    simp [List.pairwise_append, or_imp, forall_and, ih, RBNode.ordered_iff]
    -- FIXME: simp [and_assoc, and_left_comm, and_comm] is really slow here
  · exact ⟨
      fun ⟨⟨hL, hR, LR⟩, xr, ⟨Lx, xR⟩, ⟨rL, rR⟩, hr⟩ =>
        ⟨hL, ⟨⟨xr, xR⟩, hr, hR, rR⟩, Lx, fun _ ha _ hb => rL _ hb _ ha, LR⟩,
      fun ⟨hL, ⟨⟨xr, xR⟩, hr, hR, rR⟩, Lx, Lr, LR⟩ =>
        ⟨⟨hL, hR, LR⟩, xr, ⟨Lx, xR⟩, ⟨fun _ ha _ hb => Lr _ hb _ ha, rR⟩, hr⟩⟩
  · exact ⟨
      fun ⟨⟨hL, hR, LR⟩, lx, ⟨Lx, xR⟩, ⟨lL, lR⟩, hl⟩ =>
        ⟨⟨hL, ⟨hl, lx⟩, fun _ ha _ hb => lL _ hb _ ha, Lx⟩, hR, LR, lR, xR⟩,
      fun ⟨⟨hL, ⟨hl, lx⟩, Ll, Lx⟩, hR, LR, lR, xR⟩ =>
       ⟨⟨hL, hR, LR⟩, lx, ⟨Lx, xR⟩, ⟨fun _ ha _ hb => Ll _ hb _ ha, lR⟩, hl⟩⟩

theorem zoom_zoomed₁ (e : zoom cut t path = (t', path')) :
    t'.OnRoot (cut · = .eq) :=
  match t, e with
  | nil, rfl => trivial
  | node .., e => by
    revert e; unfold zoom; split
    · exact zoom_zoomed₁
    · exact zoom_zoomed₁
    · next H => intro e; cases e; exact H

@[simp] theorem fill_toList {p : Path α} : (p.fill t).toList = p.withList t.toList := by
  induction p generalizing t <;> simp [*]

theorem _root_.Batteries.RBNode.zoom_toList {t : RBNode α} (eq : t.zoom cut = (t', p')) :
    p'.withList t'.toList = t.toList := by rw [← fill_toList, ← zoom_fill eq]; rfl

@[simp] theorem ins_toList {p : Path α} : (p.ins t).toList = p.withList t.toList := by
  match p with
  | .root | .left red .. | .right red .. | .left black .. | .right black .. =>
    simp [ins, ins_toList]

@[simp] theorem insertNew_toList {p : Path α} : (p.insertNew v).toList = p.withList [v] := by
  simp [insertNew]

theorem insert_toList {p : Path α} :
    (p.insert t v).toList = p.withList (t.setRoot v).toList := by
  simp [insert]; split <;> simp [setRoot]

protected theorem Balanced.insert {path : Path α} (hp : path.Balanced c₀ n₀ c n) :
    t.Balanced c n → ∃ c n, (path.insert t v).Balanced c n
  | .nil => ⟨_, hp.insertNew⟩
  | .red ha hb => ⟨_, _, hp.fill (.red ha hb)⟩
  | .black ha hb => ⟨_, _, hp.fill (.black ha hb)⟩

theorem Ordered.insert : ∀ {path : Path α} {t : RBNode α},
    path.Ordered cmp → t.Ordered cmp → t.All (path.RootOrdered cmp) → path.RootOrdered cmp v →
    t.OnRoot (cmpEq cmp v) → (path.insert t v).Ordered cmp
  | _, nil, hp, _, _, vp, _ => hp.insertNew vp
  | _, node .., hp, ⟨ax, xb, ha, hb⟩, ⟨_, ap, bp⟩, vp, xv => Ordered.fill.2
    ⟨hp, ⟨ax.imp xv.lt_congr_right.2, xb.imp xv.lt_congr_left.2, ha, hb⟩, vp, ap, bp⟩

theorem Ordered.erase : ∀ {path : Path α} {t : RBNode α},
    path.Ordered cmp → t.Ordered cmp → t.All (path.RootOrdered cmp) → (path.erase t).Ordered cmp
  | _, nil, hp, ht, tp => Ordered.fill.2 ⟨hp, ht, tp⟩
  | _, node .., hp, ⟨ax, xb, ha, hb⟩, ⟨_, ap, bp⟩ => hp.del (ha.append ax xb hb) (ap.append bp)

theorem zoom_ins {t : RBNode α} {cmp : α → α → Ordering} :
    t.zoom (cmp v) path = (t', path') →
    path.ins (t.ins cmp v) = path'.ins (t'.setRoot v) := by
  unfold RBNode.ins; split <;> simp [zoom]
  · intro | rfl, rfl => rfl
  all_goals
  · split
    · exact zoom_ins
    · exact zoom_ins
    · intro | rfl => rfl

theorem insertNew_eq_insert (h : zoom (cmp v) t = (nil, path)) :
    path.insertNew v = (t.insert cmp v).setBlack :=
  insert_setBlack .. ▸ (zoom_ins h).symm

theorem ins_eq_fill {path : Path α} {t : RBNode α} :
    path.Balanced c₀ n₀ c n → t.Balanced c n → path.ins t = (path.fill t).setBlack
  | .root, h => rfl
  | .redL hb H, ha | .redR ha H, hb => by unfold ins; exact ins_eq_fill H (.red ha hb)
  | .blackL hb H, ha => by rw [ins, fill, ← ins_eq_fill H (.black ha hb), balance1_eq ha]
  | .blackR ha H, hb => by rw [ins, fill, ← ins_eq_fill H (.black ha hb), balance2_eq hb]

theorem zoom_insert {path : Path α} {t : RBNode α} (ht : t.Balanced c n)
    (H : zoom (cmp v) t = (t', path)) :
    (path.insert t' v).setBlack = (t.insert cmp v).setBlack := by
  have ⟨_, _, ht', hp'⟩ := ht.zoom .root H
  cases ht' with simp [insert]
  | nil => simp [insertNew_eq_insert H, setBlack_idem]
  | red hl hr => rw [← ins_eq_fill hp' (.red hl hr), insert_setBlack]; exact (zoom_ins H).symm
  | black hl hr => rw [← ins_eq_fill hp' (.black hl hr), insert_setBlack]; exact (zoom_ins H).symm

theorem zoom_del {t : RBNode α} :
    t.zoom cut path = (t', path') →
    path.del (t.del cut) (match t with | node c .. => c | _ => red) =
    path'.del t'.delRoot (match t' with | node c .. => c | _ => red) := by
  rw [RBNode.del.eq_def]; split <;> simp [zoom]
  · intro | rfl, rfl => rfl
  · next c a y b =>
    split
    · have IH := @zoom_del (t := a)
      match a with
      | nil => intro | rfl => rfl
      | node black .. | node red .. => apply IH
    · have IH := @zoom_del (t := b)
      match b with
      | nil => intro | rfl => rfl
      | node black .. | node red .. => apply IH
    · intro | rfl => rfl

/-- Asserts that `p` holds on all elements to the left of the hole. -/
def AllL (p : α → Prop) : Path α → Prop
  | .root => True
  | .left _ parent _ _ => parent.AllL p
  | .right _ a x parent => a.All p ∧ p x ∧ parent.AllL p

/-- Asserts that `p` holds on all elements to the right of the hole. -/
def AllR (p : α → Prop) : Path α → Prop
  | .root => True
  | .left _ parent x b => parent.AllR p ∧ p x ∧ b.All p
  | .right _ _ _ parent => parent.AllR p

end Path

theorem insert_toList_zoom {t : RBNode α} (ht : Balanced t c n)
    (e : zoom (cmp v) t = (t', p)) :
    (t.insert cmp v).toList = p.withList (t'.setRoot v).toList := by
  rw [← setBlack_toList, ← Path.zoom_insert ht e, setBlack_toList, Path.insert_toList]

theorem insert_toList_zoom_nil {t : RBNode α} (ht : Balanced t c n)
    (e : zoom (cmp v) t = (nil, p)) :
    (t.insert cmp v).toList = p.withList [v] := insert_toList_zoom ht e

theorem exists_insert_toList_zoom_nil {t : RBNode α} (ht : Balanced t c n)
    (e : zoom (cmp v) t = (nil, p)) :
    ∃ L R, t.toList = L ++ R ∧ (t.insert cmp v).toList = L ++ v :: R :=
  ⟨p.listL, p.listR, by simp [← zoom_toList e, insert_toList_zoom_nil ht e]⟩

theorem insert_toList_zoom_node {t : RBNode α} (ht : Balanced t c n)
    (e : zoom (cmp v) t = (node c' l v' r, p)) :
    (t.insert cmp v).toList = p.withList (node c l v r).toList := insert_toList_zoom ht e

theorem exists_insert_toList_zoom_node {t : RBNode α} (ht : Balanced t c n)
    (e : zoom (cmp v) t = (node c' l v' r, p)) :
    ∃ L R, t.toList = L ++ v' :: R ∧ (t.insert cmp v).toList = L ++ v :: R := by
  refine ⟨p.listL ++ l.toList, r.toList ++ p.listR, ?_⟩
  simp [← zoom_toList e, insert_toList_zoom_node ht e]

theorem mem_insert_self {t : RBNode α} (ht : Balanced t c n) : v ∈ t.insert cmp v := by
  rw [← mem_toList, List.mem_iff_append]
  exact match e : zoom (cmp v) t with
  | (nil, p) => let ⟨_, _, _, h⟩ := exists_insert_toList_zoom_nil ht e; ⟨_, _, h⟩
  | (node .., p) => let ⟨_, _, _, h⟩ := exists_insert_toList_zoom_node ht e; ⟨_, _, h⟩

theorem mem_insert_of_mem {t : RBNode α} (ht : Balanced t c n) (h : v' ∈ t) :
    v' ∈ t.insert cmp v ∨ cmp v v' = .eq := by
  match e : zoom (cmp v) t with
  | (nil, p) =>
    let ⟨_, _, h₁, h₂⟩ := exists_insert_toList_zoom_nil ht e
    simp [← mem_toList, h₁] at h
    simp [← mem_toList, h₂]; cases h <;> simp [*]
  | (node .., p) =>
    let ⟨_, _, h₁, h₂⟩ := exists_insert_toList_zoom_node ht e
    simp [← mem_toList, h₁] at h
    simp [← mem_toList, h₂]; rcases h with h|h|h <;> simp [*]
    exact .inr (Path.zoom_zoomed₁ e)

theorem exists_find?_insert_self [Std.TransCmp (α := α) cmp] [IsCut cmp cut]
    {t : RBNode α} (ht : Balanced t c n) (ht₂ : Ordered cmp t) (hv : cut v = .eq) :
    ∃ x, (t.insert cmp v).find? cut = some x :=
  ht₂.insert.memP_iff_find?.1 <| memP_def.2 ⟨_, mem_insert_self ht, hv⟩

theorem find?_insert_self [Std.TransCmp (α := α) cmp] [IsStrictCut cmp cut]
    {t : RBNode α} (ht : Balanced t c n) (ht₂ : Ordered cmp t) (hv : cut v = .eq) :
    (t.insert cmp v).find? cut = some v :=
  ht₂.insert.find?_some.2 ⟨mem_insert_self ht, hv⟩

theorem mem_insert [Std.TransCmp (α := α) cmp] {t : RBNode α}
    (ht : Balanced t c n) (ht₂ : Ordered cmp t) :
    v' ∈ t.insert cmp v ↔ (v' ∈ t ∧ t.find? (cmp v) ≠ some v') ∨ v' = v := by
  refine ⟨fun h => ?_, fun | .inl ⟨h₁, h₂⟩ => ?_ | .inr h => ?_⟩
  · match e : zoom (cmp v) t with
    | (nil, p) =>
      let ⟨_, _, h₁, h₂⟩ := exists_insert_toList_zoom_nil ht e
      simp [← mem_toList, h₂] at h; rw [← or_assoc, or_right_comm] at h
      refine h.imp_left fun h => ?_
      simp [← mem_toList, h₁, h]
      rw [find?_eq_zoom, e]; nofun
    | (node .., p) =>
      let ⟨_, _, h₁, h₂⟩ := exists_insert_toList_zoom_node ht e
      simp [← mem_toList, h₂] at h; simp [← mem_toList, h₁]; rw [or_left_comm] at h ⊢
      rcases h with _|h <;> simp [*]
      refine .inl fun h => ?_
      rw [find?_eq_zoom, e] at h; cases h
      suffices cmpLT cmp v' v' by cases Std.ReflCmp.compare_self.symm.trans this.1
      have := ht₂.toList_sorted; simp [h₁, List.pairwise_append] at this
      exact h.elim (this.2.2 _ · |>.1) (this.2.1.1 _)
  · exact (mem_insert_of_mem ht h₁).resolve_right fun h' => h₂ <| ht₂.find?_some.2 ⟨h₁, h'⟩
  · exact h ▸ mem_insert_self ht

end RBNode

open RBNode (IsCut IsStrictCut)

namespace RBSet

@[simp] theorem val_toList {t : RBSet α cmp} : t.1.toList = t.toList := rfl

@[simp] theorem mkRBSet_eq : mkRBSet α cmp = ∅ := rfl
@[simp] theorem empty_eq : @RBSet.empty α cmp = ∅ := rfl
@[simp] theorem default_eq : (default : RBSet α cmp) = ∅ := rfl
@[simp] theorem empty_toList : toList (∅ : RBSet α cmp) = [] := rfl
@[simp] theorem single_toList : toList (single a : RBSet α cmp) = [a] := rfl

theorem mem_toList {t : RBSet α cmp} : x ∈ toList t ↔ x ∈ t.1 := RBNode.mem_toList

theorem mem_congr [Std.TransCmp (α := α) cmp] {t : RBSet α cmp} (h : cmp x y = .eq) :
    x ∈ t ↔ y ∈ t := RBNode.mem_congr h

theorem mem_iff_mem_toList {t : RBSet α cmp} : x ∈ t ↔ ∃ y ∈ toList t, cmp x y = .eq :=
  RBNode.mem_def.trans <| by simp [mem_toList]

theorem mem_of_mem_toList [Std.OrientedCmp (α := α) cmp] {t : RBSet α cmp} (h : x ∈ toList t) :
    x ∈ t := mem_iff_mem_toList.2 ⟨_, h, Std.ReflCmp.compare_self⟩

theorem foldl_eq_foldl_toList {t : RBSet α cmp} : t.foldl f init = t.toList.foldl f init :=
  RBNode.foldl_eq_foldl_toList

theorem foldr_eq_foldr_toList {t : RBSet α cmp} : t.foldr f init = t.toList.foldr f init :=
  RBNode.foldr_eq_foldr_toList

theorem foldlM_eq_foldlM_toList [Monad m] [LawfulMonad m] {t : RBSet α cmp} :
    t.foldlM (m := m) f init = t.toList.foldlM f init := RBNode.foldlM_eq_foldlM_toList

theorem forM_eq_forM_toList [Monad m] [LawfulMonad m] {t : RBSet α cmp} :
    t.forM (m := m) f = t.toList.forM f := RBNode.forM_eq_forM_toList

theorem forIn_eq_forIn_toList [Monad m] [LawfulMonad m] {t : RBSet α cmp} :
    forIn (m := m) t init f = forIn t.toList init f := RBNode.forIn_eq_forIn_toList

theorem toStream_eq {t : RBSet α cmp} : toStream t = t.1.toStream .nil := rfl

@[simp] theorem toStream_toList {t : RBSet α cmp} : (toStream t).toList = t.toList := by
  simp [toStream_eq]

theorem isEmpty_iff_toList_eq_nil {t : RBSet α cmp} :
    t.isEmpty ↔ t.toList = [] := by obtain ⟨⟨⟩, _⟩ := t <;> simp [toList, isEmpty]

theorem toList_sorted {t : RBSet α cmp} : t.toList.Pairwise (RBNode.cmpLT cmp) :=
  t.2.out.1.toList_sorted

theorem findP?_some_eq_eq {t : RBSet α cmp} : t.findP? cut = some y → cut y = .eq :=
  RBNode.find?_some_eq_eq

theorem find?_some_eq_eq {t : RBSet α cmp} : t.find? x = some y → cmp x y = .eq :=
  findP?_some_eq_eq

theorem findP?_some_mem_toList {t : RBSet α cmp} (h : t.findP? cut = some y) :
    y ∈ toList t := mem_toList.2 <| RBNode.find?_some_mem h

theorem find?_some_mem_toList {t : RBSet α cmp} (h : t.find? x = some y) : y ∈ toList t :=
  findP?_some_mem_toList h

theorem findP?_some_memP {t : RBSet α cmp} (h : t.findP? cut = some y) : t.MemP cut :=
  RBNode.find?_some_memP h

theorem find?_some_mem {t : RBSet α cmp} (h : t.find? x = some y) : x ∈ t :=
  findP?_some_memP h

theorem mem_toList_unique [Std.TransCmp (α := α) cmp] {t : RBSet α cmp}
    (hx : x ∈ toList t) (hy : y ∈ toList t) (e : cmp x y = .eq) : x = y :=
  t.2.out.1.unique (mem_toList.1 hx) (mem_toList.1 hy) e

theorem findP?_some [Std.TransCmp (α := α) cmp] [IsStrictCut cmp cut] {t : RBSet α cmp} :
    t.findP? cut = some y ↔ y ∈ toList t ∧ cut y = .eq :=
  t.2.out.1.find?_some.trans <| by simp [mem_toList]

theorem find?_some [Std.TransCmp (α := α) cmp] {t : RBSet α cmp} :
    t.find? x = some y ↔ y ∈ toList t ∧ cmp x y = .eq := findP?_some

theorem memP_iff_findP? [Std.TransCmp (α := α) cmp] [IsCut cmp cut] {t : RBSet α cmp} :
    MemP cut t ↔ ∃ y, t.findP? cut = some y := t.2.out.1.memP_iff_find?

theorem mem_iff_find? [Std.TransCmp (α := α) cmp] {t : RBSet α cmp} :
    x ∈ t ↔ ∃ y, t.find? x = some y := memP_iff_findP?

@[simp] theorem contains_iff [Std.TransCmp (α := α) cmp] {t : RBSet α cmp} :
    t.contains x ↔ x ∈ t := Option.isSome_iff_exists.trans mem_iff_find?.symm

instance [Std.TransCmp (α := α) cmp] {t : RBSet α cmp} : Decidable (x ∈ t) :=
  decidable_of_iff _ contains_iff

theorem size_eq (t : RBSet α cmp) : t.size = t.toList.length := RBNode.size_eq

theorem mem_toList_insert_self (v) (t : RBSet α cmp) : v ∈ toList (t.insert v) :=
  let ⟨_, _, h⟩ := t.2.out.2; mem_toList.2 (RBNode.mem_insert_self h)

theorem mem_insert_self [Std.OrientedCmp (α := α) cmp] (v) (t : RBSet α cmp) :
    v ∈ t.insert v := mem_of_mem_toList <| mem_toList_insert_self v t

theorem mem_insert_of_eq [Std.TransCmp (α := α) cmp] (t : RBSet α cmp)
    (h : cmp v v' = .eq) : v' ∈ t.insert v := (mem_congr h).1 (mem_insert_self ..)

theorem mem_toList_insert_of_mem (v) {t : RBSet α cmp} (h : v' ∈ toList t) :
    v' ∈ toList (t.insert v) ∨ cmp v v' = .eq :=
  let ⟨_, _, ht⟩ := t.2.out.2
  .imp_left mem_toList.2 <| RBNode.mem_insert_of_mem ht <| mem_toList.1 h

theorem mem_insert_of_mem_toList [Std.OrientedCmp (α := α) cmp] (v) {t : RBSet α cmp}
    (h : v' ∈ toList t) : v' ∈ t.insert v :=
  match mem_toList_insert_of_mem v h with
  | .inl h' => mem_of_mem_toList h'
  | .inr h' => mem_iff_mem_toList.2 ⟨_, mem_toList_insert_self .., Std.OrientedCmp.eq_comm.1 h'⟩

theorem mem_insert_of_mem [Std.TransCmp (α := α) cmp] (v) {t : RBSet α cmp}
    (h : v' ∈ t) : v' ∈ t.insert v :=
  let ⟨_, h₁, h₂⟩ := mem_iff_mem_toList.1 h
  (mem_congr h₂).2 (mem_insert_of_mem_toList v h₁)

theorem mem_toList_insert [Std.TransCmp (α := α) cmp] {t : RBSet α cmp} :
    v' ∈ toList (t.insert v) ↔ (v' ∈ toList t ∧ t.find? v ≠ some v') ∨ v' = v := by
  let ⟨ht₁, _, _, ht₂⟩ := t.2.out
  simpa [mem_toList] using RBNode.mem_insert ht₂ ht₁

theorem mem_insert [Std.TransCmp (α := α) cmp] {t : RBSet α cmp} :
    v' ∈ t.insert v ↔ v' ∈ t ∨ cmp v v' = .eq := by
  refine ⟨fun h => ?_, fun | .inl h => mem_insert_of_mem _ h | .inr h => mem_insert_of_eq _ h⟩
  let ⟨_, h₁, h₂⟩ := mem_iff_mem_toList.1 h
  match mem_toList_insert.1 h₁ with
  | .inl ⟨h₃, _⟩ => exact .inl <| mem_iff_mem_toList.2 ⟨_, h₃, h₂⟩
  | .inr rfl => exact .inr <| Std.OrientedCmp.eq_comm.1 h₂

theorem find?_congr [Std.TransCmp (α := α) cmp] (t : RBSet α cmp) (h : cmp v₁ v₂ = .eq) :
    t.find? v₁ = t.find? v₂ := by simp only [find?]; congr; funext; rw [Std.TransCmp.congr_left h]

theorem findP?_insert_of_eq [Std.TransCmp (α := α) cmp] [IsStrictCut cmp cut]
    (t : RBSet α cmp) (h : cut v = .eq) : (t.insert v).findP? cut = some v :=
  findP?_some.2 ⟨mem_toList_insert_self .., h⟩

theorem find?_insert_of_eq [Std.TransCmp (α := α) cmp] (t : RBSet α cmp) (h : cmp v' v = .eq) :
    (t.insert v).find? v' = some v := findP?_insert_of_eq t h

theorem findP?_insert_of_ne [Std.TransCmp (α := α) cmp] [IsStrictCut cmp cut]
    (t : RBSet α cmp) (h : cut v ≠ .eq) : (t.insert v).findP? cut = t.findP? cut := by
  refine Option.ext fun u =>
    findP?_some.trans <| .trans (and_congr_left fun h' => ?_) findP?_some.symm
  rw [mem_toList_insert, or_iff_left, and_iff_left]
  · exact mt (fun h => by rwa [IsCut.congr (cut := cut) (find?_some_eq_eq h)]) h
  · rintro rfl; contradiction

theorem find?_insert_of_ne [Std.TransCmp (α := α) cmp] (t : RBSet α cmp) (h : cmp v' v ≠ .eq) :
    (t.insert v).find? v' = t.find? v' := findP?_insert_of_ne t h

theorem findP?_insert [Std.TransCmp (α := α) cmp] (t : RBSet α cmp) (v cut) [IsStrictCut cmp cut] :
    (t.insert v).findP? cut = if cut v = .eq then some v else t.findP? cut := by
  split <;> [exact findP?_insert_of_eq t ‹_›; exact findP?_insert_of_ne t ‹_›]

theorem find?_insert [Std.TransCmp (α := α) cmp] (t : RBSet α cmp) (v v') :
    (t.insert v).find? v' = if cmp v' v = .eq then some v else t.find? v' := findP?_insert ..

theorem upperBoundP?_eq_findP? {t : RBSet α cmp} {cut} (H : t.findP? cut = some x) :
    t.upperBoundP? cut = some x := RBNode.upperBound?_eq_find? _ H

theorem lowerBoundP?_eq_findP? {t : RBSet α cmp} {cut} (H : t.findP? cut = some x) :
    t.lowerBoundP? cut = some x := RBNode.lowerBound?_eq_find? _ H

theorem upperBound?_eq_find? {t : RBSet α cmp} (H : t.find? x = some y) :
    t.upperBound? x = some y := upperBoundP?_eq_findP? H

theorem lowerBound?_eq_find? {t : RBSet α cmp} (H : t.find? x = some y) :
    t.lowerBound? x = some y := lowerBoundP?_eq_findP? H

/-- The value `x` returned by `upperBoundP?` is greater or equal to the `cut`. -/
theorem upperBoundP?_ge {t : RBSet α cmp} : t.upperBoundP? cut = some x → cut x ≠ .gt :=
  RBNode.upperBound?_ge

/-- The value `y` returned by `upperBound? x` is greater or equal to `x`. -/
theorem upperBound?_ge {t : RBSet α cmp} : t.upperBound? x = some y → cmp x y ≠ .gt :=
  upperBoundP?_ge

/-- The value `x` returned by `lowerBoundP?` is less or equal to the `cut`. -/
theorem lowerBoundP?_le {t : RBSet α cmp} : t.lowerBoundP? cut = some x → cut x ≠ .lt :=
  RBNode.lowerBound?_le

/-- The value `y` returned by `lowerBound? x` is less or equal to `x`. -/
theorem lowerBound?_le {t : RBSet α cmp} : t.lowerBound? x = some y → cmp x y ≠ .lt :=
  lowerBoundP?_le

theorem upperBoundP?_mem_toList {t : RBSet α cmp} (h : t.upperBoundP? cut = some x) :
    x ∈ t.toList := mem_toList.2 (RBNode.upperBound?_mem h)

theorem upperBound?_mem_toList {t : RBSet α cmp} (h : t.upperBound? x = some y) :
    y ∈ t.toList := upperBoundP?_mem_toList h

theorem lowerBoundP?_mem_toList {t : RBSet α cmp} (h : t.lowerBoundP? cut = some x) :
    x ∈ t.toList := mem_toList.2 (RBNode.lowerBound?_mem h)

theorem lowerBound?_mem_toList {t : RBSet α cmp} (h : t.lowerBound? x = some y) :
    y ∈ t.toList := lowerBoundP?_mem_toList h

theorem upperBoundP?_mem [Std.OrientedCmp (α := α) cmp] {t : RBSet α cmp}
    (h : t.upperBoundP? cut = some x) : x ∈ t := mem_of_mem_toList (upperBoundP?_mem_toList h)

theorem lowerBoundP?_mem [Std.OrientedCmp (α := α) cmp] {t : RBSet α cmp}
    (h : t.lowerBoundP? cut = some x) : x ∈ t := mem_of_mem_toList (lowerBoundP?_mem_toList h)

theorem upperBound?_mem [Std.OrientedCmp (α := α) cmp] {t : RBSet α cmp}
    (h : t.upperBound? x = some y) : y ∈ t := upperBoundP?_mem h

theorem lowerBound?_mem [Std.OrientedCmp (α := α) cmp] {t : RBSet α cmp}
    (h : t.lowerBound? x = some y) : y ∈ t := lowerBoundP?_mem h

theorem upperBoundP?_exists {t : RBSet α cmp} [Std.TransCmp cmp] [IsCut cmp cut] :
    (∃ x, t.upperBoundP? cut = some x) ↔ ∃ x ∈ t, cut x ≠ .gt := by
  simp [upperBoundP?, t.2.out.1.upperBound?_exists, mem_toList, mem_iff_mem_toList]
  exact ⟨
    fun ⟨x, h1, h2⟩ => ⟨x, ⟨x, h1, Std.ReflCmp.compare_self⟩, h2⟩,
    fun ⟨x, ⟨y, h1, h2⟩, eq⟩ => ⟨y, h1, IsCut.congr (cut := cut) h2 ▸ eq⟩⟩

theorem lowerBoundP?_exists {t : RBSet α cmp} [Std.TransCmp cmp] [IsCut cmp cut] :
    (∃ x, t.lowerBoundP? cut = some x) ↔ ∃ x ∈ t, cut x ≠ .lt := by
  simp [lowerBoundP?, t.2.out.1.lowerBound?_exists, mem_toList, mem_iff_mem_toList]
  exact ⟨
    fun ⟨x, h1, h2⟩ => ⟨x, ⟨x, h1, Std.ReflCmp.compare_self⟩, h2⟩,
    fun ⟨x, ⟨y, h1, h2⟩, eq⟩ => ⟨y, h1, IsCut.congr (cut := cut) h2 ▸ eq⟩⟩

theorem upperBound?_exists {t : RBSet α cmp} [Std.TransCmp cmp] :
    (∃ y, t.upperBound? x = some y) ↔ ∃ y ∈ t, cmp x y ≠ .gt := upperBoundP?_exists

theorem lowerBound?_exists {t : RBSet α cmp} [Std.TransCmp cmp] :
    (∃ y, t.lowerBound? x = some y) ↔ ∃ y ∈ t, cmp x y ≠ .lt := lowerBoundP?_exists

/--
A statement of the least-ness of the result of `upperBoundP?`. If `x` is the return value of
`upperBoundP?` and it is strictly greater than the cut, then any other `y < x` in the tree is in
fact strictly less than the cut (so there is no exact match, and nothing closer to the cut).
-/
theorem upperBoundP?_least {t : RBSet α cmp} [Std.TransCmp cmp] [IsCut cmp cut]
    (H : t.upperBoundP? cut = some x) (hy : y ∈ t)
    (xy : cmp y x = .lt) (hx : cut x = .lt) : cut y = .gt :=
  let ⟨_, h1, h2⟩ := mem_iff_mem_toList.1 hy
  IsCut.congr (cut := cut) h2 ▸
  t.2.out.1.upperBound?_least H (mem_toList.1 h1) (Std.TransCmp.congr_left h2 ▸ xy) hx

/--
A statement of the greatest-ness of the result of `lowerBoundP?`. If `x` is the return value of
`lowerBoundP?` and it is strictly less than the cut, then any other `y > x` in the tree is in fact
strictly greater than the cut (so there is no exact match, and nothing closer to the cut).
-/
theorem lowerBoundP?_greatest {t : RBSet α cmp} [Std.TransCmp cmp] [IsCut cmp cut]
    (H : t.lowerBoundP? cut = some x) (hy : y ∈ t)
    (xy : cmp x y = .lt) (hx : cut x = .gt) : cut y = .lt :=
  let ⟨_, h1, h2⟩ := mem_iff_mem_toList.1 hy
  IsCut.congr (cut := cut) h2 ▸
  t.2.out.1.lowerBound?_greatest H (mem_toList.1 h1) (Std.TransCmp.congr_right h2 ▸ xy) hx

theorem memP_iff_upperBoundP? {t : RBSet α cmp} [Std.TransCmp cmp] [IsCut cmp cut] :
    t.MemP cut ↔ ∃ x, t.upperBoundP? cut = some x ∧ cut x = .eq := t.2.out.1.memP_iff_upperBound?

theorem memP_iff_lowerBoundP? {t : RBSet α cmp} [Std.TransCmp cmp] [IsCut cmp cut] :
    t.MemP cut ↔ ∃ x, t.lowerBoundP? cut = some x ∧ cut x = .eq := t.2.out.1.memP_iff_lowerBound?

theorem mem_iff_upperBound? {t : RBSet α cmp} [Std.TransCmp cmp] :
    x ∈ t ↔ ∃ y, t.upperBound? x = some y ∧ cmp x y = .eq := memP_iff_upperBoundP?

theorem mem_iff_lowerBound? {t : RBSet α cmp} [Std.TransCmp cmp] :
    x ∈ t ↔ ∃ y, t.lowerBound? x = some y ∧ cmp x y = .eq := memP_iff_lowerBoundP?

/-- A stronger version of `upperBoundP?_least` that holds when the cut is strict. -/
theorem lt_upperBoundP? {t : RBSet α cmp} [Std.TransCmp cmp] [IsStrictCut cmp cut]
    (H : t.upperBoundP? cut = some x) (hy : y ∈ t) : cmp y x = .lt ↔ cut y = .gt :=
  let ⟨_, h1, h2⟩ := mem_iff_mem_toList.1 hy
  IsCut.congr (cut := cut) h2 ▸ Std.TransCmp.congr_left h2 ▸
  t.2.out.1.lt_upperBound? H (mem_toList.1 h1)

/-- A stronger version of `lowerBoundP?_greatest` that holds when the cut is strict. -/
theorem lowerBoundP?_lt {t : RBSet α cmp} [Std.TransCmp cmp] [IsStrictCut cmp cut]
    (H : t.lowerBoundP? cut = some x) (hy : y ∈ t) : cmp x y = .lt ↔ cut y = .lt :=
  let ⟨_, h1, h2⟩ := mem_iff_mem_toList.1 hy
  IsCut.congr (cut := cut) h2 ▸ Std.TransCmp.congr_right h2 ▸
  t.2.out.1.lowerBound?_lt H (mem_toList.1 h1)

theorem lt_upperBound? {t : RBSet α cmp} [Std.TransCmp cmp]
    (H : t.upperBound? x = some y) (hz : z ∈ t) : cmp z y = .lt ↔ cmp z x = .lt :=
  (lt_upperBoundP? H hz).trans Std.OrientedCmp.gt_iff_lt

theorem lowerBound?_lt {t : RBSet α cmp} [Std.TransCmp cmp]
    (H : t.lowerBound? x = some y) (hz : z ∈ t) : cmp y z = .lt ↔ cmp x z = .lt :=
  lowerBoundP?_lt H hz

end RBSet

namespace RBMap

-- @[simp] -- FIXME: RBSet.val_toList already triggers here, seems bad?
theorem val_toList {t : RBMap α β cmp} : t.1.toList = t.toList := rfl

@[simp] theorem mkRBSet_eq : mkRBMap α β cmp = ∅ := rfl
@[simp] theorem empty_eq : @RBMap.empty α β cmp = ∅ := rfl
@[simp] theorem default_eq : (default : RBMap α β cmp) = ∅ := rfl
@[simp] theorem empty_toList : toList (∅ : RBMap α β cmp) = [] := rfl
@[simp] theorem single_toList : toList (single a b : RBMap α β cmp) = [(a, b)] := rfl

theorem mem_toList {t : RBMap α β cmp} : x ∈ toList t ↔ x ∈ t.1 := RBNode.mem_toList

theorem foldl_eq_foldl_toList {t : RBMap α β cmp} :
    t.foldl f init = t.toList.foldl (fun r p => f r p.1 p.2) init :=
  RBNode.foldl_eq_foldl_toList

theorem foldr_eq_foldr_toList {t : RBMap α β cmp} :
    t.foldr f init = t.toList.foldr (fun p r => f p.1 p.2 r) init :=
  RBNode.foldr_eq_foldr_toList

theorem foldlM_eq_foldlM_toList [Monad m] [LawfulMonad m] {t : RBMap α β cmp} :
    t.foldlM (m := m) f init = t.toList.foldlM (fun r p => f r p.1 p.2) init :=
  RBNode.foldlM_eq_foldlM_toList

theorem forM_eq_forM_toList [Monad m] [LawfulMonad m] {t : RBMap α β cmp} :
    t.forM (m := m) f = t.toList.forM (fun p => f p.1 p.2) :=
  RBNode.forM_eq_forM_toList

theorem forIn_eq_forIn_toList [Monad m] [LawfulMonad m] {t : RBMap α β cmp} :
    forIn (m := m) t init f = forIn t.toList init f := RBNode.forIn_eq_forIn_toList

theorem toStream_eq {t : RBMap α β cmp} : toStream t = t.1.toStream .nil := rfl

@[simp] theorem toStream_toList {t : RBMap α β cmp} : (toStream t).toList = t.toList :=
  RBSet.toStream_toList

theorem toList_sorted {t : RBMap α β cmp} : t.toList.Pairwise (RBNode.cmpLT (cmp ·.1 ·.1)) :=
  RBSet.toList_sorted

theorem findEntry?_some_eq_eq {t : RBMap α β cmp} : t.findEntry? x = some (y, v) → cmp x y = .eq :=
  RBSet.findP?_some_eq_eq

theorem findEntry?_some_mem_toList {t : RBMap α β cmp} (h : t.findEntry? x = some y) :
    y ∈ toList t := RBSet.findP?_some_mem_toList h

theorem find?_some_mem_toList {t : RBMap α β cmp} (h : t.find? x = some v) :
    ∃ y, (y, v) ∈ toList t ∧ cmp x y = .eq := by
  obtain ⟨⟨y, v⟩, h', rfl⟩ := Option.map_eq_some_iff.1 h
  exact ⟨_, findEntry?_some_mem_toList h', findEntry?_some_eq_eq h'⟩

theorem mem_toList_unique [Std.TransCmp (α := α) cmp] {t : RBMap α β cmp}
    (hx : x ∈ toList t) (hy : y ∈ toList t) (e : cmp x.1 y.1 = .eq) : x = y :=
  RBSet.mem_toList_unique hx hy e

/-- A "representable cut" is one generated by `cmp a` for some `a`. This is always a valid cut. -/
instance (cmp) (a : α) : IsStrictCut cmp (cmp a) where
  le_lt_trans h₁ h₂ := Std.TransCmp.lt_of_lt_of_le h₂ h₁
  le_gt_trans h₁ := Decidable.not_imp_not.1 (Std.TransCmp.le_trans · h₁)
  exact h := (Std.TransCmp.congr_left h).symm

instance (f : α → β) (cmp) [Std.TransCmp (α := β) cmp] (x : β) :
    IsStrictCut (Ordering.byKey f cmp) (fun y => cmp x (f y)) where
  le_lt_trans h₁ h₂ := Std.TransCmp.lt_of_lt_of_le h₂ h₁
  le_gt_trans h₁ := Decidable.not_imp_not.1 (Std.TransCmp.le_trans · h₁)
  exact h := (Std.TransCmp.congr_left h).symm

theorem findEntry?_some [Std.TransCmp (α := α) cmp] {t : RBMap α β cmp} :
    t.findEntry? x = some y ↔ y ∈ toList t ∧ cmp x y.1 = .eq := RBSet.findP?_some

theorem find?_some [Std.TransCmp (α := α) cmp] {t : RBMap α β cmp} :
    t.find? x = some v ↔ ∃ y, (y, v) ∈ toList t ∧ cmp x y = .eq := by
  simp only [find?, findEntry?_some, Option.map_eq_some_iff]; constructor
  · rintro ⟨_, h, rfl⟩; exact ⟨_, h⟩
  · rintro ⟨b, h⟩; exact ⟨_, h, rfl⟩

theorem contains_iff_findEntry? {t : RBMap α β cmp} :
    t.contains x ↔ ∃ v, t.findEntry? x = some v := Option.isSome_iff_exists

theorem contains_iff_find? {t : RBMap α β cmp} :
    t.contains x ↔ ∃ v, t.find? x = some v := by
  simp only [contains_iff_findEntry?, Prod.exists, find?, Option.map_eq_some_iff, and_comm,
    exists_eq_left]
  rw [exists_comm]

theorem size_eq (t : RBMap α β cmp) : t.size = t.toList.length := RBNode.size_eq

theorem mem_toList_insert_self (v) (t : RBMap α β cmp) : (k, v) ∈ toList (t.insert k v) :=
  RBSet.mem_toList_insert_self ..

theorem mem_toList_insert_of_mem (v) {t : RBMap α β cmp} (h : y ∈ toList t) :
    y ∈ toList (t.insert k v) ∨ cmp k y.1 = .eq := RBSet.mem_toList_insert_of_mem _ h

theorem mem_toList_insert [Std.TransCmp (α := α) cmp] {t : RBMap α β cmp} :
    y ∈ toList (t.insert k v) ↔ (y ∈ toList t ∧ t.findEntry? k ≠ some y) ∨ y = (k, v) :=
  RBSet.mem_toList_insert

theorem findEntry?_congr [Std.TransCmp (α := α) cmp] (t : RBMap α β cmp) (h : cmp k₁ k₂ = .eq) :
    t.findEntry? k₁ = t.findEntry? k₂ := by
  simp only [findEntry?]; congr; funext; rw [Std.TransCmp.congr_left h]

theorem find?_congr [Std.TransCmp (α := α) cmp] (t : RBMap α β cmp) (h : cmp k₁ k₂ = .eq) :
    t.find? k₁ = t.find? k₂ := by simp [find?, findEntry?_congr _ h]

theorem findEntry?_insert_of_eq [Std.TransCmp (α := α) cmp] (t : RBMap α β cmp)
    (h : cmp k' k = .eq) : (t.insert k v).findEntry? k' = some (k, v) :=
  RBSet.findP?_insert_of_eq _ h

theorem find?_insert_of_eq [Std.TransCmp (α := α) cmp] (t : RBMap α β cmp) (h : cmp k' k = .eq) :
    (t.insert k v).find? k' = some v := by rw [find?, findEntry?_insert_of_eq _ h]; rfl

theorem findEntry?_insert_of_ne [Std.TransCmp (α := α) cmp] (t : RBMap α β cmp)
    (h : cmp k' k ≠ .eq) : (t.insert k v).findEntry? k' = t.findEntry? k' :=
  RBSet.findP?_insert_of_ne _ h

theorem find?_insert_of_ne [Std.TransCmp (α := α) cmp] (t : RBMap α β cmp) (h : cmp k' k ≠ .eq) :
    (t.insert k v).find? k' = t.find? k' := by simp [find?, findEntry?_insert_of_ne _ h]

theorem findEntry?_insert [Std.TransCmp (α := α) cmp] (t : RBMap α β cmp) (k v k') :
    (t.insert k v).findEntry? k' = if cmp k' k = .eq then some (k, v) else t.findEntry? k' :=
  RBSet.findP?_insert ..

theorem find?_insert [Std.TransCmp (α := α) cmp] (t : RBMap α β cmp) (k v k') :
    (t.insert k v).find? k' = if cmp k' k = .eq then some v else t.find? k' := by
  split <;> [exact find?_insert_of_eq t ‹_›; exact find?_insert_of_ne t ‹_›]

end RBMap



=== LEAN SOURCE: WF.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Batteries.Data.RBMap.Basic
import Batteries.Tactic.SeqFocus

/-!
# Lemmas for Red-black trees

The main theorem in this file is `WF_def`, which shows that the `RBNode.WF.mk` constructor
subsumes the others, by showing that `insert` and `erase` satisfy the red-black invariants.
-/

namespace Batteries

namespace RBNode
open RBColor

attribute [simp] All

theorem All.trivial (H : ∀ {x : α}, p x) : ∀ {t : RBNode α}, t.All p
  | nil => _root_.trivial
  | node .. => ⟨H, All.trivial H, All.trivial H⟩

theorem All_and {t : RBNode α} : t.All (fun a => p a ∧ q a) ↔ t.All p ∧ t.All q := by
  induction t <;> simp [*, and_assoc, and_left_comm]

protected theorem cmpLT.flip (h₁ : cmpLT cmp x y) : cmpLT (flip cmp) y x :=
  ⟨have : Std.TransCmp cmp := inferInstanceAs (Std.TransCmp (flip (flip cmp))); h₁.1⟩

theorem cmpLT.trans (h₁ : cmpLT cmp x y) (h₂ : cmpLT cmp y z) : cmpLT cmp x z :=
  ⟨Std.TransCmp.lt_trans h₁.1 h₂.1⟩

theorem cmpLT.trans_l {cmp x y} (H : cmpLT cmp x y) {t : RBNode α}
    (h : t.All (cmpLT cmp y ·)) : t.All (cmpLT cmp x ·) := h.imp fun h => H.trans h

theorem cmpLT.trans_r {cmp x y} (H : cmpLT cmp x y) {a : RBNode α}
    (h : a.All (cmpLT cmp · x)) : a.All (cmpLT cmp · y) := h.imp fun h => h.trans H

theorem cmpEq.lt_congr_left (H : cmpEq cmp x y) : cmpLT cmp x z ↔ cmpLT cmp y z :=
  ⟨fun ⟨h⟩ => ⟨Std.TransCmp.congr_left H.1 ▸ h⟩, fun ⟨h⟩ => ⟨Std.TransCmp.congr_left H.1 ▸ h⟩⟩

theorem cmpEq.lt_congr_right (H : cmpEq cmp y z) : cmpLT cmp x y ↔ cmpLT cmp x z :=
  ⟨fun ⟨h⟩ => ⟨Std.TransCmp.congr_right H.1 ▸ h⟩, fun ⟨h⟩ => ⟨Std.TransCmp.congr_right H.1 ▸ h⟩⟩

@[simp] theorem reverse_reverse (t : RBNode α) : t.reverse.reverse = t := by
  induction t <;> simp [*]

theorem reverse_eq_iff {t t' : RBNode α} : t.reverse = t' ↔ t = t'.reverse := by
  constructor <;> rintro rfl <;> simp

@[simp] theorem reverse_balance1 (l : RBNode α) (v : α) (r : RBNode α) :
    (balance1 l v r).reverse = balance2 r.reverse v l.reverse := by
  unfold balance1 balance2; split <;> simp
  · rw [balance2.match_1.eq_2]; simp [reverse_eq_iff]; intros; solve_by_elim
  · rw [balance2.match_1.eq_3] <;> (simp [reverse_eq_iff]; intros; solve_by_elim)

@[simp] theorem reverse_balance2 (l : RBNode α) (v : α) (r : RBNode α) :
    (balance2 l v r).reverse = balance1 r.reverse v l.reverse := by
  refine Eq.trans ?_ (reverse_reverse _); rw [reverse_balance1]; simp

@[simp] theorem All.reverse {t : RBNode α} : t.reverse.All p ↔ t.All p := by
  induction t <;> simp [*, and_comm]

/-- The `reverse` function reverses the ordering invariants. -/
protected theorem Ordered.reverse : ∀ {t : RBNode α}, t.Ordered cmp → t.reverse.Ordered (flip cmp)
  | .nil, _ => ⟨⟩
  | .node .., ⟨lv, vr, hl, hr⟩ =>
    ⟨(All.reverse.2 vr).imp cmpLT.flip, (All.reverse.2 lv).imp cmpLT.flip, hr.reverse, hl.reverse⟩

protected theorem Balanced.reverse {t : RBNode α} : t.Balanced c n → t.reverse.Balanced c n
  | .nil => .nil
  | .black hl hr => .black hr.reverse hl.reverse
  | .red hl hr => .red hr.reverse hl.reverse

/-- The `balance1` function preserves the ordering invariants. -/
protected theorem Ordered.balance1 {l : RBNode α} {v : α} {r : RBNode α}
    (lv : l.All (cmpLT cmp · v)) (vr : r.All (cmpLT cmp v ·))
    (hl : l.Ordered cmp) (hr : r.Ordered cmp) : (balance1 l v r).Ordered cmp := by
  unfold balance1; split
  · next a x b y c =>
    have ⟨yv, _, cv⟩ := lv; have ⟨xy, yc, hx, hc⟩ := hl
    exact ⟨xy, ⟨yv, yc, yv.trans_l vr⟩, hx, cv, vr, hc, hr⟩
  · next a x b y c _ =>
    have ⟨_, _, yv, _, cv⟩ := lv; have ⟨ax, ⟨xy, xb, _⟩, ha, by_, yc, hb, hc⟩ := hl
    exact ⟨⟨xy, xy.trans_r ax, by_⟩, ⟨yv, yc, yv.trans_l vr⟩, ⟨ax, xb, ha, hb⟩, cv, vr, hc, hr⟩
  · exact ⟨lv, vr, hl, hr⟩

@[simp] theorem balance1_All {l : RBNode α} {v : α} {r : RBNode α} :
    (balance1 l v r).All p ↔ p v ∧ l.All p ∧ r.All p := by
  unfold balance1; split <;> simp [and_assoc, and_left_comm]

/-- The `balance2` function preserves the ordering invariants. -/
protected theorem Ordered.balance2 {l : RBNode α} {v : α} {r : RBNode α}
    (lv : l.All (cmpLT cmp · v)) (vr : r.All (cmpLT cmp v ·))
    (hl : l.Ordered cmp) (hr : r.Ordered cmp) : (balance2 l v r).Ordered cmp := by
  rw [← reverse_reverse (balance2 ..), reverse_balance2]
  exact .reverse <| hr.reverse.balance1
    ((All.reverse.2 vr).imp cmpLT.flip) ((All.reverse.2 lv).imp cmpLT.flip) hl.reverse

@[simp] theorem balance2_All {l : RBNode α} {v : α} {r : RBNode α} :
    (balance2 l v r).All p ↔ p v ∧ l.All p ∧ r.All p := by
  unfold balance2; split <;> simp [and_assoc, and_left_comm]

@[simp] theorem reverse_setBlack {t : RBNode α} : (setBlack t).reverse = setBlack t.reverse := by
  unfold setBlack; split <;> simp

protected theorem Ordered.setBlack {t : RBNode α} : (setBlack t).Ordered cmp ↔ t.Ordered cmp := by
  unfold setBlack; split <;> simp [Ordered]

protected theorem Balanced.setBlack : t.Balanced c n → ∃ n', (setBlack t).Balanced black n'
  | .nil => ⟨_, .nil⟩
  | .black hl hr | .red hl hr => ⟨_, hl.black hr⟩

theorem setBlack_idem {t : RBNode α} : t.setBlack.setBlack = t.setBlack := by cases t <;> rfl

@[simp] theorem reverse_ins [inst : Std.OrientedCmp (α := α) cmp] {t : RBNode α} :
    (ins cmp x t).reverse = ins (flip cmp) x t.reverse := by
  induction t with
  | nil => simp [ins]
  | node c a y b iha ihb =>
    cases c <;>
      (simp only [ins, Std.OrientedCmp.eq_swap (cmp := cmp) (a := x) (b := y)]; split) <;>
        simp_all [ins, reverse, flip]

protected theorem All.ins {x : α} {t : RBNode α}
  (h₁ : p x) (h₂ : t.All p) : (ins cmp x t).All p := by
  induction t <;> unfold ins <;> try simp [*]
  split <;> cases ‹_=_› <;> split <;> simp at h₂ <;> simp [*]

/-- The `ins` function preserves the ordering invariants. -/
protected theorem Ordered.ins : ∀ {t : RBNode α}, t.Ordered cmp → (ins cmp x t).Ordered cmp
  | nil, _ => ⟨⟨⟩, ⟨⟩, ⟨⟩, ⟨⟩⟩
  | node red a y b, ⟨ay, yb, ha, hb⟩ => by
    unfold ins; split
    · next h => exact ⟨ay.ins ⟨h⟩, yb, ha.ins, hb⟩
    · next h => exact ⟨ay, yb.ins ⟨Std.OrientedCmp.gt_iff_lt.1 h⟩, ha, hb.ins⟩
    · next h => exact (⟨
        ay.imp fun ⟨h'⟩ => ⟨(Std.TransCmp.congr_right h).trans h'⟩,
        yb.imp fun ⟨h'⟩ => ⟨(Std.TransCmp.congr_left h).trans h'⟩, ha, hb⟩)
  | node black a y b, ⟨ay, yb, ha, hb⟩ => by
    unfold ins; split
    · next h => exact ha.ins.balance1 (ay.ins ⟨h⟩) yb hb
    · next h => exact ha.balance2 ay (yb.ins ⟨Std.OrientedCmp.gt_iff_lt.1 h⟩) hb.ins
    · next h => exact (⟨
        ay.imp fun ⟨h'⟩ => ⟨(Std.TransCmp.congr_right h).trans h'⟩,
        yb.imp fun ⟨h'⟩ => ⟨(Std.TransCmp.congr_left h).trans h'⟩, ha, hb⟩)

@[simp] theorem isRed_reverse {t : RBNode α} : t.reverse.isRed = t.isRed := by
  cases t <;> simp [isRed]

@[simp] theorem reverse_insert [inst : Std.OrientedCmp (α := α) cmp] {t : RBNode α} :
    (insert cmp t x).reverse = insert (flip cmp) t.reverse x := by
  simp [insert]; split <;> simp

theorem insert_setBlack {t : RBNode α} :
    (t.insert cmp v).setBlack = (t.ins cmp v).setBlack := by
  unfold insert; split <;> simp [setBlack_idem]

/-- The `insert` function preserves the ordering invariants. -/
protected theorem Ordered.insert (h : t.Ordered cmp) : (insert cmp t v).Ordered cmp := by
  unfold RBNode.insert; split <;> simp [Ordered.setBlack, h.ins (x := v)]

/--
The red-red invariant is a weakening of the red-black balance invariant which allows
the root to be red with red children, but does not allow any other violations.
It occurs as a temporary condition in the `insert` and `erase` functions.

The `p` parameter allows the `.redred` case to be dependent on an additional condition.
If it is false, then this is equivalent to the usual red-black invariant.
-/
inductive RedRed (p : Prop) : RBNode α → Nat → Prop where
  /-- A balanced tree has the red-red invariant. -/
  | balanced : Balanced t c n → RedRed p t n
  /-- A red node with balanced red children has the red-red invariant (if `p` is true). -/
  | redred : p → Balanced a c₁ n → Balanced b c₂ n → RedRed p (node red a x b) n

/-- When `p` is false, the red-red case is impossible so the tree is balanced. -/
protected theorem RedRed.of_false (h : ¬p) : RedRed p t n → ∃ c, Balanced t c n
  | .balanced h => ⟨_, h⟩
  | .redred hp .. => nomatch h hp

/-- A `red` node with the red-red invariant has balanced children. -/
protected theorem RedRed.of_red : RedRed p (node red a x b) n →
    ∃ c₁ c₂, Balanced a c₁ n ∧ Balanced b c₂ n
  | .balanced (.red ha hb) | .redred _ ha hb => ⟨_, _, ha, hb⟩

/-- The red-red invariant is monotonic in `p`. -/
protected theorem RedRed.imp (h : p → q) : RedRed p t n → RedRed q t n
  | .balanced h => .balanced h
  | .redred hp ha hb => .redred (h hp) ha hb

protected theorem RedRed.reverse : RedRed p t n → RedRed p t.reverse n
  | .balanced h => .balanced h.reverse
  | .redred hp ha hb => .redred hp hb.reverse ha.reverse

/-- If `t` has the red-red invariant, then setting the root to black yields a balanced tree. -/
protected theorem RedRed.setBlack : t.RedRed p n → ∃ n', (setBlack t).Balanced black n'
  | .balanced h => h.setBlack
  | .redred _ hl hr => ⟨_, hl.black hr⟩

/-- The `balance1` function repairs the balance invariant when the first argument is red-red. -/
protected theorem RedRed.balance1 {l : RBNode α} {v : α} {r : RBNode α}
    (hl : l.RedRed p n) (hr : r.Balanced c n) : ∃ c, (balance1 l v r).Balanced c (n + 1) := by
  unfold balance1; split
  · have .redred _ (.red ha hb) hc := hl; exact ⟨_, .red (.black ha hb) (.black hc hr)⟩
  · have .redred _ ha (.red hb hc) := hl; exact ⟨_, .red (.black ha hb) (.black hc hr)⟩
  · next H1 H2 => match hl with
    | .balanced hl => exact ⟨_, .black hl hr⟩
    | .redred _ (c₁ := black) (c₂ := black) ha hb => exact ⟨_, .black (.red ha hb) hr⟩
    | .redred _ (c₁ := red) (.red ..) _ => cases H1 _ _ _ _ _ rfl
    | .redred _ (c₂ := red) _ (.red ..) => cases H2 _ _ _ _ _ rfl

/-- The `balance2` function repairs the balance invariant when the second argument is red-red. -/
protected theorem RedRed.balance2 {l : RBNode α} {v : α} {r : RBNode α}
    (hl : l.Balanced c n) (hr : r.RedRed p n) : ∃ c, (balance2 l v r).Balanced c (n + 1) :=
  (hr.reverse.balance1 hl.reverse (v := v)).imp fun _ h => by simpa using h.reverse

/-- The `balance1` function does nothing if the first argument is already balanced. -/
theorem balance1_eq {l : RBNode α} {v : α} {r : RBNode α}
    (hl : l.Balanced c n) : balance1 l v r = node black l v r := by
  unfold balance1; split <;> first | rfl | nomatch hl

/-- The `balance2` function does nothing if the second argument is already balanced. -/
theorem balance2_eq {l : RBNode α} {v : α} {r : RBNode α}
    (hr : r.Balanced c n) : balance2 l v r = node black l v r :=
  (reverse_reverse _).symm.trans <| by simp [balance1_eq hr.reverse]

/-! ## insert -/

/--
The balance invariant of the `ins` function.
The result of inserting into the tree either yields a balanced tree,
or a tree which is almost balanced except that it has a red-red violation at the root.
-/
protected theorem Balanced.ins (cmp v) {t : RBNode α}
    (h : t.Balanced c n) : (ins cmp v t).RedRed (t.isRed = red) n := by
  induction h with
  | nil => exact .balanced (.red .nil .nil)
  | @red a n b x hl hr ihl ihr =>
    unfold ins; split
    · match ins cmp v a, ihl with
      | _, .balanced .nil => exact .balanced (.red .nil hr)
      | _, .balanced (.red ha hb) => exact .redred rfl (.red ha hb) hr
      | _, .balanced (.black ha hb) => exact .balanced (.red (.black ha hb) hr)
      | _, .redred h .. => cases hl <;> cases h
    · match ins cmp v b, ihr with
      | _, .balanced .nil => exact .balanced (.red hl .nil)
      | _, .balanced (.red ha hb) => exact .redred rfl hl (.red ha hb)
      | _, .balanced (.black ha hb) => exact .balanced (.red hl (.black ha hb))
      | _, .redred h .. => cases hr <;> cases h
    · exact .balanced (.red hl hr)
  | @black a ca n b cb x hl hr ihl ihr =>
    unfold ins; split
    · exact have ⟨c, h⟩ := ihl.balance1 hr; .balanced h
    · exact have ⟨c, h⟩ := ihr.balance2 hl; .balanced h
    · exact .balanced (.black hl hr)

/--
The `insert` function is balanced if the input is balanced.
(We lose track of both the color and the black-height of the result,
so this is only suitable for use on the root of the tree.)
-/
theorem Balanced.insert {t : RBNode α} (h : t.Balanced c n) :
    ∃ c' n', (insert cmp t v).Balanced c' n' := by
  unfold RBNode.insert
  match ins cmp v t, h.ins cmp v with
  | _, .balanced h => split <;> [exact ⟨_, h.setBlack⟩; exact ⟨_, _, h⟩]
  | _, .redred _ ha hb => have .node red .. := t; exact ⟨_, _, .black ha hb⟩

@[simp] theorem reverse_setRed {t : RBNode α} : (setRed t).reverse = setRed t.reverse := by
  unfold setRed; split <;> simp

protected theorem All.setRed {t : RBNode α} (h : t.All p) : (setRed t).All p := by
  unfold setRed; split <;> simp_all

/-- The `setRed` function preserves the ordering invariants. -/
protected theorem Ordered.setRed {t : RBNode α} : (setRed t).Ordered cmp ↔ t.Ordered cmp := by
  unfold setRed; split <;> simp [Ordered]

@[simp] theorem reverse_balLeft (l : RBNode α) (v : α) (r : RBNode α) :
    (balLeft l v r).reverse = balRight r.reverse v l.reverse := by
  unfold balLeft balRight; split
  · simp
  · rw [balLeft.match_3.eq_2 _ _ _ _ (by simp [reverse_eq_iff]; intros; solve_by_elim)]
    split <;> simp
    rw [balRight.match_1.eq_3] <;> (simp [reverse_eq_iff]; intros; solve_by_elim)

@[simp] theorem reverse_balRight (l : RBNode α) (v : α) (r : RBNode α) :
    (balRight l v r).reverse = balLeft r.reverse v l.reverse := by
  rw [← reverse_reverse (balLeft ..)]; simp

protected theorem All.balLeft
    (hl : l.All p) (hv : p v) (hr : r.All p) : (balLeft l v r).All p := by
  unfold balLeft; split <;> (try simp_all); split <;> simp_all [All.setRed]

/-- The `balLeft` function preserves the ordering invariants. -/
protected theorem Ordered.balLeft {l : RBNode α} {v : α} {r : RBNode α}
    (lv : l.All (cmpLT cmp · v)) (vr : r.All (cmpLT cmp v ·))
    (hl : l.Ordered cmp) (hr : r.Ordered cmp) : (balLeft l v r).Ordered cmp := by
  unfold balLeft; split
  · exact ⟨lv, vr, hl, hr⟩
  split
  · exact hl.balance2 lv vr hr
  · have ⟨vy, va, _⟩ := vr.2.1; have ⟨⟨yz, _, bz⟩, zc, ⟨ay, yb, ha, hb⟩, hc⟩ := hr
    exact ⟨⟨vy, vy.trans_r lv, ay⟩, balance2_All.2 ⟨yz, yb, (yz.trans_l zc).setRed⟩,
      ⟨lv, va, hl, ha⟩, hb.balance2 bz zc.setRed (Ordered.setRed.2 hc)⟩
  · exact ⟨lv, vr, hl, hr⟩

/-- The balancing properties of the `balLeft` function. -/
protected theorem Balanced.balLeft (hl : l.RedRed True n) (hr : r.Balanced cr (n + 1)) :
    (balLeft l v r).RedRed (cr = red) (n + 1) := by
  unfold balLeft; split
  · next a x b => exact
    let ⟨ca, cb, ha, hb⟩ := hl.of_red
    match cr with
    | red => .redred rfl (.black ha hb) hr
    | black => .balanced (.red (.black ha hb) hr)
  · next H => exact match hl with
    | .redred .. => nomatch H _ _ _ rfl
    | .balanced hl => match hr with
      | .black ha hb =>
        let ⟨c, h⟩ := RedRed.balance2 hl (.redred trivial ha hb); .balanced h
      | .red (.black ha hb) (.black hc hd) =>
        let ⟨c, h⟩ := RedRed.balance2 hb (.redred trivial hc hd); .redred rfl (.black hl ha) h

protected theorem All.balRight
    (hl : l.All p) (hv : p v) (hr : r.All p) : (balRight l v r).All p :=
  All.reverse.1 <| reverse_balRight .. ▸ (All.reverse.2 hr).balLeft hv (All.reverse.2 hl)

/-- The `balRight` function preserves the ordering invariants. -/
protected theorem Ordered.balRight {l : RBNode α} {v : α} {r : RBNode α}
    (lv : l.All (cmpLT cmp · v)) (vr : r.All (cmpLT cmp v ·))
    (hl : l.Ordered cmp) (hr : r.Ordered cmp) : (balRight l v r).Ordered cmp := by
  rw [← reverse_reverse (balRight ..), reverse_balRight]
  exact .reverse <| hr.reverse.balLeft
    ((All.reverse.2 vr).imp cmpLT.flip) ((All.reverse.2 lv).imp cmpLT.flip) hl.reverse

/-- The balancing properties of the `balRight` function. -/
protected theorem Balanced.balRight (hl : l.Balanced cl (n + 1)) (hr : r.RedRed True n) :
    (balRight l v r).RedRed (cl = red) (n + 1) := by
  rw [← reverse_reverse (balRight ..), reverse_balRight]
  exact .reverse <| hl.reverse.balLeft hr.reverse

-- note: reverse_append is false!

protected theorem All.append (hl : l.All p) (hr : r.All p) : (append l r).All p := by
  unfold append; split <;> try simp [*]
  · have ⟨hx, ha, hb⟩ := hl; have ⟨hy, hc, hd⟩ := hr
    have := hb.append hc; split <;> simp_all
  · have ⟨hx, ha, hb⟩ := hl; have ⟨hy, hc, hd⟩ := hr
    have := hb.append hc; split <;> simp_all [All.balLeft]
  · simp_all [hl.append hr.2.1]
  · simp_all [hl.2.2.append hr]
termination_by l.size + r.size

/-- The `append` function preserves the ordering invariants. -/
protected theorem Ordered.append {l : RBNode α} {v : α} {r : RBNode α}
    (lv : l.All (cmpLT cmp · v)) (vr : r.All (cmpLT cmp v ·))
    (hl : l.Ordered cmp) (hr : r.Ordered cmp) : (append l r).Ordered cmp := by
  unfold append; split
  · exact hr
  · exact hl
  · have ⟨xv, _, bv⟩ := lv; have ⟨ax, xb, ha, hb⟩ := hl
    have ⟨vy, vc, _⟩ := vr; have ⟨cy, yd, hc, hd⟩ := hr
    have : _ ∧ _ ∧ _ := ⟨hb.append bv vc hc, xb.append (xv.trans_l vc), (vy.trans_r bv).append cy⟩
    split
    · next H =>
      have ⟨⟨b'z, c'z, hb', hc'⟩, ⟨xz, xb', _⟩, zy, _, c'y⟩ := H ▸ this
      have az := xz.trans_r ax; have zd := zy.trans_l yd
      exact ⟨⟨xz, az, b'z⟩, ⟨zy, c'z, zd⟩, ⟨ax, xb', ha, hb'⟩, c'y, yd, hc', hd⟩
    · have ⟨hbc, xbc, bcy⟩ := this; have xy := xv.trans vy
      exact ⟨ax, ⟨xy, xbc, xy.trans_l yd⟩, ha, bcy, yd, hbc, hd⟩
  · have ⟨xv, _, bv⟩ := lv; have ⟨ax, xb, ha, hb⟩ := hl
    have ⟨vy, vc, _⟩ := vr; have ⟨cy, yd, hc, hd⟩ := hr
    have : _ ∧ _ ∧ _ := ⟨hb.append bv vc hc, xb.append (xv.trans_l vc), (vy.trans_r bv).append cy⟩
    split
    · next H =>
      have ⟨⟨b'z, c'z, hb', hc'⟩, ⟨xz, xb', _⟩, zy, _, c'y⟩ := H ▸ this
      have az := xz.trans_r ax; have zd := zy.trans_l yd
      exact ⟨⟨xz, az, b'z⟩, ⟨zy, c'z, zd⟩, ⟨ax, xb', ha, hb'⟩, c'y, yd, hc', hd⟩
    · have ⟨hbc, xbc, bcy⟩ := this; have xy := xv.trans vy
      exact ha.balLeft ax ⟨xy, xbc, xy.trans_l yd⟩ ⟨bcy, yd, hbc, hd⟩
  · have ⟨vx, vb, _⟩ := vr; have ⟨bx, yc, hb, hc⟩ := hr
    exact ⟨(vx.trans_r lv).append bx, yc, hl.append lv vb hb, hc⟩
  · have ⟨xv, _, bv⟩ := lv; have ⟨ax, xb, ha, hb⟩ := hl
    exact ⟨ax, xb.append (xv.trans_l vr), ha, hb.append bv vr hr⟩
termination_by l.size + r.size

/-- The balance properties of the `append` function. -/
protected theorem Balanced.append {l r : RBNode α}
    (hl : l.Balanced c₁ n) (hr : r.Balanced c₂ n) :
    (l.append r).RedRed (c₁ = black → c₂ ≠ black) n := by
  unfold append; split
  · exact .balanced hr
  · exact .balanced hl
  · next b c _ _ =>
    have .red ha hb := hl; have .red hc hd := hr
    have ⟨_, IH⟩ := (hb.append hc).of_false (· rfl rfl); split
    · next e =>
      have .red hb' hc' := e ▸ IH
      exact .redred nofun (.red ha hb') (.red hc' hd)
    · next bcc _ H =>
      match bcc, append b c, IH, H with
      | black, _, IH, _ => exact .redred nofun ha (.red IH hd)
      | red, _, .red .., H => cases H _ _ _ rfl
  · next b c _ _ =>
    have .black ha hb := hl; have .black hc hd := hr
    have IH := hb.append hc; split
    · next e => match e ▸ IH with
      | .balanced (.red hb' hc') | .redred _ hb' hc' =>
        exact .balanced (.red (.black ha hb') (.black hc' hd))
    · next H =>
      match append b c, IH, H with
      | bc, .balanced hbc, _ =>
        unfold balLeft; split
        · have .red ha' hb' := ha
          exact .balanced (.red (.black ha' hb') (.black hbc hd))
        · exact have ⟨c, h⟩ := RedRed.balance2 ha (.redred trivial hbc hd); .balanced h
      | _, .redred .., H => cases H _ _ _ rfl
  · have .red hc hd := hr; have IH := hl.append hc
    have .black ha hb := hl; have ⟨c, IH⟩ := IH.of_false (· rfl rfl)
    exact .redred nofun IH hd
  · have .red ha hb := hl; have IH := hb.append hr
    have .black hc hd := hr; have ⟨c, IH⟩ := IH.of_false (· rfl rfl)
    exact .redred nofun ha IH
termination_by l.size + r.size

/-! ## erase -/

/--
The invariant of the `del` function.
* If the input tree is black, then the result of deletion is a red-red tree with
  black-height lowered by 1.
* If the input tree is red or nil, then the result of deletion is a balanced tree with
  some color and the same black-height.
-/
def DelProp (p : RBColor) (t : RBNode α) (n : Nat) : Prop :=
  match p with
  | black => ∃ n', n = n' + 1 ∧ RedRed True t n'
  | red => ∃ c, Balanced t c n

/-- The `DelProp` property is a strengthened version of the red-red invariant. -/
theorem DelProp.redred (h : DelProp c t n) : ∃ n', RedRed (c = black) t n' := by
  unfold DelProp at h
  exact match c, h with
  | red, ⟨_, h⟩ => ⟨_, .balanced h⟩
  | black, ⟨_, _, h⟩ => ⟨_, h.imp fun _ => rfl⟩

protected theorem All.del : ∀ {t : RBNode α}, t.All p → (del cut t).All p
  | .nil, h => h
  | .node .., ⟨hy, ha, hb⟩ => by
    unfold del; split
    · split
      · exact ha.del.balLeft hy hb
      · exact ⟨hy, ha.del, hb⟩
    · split
      · exact ha.balRight hy hb.del
      · exact ⟨hy, ha, hb.del⟩
    · exact ha.append hb

/-- The `del` function preserves the ordering invariants. -/
protected theorem Ordered.del : ∀ {t : RBNode α}, t.Ordered cmp → (del cut t).Ordered cmp
  | .nil, _ => ⟨⟩
  | .node _ a y b, ⟨ay, yb, ha, hb⟩ => by
    unfold del; split
    · split
      · exact ha.del.balLeft ay.del yb hb
      · exact ⟨ay.del, yb, ha.del, hb⟩
    · split
      · exact ha.balRight ay yb.del hb.del
      · exact ⟨ay, yb.del, ha, hb.del⟩
    · exact ha.append ay yb hb

/-- The `del` function has the `DelProp` property. -/
protected theorem Balanced.del {t : RBNode α} (h : t.Balanced c n) :
    (t.del cut).DelProp t.isBlack n := by
  induction h with
  | nil => exact ⟨_, .nil⟩
  | @black a _ n b _ _ ha hb iha ihb =>
    refine ⟨_, rfl, ?_⟩
    unfold del; split
    · exact match a, n, iha with
      | .nil, _, ⟨c, ha⟩ | .node red .., _, ⟨c, ha⟩ => .redred ⟨⟩ ha hb
      | .node black .., _, ⟨n, rfl, ha⟩ => (hb.balLeft ha).imp fun _ => ⟨⟩
    · exact match b, n, ihb with
      | .nil, _, ⟨c, hb⟩ | .node .red .., _, ⟨c, hb⟩ => .redred ⟨⟩ ha hb
      | .node black .., _, ⟨n, rfl, hb⟩ => (ha.balRight hb).imp fun _ => ⟨⟩
    · exact (ha.append hb).imp fun _ => ⟨⟩
  | @red a n b _ ha hb iha ihb =>
    unfold del; split
    · exact match a, n, iha with
      | .nil, _, _ => ⟨_, .red ha hb⟩
      | .node black .., _, ⟨n, rfl, ha⟩ => (hb.balLeft ha).of_false nofun
    · exact match b, n, ihb with
      | .nil, _, _ => ⟨_, .red ha hb⟩
      | .node black .., _, ⟨n, rfl, hb⟩ => (ha.balRight hb).of_false nofun
    · exact (ha.append hb).of_false (· rfl rfl)

/-- The `erase` function preserves the ordering invariants. -/
protected theorem Ordered.erase {t : RBNode α} (h : t.Ordered cmp) : (erase cut t).Ordered cmp :=
  Ordered.setBlack.2 h.del

/-- The `erase` function preserves the balance invariants. -/
protected theorem Balanced.erase {t : RBNode α}
    (h : t.Balanced c n) : ∃ n, (t.erase cut).Balanced black n :=
  have ⟨_, h⟩ := h.del.redred; h.setBlack

/-- The well-formedness invariant implies the ordering and balance properties. -/
theorem WF.out {t : RBNode α} (h : t.WF cmp) : t.Ordered cmp ∧ ∃ c n, t.Balanced c n := by
  induction h with
  | mk o h => exact ⟨o, _, _, h⟩
  | insert _ ih => have ⟨o, _, _, h⟩ := ih; exact ⟨o.insert, h.insert⟩
  | erase _ ih => have ⟨o, _, _, h⟩ := ih; exact ⟨o.erase, _, h.erase⟩

/--
The well-formedness invariant for a red-black tree is exactly the `mk` constructor,
because the other constructors of `WF` are redundant.
-/
@[simp] theorem WF_iff {t : RBNode α} : t.WF cmp ↔ t.Ordered cmp ∧ ∃ c n, t.Balanced c n :=
  ⟨fun h => h.out, fun ⟨o, _, _, h⟩ => .mk o h⟩

/-- The `map` function preserves the balance invariants. -/
protected theorem Balanced.map {t : RBNode α} : t.Balanced c n → (t.map f).Balanced c n
  | .nil => .nil
  | .red hl hr => .red hl.map hr.map
  | .black hl hr => .black hl.map hr.map

/-- The property of a map function `f` which ensures the `map` operation is valid. -/
class IsMonotone (cmpα cmpβ) (f : α → β) : Prop where
  /-- If `x < y` then `f x < f y`. -/
  lt_mono : cmpLT cmpα x y → cmpLT cmpβ (f x) (f y)

/-- Sufficient condition for `map` to preserve an `All` quantifier. -/
protected theorem All.map {f : α → β} (H : ∀ {x}, p x → q (f x)) :
    ∀ {t : RBNode α}, t.All p → (t.map f).All q
  | nil, _ => ⟨⟩
  | node .., ⟨hx, ha, hb⟩ => ⟨H hx, ha.map H, hb.map H⟩

/-- The `map` function preserves the order invariants if `f` is monotone. -/
protected theorem Ordered.map (f : α → β) [IsMonotone cmpα cmpβ f] :
    ∀ {t : RBNode α}, t.Ordered cmpα → (t.map f).Ordered cmpβ
  | nil, _ => ⟨⟩
  | node _ a x b, ⟨ax, xb, ha, hb⟩ => by
    refine ⟨ax.map ?_, xb.map ?_, ha.map f, hb.map f⟩ <;> exact IsMonotone.lt_mono

end RBNode

namespace RBSet
export RBNode (IsMonotone)

/--
`O(n)`. Map a function on every value in the set.
This requires `IsMonotone` on the function in order to preserve the order invariant.
If the function is not monotone, use `RBSet.map` instead.
-/
@[inline] def mapMonotone (f : α → β) [IsMonotone cmpα cmpβ f] (t : RBSet α cmpα) : RBSet β cmpβ :=
  ⟨t.1.map f, have ⟨h₁, _, _, h₂⟩ := t.2.out; .mk (h₁.map _) h₂.map⟩

end RBSet

namespace RBMap
export RBNode (IsMonotone)

namespace Imp

/--
Applies `f` to the second component.
We extract this as a function so that `IsMonotone (mapSnd f)` can be an instance.
-/
@[inline] def mapSnd (f : α → β → γ) := fun (a, b) => (a, f a b)

open Ordering (byKey)

instance (cmp : α → α → Ordering) (f : α → β → γ) :
    IsMonotone (byKey Prod.fst cmp) (byKey Prod.fst cmp) (mapSnd f) where
  lt_mono | ⟨h⟩ => ⟨@fun _ => @h {
    eq_swap := @fun (a₁, b₁) (a₂, b₂) =>
      Std.OrientedCmp.eq_swap (cmp := byKey Prod.fst cmp) (a := (a₁, f a₁ b₁)) (b := (a₂, f a₂ b₂))
    isLE_trans := @fun (a₁, b₁) (a₂, b₂) (a₃, b₃) =>
      Std.TransCmp.isLE_trans (cmp := byKey Prod.fst cmp)
        (a := (a₁, f a₁ b₁)) (b := (a₂, f a₂ b₂)) (c := (a₃, f a₃ b₃))
  }⟩

end Imp

/-- `O(n)`. Map a function on the values in the map. -/
def mapVal (f : α → β → γ) (t : RBMap α β cmp) : RBMap α γ cmp := t.mapMonotone (Imp.mapSnd f)

end RBMap



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg, James Gallicchio, F. G. Dorais
-/

instance : Coe String Substring := ⟨String.toSubstring⟩

namespace String

/-- Count the occurrences of a character in a string. -/
def count (s : String) (c : Char) : Nat :=
  s.foldl (fun n d => if d = c then n + 1 else n) 0

/--
Convert a string of assumed-ASCII characters into a byte array.
(If any characters are non-ASCII they will be reduced modulo 256.)

Note: if you just need the underlying `ByteArray` of a non-ASCII string,
use `String.toUTF8`.
-/
def toAsciiByteArray (s : String) : ByteArray :=
  let rec
  /--
  Internal implementation of `toAsciiByteArray`.
  `loop p out = out ++ toAsciiByteArray ({ s with startPos := p } : Substring)`
  -/
  loop (p : Pos) (out : ByteArray) : ByteArray :=
    if h : s.atEnd p then out else
    let c := s.get p
    have : utf8ByteSize s - (next s p).byteIdx < utf8ByteSize s - p.byteIdx :=
      Nat.sub_lt_sub_left (Nat.lt_of_not_le <| mt decide_eq_true h)
        (Nat.lt_add_of_pos_right (Char.utf8Size_pos _))
    loop (s.next p) (out.push c.toUInt8)
    termination_by utf8ByteSize s - p.byteIdx
  loop 0 ByteArray.empty



=== LEAN SOURCE: Lemmas.lean ===
/-
Copyright (c) 2023 Bulhwi Cha. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bulhwi Cha, Mario Carneiro
-/
import Batteries.Data.String.Basic
import Batteries.Tactic.Lint.Misc
import Batteries.Tactic.SeqFocus
import Batteries.Classes.Order
import Batteries.Data.List.Basic
import Std.Classes.Ord.String -- adds import only to avoid instance name collisions

namespace String

-- TODO(kmill): add `@[ext]` attribute to `String.ext` in core.
attribute [ext (iff := false)] ext

theorem lt_antisymm {s₁ s₂ : String} (h₁ : ¬s₁ < s₂) (h₂ : ¬s₂ < s₁) : s₁ = s₂ := by
  simp at h₁ h₂
  exact String.le_antisymm h₂ h₁

instance : Std.LawfulLTOrd String :=
  .compareOfLessAndEq_of_irrefl_of_trans_of_antisymm
    String.lt_irrefl String.lt_trans String.lt_antisymm

@[simp] theorem mk_length (s : List Char) : (String.mk s).length = s.length := rfl

attribute [simp] toList -- prefer `String.data` over `String.toList` in lemmas

private theorem add_utf8Size_pos : 0 < i + Char.utf8Size c :=
  Nat.add_pos_right _ (Char.utf8Size_pos c)

private theorem ne_add_utf8Size_add_self : i ≠ n + Char.utf8Size c + i :=
  Nat.ne_of_lt (Nat.lt_add_of_pos_left add_utf8Size_pos)

private theorem ne_self_add_add_utf8Size : i ≠ i + (n + Char.utf8Size c) :=
  Nat.ne_of_lt (Nat.lt_add_of_pos_right add_utf8Size_pos)

/-- The UTF-8 byte length of a list of characters. (This is intended for specification purposes.) -/
@[inline] def utf8Len : List Char → Nat := utf8ByteSize.go

@[simp] theorem utf8ByteSize.go_eq : utf8ByteSize.go = utf8Len := rfl

@[simp] theorem utf8ByteSize_mk (cs) : utf8ByteSize ⟨cs⟩ = utf8Len cs := rfl

@[simp] theorem utf8Len_nil : utf8Len [] = 0 := rfl

@[simp] theorem utf8Len_cons (c cs) : utf8Len (c :: cs) = utf8Len cs + c.utf8Size := rfl

@[simp] theorem utf8Len_append (cs₁ cs₂) : utf8Len (cs₁ ++ cs₂) = utf8Len cs₁ + utf8Len cs₂ := by
  induction cs₁ <;> simp [*, Nat.add_right_comm]

theorem utf8Len_reverseAux (cs₁ cs₂) :
    utf8Len (cs₁.reverseAux cs₂) = utf8Len cs₁ + utf8Len cs₂ := by
  induction cs₁ generalizing cs₂ <;> simp_all [← Nat.add_assoc, Nat.add_right_comm]

@[simp] theorem utf8Len_reverse (cs) : utf8Len cs.reverse = utf8Len cs := utf8Len_reverseAux ..

@[simp] theorem utf8Len_eq_zero : utf8Len l = 0 ↔ l = [] := by
  cases l <;> simp [Nat.ne_zero_iff_zero_lt.mpr (Char.utf8Size_pos _)]

section
open List
theorem utf8Len_le_of_sublist : ∀ {cs₁ cs₂}, cs₁ <+ cs₂ → utf8Len cs₁ ≤ utf8Len cs₂
  | _, _, .slnil => Nat.le_refl _
  | _, _, .cons _ h => Nat.le_trans (utf8Len_le_of_sublist h) (Nat.le_add_right ..)
  | _, _, .cons₂ _ h => Nat.add_le_add_right (utf8Len_le_of_sublist h) _

theorem utf8Len_le_of_infix (h : cs₁ <:+: cs₂) : utf8Len cs₁ ≤ utf8Len cs₂ :=
  utf8Len_le_of_sublist h.sublist

theorem utf8Len_le_of_suffix (h : cs₁ <:+ cs₂) : utf8Len cs₁ ≤ utf8Len cs₂ :=
  utf8Len_le_of_sublist h.sublist

theorem utf8Len_le_of_prefix (h : cs₁ <+: cs₂) : utf8Len cs₁ ≤ utf8Len cs₂ :=
  utf8Len_le_of_sublist h.sublist
end

@[simp] theorem endPos_eq (cs : List Char) : endPos ⟨cs⟩ = ⟨utf8Len cs⟩ := rfl

namespace Pos

-- TODO(kmill): add `@[ext]` attribute to `String.Pos.ext` in core.
attribute [ext (iff := false)] ext

theorem lt_addChar (p : Pos) (c : Char) : p < p + c := Nat.lt_add_of_pos_right (Char.utf8Size_pos _)

private theorem zero_ne_addChar {i : Pos} {c : Char} : 0 ≠ i + c :=
  ne_of_lt add_utf8Size_pos

/-- A string position is valid if it is equal to the UTF-8 length of an initial substring of `s`. -/
def Valid (s : String) (p : Pos) : Prop :=
  ∃ cs cs', cs ++ cs' = s.1 ∧ p.1 = utf8Len cs

@[simp] theorem valid_zero : Valid s 0 := ⟨[], s.1, rfl, rfl⟩

@[simp] theorem valid_endPos : Valid s (endPos s) := ⟨s.1, [], by simp, rfl⟩

theorem Valid.mk (cs cs' : List Char) : Valid ⟨cs ++ cs'⟩ ⟨utf8Len cs⟩ := ⟨cs, cs', rfl, rfl⟩

theorem Valid.le_endPos : ∀ {s p}, Valid s p → p ≤ endPos s
  | ⟨_⟩, ⟨_⟩, ⟨cs, cs', rfl, rfl⟩ => by simp [Nat.le_add_right]

end Pos

theorem endPos_eq_zero : ∀ (s : String), endPos s = 0 ↔ s = ""
  | ⟨_⟩ => Pos.ext_iff.trans <| utf8Len_eq_zero.trans ext_iff.symm

theorem isEmpty_iff (s : String) : isEmpty s ↔ s = "" :=
  (beq_iff_eq ..).trans (endPos_eq_zero _)

/--
Induction along the valid positions in a list of characters.
(This definition is intended only for specification purposes.)
-/
def utf8InductionOn {motive : List Char → Pos → Sort u}
    (s : List Char) (i p : Pos)
    (nil : ∀ i, motive [] i)
    (eq  : ∀ c cs, motive (c :: cs) p)
    (ind : ∀ (c : Char) cs i, i ≠ p → motive cs (i + c) → motive (c :: cs) i) :
    motive s i :=
  match s with
  | [] => nil i
  | c::cs =>
    if h : i = p then
      h ▸ eq c cs
    else ind c cs i h (utf8InductionOn cs (i + c) p nil eq ind)

theorem utf8GetAux_add_right_cancel (s : List Char) (i p n : Nat) :
    utf8GetAux s ⟨i + n⟩ ⟨p + n⟩ = utf8GetAux s ⟨i⟩ ⟨p⟩ := by
  apply utf8InductionOn s ⟨i⟩ ⟨p⟩ (motive := fun s i =>
    utf8GetAux s ⟨i.byteIdx + n⟩ ⟨p + n⟩ = utf8GetAux s i ⟨p⟩) <;>
  simp only [utf8GetAux, Char.reduceDefault, implies_true, ↓reduceIte, ne_eq, pos_add_char]
  intro c cs ⟨i⟩ h ih
  simp only [Pos.ext_iff, Pos.addChar_eq] at h ⊢
  simp only [Nat.add_right_cancel_iff, h, ↓reduceIte]
  rw [Nat.add_right_comm]
  exact ih

theorem utf8GetAux_addChar_right_cancel (s : List Char) (i p : Pos) (c : Char) :
    utf8GetAux s (i + c) (p + c) = utf8GetAux s i p := utf8GetAux_add_right_cancel ..

theorem utf8GetAux_of_valid (cs cs' : List Char) {i p : Nat} (hp : i + utf8Len cs = p) :
    utf8GetAux (cs ++ cs') ⟨i⟩ ⟨p⟩ = cs'.headD default := by
  match cs, cs' with
  | [], [] => rfl
  | [], c::cs' => simp [← hp, utf8GetAux]
  | c::cs, cs' =>
    simp only [List.cons_append, utf8GetAux, Char.reduceDefault]
    rw [if_neg]
    case hnc => simp only [← hp, utf8Len_cons, Pos.ext_iff]; exact ne_self_add_add_utf8Size
    refine utf8GetAux_of_valid cs cs' ?_
    simpa [Nat.add_assoc, Nat.add_comm] using hp

theorem get_of_valid (cs cs' : List Char) : get ⟨cs ++ cs'⟩ ⟨utf8Len cs⟩ = cs'.headD default :=
  utf8GetAux_of_valid _ _ (Nat.zero_add _)

theorem get_cons_addChar (c : Char) (cs : List Char) (i : Pos) :
    get ⟨c :: cs⟩ (i + c) = get ⟨cs⟩ i := by
  simp [get, utf8GetAux, Pos.zero_ne_addChar, utf8GetAux_addChar_right_cancel]

theorem utf8GetAux?_of_valid (cs cs' : List Char) {i p : Nat} (hp : i + utf8Len cs = p) :
    utf8GetAux? (cs ++ cs') ⟨i⟩ ⟨p⟩ = cs'.head? := by
  match cs, cs' with
  | [], [] => rfl
  | [], c::cs' => simp [← hp, utf8GetAux?]
  | c::cs, cs' =>
    simp only [List.cons_append, utf8GetAux?]
    rw [if_neg]
    case hnc => simp only [← hp, Pos.ext_iff]; exact ne_self_add_add_utf8Size
    refine utf8GetAux?_of_valid cs cs' ?_
    simpa [Nat.add_assoc, Nat.add_comm] using hp

theorem get?_of_valid (cs cs' : List Char) : get? ⟨cs ++ cs'⟩ ⟨utf8Len cs⟩ = cs'.head? :=
  utf8GetAux?_of_valid _ _ (Nat.zero_add _)

theorem utf8SetAux_of_valid (c' : Char) (cs cs' : List Char) {i p : Nat} (hp : i + utf8Len cs = p) :
    utf8SetAux c' (cs ++ cs') ⟨i⟩ ⟨p⟩ = cs ++ cs'.modifyHead fun _ => c' := by
  match cs, cs' with
  | [], [] => rfl
  | [], c::cs' => simp [← hp, utf8SetAux]
  | c::cs, cs' =>
    simp only [utf8SetAux, List.cons_append]
    rw [if_neg]
    case hnc => simp only [← hp, Pos.ext_iff]; exact ne_self_add_add_utf8Size
    refine congrArg (c::·) (utf8SetAux_of_valid c' cs cs' ?_)
    simpa [Nat.add_assoc, Nat.add_comm] using hp

theorem set_of_valid (cs cs' : List Char) (c' : Char) :
    set ⟨cs ++ cs'⟩ ⟨utf8Len cs⟩ c' = ⟨cs ++ cs'.modifyHead fun _ => c'⟩ :=
  ext (utf8SetAux_of_valid _ _ _ (Nat.zero_add _))

theorem modify_of_valid (cs cs' : List Char) :
    modify ⟨cs ++ cs'⟩ ⟨utf8Len cs⟩ f = ⟨cs ++ cs'.modifyHead f⟩ := by
  rw [modify, set_of_valid, get_of_valid]; cases cs' <;> rfl

theorem next_of_valid' (cs cs' : List Char) :
    next ⟨cs ++ cs'⟩ ⟨utf8Len cs⟩ = ⟨utf8Len cs + (cs'.headD default).utf8Size⟩ := by
  simp only [next, get_of_valid]; rfl

theorem next_of_valid (cs : List Char) (c : Char) (cs' : List Char) :
    next ⟨cs ++ c :: cs'⟩ ⟨utf8Len cs⟩ = ⟨utf8Len cs + c.utf8Size⟩ := next_of_valid' ..

@[simp] theorem atEnd_iff (s : String) (p : Pos) : atEnd s p ↔ s.endPos ≤ p :=
  decide_eq_true_iff

theorem valid_next {p : Pos} (h : p.Valid s) (h₂ : p < s.endPos) : (next s p).Valid s := by
  match s, p, h with
  | ⟨_⟩, ⟨_⟩, ⟨cs, [], rfl, rfl⟩ => simp at h₂
  | ⟨_⟩, ⟨_⟩, ⟨cs, c::cs', rfl, rfl⟩ =>
    rw [utf8ByteSize.go_eq, next_of_valid]
    simpa using Pos.Valid.mk (cs ++ [c]) cs'

theorem utf8PrevAux_of_valid {cs cs' : List Char} {c : Char} {i p : Nat}
    (hp : i + (utf8Len cs + c.utf8Size) = p) :
    utf8PrevAux (cs ++ c :: cs') ⟨i⟩ ⟨p⟩ = ⟨i + utf8Len cs⟩ := by
  match cs with
  | [] => simp [utf8PrevAux, ← hp, Pos.addChar_eq]
  | c'::cs =>
    simp only [utf8PrevAux, List.cons_append, utf8Len_cons, ← hp]
    rw [if_neg]
    case hnc =>
      simp only [Pos.ext_iff]
      rw [Nat.add_right_comm, Nat.add_left_comm]
      apply ne_add_utf8Size_add_self
    refine (utf8PrevAux_of_valid (by simp [Nat.add_assoc, Nat.add_left_comm])).trans ?_
    simp [Nat.add_assoc, Nat.add_comm]

theorem prev_of_valid (cs : List Char) (c : Char) (cs' : List Char) :
    prev ⟨cs ++ c :: cs'⟩ ⟨utf8Len cs + c.utf8Size⟩ = ⟨utf8Len cs⟩ := by
  simp only [prev]
  refine (if_neg (Pos.ne_of_gt add_utf8Size_pos)).trans ?_
  rw [utf8PrevAux_of_valid] <;> simp

theorem prev_of_valid' (cs cs' : List Char) :
    prev ⟨cs ++ cs'⟩ ⟨utf8Len cs⟩ = ⟨utf8Len cs.dropLast⟩ := by
  match cs, cs.eq_nil_or_concat with
  | _, .inl rfl => rfl
  | _, .inr ⟨cs, c, rfl⟩ => simp [prev_of_valid]

theorem front_eq (s : String) : front s = s.1.headD default := by
  unfold front; exact get_of_valid [] s.1

theorem back_eq (s : String) : back s = s.1.getLastD default := by
  match s, s.1.eq_nil_or_concat with
  | ⟨_⟩, .inl rfl => rfl
  | ⟨_⟩, .inr ⟨cs, c, rfl⟩ => simp [back, prev_of_valid, get_of_valid]

theorem atEnd_of_valid (cs : List Char) (cs' : List Char) :
    atEnd ⟨cs ++ cs'⟩ ⟨utf8Len cs⟩ ↔ cs' = [] := by
  rw [atEnd_iff]
  cases cs' <;> simp [add_utf8Size_pos]

unseal posOfAux findAux in
theorem posOfAux_eq (s c) : posOfAux s c = findAux s (· == c) := rfl

unseal posOfAux findAux in
theorem posOf_eq (s c) : posOf s c = find s (· == c) := rfl

unseal revPosOfAux revFindAux in
theorem revPosOfAux_eq (s c) : revPosOfAux s c = revFindAux s (· == c) := rfl

unseal revPosOfAux revFindAux in
theorem revPosOf_eq (s c) : revPosOf s c = revFind s (· == c) := rfl

@[nolint unusedHavesSuffices] -- false positive from unfolding String.findAux
theorem findAux_of_valid (p) : ∀ l m r,
    findAux ⟨l ++ m ++ r⟩ p ⟨utf8Len l + utf8Len m⟩ ⟨utf8Len l⟩ =
    ⟨utf8Len l + utf8Len (m.takeWhile (!p ·))⟩
  | l, [], r => by unfold findAux List.takeWhile; simp
  | l, c::m, r => by
    unfold findAux List.takeWhile
    rw [dif_pos (by exact Nat.lt_add_of_pos_right add_utf8Size_pos)]
    have h1 := get_of_valid l (c::m++r); have h2 := next_of_valid l c (m++r)
    simp only [List.cons_append, Char.reduceDefault, List.headD_cons] at h1 h2
    simp only [List.append_assoc, List.cons_append, h1, utf8Len_cons, h2]
    cases p c
    · simp only [Bool.false_eq_true, ↓reduceIte, Bool.not_false, utf8Len_cons]
      have foo := findAux_of_valid p (l++[c]) m r
      simp only [List.append_assoc, List.cons_append, utf8Len_append,
        utf8Len_cons, utf8Len_nil, Nat.zero_add, List.nil_append] at foo
      rw [Nat.add_right_comm, Nat.add_assoc] at foo
      rw [foo, Nat.add_right_comm, Nat.add_assoc]
    · simp

theorem find_of_valid (p s) : find s p = ⟨utf8Len (s.1.takeWhile (!p ·))⟩ := by
  simpa using findAux_of_valid p [] s.1 []

@[nolint unusedHavesSuffices] -- false positive from unfolding String.revFindAux
theorem revFindAux_of_valid (p) : ∀ l r,
    revFindAux ⟨l.reverse ++ r⟩ p ⟨utf8Len l⟩ = (l.dropWhile (!p ·)).tail?.map (⟨utf8Len ·⟩)
  | [], r => by unfold revFindAux List.dropWhile; simp
  | c::l, r => by
    unfold revFindAux List.dropWhile
    rw [dif_neg (by exact Pos.ne_of_gt add_utf8Size_pos)]
    have h1 := get_of_valid l.reverse (c::r); have h2 := prev_of_valid l.reverse c r
    simp only [utf8Len_reverse, Char.reduceDefault, List.headD_cons] at h1 h2
    simp only [List.reverse_cons, List.append_assoc, List.singleton_append, utf8Len_cons, h2, h1]
    cases p c <;> simp only [Bool.false_eq_true, ↓reduceIte, Bool.not_false, Bool.not_true,
      List.tail?_cons, Option.map_some]
    exact revFindAux_of_valid p l (c::r)

theorem revFind_of_valid (p s) :
    revFind s p = (s.1.reverse.dropWhile (!p ·)).tail?.map (⟨utf8Len ·⟩) := by
  simpa using revFindAux_of_valid p s.1.reverse []

theorem firstDiffPos_loop_eq (l₁ l₂ r₁ r₂ stop p)
    (hl₁ : p = utf8Len l₁) (hl₂ : p = utf8Len l₂)
    (hstop : stop = min (utf8Len l₁ + utf8Len r₁) (utf8Len l₂ + utf8Len r₂)) :
    firstDiffPos.loop ⟨l₁ ++ r₁⟩ ⟨l₂ ++ r₂⟩ ⟨stop⟩ ⟨p⟩ =
      ⟨p + utf8Len (List.takeWhile₂ (· = ·) r₁ r₂).1⟩ := by
  unfold List.takeWhile₂; split <;> unfold firstDiffPos.loop
  · next a r₁ b r₂ =>
    rw [
      dif_pos <| by
        rw [hstop, ← hl₁, ← hl₂]
        refine Nat.lt_min.2 ⟨?_, ?_⟩ <;> exact Nat.lt_add_of_pos_right add_utf8Size_pos,
      show get ⟨l₁ ++ a :: r₁⟩ ⟨p⟩ = a by simp [hl₁, get_of_valid],
      show get ⟨l₂ ++ b :: r₂⟩ ⟨p⟩ = b by simp [hl₂, get_of_valid]]
    simp only [bne_iff_ne, ne_eq, ite_not, decide_eq_true_eq]
    split
    · simp only [utf8Len_cons]
      subst b
      rw [show next ⟨l₁ ++ a :: r₁⟩ ⟨p⟩ = ⟨utf8Len l₁ + a.utf8Size⟩ by simp [hl₁, next_of_valid]]
      simpa [← hl₁, ← Nat.add_assoc, Nat.add_right_comm] using
        firstDiffPos_loop_eq (l₁ ++ [a]) (l₂ ++ [a]) r₁ r₂ stop (p + a.utf8Size)
          (by simp [hl₁]) (by simp [hl₂]) (by simp [hstop, ← Nat.add_assoc, Nat.add_right_comm])
    · simp
  · next h =>
    rw [dif_neg] <;> simp [hstop, ← hl₁, ← hl₂, -Nat.not_lt, Nat.lt_min]
    intro h₁ h₂
    have : ∀ {cs}, 0 < utf8Len cs → cs ≠ [] := by rintro _ h rfl; simp at h
    obtain ⟨a, as, e₁⟩ := List.exists_cons_of_ne_nil (this h₁)
    obtain ⟨b, bs, e₂⟩ := List.exists_cons_of_ne_nil (this h₂)
    exact h _ _ _ _ e₁ e₂

theorem firstDiffPos_eq (a b : String) :
    firstDiffPos a b = ⟨utf8Len (List.takeWhile₂ (· = ·) a.1 b.1).1⟩ := by
  simpa [firstDiffPos] using
    firstDiffPos_loop_eq [] [] a.1 b.1 ((utf8Len a.1).min (utf8Len b.1)) 0 rfl rfl (by simp)

theorem extract.go₂_add_right_cancel (s : List Char) (i e n : Nat) :
    go₂ s ⟨i + n⟩ ⟨e + n⟩ = go₂ s ⟨i⟩ ⟨e⟩ := by
  apply utf8InductionOn s ⟨i⟩ ⟨e⟩ (motive := fun s i =>
    go₂ s ⟨i.byteIdx + n⟩ ⟨e + n⟩ = go₂ s i ⟨e⟩)
    <;> simp only [ne_eq, go₂, pos_add_char, implies_true, ↓reduceIte]
  intro c cs ⟨i⟩ h ih
  simp only [Pos.ext_iff, Pos.addChar_eq] at h ⊢
  simp only [Nat.add_right_cancel_iff, h, ↓reduceIte, List.cons.injEq, true_and]
  rw [Nat.add_right_comm]
  exact ih

theorem extract.go₂_append_left : ∀ (s t : List Char) (i e : Nat),
    e = utf8Len s + i → go₂ (s ++ t) ⟨i⟩ ⟨e⟩ = s
| [], t, i, _, rfl => by cases t <;> simp [go₂]
| c :: cs, t, i, _, rfl => by
  simp only [List.cons_append, utf8Len_cons, go₂, Pos.ext_iff, ne_add_utf8Size_add_self, ↓reduceIte,
    Pos.addChar_eq, List.cons.injEq, true_and]
  apply go₂_append_left; rw [Nat.add_right_comm, Nat.add_assoc]

theorem extract.go₁_add_right_cancel (s : List Char) (i b e n : Nat) :
    go₁ s ⟨i + n⟩ ⟨b + n⟩ ⟨e + n⟩ = go₁ s ⟨i⟩ ⟨b⟩ ⟨e⟩ := by
  apply utf8InductionOn s ⟨i⟩ ⟨b⟩ (motive := fun s i =>
    go₁ s ⟨i.byteIdx + n⟩ ⟨b + n⟩ ⟨e + n⟩ = go₁ s i ⟨b⟩ ⟨e⟩)
    <;> simp only [ne_eq, go₁, pos_add_char, implies_true, ↓reduceIte]
  · intro c cs
    apply go₂_add_right_cancel
  · intro c cs ⟨i⟩ h ih
    simp only [Pos.ext_iff, Pos.addChar_eq] at h ih ⊢
    simp only [Nat.add_right_cancel_iff, h, ↓reduceIte]
    rw [Nat.add_right_comm]
    exact ih

theorem extract.go₁_cons_addChar (c : Char) (cs : List Char) (b e : Pos) :
    go₁ (c :: cs) 0 (b + c) (e + c) = go₁ cs 0 b e := by
  simp only [go₁, Pos.ext_iff, Pos.byteIdx_zero, pos_add_char, Nat.ne_of_lt add_utf8Size_pos,
    ↓reduceIte]
  apply go₁_add_right_cancel

theorem extract.go₁_append_right : ∀ (s t : List Char) (i b : Nat) (e : Pos),
    b = utf8Len s + i → go₁ (s ++ t) ⟨i⟩ ⟨b⟩ e = go₂ t ⟨b⟩ e
| [], t, i, _, e, rfl => by cases t <;> simp [go₁, go₂]
| c :: cs, t, i, _, e, rfl => by
  simp only [go₁, utf8Len_cons, Pos.ext_iff, ne_add_utf8Size_add_self, ↓reduceIte, List.cons_append,
    Pos.addChar_eq]
  apply go₁_append_right; rw [Nat.add_right_comm, Nat.add_assoc]

theorem extract.go₁_zero_utf8Len (s : List Char) : go₁ s 0 0 ⟨utf8Len s⟩ = s :=
  (go₁_append_right [] s 0 0 ⟨utf8Len s⟩ rfl).trans <| by
    simpa using go₂_append_left s [] 0 (utf8Len s) rfl

theorem extract_cons_addChar (c : Char) (cs : List Char) (b e : Pos) :
    extract ⟨c :: cs⟩ (b + c) (e + c) = extract ⟨cs⟩ b e := by
  simp only [extract, pos_add_char, ge_iff_le, Nat.add_le_add_iff_right]
  split <;> [rfl; rw [extract.go₁_cons_addChar]]

theorem extract_zero_endPos : ∀ (s : String), s.extract 0 (endPos s) = s
  | ⟨[]⟩ => rfl
  | ⟨c :: cs⟩ => by
    simp only [extract, Pos.byteIdx_zero, endPos_eq, utf8Len_cons, ge_iff_le, Nat.le_zero_eq,
      Nat.ne_of_gt add_utf8Size_pos, ↓reduceIte]
    congr
    apply extract.go₁_zero_utf8Len

theorem extract_of_valid (l m r : List Char) :
    extract ⟨l ++ m ++ r⟩ ⟨utf8Len l⟩ ⟨utf8Len l + utf8Len m⟩ = ⟨m⟩ := by
  simp only [extract]
  split
  · next h => rw [utf8Len_eq_zero.1 <| Nat.le_zero.1 <| Nat.add_le_add_iff_left.1 h]
  · congr; rw [List.append_assoc, extract.go₁_append_right _ _ _ _ _ (by rfl)]
    apply extract.go₂_append_left; apply Nat.add_comm

theorem splitAux_of_valid (p l m r acc) :
    splitAux ⟨l ++ m ++ r⟩ p ⟨utf8Len l⟩ ⟨utf8Len l + utf8Len m⟩ acc =
      acc.reverse ++ (List.splitOnP.go p r m.reverse).map mk := by
  unfold splitAux
  simp only [List.append_assoc, atEnd_iff, endPos_eq, utf8Len_append, Pos.mk_le_mk,
    Nat.add_le_add_iff_left, by simpa using atEnd_of_valid (l ++ m) r, List.reverse_cons,
    dite_eq_ite]
  split
  · subst r; simpa [List.splitOnP.go] using extract_of_valid l m []
  · obtain ⟨c, r, rfl⟩ := r.exists_cons_of_ne_nil ‹_›
    simp only [by
      simpa using
        (⟨get_of_valid (l ++ m) (c :: r), next_of_valid (l ++ m) c r,
            extract_of_valid l m (c :: r)⟩ :
          _ ∧ _ ∧ _),
      List.splitOnP.go, List.reverse_reverse]
    split <;> rename_i h
    · simpa [Nat.add_assoc] using splitAux_of_valid p (l++m++[c]) [] r (⟨m⟩::acc)
    · simpa [Nat.add_assoc] using splitAux_of_valid p l (m++[c]) r acc

theorem split_of_valid (s p) : split s p = (List.splitOnP p s.1).map mk := by
  simpa [split] using splitAux_of_valid p [] [] s.1 []

-- TODO: splitOn

@[simp] theorem toString_toSubstring (s : String) : s.toSubstring.toString = s :=
  extract_zero_endPos _

attribute [simp] toSubstring'

theorem join_eq (ss : List String) : join ss = ⟨(ss.map data).flatten⟩ := go ss [] where
  go : ∀ (ss : List String) cs, ss.foldl (· ++ ·) (mk cs) = ⟨cs ++ (ss.map data).flatten⟩
    | [], _ => by simp
    | ⟨s⟩::ss, _ => (go ss _).trans (by simp)

@[simp] theorem data_join (ss : List String) : (join ss).data = (ss.map data).flatten := by
  rw [join_eq]

namespace Iterator

@[simp] theorem forward_eq_nextn : forward = nextn := by
  funext it n; induction n generalizing it <;> simp [forward, nextn, *]

theorem hasNext_cons_addChar (c : Char) (cs : List Char) (i : Pos) :
    hasNext ⟨⟨c :: cs⟩, i + c⟩ = hasNext ⟨⟨cs⟩, i⟩ := by
  simp [hasNext, Nat.add_lt_add_iff_right]

/-- Validity for a string iterator. -/
def Valid (it : Iterator) : Prop := it.pos.Valid it.s

/-- `it.ValidFor l r` means that `it` is a string iterator whose underlying string is
`l.reverse ++ r`, and where the cursor is pointing at the end of `l.reverse`. -/
inductive ValidFor (l r : List Char) : Iterator → Prop
  /-- The canonical constructor for `ValidFor`. -/
  | mk : ValidFor l r ⟨⟨l.reverseAux r⟩, ⟨utf8Len l⟩⟩

attribute [simp] toString pos

namespace ValidFor

theorem valid : ∀ {it}, ValidFor l r it → Valid it
  | _, ⟨⟩ => by simpa [List.reverseAux_eq] using Pos.Valid.mk l.reverse r

theorem out : ∀ {it}, ValidFor l r it → it = ⟨⟨l.reverseAux r⟩, ⟨utf8Len l⟩⟩
  | _, ⟨⟩ => rfl

theorem out' : ∀ {it}, ValidFor l r it → it = ⟨⟨l.reverse ++ r⟩, ⟨utf8Len l.reverse⟩⟩
  | _, ⟨⟩ => by simp [List.reverseAux_eq]

theorem mk' : ValidFor l r ⟨⟨l.reverse ++ r⟩, ⟨utf8Len l.reverse⟩⟩ := by
  simpa [List.reverseAux_eq] using mk

theorem of_eq : ∀ it, it.1.1 = l.reverseAux r → it.2.1 = utf8Len l → ValidFor l r it
  | ⟨⟨_⟩, ⟨_⟩⟩, rfl, rfl => ⟨⟩

theorem _root_.String.validFor_mkIterator (s) : (mkIterator s).ValidFor [] s.1 := ⟨⟩

theorem remainingBytes : ∀ {it}, ValidFor l r it → it.remainingBytes = utf8Len r
  | _, ⟨⟩ => by simp [Iterator.remainingBytes, Nat.add_sub_cancel_left]

theorem toString : ∀ {it}, ValidFor l r it → it.1 = ⟨l.reverseAux r⟩
  | _, ⟨⟩ => rfl

theorem pos : ∀ {it}, ValidFor l r it → it.2 = ⟨utf8Len l⟩
  | _, ⟨⟩ => rfl

theorem pos_eq_zero {l r it} (h : ValidFor l r it) : it.2 = 0 ↔ l = [] := by
  simp [h.pos, Pos.ext_iff]

theorem pos_eq_endPos {l r it} (h : ValidFor l r it) : it.2 = it.1.endPos ↔ r = [] := by
  simp only [h.pos, h.toString, endPos_eq, utf8Len_reverseAux, Pos.ext_iff]
  exact (Nat.add_left_cancel_iff (m := 0)).trans <| eq_comm.trans utf8Len_eq_zero

theorem curr : ∀ {it}, ValidFor l r it → it.curr = r.headD default
  | it, h => by cases h.out'; apply get_of_valid

theorem next : ∀ {it}, ValidFor l (c :: r) it → ValidFor (c :: l) r it.next
  | it, h => by
    cases h.out'
    simp only [Iterator.next, next_of_valid l.reverse c r]
    rw [← List.reverseAux_eq, utf8Len_reverse]; constructor

theorem prev : ∀ {it}, ValidFor (c :: l) r it → ValidFor l (c :: r) it.prev
  | it, h => by
    cases h.out'
    have := prev_of_valid l.reverse c r
    simp only [utf8Len_reverse] at this
    simp only [Iterator.prev, List.reverse_cons, List.append_assoc, List.singleton_append,
      utf8Len_append, utf8Len_reverse, utf8Len_cons, utf8Len_nil, Nat.zero_add, this]
    exact .of_eq _ (by simp [List.reverseAux_eq]) (by simp)

theorem prev_nil : ∀ {it}, ValidFor [] r it → ValidFor [] r it.prev
  | it, h => by
    simp only [Iterator.prev, h.toString, List.reverseAux_nil, h.pos, utf8Len_nil,
      Pos.mk_zero, prev_zero]
    constructor

theorem atEnd : ∀ {it}, ValidFor l r it → (it.atEnd ↔ r = [])
  | it, h => by
    simp only [Iterator.atEnd, h.pos, h.toString, endPos_eq, utf8Len_reverseAux, ge_iff_le,
      decide_eq_true_eq]
    exact Nat.add_le_add_iff_left.trans <| Nat.le_zero.trans utf8Len_eq_zero

theorem hasNext : ∀ {it}, ValidFor l r it → (it.hasNext ↔ r ≠ [])
  | it, h => by simp [Iterator.hasNext, ← h.atEnd, Iterator.atEnd]

theorem hasPrev : ∀ {it}, ValidFor l r it → (it.hasPrev ↔ l ≠ [])
  | it, h => by simp [Iterator.hasPrev, h.pos, Nat.pos_iff_ne_zero]

theorem setCurr' : ∀ {it}, ValidFor l r it →
    ValidFor l (r.modifyHead fun _ => c) (it.setCurr c)
  | it, h => by
    cases h.out'
    simp only [setCurr, utf8Len_reverse]
    refine .of_eq _ ?_ (by simp)
    have := set_of_valid l.reverse r c
    simp only [utf8Len_reverse] at this; simp [List.reverseAux_eq, this]

theorem setCurr (h : ValidFor l (c :: r) it) :
    ValidFor l (c :: r) (it.setCurr c) := h.setCurr'

theorem toEnd (h : ValidFor l r it) : ValidFor (r.reverse ++ l) [] it.toEnd := by
  simp only [Iterator.toEnd, h.toString, endPos_eq, utf8Len_reverseAux]
  exact .of_eq _ (by simp [List.reverseAux_eq]) (by simp [Nat.add_comm])

theorem toEnd' (it : Iterator) : ValidFor it.s.1.reverse [] it.toEnd := by
  simp only [Iterator.toEnd]
  exact .of_eq _ (by simp [List.reverseAux_eq]) (by simp [endPos, utf8ByteSize])

theorem extract (h₁ : ValidFor l (m ++ r) it₁) (h₂ : ValidFor (m.reverse ++ l) r it₂) :
    it₁.extract it₂ = ⟨m⟩ := by
  cases h₁.out; cases h₂.out
  simp only [Iterator.extract, List.reverseAux_eq, List.reverse_append, List.reverse_reverse,
    List.append_assoc, ne_eq, not_true_eq_false, decide_false, utf8Len_append, utf8Len_reverse,
    gt_iff_lt, pos_lt_eq, Nat.not_lt.2 (Nat.le_add_left ..), Bool.or_self, Bool.false_eq_true,
    ↓reduceIte]
  simpa [Nat.add_comm] using extract_of_valid l.reverse m r

theorem remainingToString {it} (h : ValidFor l r it) : it.remainingToString = ⟨r⟩ := by
  cases h.out
  simpa [Iterator.remainingToString, List.reverseAux_eq] using extract_of_valid l.reverse r []

theorem nextn : ∀ {it}, ValidFor l r it →
      ∀ n, n ≤ r.length → ValidFor ((r.take n).reverse ++ l) (r.drop n) (it.nextn n)
  | it, h, 0, _ => by simp [h, Iterator.nextn]
  | it, h, n+1, hn => by
    simp only [Iterator.nextn]
    have a::r := r
    simpa using h.next.nextn _ (Nat.le_of_succ_le_succ hn)

theorem prevn : ∀ {it}, ValidFor l r it →
      ∀ n, n ≤ l.length → ValidFor (l.drop n) ((l.take n).reverse ++ r) (it.prevn n)
  | it, h, 0, _ => by simp [h, Iterator.prevn]
  | it, h, n+1, hn => by
    simp only [Iterator.prevn]
    have a::l := l
    simpa using h.prev.prevn _ (Nat.le_of_succ_le_succ hn)

end ValidFor

namespace Valid

theorem validFor : ∀ {it}, Valid it → ∃ l r, ValidFor l r it
  | ⟨⟨_⟩, ⟨_⟩⟩, ⟨l, r, rfl, rfl⟩ =>
    ⟨l.reverse, r, by simpa [List.reverseAux_eq] using @ValidFor.mk l.reverse r⟩

theorem _root_.String.valid_mkIterator (s) : (mkIterator s).Valid := s.validFor_mkIterator.valid

theorem remainingBytes_le : ∀ {it}, Valid it → it.remainingBytes ≤ utf8ByteSize it.s
  | _, h => let ⟨l, r, h⟩ := h.validFor; by simp [h.remainingBytes, h.toString, Nat.le_add_left]

theorem next : ∀ {it}, Valid it → it.hasNext → Valid it.next
  | _, h, hn => by
    let ⟨l, r, h⟩ := h.validFor
    obtain ⟨c, r, rfl⟩ := List.exists_cons_of_ne_nil (h.hasNext.1 hn)
    exact h.next.valid

theorem prev : ∀ {it}, Valid it → Valid it.prev
  | _, h =>
    match h.validFor with
    | ⟨[], _, h⟩ => h.prev_nil.valid
    | ⟨_::_, _, h⟩ => h.prev.valid

theorem setCurr : ∀ {it}, Valid it → Valid (it.setCurr c)
  | it, h => by
    let ⟨l, r, h⟩ := h.validFor
    exact h.setCurr'.valid

theorem toEnd (it : String.Iterator) : Valid it.toEnd := (ValidFor.toEnd' _).valid

theorem remainingToString {it} (h : ValidFor l r it) : it.remainingToString = ⟨r⟩ := by
  cases h.out
  simpa [Iterator.remainingToString, List.reverseAux_eq] using extract_of_valid l.reverse r []

theorem prevn (h : Valid it) : ∀ n, Valid (it.prevn n)
  | 0 => h
  | n+1 => h.prev.prevn n

end Valid
end Iterator

@[nolint unusedHavesSuffices] -- false positive from unfolding String.offsetOfPosAux
theorem offsetOfPosAux_of_valid : ∀ l m r n,
    offsetOfPosAux ⟨l ++ m ++ r⟩ ⟨utf8Len l + utf8Len m⟩ ⟨utf8Len l⟩ n = n + m.length
  | l, [], r, n => by unfold offsetOfPosAux; simp
  | l, c::m, r, n => by
    unfold offsetOfPosAux
    rw [if_neg (by exact Nat.not_le.2 (Nat.lt_add_of_pos_right add_utf8Size_pos))]
    simp only [List.append_assoc, atEnd_of_valid l (c::m++r)]
    simp only [List.cons_append, utf8Len_cons, next_of_valid l c (m ++ r)]
    simpa [← Nat.add_assoc, Nat.add_right_comm] using
      offsetOfPosAux_of_valid (l++[c]) m r (n + 1)

theorem offsetOfPos_of_valid (l r) : offsetOfPos ⟨l ++ r⟩ ⟨utf8Len l⟩ = l.length := by
  simpa using offsetOfPosAux_of_valid [] l r 0

@[nolint unusedHavesSuffices] -- false positive from unfolding String.foldlAux
theorem foldlAux_of_valid (f : α → Char → α) : ∀ l m r a,
    foldlAux f ⟨l ++ m ++ r⟩ ⟨utf8Len l + utf8Len m⟩ ⟨utf8Len l⟩ a = m.foldl f a
  | l, [], r, a => by unfold foldlAux; simp
  | l, c::m, r, a => by
    unfold foldlAux
    rw [dif_pos (by exact Nat.lt_add_of_pos_right add_utf8Size_pos)]
    simp only [List.append_assoc, List.cons_append, utf8Len_cons, next_of_valid l c (m ++ r),
      get_of_valid l (c :: (m ++ r)), Char.reduceDefault, List.headD_cons, List.foldl_cons]
    simpa [← Nat.add_assoc, Nat.add_right_comm] using foldlAux_of_valid f (l++[c]) m r (f a c)

theorem foldl_eq (f : α → Char → α) (s a) : foldl f a s = s.1.foldl f a := by
  simpa using foldlAux_of_valid f [] s.1 [] a

@[nolint unusedHavesSuffices] -- false positive from unfolding String.foldrAux
theorem foldrAux_of_valid (f : Char → α → α) (l m r a) :
    foldrAux f a ⟨l ++ m ++ r⟩ ⟨utf8Len l + utf8Len m⟩ ⟨utf8Len l⟩ = m.foldr f a := by
  rw [← m.reverse_reverse]
  induction m.reverse generalizing r a with (unfold foldrAux; simp)
  | cons c m IH =>
    rw [if_pos add_utf8Size_pos]
    simp only [← Nat.add_assoc, by simpa using prev_of_valid (l ++ m.reverse) c r]
    simp only [by simpa using get_of_valid (l ++ m.reverse) (c :: r)]
    simpa using IH (c::r) (f c a)

theorem foldr_eq (f : Char → α → α) (s a) : foldr f a s = s.1.foldr f a := by
  simpa using foldrAux_of_valid f [] s.1 [] a

@[nolint unusedHavesSuffices] -- false positive from unfolding String.anyAux
theorem anyAux_of_valid (p : Char → Bool) : ∀ l m r,
    anyAux ⟨l ++ m ++ r⟩ ⟨utf8Len l + utf8Len m⟩ p ⟨utf8Len l⟩ = m.any p
  | l, [], r => by unfold anyAux; simp
  | l, c::m, r => by
    unfold anyAux
    rw [dif_pos (by exact Nat.lt_add_of_pos_right add_utf8Size_pos)]
    simp only [List.append_assoc, List.cons_append, get_of_valid l (c :: (m ++ r)),
      Char.reduceDefault, List.headD_cons, utf8Len_cons, next_of_valid l c (m ++ r),
      Bool.if_true_left, Bool.decide_eq_true, List.any_cons]
    cases p c <;> simp
    simpa [← Nat.add_assoc, Nat.add_right_comm] using anyAux_of_valid p (l++[c]) m r

theorem any_eq (s : String) (p : Char → Bool) : any s p = s.1.any p := by
  simpa using anyAux_of_valid p [] s.1 []

theorem any_iff (s : String) (p : Char → Bool) : any s p ↔ ∃ c ∈ s.1, p c := by simp [any_eq]

theorem all_eq (s : String) (p : Char → Bool) : all s p = s.1.all p := by
  rw [all, any_eq, List.all_eq_not_any_not]

theorem all_iff (s : String) (p : Char → Bool) : all s p ↔ ∀ c ∈ s.1, p c := by simp [all_eq]

theorem contains_iff (s : String) (c : Char) : contains s c ↔ c ∈ s.1 := by
  simp [contains, any_iff]

@[nolint unusedHavesSuffices] -- false positive from unfolding String.mapAux
theorem mapAux_of_valid (f : Char → Char) : ∀ l r, mapAux f ⟨utf8Len l⟩ ⟨l ++ r⟩ = ⟨l ++ r.map f⟩
  | l, [] => by unfold mapAux; simp
  | l, c::r => by
    unfold mapAux
    rw [dif_neg (by rw [atEnd_of_valid]; simp)]
    simp only [get_of_valid l (c :: r), Char.reduceDefault, List.headD_cons,
      set_of_valid l (c :: r), List.modifyHead_cons, next_of_valid l (f c) r, List.map_cons]
    simpa using mapAux_of_valid f (l++[f c]) r

theorem map_eq (f : Char → Char) (s) : map f s = ⟨s.1.map f⟩ := by
  simpa using mapAux_of_valid f [] s.1

-- TODO: substrEq
-- TODO: isPrefixOf
-- TODO: replace

@[nolint unusedHavesSuffices] -- false positive from unfolding String.takeWhileAux
theorem takeWhileAux_of_valid (p : Char → Bool) : ∀ l m r,
    Substring.takeWhileAux ⟨l ++ m ++ r⟩ ⟨utf8Len l + utf8Len m⟩ p ⟨utf8Len l⟩ =
      ⟨utf8Len l + utf8Len (m.takeWhile p)⟩
  | l, [], r => by unfold Substring.takeWhileAux List.takeWhile; simp
  | l, c::m, r => by
    unfold Substring.takeWhileAux List.takeWhile
    rw [dif_pos (by exact Nat.lt_add_of_pos_right add_utf8Size_pos)]
    simp only [List.append_assoc, List.cons_append, get_of_valid l (c :: (m ++ r)),
      Char.reduceDefault, List.headD_cons, utf8Len_cons, next_of_valid l c (m ++ r)]
    cases p c <;> simp
    simpa [← Nat.add_assoc, Nat.add_right_comm] using takeWhileAux_of_valid p (l++[c]) m r

end String

open String

namespace Substring

/-- Validity for a substring. -/
structure Valid (s : Substring) : Prop where
  /-- The start position of a valid substring is valid. -/
  startValid : s.startPos.Valid s.str
  /-- The stop position of a valid substring is valid. -/
  stopValid : s.stopPos.Valid s.str
  /-- The stop position of a substring is at least the start. -/
  le : s.startPos ≤ s.stopPos

theorem Valid_default : Valid default := ⟨Pos.valid_zero, Pos.valid_zero, Nat.le_refl _⟩

/-- A substring is represented by three lists `l m r`, where `m` is the middle section
(the actual substring) and `l ++ m ++ r` is the underlying string. -/
inductive ValidFor (l m r : List Char) : Substring → Prop
  /-- The constructor for `ValidFor`. -/
  | mk : ValidFor l m r ⟨⟨l ++ m ++ r⟩, ⟨utf8Len l⟩, ⟨utf8Len l + utf8Len m⟩⟩

namespace ValidFor

theorem valid : ∀ {s}, ValidFor l m r s → Valid s
  | _, ⟨⟩ => ⟨⟨l, m ++ r, by simp⟩, ⟨l ++ m, r, by simp⟩, Nat.le_add_right ..⟩

theorem of_eq : ∀ s,
    s.str.1 = l ++ m ++ r →
    s.startPos.1 = utf8Len l →
    s.stopPos.1 = utf8Len l + utf8Len m →
    ValidFor l m r s
  | ⟨⟨_⟩, ⟨_⟩, ⟨_⟩⟩, rfl, rfl, rfl => ⟨⟩

theorem _root_.String.validFor_toSubstring (s : String) : ValidFor [] s.1 [] s :=
  .of_eq _ (by simp [toSubstring]) rfl (by simp [toSubstring, endPos, utf8ByteSize])

theorem str : ∀ {s}, ValidFor l m r s → s.str = ⟨l ++ m ++ r⟩
  | _, ⟨⟩ => rfl

theorem startPos : ∀ {s}, ValidFor l m r s → s.startPos = ⟨utf8Len l⟩
  | _, ⟨⟩ => rfl

theorem stopPos : ∀ {s}, ValidFor l m r s → s.stopPos = ⟨utf8Len l + utf8Len m⟩
  | _, ⟨⟩ => rfl

theorem bsize : ∀ {s}, ValidFor l m r s → s.bsize = utf8Len m
  | _, ⟨⟩ => by simp [Substring.bsize, Nat.add_sub_cancel_left]

theorem isEmpty : ∀ {s}, ValidFor l m r s → (s.isEmpty ↔ m = [])
  | _, h => by simp [Substring.isEmpty, h.bsize]

theorem toString : ∀ {s}, ValidFor l m r s → s.toString = ⟨m⟩
  | _, ⟨⟩ => extract_of_valid l m r

theorem toIterator : ∀ {s}, ValidFor l m r s → s.toIterator.ValidFor l.reverse (m ++ r)
  | _, h => by
    simp only [Substring.toIterator]
    exact .of_eq _ (by simp [h.str, List.reverseAux_eq]) (by simp [h.startPos])

theorem get : ∀ {s}, ValidFor l (m₁ ++ c :: m₂) r s → s.get ⟨utf8Len m₁⟩ = c
  | _, ⟨⟩ => by simpa using get_of_valid (l ++ m₁) (c :: m₂ ++ r)

theorem next : ∀ {s}, ValidFor l (m₁ ++ c :: m₂) r s →
    s.next ⟨utf8Len m₁⟩ = ⟨utf8Len m₁ + c.utf8Size⟩
  | _, ⟨⟩ => by
    simp only [Substring.next, utf8Len_append, utf8Len_cons, List.append_assoc, List.cons_append]
    rw [if_neg (mt Pos.ext_iff.1 ?a)]
    case a =>
      simpa [Nat.add_assoc, Nat.add_comm, Nat.add_left_comm] using
        @ne_add_utf8Size_add_self (utf8Len l + utf8Len m₁) (utf8Len m₂) c
    have := next_of_valid (l ++ m₁) c (m₂ ++ r)
    simp only [List.append_assoc, utf8Len_append, Pos.add_eq] at this ⊢; rw [this]
    simp [Nat.add_assoc, Nat.add_sub_cancel_left]

theorem next_stop : ∀ {s}, ValidFor l m r s → s.next ⟨utf8Len m⟩ = ⟨utf8Len m⟩
  | _, ⟨⟩ => by simp [Substring.next, Pos.add_eq]

theorem prev : ∀ {s}, ValidFor l (m₁ ++ c :: m₂) r s →
    s.prev ⟨utf8Len m₁ + c.utf8Size⟩ = ⟨utf8Len m₁⟩
  | _, ⟨⟩ => by
    simp only [Substring.prev, List.append_assoc, List.cons_append]
    rw [if_neg (mt Pos.ext_iff.1 <| Ne.symm ?a)]
    case a => simpa [Nat.add_comm] using @ne_add_utf8Size_add_self (utf8Len l) (utf8Len m₁) c
    have := prev_of_valid (l ++ m₁) c (m₂ ++ r)
    simp only [List.append_assoc, utf8Len_append, Nat.add_assoc, Pos.add_eq] at this ⊢; rw [this]
    simp [Nat.add_sub_cancel_left]

theorem nextn_stop : ∀ {s}, ValidFor l m r s → ∀ n, s.nextn n ⟨utf8Len m⟩ = ⟨utf8Len m⟩
  | _, _, 0 => rfl
  | _, h, n+1 => by simp [Substring.nextn, h.next_stop, h.nextn_stop n]

theorem nextn : ∀ {s}, ValidFor l (m₁ ++ m₂) r s →
    ∀ n, s.nextn n ⟨utf8Len m₁⟩ = ⟨utf8Len m₁ + utf8Len (m₂.take n)⟩
  | _, _, 0 => by simp [Substring.nextn]
  | s, h, n+1 => by
    simp only [Substring.nextn]
    match m₂ with
    | [] => simp at h; simp [h.next_stop, h.nextn_stop]
    | c::m₂ =>
      rw [h.next]
      have := @nextn l (m₁ ++ [c]) m₂ r s (by simp [h]) n
      simp at this; rw [this]; simp [Nat.add_assoc, Nat.add_comm, Nat.add_left_comm]

theorem prevn : ∀ {s}, ValidFor l (m₁.reverse ++ m₂) r s →
    ∀ n, s.prevn n ⟨utf8Len m₁⟩ = ⟨utf8Len (m₁.drop n)⟩
  | _, _, 0 => by simp [Substring.prevn]
  | s, h, n+1 => by
    simp only [Substring.prevn]
    match m₁ with
    | [] => simp
    | c::m₁ =>
      rw [List.reverse_cons, List.append_assoc] at h
      have := h.prev; simp at this; simp [this, h.prevn n]

theorem front : ∀ {s}, ValidFor l (c :: m) r s → s.front = c
  | _, h => h.get (m₁ := [])

theorem drop : ∀ {s}, ValidFor l m r s → ∀ n, ValidFor (l ++ m.take n) (m.drop n) r (s.drop n)
  | s, h, n => by
    have : Substring.nextn {..} .. = _ := h.nextn (m₁ := []) n
    simp only [utf8Len_nil, Pos.mk_zero, Nat.zero_add] at this
    simp only [Substring.drop, this]
    simp only [h.str, List.append_assoc, h.startPos, h.stopPos]
    rw [← List.take_append_drop n m] at h
    refine .of_eq _ (by simp) (by simp) ?_
    conv => lhs; rw [← List.take_append_drop n m]
    simp [-List.take_append_drop, Nat.add_assoc]

theorem take : ∀ {s}, ValidFor l m r s → ∀ n, ValidFor l (m.take n) (m.drop n ++ r) (s.take n)
  | s, h, n => by
    have : Substring.nextn {..} .. = _ := h.nextn (m₁ := []) n
    simp at this
    simp only [Substring.take, this]
    simp only [h.str, List.append_assoc, h.startPos]
    rw [← List.take_append_drop n m] at h
    refine .of_eq _ ?_ (by simp) (by simp)
    conv => lhs; rw [← List.take_append_drop n m]
    simp [-List.take_append_drop]

-- TODO: takeRight, dropRight

theorem atEnd : ∀ {s}, ValidFor l m r s → (s.atEnd ⟨p⟩ ↔ p = utf8Len m)
  | _, ⟨⟩ => by simp [Substring.atEnd, Pos.ext_iff, Nat.add_left_cancel_iff]

theorem extract : ∀ {s}, ValidFor l m r s → ValidFor ml mm mr ⟨⟨m⟩, b, e⟩ →
    ∃ l' r', ValidFor l' mm r' (s.extract b e)
  | _, ⟨⟩, ⟨⟩ => by
    simp only [Substring.extract, ge_iff_le, Pos.mk_le_mk, List.append_assoc, utf8Len_append]
    split
    · next h =>
      rw [utf8Len_eq_zero.1 <| Nat.le_zero.1 <| Nat.add_le_add_iff_left.1 h]
      exact ⟨[], [], ⟨⟩⟩
    · next h =>
      refine ⟨l ++ ml, mr ++ r, .of_eq _ (by simp) ?_ ?_⟩ <;>
        simp only [Pos.add_byteIdx, Nat.min_eq_min, utf8Len_append]
          <;> rw [Nat.min_eq_right]
          <;> try simp [Nat.add_le_add_iff_left, Nat.le_add_right]
      rw [Nat.add_assoc]

-- TODO: splitOn

theorem foldl (f) (init : α) : ∀ {s}, ValidFor l m r s → s.foldl f init = m.foldl f init
  | _, ⟨⟩ => by simp [-List.append_assoc, Substring.foldl, foldlAux_of_valid]

theorem foldr (f) (init : α) : ∀ {s}, ValidFor l m r s → s.foldr f init = m.foldr f init
  | _, ⟨⟩ => by simp [-List.append_assoc, Substring.foldr, foldrAux_of_valid]

theorem any (f) : ∀ {s}, ValidFor l m r s → s.any f = m.any f
  | _, ⟨⟩ => by simp [-List.append_assoc, Substring.any, anyAux_of_valid]

theorem all (f) : ∀ {s}, ValidFor l m r s → s.all f = m.all f
  | _, h => by simp [Substring.all, h.any, List.all_eq_not_any_not]

theorem contains (c) : ∀ {s}, ValidFor l m r s → (s.contains c ↔ c ∈ m)
  | _, h => by simp [Substring.contains, h.any]

theorem takeWhile (p : Char → Bool) : ∀ {s}, ValidFor l m r s →
    ValidFor l (m.takeWhile p) (m.dropWhile p ++ r) (s.takeWhile p)
  | _, ⟨⟩ => by
    simp only [Substring.takeWhile, takeWhileAux_of_valid]
    apply ValidFor.of_eq <;> simp
    rw [← List.append_assoc, List.takeWhile_append_dropWhile]

theorem dropWhile (p : Char → Bool) : ∀ {s}, ValidFor l m r s →
    ValidFor (l ++ m.takeWhile p) (m.dropWhile p) r (s.dropWhile p)
  | _, ⟨⟩ => by
    simp only [Substring.dropWhile, takeWhileAux_of_valid]
    apply ValidFor.of_eq <;> simp
    rw [Nat.add_assoc, ← utf8Len_append (m.takeWhile p), List.takeWhile_append_dropWhile]

-- TODO: takeRightWhile

end ValidFor

namespace Valid

theorem validFor : ∀ {s}, Valid s → ∃ l m r, ValidFor l m r s
  | ⟨⟨_⟩, ⟨_⟩, ⟨_⟩⟩, ⟨⟨l, mr, rfl, rfl⟩, ⟨lm, r, e, rfl⟩, h⟩ => by
    simp only [utf8ByteSize.go_eq, Pos.mk_le_mk] at *
    have := (or_iff_right_iff_imp.2 fun h => ?x).1 (List.append_eq_append_iff.1 e)
    case x =>
      match l, r, h with | _, _, ⟨m, rfl, rfl⟩ => ?_
      simp only [utf8Len_append] at h
      cases utf8Len_eq_zero.1 <| Nat.le_zero.1 (Nat.le_of_add_le_add_left (c := 0) h)
      exact ⟨[], by simp⟩
    match lm, mr, this with
    | _, _, ⟨m, rfl, rfl⟩ => exact ⟨l, m, r, by simpa using ValidFor.mk⟩

theorem valid : ∀ {s}, ValidFor l m r s → Valid s
  | _, ⟨⟩ => ⟨⟨l, m ++ r, by simp⟩, ⟨l ++ m, r, by simp⟩, Nat.le_add_right ..⟩

theorem _root_.String.valid_toSubstring (s : String) : Valid s :=
  s.validFor_toSubstring.valid

theorem bsize : ∀ {s}, Valid s → s.bsize = utf8Len s.toString.1
  | _, h => let ⟨l, m, r, h⟩ := h.validFor; by simp [h.bsize, h.toString]

theorem isEmpty : ∀ {s}, Valid s → (s.isEmpty ↔ s.toString = "")
  | _, h => let ⟨l, m, r, h⟩ := h.validFor; by simp [h.isEmpty, h.toString, ext_iff]

theorem get : ∀ {s}, Valid s → s.toString.1 = m₁ ++ c :: m₂ → s.get ⟨utf8Len m₁⟩ = c
  | _, h, e => by
    let ⟨l, m, r, h⟩ := h.validFor
    simp only [h.toString] at e; subst e; simp [h.get]

theorem next : ∀ {s}, Valid s → s.toString.1 = m₁ ++ c :: m₂ →
    s.next ⟨utf8Len m₁⟩ = ⟨utf8Len m₁ + c.utf8Size⟩
  | _, h, e => by
    let ⟨l, m, r, h⟩ := h.validFor
    simp only [h.toString] at e; subst e; simp [h.next]

theorem next_stop : ∀ {s}, Valid s → s.next ⟨s.bsize⟩ = ⟨s.bsize⟩
  | _, h => let ⟨l, m, r, h⟩ := h.validFor; by simp [h.bsize, h.next_stop]

theorem prev : ∀ {s}, Valid s → s.toString.1 = m₁ ++ c :: m₂ →
    s.prev ⟨utf8Len m₁ + c.utf8Size⟩ = ⟨utf8Len m₁⟩
  | _, h, e => by
    let ⟨l, m, r, h⟩ := h.validFor
    simp only [h.toString] at e; subst e; simp [h.prev]

theorem nextn_stop : ∀ {s}, Valid s → ∀ n, s.nextn n ⟨s.bsize⟩ = ⟨s.bsize⟩
  | _, h, n => let ⟨l, m, r, h⟩ := h.validFor; by simp [h.bsize, h.nextn_stop]

theorem nextn : ∀ {s}, Valid s → s.toString.1 = m₁ ++ m₂ →
    ∀ n, s.nextn n ⟨utf8Len m₁⟩ = ⟨utf8Len m₁ + utf8Len (m₂.take n)⟩
  | _, h, e => by
    let ⟨l, m, r, h⟩ := h.validFor
    simp only [h.toString] at e; subst e; simp [h.nextn]

theorem prevn : ∀ {s}, Valid s → s.toString.1 = m₁.reverse ++ m₂ →
    ∀ n, s.prevn n ⟨utf8Len m₁⟩ = ⟨utf8Len (m₁.drop n)⟩
  | _, h, e => by
    let ⟨l, m, r, h⟩ := h.validFor
    simp only [h.toString] at e; subst e; simp [h.prevn]

theorem front : ∀ {s}, Valid s → s.toString.1 = c :: m → s.front = c
  | _, h => h.get (m₁ := [])

theorem drop : ∀ {s}, Valid s → ∀ n, Valid (s.drop n)
  | _, h, _ => let ⟨_, _, _, h⟩ := h.validFor; (h.drop _).valid

theorem data_drop : ∀ {s}, Valid s → ∀ n, (s.drop n).toString.1 = s.toString.1.drop n
  | _, h, _ => let ⟨_, _, _, h⟩ := h.validFor; by simp [(h.drop _).toString, h.toString]

theorem take : ∀ {s}, Valid s → ∀ n, Valid (s.take n)
  | _, h, _ => let ⟨_, _, _, h⟩ := h.validFor; (h.take _).valid

theorem data_take : ∀ {s}, Valid s → ∀ n, (s.take n).toString.1 = s.toString.1.take n
  | _, h, _ => let ⟨_, _, _, h⟩ := h.validFor; by simp [(h.take _).toString, h.toString]

-- TODO: takeRight, dropRight

theorem atEnd : ∀ {s}, Valid s → (s.atEnd ⟨p⟩ ↔ p = utf8ByteSize s.toString)
  | _, h => let ⟨_, _, _, h⟩ := h.validFor; by simp [h.atEnd, h.toString]

theorem extract : ∀ {s}, Valid s → Valid ⟨s.toString, b, e⟩ → Valid (s.extract b e)
  | _, h₁, h₂ => by
    let ⟨l, m, r, h₁⟩ := h₁.validFor
    rw [h₁.toString] at h₂
    let ⟨ml, mm, mr, h₂⟩ := h₂.validFor
    have ⟨l', r', h₃⟩ := h₁.extract h₂
    exact h₃.valid

theorem toString_extract : ∀ {s}, Valid s → Valid ⟨s.toString, b, e⟩ →
    (s.extract b e).toString = s.toString.extract b e
  | _, h₁, h₂ => by
    let ⟨l, m, r, h₁⟩ := h₁.validFor
    rw [h₁.toString] at h₂
    let ⟨ml, mm, mr, h₂⟩ := h₂.validFor
    have ⟨l', r', h₃⟩ := h₁.extract h₂
    rw [h₃.toString, h₁.toString, ← h₂.toString, toString]

theorem foldl (f) (init : α) : ∀ {s}, Valid s → s.foldl f init = s.toString.1.foldl f init
  | _, h => let ⟨_, _, _, h⟩ := h.validFor; by simp [h.foldl, h.toString]

theorem foldr (f) (init : α) : ∀ {s}, Valid s → s.foldr f init = s.toString.1.foldr f init
  | _, h => let ⟨_, _, _, h⟩ := h.validFor; by simp [h.foldr, h.toString]

theorem any (f) : ∀ {s}, Valid s → s.any f = s.toString.1.any f
  | _, h => let ⟨_, _, _, h⟩ := h.validFor; by simp [h.any, h.toString]

theorem all (f) : ∀ {s}, Valid s → s.all f = s.toString.1.all f
  | _, h => let ⟨_, _, _, h⟩ := h.validFor; by simp [h.all, h.toString]

theorem contains (c) : ∀ {s}, Valid s → (s.contains c ↔ c ∈ s.toString.1)
  | _, h => let ⟨_, _, _, h⟩ := h.validFor; by simp [h.contains, h.toString]

theorem takeWhile (p : Char → Bool) : ∀ {s}, Valid s → Valid (s.takeWhile p)
  | _, h => let ⟨_, _, _, h⟩ := h.validFor; (h.takeWhile _).valid

theorem data_takeWhile (p) : ∀ {s}, Valid s →
    (s.takeWhile p).toString.1 = s.toString.1.takeWhile p
  | _, h => let ⟨_, _, _, h⟩ := h.validFor; by simp [(h.takeWhile _).toString, h.toString]

theorem dropWhile (p : Char → Bool) : ∀ {s}, Valid s → Valid (s.dropWhile p)
  | _, h => let ⟨_, _, _, h⟩ := h.validFor; (h.dropWhile _).valid

theorem data_dropWhile (p) : ∀ {s}, Valid s →
    (s.dropWhile p).toString.1 = s.toString.1.dropWhile p
  | _, h => let ⟨_, _, _, h⟩ := h.validFor; by simp [(h.dropWhile _).toString, h.toString]

-- TODO: takeRightWhile

end Valid
end Substring

namespace String

theorem drop_eq (s : String) (n : Nat) : s.drop n = ⟨s.1.drop n⟩ :=
  (s.validFor_toSubstring.drop n).toString

@[simp] theorem data_drop (s : String) (n : Nat) : (s.drop n).1 = s.1.drop n := by rw [drop_eq]

@[simp] theorem drop_empty {n : Nat} : "".drop n = "" := by rw [drop_eq, List.drop_nil]

theorem take_eq (s : String) (n : Nat) : s.take n = ⟨s.1.take n⟩ :=
  (s.validFor_toSubstring.take n).toString

@[simp] theorem data_take (s : String) (n : Nat) : (s.take n).1 = s.1.take n := by rw [take_eq]

theorem takeWhile_eq (p : Char → Bool) (s : String) : s.takeWhile p = ⟨s.1.takeWhile p⟩ :=
  (s.validFor_toSubstring.takeWhile p).toString

@[simp] theorem data_takeWhile (p : Char → Bool) (s : String) :
    (s.takeWhile p).1 = s.1.takeWhile p := by rw [takeWhile_eq]

theorem dropWhile_eq (p : Char → Bool) (s : String) : s.dropWhile p = ⟨s.1.dropWhile p⟩ :=
  (s.validFor_toSubstring.dropWhile p).toString

@[simp] theorem data_dropWhile (p : Char → Bool) (s : String) :
    (s.dropWhile p).1 = s.1.dropWhile p := by rw [dropWhile_eq]

end String



=== LEAN SOURCE: Matcher.lean ===
/-
Copyright (c) 2023 F. G. Dorais. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: F. G. Dorais
-/
import Batteries.Data.Array.Match
import Batteries.Data.String.Basic

namespace String

/-- Knuth-Morris-Pratt matcher type

This type is used to keep data for running the Knuth-Morris-Pratt (KMP) string matching algorithm.
KMP is a linear time algorithm to locate all substrings of a string that match a given pattern.
Generating the algorithm data is also linear in the length of the pattern but the data can be
re-used to match the same pattern over different strings.

The KMP data for a pattern string can be generated using `Matcher.ofString`. Then `Matcher.find?`
and `Matcher.findAll` can be used to run the algorithm on an input string.
```
def m := Matcher.ofString "abba"

#eval Option.isSome <| m.find? "AbbabbA" -- false
#eval Option.isSome <| m.find? "aabbaa" -- true

#eval Array.size <| m.findAll "abbabba" -- 2
#eval Array.size <| m.findAll "abbabbabba" -- 3
```
-/
structure Matcher extends Array.Matcher Char where
  /-- The pattern for the matcher -/
  pattern : Substring

/-- Make KMP matcher from pattern substring -/
@[inline] def Matcher.ofSubstring (pattern : Substring) : Matcher where
  toMatcher := Array.Matcher.ofStream pattern
  pattern := pattern

/-- Make KMP matcher from pattern string -/
@[inline] def Matcher.ofString (pattern : String) : Matcher :=
  Matcher.ofSubstring pattern

/-- The byte size of the string pattern for the matcher -/
abbrev Matcher.patternSize (m : Matcher) : Nat := m.pattern.bsize

/-- Find all substrings of `s` matching `m.pattern`. -/
partial def Matcher.findAll (m : Matcher) (s : Substring) : Array Substring :=
  loop s m.toMatcher #[]
where
  /-- Accumulator loop for `String.Matcher.findAll` -/
  loop (s : Substring) (am : Array.Matcher Char) (occs : Array Substring) : Array Substring :=
    match am.next? s with
    | none => occs
    | some (s, am) =>
      loop s am <| occs.push { s with
        startPos := ⟨s.startPos.byteIdx - m.patternSize⟩
        stopPos := s.startPos }

/-- Find the first substring of `s` matching `m.pattern`, or `none` if no such substring exists. -/
def Matcher.find? (m : Matcher) (s : Substring) : Option Substring :=
  match m.next? s with
  | none => none
  | some (s, _) =>
    some { s with
      startPos := ⟨s.startPos.byteIdx - m.patternSize⟩
      stopPos := s.startPos }

end String

namespace Substring

/--
Returns all the substrings of `s` that match `pattern`.
-/
@[inline] def findAllSubstr (s pattern : Substring) : Array Substring :=
  (String.Matcher.ofSubstring pattern).findAll s

/--
Returns the first substring of `s` that matches `pattern`,
or `none` if there is no such substring.
-/
@[inline] def findSubstr? (s pattern : Substring) : Option Substring :=
  (String.Matcher.ofSubstring pattern).find? s

/--
Returns true iff `pattern` occurs as a substring of `s`.
-/
@[inline] def containsSubstr (s pattern : Substring) : Bool :=
  s.findSubstr? pattern |>.isSome

end Substring

namespace String

@[inherit_doc Substring.findAllSubstr]
abbrev findAllSubstr (s : String) (pattern : Substring) : Array Substring :=
  (String.Matcher.ofSubstring pattern).findAll s

@[inherit_doc Substring.findSubstr?]
abbrev findSubstr? (s : String) (pattern : Substring) : Option Substring :=
  s.toSubstring.findSubstr? pattern

@[inherit_doc Substring.containsSubstr]
abbrev containsSubstr (s : String) (pattern : Substring) : Bool :=
  s.toSubstring.containsSubstr pattern

end String



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2021 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Batteries.Tactic.Lint.Misc
import Batteries.Tactic.SeqFocus
import Batteries.Util.Panic

namespace Batteries

/-- Union-find node type -/
structure UFNode where
  /-- Parent of node -/
  parent : Nat
  /-- Rank of node -/
  rank : Nat

namespace UnionFind

/-- Parent of a union-find node, defaults to self when the node is a root -/
def parentD (arr : Array UFNode) (i : Nat) : Nat :=
  if h : i < arr.size then arr[i].parent else i

/-- Rank of a union-find node, defaults to 0 when the node is a root -/
def rankD (arr : Array UFNode) (i : Nat) : Nat :=
  if h : i < arr.size then arr[i].rank else 0

theorem parentD_eq {arr : Array UFNode} {i} (h) :
    parentD arr i = arr[i].parent := dif_pos _

theorem rankD_eq {arr : Array UFNode} {i} (h) : rankD arr i = arr[i].rank := dif_pos _

theorem parentD_of_not_lt : ¬i < arr.size → parentD arr i = i := (dif_neg ·)

theorem lt_of_parentD : parentD arr i ≠ i → i < arr.size :=
  Decidable.not_imp_comm.1 parentD_of_not_lt

theorem parentD_set {arr : Array UFNode} {x v i h} :
    parentD (arr.set x v h) i = if x = i then v.parent else parentD arr i := by
  rw [parentD]; simp only [Array.size_set, parentD]
  split
  · split <;> simp_all
  · split <;> [(subst i; cases ‹¬_› h); rfl]

theorem rankD_set {arr : Array UFNode} {x v i h} :
    rankD (arr.set x v h) i = if x = i then v.rank else rankD arr i := by
  rw [rankD]; simp only [Array.size_set, rankD]
  split
  · split <;> simp_all
  · split <;> [(subst i; cases ‹¬_› h); rfl]

end UnionFind

open UnionFind

/-- ### Union-find data structure

The `UnionFind` structure is an implementation of disjoint-set data structure
that uses path compression to make the primary operations run in amortized
nearly linear time. The nodes of a `UnionFind` structure `s` are natural
numbers smaller than `s.size`. The structure associates with a canonical
representative from its equivalence class. The structure can be extended
using the `push` operation and equivalence classes can be updated using the
`union` operation.

The main operations for `UnionFind` are:

* `empty`/`mkEmpty` are used to create a new empty structure.
* `size` returns the size of the data structure.
* `push` adds a new node to a structure, unlinked to any other node.
* `union` links two nodes of the data structure, joining their equivalence
  classes, and performs path compression.
* `find` returns the canonical representative of a node and updates the data
  structure using path compression.
* `root` returns the canonical representative of a node without altering the
  data structure.
* `checkEquiv` checks whether two nodes have the same canonical representative
  and updates the structure using path compression.

Most use cases should prefer `find` over `root` to benefit from the speedup from path-compression.

The main operations use `Fin s.size` to represent nodes of the union-find structure.
Some alternatives are provided:

* `unionN`, `findN`, `rootN`, `checkEquivN` use `Fin n` with a proof that `n = s.size`.
* `union!`, `find!`, `root!`, `checkEquiv!` use `Nat` and panic when the indices are out of bounds.
* `findD`, `rootD`, `checkEquivD` use `Nat` and treat out of bound indices as isolated nodes.

The noncomputable relation `UnionFind.Equiv` is provided to use the equivalence relation from a
`UnionFind` structure in the context of proofs.
-/
structure UnionFind where
  /-- Array of union-find nodes -/
  arr : Array UFNode
  /-- Validity for parent nodes -/
  parentD_lt : ∀ {i}, i < arr.size → parentD arr i < arr.size
  /-- Validity for rank -/
  rankD_lt : ∀ {i}, parentD arr i ≠ i → rankD arr i < rankD arr (parentD arr i)

namespace UnionFind

/-- Size of union-find structure. -/
@[inline] abbrev size (self : UnionFind) := self.arr.size

/-- Create an empty union-find structure with specific capacity -/
def mkEmpty (c : Nat) : UnionFind where
  arr := Array.mkEmpty c
  parentD_lt := nofun
  rankD_lt := nofun

/-- Empty union-find structure -/
def empty := mkEmpty 0

instance : EmptyCollection UnionFind := ⟨.empty⟩

/-- Parent of union-find node -/
abbrev parent (self : UnionFind) (i : Nat) : Nat := parentD self.arr i

theorem parent'_lt (self : UnionFind) (i : Nat) (h) : self.arr[i].parent < self.size := by
  simp [← parentD_eq, parentD_lt, h]

theorem parent_lt (self : UnionFind) (i : Nat) : self.parent i < self.size ↔ i < self.size := by
  simp only [parentD]; split <;> simp only [*, parent'_lt]

/-- Rank of union-find node -/
abbrev rank (self : UnionFind) (i : Nat) : Nat := rankD self.arr i

theorem rank_lt {self : UnionFind} {i : Nat} : self.parent i ≠ i →
    self.rank i < self.rank (self.parent i) := by simpa only [rank] using self.rankD_lt

theorem rank'_lt (self : UnionFind) (i h) : self.arr[i].parent ≠ i →
    self.rank i < self.rank (self.arr[i]).parent := by
  simpa only [← parentD_eq] using self.rankD_lt

/-- Maximum rank of nodes in a union-find structure -/
noncomputable def rankMax (self : UnionFind) := self.arr.foldr (max ·.rank) 0 + 1

theorem rank'_lt_rankMax (self : UnionFind) (i : Nat) (h) : (self.arr[i]).rank < self.rankMax := by
  let rec go : ∀ {l} {x : UFNode}, x ∈ l → x.rank ≤ List.foldr (max ·.rank) 0 l
    | a::l, _, List.Mem.head _ => by dsimp; apply Nat.le_max_left
    | a::l, _, .tail _ h => by dsimp; exact Nat.le_trans (go h) (Nat.le_max_right ..)
  simp only [rankMax, ← Array.foldr_toList]
  exact Nat.lt_succ.2 <| go (self.arr.toList.getElem_mem _)

theorem rankD_lt_rankMax (self : UnionFind) (i : Nat) :
    rankD self.arr i < self.rankMax := by
  simp [rankD]; split <;> [apply rank'_lt_rankMax; apply Nat.succ_pos]

theorem lt_rankMax (self : UnionFind) (i : Nat) : self.rank i < self.rankMax := rankD_lt_rankMax ..

theorem push_rankD (arr : Array UFNode) : rankD (arr.push ⟨arr.size, 0⟩) i = rankD arr i := by
  simp only [rankD, Array.size_push, Array.getElem_push, dite_eq_ite]
  split <;> split <;> first | simp | cases ‹¬_› (Nat.lt_succ_of_lt ‹_›)

theorem push_parentD (arr : Array UFNode) : parentD (arr.push ⟨arr.size, 0⟩) i = parentD arr i := by
  simp only [parentD, Array.size_push, Array.getElem_push, dite_eq_ite]
  split <;> split <;> try simp
  · exact Nat.le_antisymm (Nat.ge_of_not_lt ‹_›) (Nat.le_of_lt_succ ‹_›)
  · cases ‹¬_› (Nat.lt_succ_of_lt ‹_›)

/-- Add a new node to a union-find structure, unlinked with any other nodes -/
def push (self : UnionFind) : UnionFind where
  arr := self.arr.push ⟨self.arr.size, 0⟩
  parentD_lt {i} := by
    simp only [Array.size_push, push_parentD]; simp only [parentD]
    split <;> [exact fun _ => Nat.lt_succ_of_lt (self.parent'_lt ..); exact id]
  rankD_lt := by simp only [push_parentD, ne_eq, push_rankD]; exact self.rank_lt

/-- Root of a union-find node. -/
def root (self : UnionFind) (x : Fin self.size) : Fin self.size :=
  let y := self.arr[x.1].parent
  if h : y = x then
    x
  else
    have := Nat.sub_lt_sub_left (self.lt_rankMax x) (self.rank'_lt _ _ h)
    self.root ⟨y, self.parent'_lt x _⟩
termination_by self.rankMax - self.rank x

@[inherit_doc root]
def rootN (self : UnionFind) (x : Fin n) (h : n = self.size) : Fin n :=
  match n, h with | _, rfl => self.root x

/-- Root of a union-find node. Panics if index is out of bounds. -/
def root! (self : UnionFind) (x : Nat) : Nat :=
  if h : x < self.size then self.root ⟨x, h⟩ else panicWith x "index out of bounds"

/-- Root of a union-find node. Returns input if index is out of bounds. -/
def rootD (self : UnionFind) (x : Nat) : Nat :=
  if h : x < self.size then self.root ⟨x, h⟩ else x

@[nolint unusedHavesSuffices]
theorem parent_root (self : UnionFind) (x : Fin self.size) :
    (self.arr[(self.root x).1]).parent = self.root x := by
  rw [root]; split <;> [assumption; skip]
  have := Nat.sub_lt_sub_left (self.lt_rankMax x) (self.rank'_lt _ _ ‹_›)
  apply parent_root
termination_by self.rankMax - self.rank x

theorem parent_rootD (self : UnionFind) (x : Nat) :
    self.parent (self.rootD x) = self.rootD x := by
  rw [rootD]
  split
  · simp [parentD, parent_root]
  · simp [parentD_of_not_lt, *]

@[nolint unusedHavesSuffices]
theorem rootD_parent (self : UnionFind) (x : Nat) : self.rootD (self.parent x) = self.rootD x := by
  simp only [rootD, parent_lt]
  split
  · simp only [parentD, ↓reduceDIte, *]
    (conv => rhs; rw [root]); split
    · rw [root, dif_pos] <;> simp_all
    · simp
  · simp only [not_false_eq_true, parentD_of_not_lt, *]

theorem rootD_lt {self : UnionFind} {x : Nat} : self.rootD x < self.size ↔ x < self.size := by
  simp only [rootD]; split <;> simp [*]

@[nolint unusedHavesSuffices]
theorem rootD_eq_self {self : UnionFind} {x : Nat} : self.rootD x = x ↔ self.parent x = x := by
  refine ⟨fun h => by rw [← h, parent_rootD], fun h => ?_⟩
  rw [rootD]; split <;> [rw [root, dif_pos (by rwa [parent, parentD_eq ‹_›] at h)]; rfl]

theorem rootD_rootD {self : UnionFind} {x : Nat} : self.rootD (self.rootD x) = self.rootD x :=
  rootD_eq_self.2 (parent_rootD ..)

theorem rootD_ext {m1 m2 : UnionFind}
    (H : ∀ x, m1.parent x = m2.parent x) {x} : m1.rootD x = m2.rootD x := by
  if h : m2.parent x = x then
    rw [rootD_eq_self.2 h, rootD_eq_self.2 ((H _).trans h)]
  else
    have := Nat.sub_lt_sub_left (m2.lt_rankMax x) (m2.rank_lt h)
    rw [← rootD_parent, H, rootD_ext H, rootD_parent]
termination_by m2.rankMax - m2.rank x

theorem le_rank_root {self : UnionFind} {x : Nat} : self.rank x ≤ self.rank (self.rootD x) := by
  if h : self.parent x = x then
    rw [rootD_eq_self.2 h]; exact Nat.le_refl ..
  else
    have := Nat.sub_lt_sub_left (self.lt_rankMax x) (self.rank_lt h)
    rw [← rootD_parent]
    exact Nat.le_trans (Nat.le_of_lt (self.rank_lt h)) le_rank_root
termination_by self.rankMax - self.rank x

theorem lt_rank_root {self : UnionFind} {x : Nat} :
    self.rank x < self.rank (self.rootD x) ↔ self.parent x ≠ x := by
  refine ⟨fun h h' => Nat.ne_of_lt h (by rw [rootD_eq_self.2 h']), fun h => ?_⟩
  rw [← rootD_parent]
  exact Nat.lt_of_lt_of_le (self.rank_lt h) le_rank_root

/-- Auxiliary data structure for find operation -/
structure FindAux (n : Nat) where
  /-- Array of nodes -/
  s : Array UFNode
  /-- Index of root node -/
  root : Fin n
  /-- Size requirement -/
  size_eq : s.size = n

/-- Auxiliary function for find operation -/
def findAux (self : UnionFind) (x : Fin self.size) : FindAux self.size :=
  let y := self.arr[x.1].parent
  if h : y = x then
    ⟨self.arr, x, rfl⟩
  else
    have := Nat.sub_lt_sub_left (self.lt_rankMax x) (self.rank'_lt _ _ h)
    let ⟨arr₁, root, H⟩ := self.findAux ⟨y, self.parent'_lt _ x.2⟩
    ⟨arr₁.modify x fun s => { s with parent := root }, root, by simp [H]⟩
termination_by self.rankMax - self.rank x

@[nolint unusedHavesSuffices]
theorem findAux_root {self : UnionFind} {x : Fin self.size} :
    (findAux self x).root = self.root x := by
  rw [findAux, root]
  simp only [dite_eq_ite]
  split <;> simp only
  have := Nat.sub_lt_sub_left (self.lt_rankMax x) (self.rank'_lt _ _ ‹_›)
  exact findAux_root
termination_by self.rankMax - self.rank x

@[nolint unusedHavesSuffices]
theorem findAux_s {self : UnionFind} {x : Fin self.size} :
    (findAux self x).s = if self.arr[x.1].parent = x then self.arr else
      (self.findAux ⟨_, self.parent'_lt x x.2⟩).s.modify x fun s =>
        { s with parent := self.rootD x } := by
  rw [show self.rootD _ = (self.findAux ⟨_, self.parent'_lt x x.2⟩).root from _]
  · rw [findAux]; split <;> rfl
  · rw [← rootD_parent, parent, parentD_eq]
    simp only [rootD, findAux_root]
    apply dif_pos

theorem rankD_findAux {self : UnionFind} {x : Fin self.size} :
    rankD (findAux self x).s i = self.rank i := by
  if h : i < self.size then
    rw [findAux_s]; split <;> [rfl; skip]
    have := Nat.sub_lt_sub_left (self.lt_rankMax x) (self.rank'_lt _ _ ‹_›)
    have := lt_of_parentD (by rwa [parentD_eq])
    rw [rankD_eq (by simp [FindAux.size_eq, h]), Array.getElem_modify]
    split <;>
      simp [← rankD_eq, rankD_findAux (x := ⟨_, self.parent'_lt _ x.2⟩)]
  else
    simp only [rankD, rank]
    rw [dif_neg (by rwa [FindAux.size_eq]), dif_neg h]
termination_by self.rankMax - self.rank x

theorem parentD_findAux {self : UnionFind} {x : Fin self.size} :
    parentD (findAux self x).s i =
    if i = x then self.rootD x else parentD (self.findAux ⟨_, self.parent'_lt _ x.2⟩).s i := by
  rw [findAux_s]; split <;> [split; skip]
  · subst i; rw [rootD_eq_self.2 _] <;> simp [parentD_eq, *]
  · rw [findAux_s]; simp [*]
  · next h =>
    rw [parentD]; split <;> rename_i h'
    · rw [Array.getElem_modify (by simpa using h')]
      simp only [@eq_comm _ i]
      split <;> simp [← parentD_eq]
    · rw [if_neg (mt (by rintro rfl; simp [FindAux.size_eq]) h')]
      rw [parentD, dif_neg]; simpa using h'

theorem parentD_findAux_rootD {self : UnionFind} {x : Fin self.size} :
    parentD (findAux self x).s (self.rootD x) = self.rootD x := by
  rw [parentD_findAux]; split <;> [rfl; rename_i h]
  rw [rootD_eq_self, parent, parentD_eq x.2] at h
  have := Nat.sub_lt_sub_left (self.lt_rankMax x) (self.rank'_lt _ _ ‹_›)
  rw [← rootD_parent, parent, parentD_eq x.2]
  exact parentD_findAux_rootD (x := ⟨_, self.parent'_lt _ x.2⟩)
termination_by self.rankMax - self.rank x

theorem parentD_findAux_lt {self : UnionFind} {x : Fin self.size} (h : i < self.size) :
    parentD (findAux self x).s i < self.size := by
  if h' : self.arr[x.1].parent = x then
    rw [findAux_s, if_pos h']; apply self.parentD_lt h
  else
    rw [parentD_findAux]
    split
    · simp [rootD_lt]
    · have := Nat.sub_lt_sub_left (self.lt_rankMax x) (self.rank'_lt _ _ ‹_›)
      apply parentD_findAux_lt h
termination_by self.rankMax - self.rank x

theorem parentD_findAux_or (self : UnionFind) (x : Fin self.size) (i) :
    parentD (findAux self x).s i = self.rootD i ∧ self.rootD i = self.rootD x ∨
    parentD (findAux self x).s i = self.parent i := by
  if h' : self.arr[x.1].parent = x then
    rw [findAux_s, if_pos h']; exact .inr rfl
  else
    rw [parentD_findAux]
    split
    · simp [*]
    · have := Nat.sub_lt_sub_left (self.lt_rankMax x) (self.rank'_lt _ _ ‹_›)
      refine (parentD_findAux_or self ⟨_, self.parent'_lt _ x.2⟩ i)
        |>.imp_left (.imp_right fun h => ?_)
      simp only [h, ← parentD_eq, rootD_parent]
termination_by self.rankMax - self.rank x

theorem lt_rankD_findAux {self : UnionFind} {x : Fin self.size} :
    parentD (findAux self x).s i ≠ i →
    self.rank i < self.rank (parentD (findAux self x).s i) := by
  if h' : self.arr[x.1].parent = x then
    rw [findAux_s, if_pos h']; apply self.rank_lt
  else
    rw [parentD_findAux]; split <;> rename_i h <;> intro h'
    · subst i; rwa [lt_rank_root, Ne, ← rootD_eq_self]
    · have := Nat.sub_lt_sub_left (self.lt_rankMax x) (self.rank'_lt _ _ ‹_›)
      apply lt_rankD_findAux h'
termination_by self.rankMax - self.rank x

/-- Find root of a union-find node, updating the structure using path compression. -/
def find (self : UnionFind) (x : Fin self.size) :
    (s : UnionFind) × {_root : Fin s.size // s.size = self.size} :=
  let r := self.findAux x
  { 1.arr := r.s
    2.1.val := r.root
    1.parentD_lt := fun h => by
      simp only [FindAux.size_eq] at *
      exact parentD_findAux_lt h
    1.rankD_lt := fun h => by rw [rankD_findAux, rankD_findAux]; exact lt_rankD_findAux h
    2.1.isLt := show _ < r.s.size by rw [r.size_eq]; exact r.root.2
    2.2 := by simp [size, r.size_eq] }

@[inherit_doc find]
def findN (self : UnionFind) (x : Fin n) (h : n = self.size) : UnionFind × Fin n :=
  match n, h with | _, rfl => match self.find x with | ⟨s, r, h⟩ => (s, Fin.cast h r)

/-- Find root of a union-find node, updating the structure using path compression.
  Panics if index is out of bounds. -/
def find! (self : UnionFind) (x : Nat) : UnionFind × Nat :=
  if h : x < self.size then
    match self.find ⟨x, h⟩ with | ⟨s, r, _⟩ => (s, r)
  else
    panicWith (self, x) "index out of bounds"

/-- Find root of a union-find node, updating the structure using path compression.
  Returns inputs unchanged when index is out of bounds. -/
def findD (self : UnionFind) (x : Nat) : UnionFind × Nat :=
  if h : x < self.size then
    match self.find ⟨x, h⟩ with | ⟨s, r, _⟩ => (s, r)
  else
    (self, x)

@[simp] theorem find_size (self : UnionFind) (x : Fin self.size) :
    (self.find x).1.size = self.size := by simp [find, size, FindAux.size_eq]

@[simp] theorem find_root_2 (self : UnionFind) (x : Fin self.size) :
    (self.find x).2.1.1 = self.rootD x := by simp [find, findAux_root, rootD]

@[simp] theorem find_parent_1 (self : UnionFind) (x : Fin self.size) :
    (self.find x).1.parent x = self.rootD x := by
  simp only [parent, find]
  rw [parentD_findAux, if_pos rfl]

theorem find_parent_or (self : UnionFind) (x : Fin self.size) (i) :
    (self.find x).1.parent i = self.rootD i ∧ self.rootD i = self.rootD x ∨
    (self.find x).1.parent i = self.parent i := parentD_findAux_or ..

@[simp] theorem find_root_1 (self : UnionFind) (x : Fin self.size) (i : Nat) :
    (self.find x).1.rootD i = self.rootD i := by
  if h : (self.find x).1.parent i = i then
    rw [rootD_eq_self.2 h]
    obtain ⟨h1, _⟩ | h1 := find_parent_or self x i <;> rw [h1] at h
    · rw [h]
    · rw [rootD_eq_self.2 h]
  else
    have := Nat.sub_lt_sub_left ((self.find x).1.lt_rankMax _) ((self.find x).1.rank_lt h)
    rw [← rootD_parent, find_root_1 self x ((self.find x).1.parent i)]
    obtain ⟨h1, _⟩ | h1 := find_parent_or self x i
    · rw [h1, rootD_rootD]
    · rw [h1, rootD_parent]
termination_by  (self.find x).1.rankMax - (self.find x).1.rank i
decreasing_by exact this -- why is this needed? It is way slower without it

/-- Link two union-find nodes -/
def linkAux (self : Array UFNode) (x y : Fin self.size) : Array UFNode :=
  if x.1 = y then
    self
  else
    let nx := self[x.1]
    let ny := self[y.1]
    if ny.rank < nx.rank then
      self.set y {ny with parent := x}
    else
      let arr₁ := self.set x {nx with parent := y}
      if nx.rank = ny.rank then
        arr₁.set y {ny with rank := ny.rank + 1} (by simp [arr₁])
      else
        arr₁

theorem setParentBump_rankD_lt {arr : Array UFNode} {x y : Fin arr.size}
    (hroot : arr[x.1].rank < arr[y.1].rank ∨ arr[y.1].parent = y)
    (H : arr[x.1].rank ≤ arr[y.1].rank) {i : Nat}
    (rankD_lt : parentD arr i ≠ i → rankD arr i < rankD arr (parentD arr i))
    (hP : parentD arr' i = if x.1 = i then y.1 else parentD arr i)
    (hR : ∀ {i}, rankD arr' i =
      if y.1 = i ∧ arr[x.1].rank = arr[y.1].rank then
        arr[y.1].rank + 1
      else rankD arr i) :
    ¬parentD arr' i = i → rankD arr' i < rankD arr' (parentD arr' i) := by
  simp only [ne_eq, hP, hR, implies_true] at *; split <;> rename_i h₁ <;> [simp [← h₁]; skip] <;>
    split <;> rename_i h₂ <;> intro h
  · simp [h₂] at h
  · simp only [rankD_eq, x.2, y.2]
    split <;> rename_i h₃
    · rw [← h₃]; apply Nat.lt_succ_self
    · exact Nat.lt_of_le_of_ne H h₃
  · cases h₂.1
    simp only [h₂.2, false_or, Nat.lt_irrefl] at hroot
    simp only [hroot, parentD_eq y.2, not_true_eq_false] at h
  · have := rankD_lt h
    split <;> rename_i h₃
    · rw [← rankD_eq, h₃.1]; exact Nat.lt_succ_of_lt this
    · exact this

theorem setParent_rankD_lt {arr : Array UFNode} {x y : Fin arr.size}
    (h : arr[x.1].rank < arr[y.1].rank) {i : Nat}
    (rankD_lt : parentD arr i ≠ i → rankD arr i < rankD arr (parentD arr i)) :
    let arr' := arr.set x ⟨y, arr[x].rank⟩
    parentD arr' i ≠ i → rankD arr' i < rankD arr' (parentD arr' i) :=
  setParentBump_rankD_lt (.inl h) (Nat.le_of_lt h) rankD_lt parentD_set
    (by simp [rankD_set, Nat.ne_of_lt h, rankD_eq])

@[simp] theorem linkAux_size : (linkAux self x y).size = self.size := by
  simp only [linkAux]
  split <;> [rfl; split] <;> [skip; split] <;> simp

/-- Link a union-find node to a root node. -/
def link (self : UnionFind) (x y : Fin self.size) (yroot : self.parent y = y) : UnionFind where
  arr := linkAux self.arr x y
  parentD_lt h := by
    simp only [linkAux_size] at *
    simp only [linkAux]
    split <;> [skip; split <;> [skip; split]]
    · exact self.parentD_lt h
    · rw [parentD_set]; split <;> [exact x.2; exact self.parentD_lt h]
    · rw [parentD_set]; split
      · exact self.parent'_lt ..
      · rw [parentD_set]; split <;> [exact y.2; exact self.parentD_lt h]
    · rw [parentD_set]; split <;> [exact y.2; exact self.parentD_lt h]
  rankD_lt := by
    rw [parent, parentD_eq] at yroot
    simp only [linkAux, ne_eq]
    split <;> [skip; split <;> [skip; split]]
    · exact self.rankD_lt
    · exact setParent_rankD_lt ‹_› self.rankD_lt
    · refine setParentBump_rankD_lt (.inr yroot) (Nat.le_of_eq ‹_›) self.rankD_lt (by
        simp only [parentD_set, ite_eq_right_iff]
        rintro rfl
        simp [*, parentD_eq]) fun {i} => ?_
      simp only [rankD_set]
      split
      · simp_all
      · simp_all only [Nat.lt_irrefl, not_false_eq_true,
          and_true, ite_false, ite_eq_right_iff]
        rintro rfl
        simp [rankD_eq, *]
    · exact setParent_rankD_lt (Nat.lt_of_le_of_ne (Nat.not_lt.1 ‹_›) ‹_›) self.rankD_lt

@[inherit_doc link]
def linkN (self : UnionFind) (x y : Fin n) (yroot : self.parent y = y) (h : n = self.size) :
    UnionFind := match n, h with | _, rfl => self.link x y yroot

/-- Link a union-find node to a root node. Panics if either index is out of bounds. -/
def link! (self : UnionFind) (x y : Nat) (yroot : self.parent y = y) : UnionFind :=
  if h : x < self.size ∧ y < self.size then
    self.link ⟨x, h.1⟩ ⟨y, h.2⟩ yroot
  else
    panicWith self "index out of bounds"

/-- Link two union-find nodes, uniting their respective classes. -/
def union (self : UnionFind) (x y : Fin self.size) : UnionFind :=
  let ⟨self₁, rx, ex⟩ := self.find x
  have hy := by rw [ex]; exact y.2
  match eq : self₁.find ⟨y, hy⟩ with
  | ⟨self₂, ry, ey⟩ =>
    self₂.link ⟨rx, by rw [ey]; exact rx.2⟩ ry <| by
      have := find_root_1 self₁ ⟨y, hy⟩ (⟨y, hy⟩ : Fin _)
      rw [← find_root_2, eq] at this; simp at this
      rw [← this, parent_rootD]

@[inherit_doc union]
def unionN (self : UnionFind) (x y : Fin n) (h : n = self.size) : UnionFind :=
  match n, h with | _, rfl => self.union x y

/-- Link two union-find nodes, uniting their respective classes.
Panics if either index is out of bounds. -/
def union! (self : UnionFind) (x y : Nat) : UnionFind :=
  if h : x < self.size ∧ y < self.size then
    self.union ⟨x, h.1⟩ ⟨y, h.2⟩
  else
    panicWith self "index out of bounds"

/-- Check whether two union-find nodes are equivalent, updating structure using path compression. -/
def checkEquiv (self : UnionFind) (x y : Fin self.size) : UnionFind × Bool :=
  let ⟨s, ⟨r₁, _⟩, h⟩ := self.find x
  let ⟨s, ⟨r₂, _⟩, _⟩ := s.find (h ▸ y)
  (s, r₁ == r₂)

@[inherit_doc checkEquiv]
def checkEquivN (self : UnionFind) (x y : Fin n) (h : n = self.size) : UnionFind × Bool :=
  match n, h with | _, rfl => self.checkEquiv x y

/-- Check whether two union-find nodes are equivalent, updating structure using path compression.
Panics if either index is out of bounds. -/
def checkEquiv! (self : UnionFind) (x y : Nat) : UnionFind × Bool :=
  if h : x < self.size ∧ y < self.size then
    self.checkEquiv ⟨x, h.1⟩ ⟨y, h.2⟩
  else
    panicWith (self, false) "index out of bounds"

/-- Check whether two union-find nodes are equivalent with path compression,
returns `x == y` if either index is out of bounds -/
def checkEquivD (self : UnionFind) (x y : Nat) : UnionFind × Bool :=
  let (s, x) := self.findD x
  let (s, y) := s.findD y
  (s, x == y)

/-- Equivalence relation from a `UnionFind` structure -/
def Equiv (self : UnionFind) (a b : Nat) : Prop := self.rootD a = self.rootD b



=== LEAN SOURCE: Lemmas.lean ===
/-
Copyright (c) 2021 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Batteries.Data.UnionFind.Basic

namespace Batteries.UnionFind

@[simp] theorem arr_empty : empty.arr = #[] := rfl
@[simp] theorem parent_empty : empty.parent a = a := rfl
@[simp] theorem rank_empty : empty.rank a = 0 := rfl
@[simp] theorem rootD_empty : empty.rootD a = a := rfl

@[simp] theorem arr_push {m : UnionFind} : m.push.arr = m.arr.push ⟨m.arr.size, 0⟩ := rfl

@[simp] theorem parentD_push {arr : Array UFNode} :
    parentD (arr.push ⟨arr.size, 0⟩) a = parentD arr a := by
  simp [parentD]; split <;> split <;> try simp [Array.getElem_push, *]
  · next h1 h2 =>
    simp [Nat.lt_succ] at h1 h2
    exact Nat.le_antisymm h2 h1
  · next h1 h2 => cases h1 (Nat.lt_succ_of_lt h2)

@[simp] theorem parent_push {m : UnionFind} : m.push.parent a = m.parent a := by simp [parent]

@[simp] theorem rankD_push {arr : Array UFNode} :
    rankD (arr.push ⟨arr.size, 0⟩) a = rankD arr a := by
  simp [rankD]; split <;> split <;> try simp [Array.getElem_push, *]
  next h1 h2 => cases h1 (Nat.lt_succ_of_lt h2)

@[simp] theorem rank_push {m : UnionFind} : m.push.rank a = m.rank a := by simp [rank]

@[simp] theorem rankMax_push {m : UnionFind} : m.push.rankMax = m.rankMax := by simp [rankMax]

@[simp] theorem root_push {self : UnionFind} : self.push.rootD x = self.rootD x :=
  rootD_ext fun _ => parent_push

@[simp] theorem arr_link : (link self x y yroot).arr = linkAux self.arr x y := rfl

theorem parentD_linkAux {self} {x y : Fin self.size} :
    parentD (linkAux self x y) i =
    if x.1 = y then
      parentD self i
    else
      if self[y.1].rank < self[x.1].rank then
        if y = i then x else parentD self i
      else
        if x = i then y else parentD self i := by
  dsimp only [linkAux]; split <;> [rfl; split] <;> [rw [parentD_set]; split] <;> rw [parentD_set]
  split <;> [(subst i; rwa [if_neg, parentD_eq]); rw [parentD_set]]

theorem parent_link {self} {x y : Fin self.size} (yroot) {i} :
    (link self x y yroot).parent i =
    if x.1 = y then
      self.parent i
    else
      if self.rank y < self.rank x then
        if y = i then x else self.parent i
      else
        if x = i then y else self.parent i := by
  simp [rankD_eq]; exact parentD_linkAux

theorem root_link {self : UnionFind} {x y : Fin self.size}
    (xroot : self.parent x = x) (yroot : self.parent y = y) :
    ∃ r, (r = x ∨ r = y) ∧ ∀ i,
      (link self x y yroot).rootD i =
      if self.rootD i = x ∨ self.rootD i = y then r.1 else self.rootD i := by
  if h : x.1 = y then
    refine ⟨x, .inl rfl, fun i => ?_⟩
    rw [rootD_ext (m2 := self) (fun _ => by rw [parent_link, if_pos h])]
    split <;> [obtain _ | _ := ‹_› <;> simp [*]; rfl]
  else
  have {x y : Fin self.size}
      (xroot : self.parent x = x) (yroot : self.parent y = y) {m : UnionFind}
      (hm : ∀ i, m.parent i = if y = i then x.1 else self.parent i) :
      ∃ r, (r = x ∨ r = y) ∧ ∀ i,
        m.rootD i = if self.rootD i = x ∨ self.rootD i = y then r.1 else self.rootD i := by
    let rec go (i) :
        m.rootD i = if self.rootD i = x ∨ self.rootD i = y then x.1 else self.rootD i := by
      if h : m.parent i = i then
        rw [rootD_eq_self.2 h]; rw [hm i] at h; split at h
        · rw [if_pos, h]; simp [← h, rootD_eq_self, xroot]
        · rw [rootD_eq_self.2 ‹_›]; split <;> [skip; rfl]
          next h' => exact h'.resolve_right (Ne.symm ‹_›)
      else
        have _ := Nat.sub_lt_sub_left (m.lt_rankMax i) (m.rank_lt h)
        rw [← rootD_parent, go (m.parent i)]
        rw [hm i]; split <;> [subst i; rw [rootD_parent]]
        simp [rootD_eq_self.2 xroot, rootD_eq_self.2 yroot]
    termination_by m.rankMax - m.rank i
    exact ⟨x, .inl rfl, go⟩
  if hr : self.rank y < self.rank x then
    exact this xroot yroot fun i => by simp [parent_link, h, hr]
  else
    simpa (config := {singlePass := true}) [or_comm] using
      this yroot xroot fun i => by simp [parent_link, h, hr]

nonrec theorem Equiv.rfl : Equiv self a a := rfl
nonrec theorem Equiv.symm : Equiv self a b → Equiv self b a := .symm
nonrec theorem Equiv.trans : Equiv self a b → Equiv self b c → Equiv self a c := .trans

@[simp] theorem equiv_empty : Equiv empty a b ↔ a = b := by simp [Equiv]

@[simp] theorem equiv_push : Equiv self.push a b ↔ Equiv self a b := by simp [Equiv]

@[simp] theorem equiv_rootD : Equiv self (self.rootD a) a := by simp [Equiv, rootD_rootD]
@[simp] theorem equiv_rootD_l : Equiv self (self.rootD a) b ↔ Equiv self a b := by
  simp [Equiv, rootD_rootD]
@[simp] theorem equiv_rootD_r : Equiv self a (self.rootD b) ↔ Equiv self a b := by
  simp [Equiv, rootD_rootD]

theorem equiv_find : Equiv (self.find x).1 a b ↔ Equiv self a b := by simp [Equiv, find_root_1]

theorem equiv_link {self : UnionFind} {x y : Fin self.size}
    (xroot : self.parent x = x) (yroot : self.parent y = y) :
    Equiv (link self x y yroot) a b ↔
    Equiv self a b ∨ Equiv self a x ∧ Equiv self y b ∨ Equiv self a y ∧ Equiv self x b := by
  have {m : UnionFind} {x y : Fin self.size}
      (xroot : self.rootD x = x) (yroot : self.rootD y = y)
      (hm : ∀ i, m.rootD i = if self.rootD i = x ∨ self.rootD i = y then x.1 else self.rootD i) :
      Equiv m a b ↔
      Equiv self a b ∨ Equiv self a x ∧ Equiv self y b ∨ Equiv self a y ∧ Equiv self x b := by
    simp [Equiv, hm, xroot, yroot]
    by_cases h1 : rootD self a = x <;> by_cases h2 : rootD self b = x <;>
      simp [h1, h2, imp_false, Decidable.not_not, -left_eq_ite_iff]
    · simp [Ne.symm h2, -left_eq_ite_iff]; split <;> simp [@eq_comm _ _ (rootD self b), *]
    · by_cases h1 : rootD self a = y <;> by_cases h2 : rootD self b = y <;>
        simp [@eq_comm _ _ (rootD self b), *]
  obtain ⟨r, ha, hr⟩ := root_link xroot yroot; revert hr
  rw [← rootD_eq_self] at xroot yroot
  obtain rfl | rfl := ha
  · exact this xroot yroot
  · simpa [or_comm, and_comm] using this yroot xroot

theorem equiv_union {self : UnionFind} {x y : Fin self.size} :
    Equiv (union self x y) a b ↔
    Equiv self a b ∨ Equiv self a x ∧ Equiv self y b ∨ Equiv self a y ∧ Equiv self x b := by
  simp [union]; rw [equiv_link (by simp [← rootD_eq_self, rootD_rootD])]; simp [equiv_find]



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2024 Shreyas Srinivas. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Shreyas Srinivas, François G. Dorais
-/


/-!
# Vectors

`Vector α n` is a thin wrapper around `Array α` for arrays of fixed size `n`.
-/

namespace Vector

/--
Returns `true` when all elements of the vector are pairwise distinct using `==` for comparison.
-/
@[inline] def allDiff [BEq α] (as : Vector α n) : Bool :=
  as.toArray.allDiff



=== LEAN SOURCE: Lemmas.lean ===
/-
Copyright (c) 2024 Shreyas Srinivas. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Shreyas Srinivas, François G. Dorais, Eric Wieser
-/


namespace Vector

theorem toArray_injective : ∀ {v w : Vector α n}, v.toArray = w.toArray → v = w
  | {..}, {..}, rfl => rfl


/-! ### mk lemmas -/

@[simp] theorem get_mk (a : Array α) (h : a.size = n) (i) :
    (Vector.mk a h).get i = a[i] := rfl

@[simp] theorem getD_mk (a : Array α) (h : a.size = n) (i x) :
    (Vector.mk a h).getD i x = a.getD i x := rfl

@[simp] theorem uget_mk (a : Array α) (h : a.size = n) (i) (hi : i.toNat < n) :
    (Vector.mk a h).uget i hi = a.uget i (by simp [h, hi]) := rfl

/-! ### tail lemmas -/

theorem tail_eq_of_zero {v : Vector α 0} : v.tail = #v[] := Vector.eq_empty

theorem tail_eq_of_ne_zero [NeZero n] {v : Vector α n} :
    v.tail = v.eraseIdx 0 n.pos_of_neZero := by
  simp only [tail_eq_cast_extract]
  ext
  simp only [getElem_cast, getElem_extract, getElem_eraseIdx, Nat.not_lt_zero, ↓reduceDIte]
  congr 1
  omega

-- This is not a `@[simp]` lemma because the LHS simplifies to `Vector.extract`.
theorem toList_tail {v : Vector α n} :
    v.tail.toList = v.toList.tail :=
  match n with
  | 0 => by simp [Vector.eq_empty]
  | _ + 1 => by
    apply List.ext_getElem
    · simp
    · intro i h₁ h₂
      simp only [Nat.add_one_sub_one, tail_eq_cast_extract, getElem_toList, getElem_cast,
        getElem_extract, List.getElem_tail]
      congr 1
      omega

/-! ### getElem lemmas -/

theorem getElem_tail {v : Vector α n} {i : Nat} (hi : i < n - 1) :
    v.tail[i] = v[i + 1] :=
  match n with
  | _ + 1 =>
    getElem_congr_coll tail_eq_of_ne_zero |>.trans <|
    getElem_eraseIdx (Nat.zero_lt_succ _) hi

/-! ### get lemmas -/

theorem get_eq_getElem (v : Vector α n) (i : Fin n) : v.get i = v[(i : Nat)] := rfl

@[simp] theorem get_push_last (v : Vector α n) (a : α) :
    (v.push a).get (Fin.last n) = a :=
  getElem_push_last

@[simp] theorem get_push_castSucc (v : Vector α n) (a : α) (i : Fin n) :
    (v.push a).get (Fin.castSucc i) = v.get i :=
  getElem_push_lt _

@[simp] theorem get_map (v : Vector α n) (f : α → β) (i : Fin n) :
    (v.map f).get i = f (v.get i) :=
  getElem_map _ _

@[simp] theorem get_reverse (v : Vector α n) (i : Fin n) :
    v.reverse.get i = v.get (i.rev) :=
  getElem_reverse _ |>.trans <| congrArg v.get <| Fin.ext <| by simp; omega

@[simp] theorem get_replicate (n : Nat) (a : α) (i : Fin n) : (replicate n a).get i = a :=
  getElem_replicate _

@[simp] theorem get_range (n : Nat) (i : Fin n) : (range n).get i = i :=
  getElem_range _

@[simp] theorem get_ofFn (f : Fin n → α) (i : Fin n) : (ofFn f).get i = f i :=
  getElem_ofFn _

@[simp] theorem get_cast (v : Vector α m) (h : m = n) (i : Fin n) :
    (v.cast h).get i = v.get (i.cast h.symm) :=
  getElem_cast _

-- This is not a `@[simp]` lemma because the LHS simplifies to `Vector.extract`.
theorem get_tail (v : Vector α (n + 1)) (i : Fin n) :
    v.tail.get i = v.get i.succ := getElem_tail _

/-! ### finIdxOf? lemmas -/

@[simp]
theorem finIdxOf?_empty [BEq α] (v : Vector α 0) : v.finIdxOf? a = none := by
  simp [v.eq_empty]

@[simp]
theorem finIdxOf?_eq_none_iff [BEq α] [LawfulBEq α] {v : Vector α n} {a : α} :
    v.finIdxOf? a = none ↔ a ∉ v := by
  obtain ⟨xs, rfl⟩ := v
  simp

@[simp]
theorem finIdxOf?_eq_some_iff [BEq α] [LawfulBEq α] {v : Vector α n} {a : α} {i : Fin n} :
    v.finIdxOf? a = some i ↔ v.get i = a ∧ ∀ j < i, ¬v.get j = a := by
  obtain ⟨xs, rfl⟩ := v
  simp

@[simp]
theorem isSome_finIdxOf? [BEq α] [PartialEquivBEq α] {v : Vector α n} {a : α} :
    (v.finIdxOf? a).isSome = v.contains a := by
  obtain ⟨v, rfl⟩ := v
  simp

@[simp]
theorem isNone_finIdxOf? [BEq α] [PartialEquivBEq α] {v : Vector α n} {a : α} :
    (v.finIdxOf? a).isNone = !v.contains a := by
  obtain ⟨v, rfl⟩ := v
  simp



=== LEAN SOURCE: Monadic.lean ===
/-
Copyright (c) 2025 Lean FRO, LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Batteries.Classes.SatisfiesM
import Batteries.Data.Array.Monadic

namespace Vector

theorem mapM_mk [Monad m] [LawfulMonad m] [MonadSatisfying m]
    (a : Array α) (h : a.size = n) (f : α → m β) :
    (Vector.mk a h).mapM f =
      (fun ⟨a, h'⟩ => Vector.mk a (h'.trans h)) <$> satisfying (Array.size_mapM f a) := by
  rw [← _root_.map_inj_right Vector.toArray_inj.mp]
  simp only [Functor.map_map, MonadSatisfying.val_eq, toArray_mapM]

theorem mapIdxM_mk [Monad m] [LawfulMonad m] [MonadSatisfying m]
    (a : Array α) (h : a.size = n) (f : Nat → α → m β) :
    (Vector.mk a h).mapIdxM f =
      (fun ⟨a, h'⟩ => Vector.mk a (h'.trans h)) <$> satisfying (Array.size_mapIdxM a f) := by
  rw [← _root_.map_inj_right Vector.toArray_inj.mp]
  simp only [Functor.map_map, MonadSatisfying.val_eq, toArray_mapIdxM]

theorem mapFinIdxM_mk [Monad m] [LawfulMonad m] [MonadSatisfying m]
    (a : Array α) (h : a.size = n) (f : (i : Nat) → α → (h : i < n) → m β) :
    (Vector.mk a h).mapFinIdxM f =
      (fun ⟨a, h'⟩ => Vector.mk a (h'.trans h)) <$> satisfying
        (Array.size_mapFinIdxM a (fun i a h' => f i a (h ▸ h'))) := by
  rw [← _root_.map_inj_right Vector.toArray_inj.mp]
  simp only [Functor.map_map, MonadSatisfying.val_eq, toArray_mapFinIdxM]



=== LEAN SOURCE: AttributeExtra.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Batteries.Lean.TagAttribute
import Std.Data.HashMap.Basic

open Lean

namespace Lean

open Std

/--
`TagAttributeExtra` works around a limitation of `TagAttribute`, which is that definitions
must be tagged in the same file that declares the definition.
This works well for definitions in lean core, but for attributes declared outside the core
this is problematic because we may want to tag declarations created before the attribute
was defined.

To resolve this, we allow a one-time exception to the rule that attributes must be applied
in the same file as the declaration: During the declaration of the attribute itself,
we can tag arbitrary other definitions, but once the attribute is declared we must tag things
in the same file as normal.
-/
structure TagAttributeExtra where
  /-- The environment extension for the attribute. -/
  ext : PersistentEnvExtension Name Name NameSet
  /-- A list of "base" declarations which have been pre-tagged. -/
  base : NameHashSet
  deriving Inhabited

/--
Registers a new tag attribute. The `extra` field is a list of definitions from other modules
which will be "pre-tagged" and are not subject to the usual restriction on tagging in the same
file as the declaration.

Note: The `extra` fields bypass the `validate` function -
we assume the builtins are also pre-validated.
-/
def registerTagAttributeExtra (name : Name) (descr : String) (extra : List Name)
    (validate : Name → AttrM Unit := fun _ => pure ()) (ref : Name := by exact decl_name%) :
    IO TagAttributeExtra := do
  let { ext, .. } ← registerTagAttribute name descr validate ref
  pure { ext, base := extra.foldl (·.insert ·) {} }

namespace TagAttributeExtra

/-- Does declaration `decl` have the tag `attr`? -/
def hasTag (attr : TagAttributeExtra) (env : Environment) (decl : Name) : Bool :=
  match env.getModuleIdxFor? decl with
  | some modIdx => (attr.ext.getModuleEntries env modIdx).binSearchContains decl Name.quickLt
  | none        => (attr.ext.getState env).contains decl
  || attr.base.contains decl

/-- Get the list of declarations tagged with the tag attribute `attr`. -/
def getDecls (attr : TagAttributeExtra) (env : Environment) : Array Name := Id.run do
  let decls := TagAttribute.getDecls.core <| attr.ext.toEnvExtension.getState env
  attr.base.fold (·.push ·) decls

end TagAttributeExtra

/--
`ParametricAttributeExtra` works around a limitation of `ParametricAttribute`, which is that
definitions must be tagged in the same file that declares the definition.
This works well for definitions in lean core, but for attributes declared outside the core
this is problematic because we may want to tag declarations created before the attribute
was defined.

To resolve this, we allow a one-time exception to the rule that attributes must be applied
in the same file as the declaration: During the declaration of the attribute itself,
we can tag arbitrary other definitions, but once the attribute is declared we must tag things
in the same file as normal.
-/
structure ParametricAttributeExtra (α : Type) where
  /-- The underlying `ParametricAttribute`. -/
  attr : ParametricAttribute α
  /-- A list of pre-tagged declarations with their values. -/
  base : Std.HashMap Name α
  deriving Inhabited

/--
Registers a new parametric attribute. The `extra` field is a list of definitions from other modules
which will be "pre-tagged" and are not subject to the usual restriction on tagging in the same
file as the declaration.
-/
def registerParametricAttributeExtra (impl : ParametricAttributeImpl α)
    (extra : List (Name × α)) : IO (ParametricAttributeExtra α) := do
  let attr ← registerParametricAttribute impl
  pure { attr, base := extra.foldl (fun s (a, b) => s.insert a b) {} }

namespace ParametricAttributeExtra

/--
Gets the parameter of attribute `attr` associated to declaration `decl`,
or `none` if `decl` is not tagged.
-/
def getParam? [Inhabited α] (attr : ParametricAttributeExtra α)
    (env : Environment) (decl : Name) : Option α :=
  attr.attr.getParam? env decl <|> attr.base[decl]?

/-- Applies attribute `attr` to declaration `decl`, given a value for the parameter. -/
def setParam (attr : ParametricAttributeExtra α)
    (env : Environment) (decl : Name) (param : α) : Except String Environment :=
  attr.attr.setParam env decl param

end ParametricAttributeExtra



/-
Copyright (c) 2024 Lean FRO, LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/

namespace EStateM

open Backtrackable

namespace Result

/-- Map a function over an `EStateM.Result`, preserving states and errors. -/
def map {ε σ α β} (f : α → β) (x : Result ε σ α) : Result ε σ β :=
  match x with
  | .ok a s' => .ok (f a) s'
  | .error e s' => .error e s'

@[simp] theorem map_ok {ε σ α β} (f : α → β) (a : α) (s : σ) :
    (Result.ok a s : Result ε σ α).map f = .ok (f a) s := rfl

@[simp] theorem map_error {ε σ α β} (f : α → β) (e : ε) (s : σ) :
    (Result.error e s : Result ε σ α).map f = .error e s := rfl

@[simp] theorem map_eq_ok {ε σ α β} {f : α → β} {x : Result ε σ α} {b : β} {s : σ} :
    x.map f = .ok b s ↔ ∃ a, x = .ok a s ∧ b = f a := by
  cases x <;> simp [and_assoc, and_comm, eq_comm]

@[simp] theorem map_eq_error {ε σ α β} (f : α → β) {x : Result ε σ α} {e : ε} {s : σ} :
    x.map f = .error e s ↔ x = .error e s := by
  cases x <;> simp [eq_comm]

end Result

@[simp] theorem dummySave_apply (s : σ) : EStateM.dummySave s = PUnit.unit := rfl

@[simp] theorem dummyRestore_apply (s : σ) : EStateM.dummyRestore s = Function.const _ s := rfl

@[simp] theorem run_pure (x : α) (s : σ) :
    (pure x : EStateM ε σ α).run s = Result.ok x s := rfl

@[simp] theorem run'_pure (x : α) (s : σ) :
    (pure x : EStateM ε σ α).run' s = some x := rfl

@[simp] theorem run_bind (x : EStateM ε σ α) (f : α → EStateM ε σ β) (s : σ) :
    (x >>= f).run s = match x.run s with
    | .ok a s => (f a).run s
    | .error e s => .error e s := rfl

@[simp] theorem run'_bind (x : EStateM ε σ α) (f : α → EStateM ε σ β) (s : σ) :
    (x >>= f).run' s = match x.run s with
    | .ok a s => (f a).run' s
    | .error _ _ => none := by
  rw [run', run_bind]
  cases x.run s <;> rfl

@[simp] theorem run_map (f : α → β) (x : EStateM ε σ α) (s : σ) :
    (f <$> x).run s = (x.run s).map f := rfl

@[simp] theorem run'_map (f : α → β) (x : EStateM ε σ α) (s : σ) :
    (f <$> x).run' s = Option.map f (x.run' s) := by
  rw [run', run', run_map]
  cases x.run s <;> rfl

theorem run_seq (f : EStateM ε σ (α → β)) (x : EStateM ε σ α) (s : σ) :
    (f <*> x).run s = match f.run s with
    | .ok g s => Result.map g (x.run s)
    | .error e s => .error e s := by
  simp only [seq_eq_bind, run_bind, run_map]
  cases f.run s <;> rfl

theorem run'_seq (f : EStateM ε σ (α → β)) (x : EStateM ε σ α) (s : σ) :
    (f <*> x).run' s = match f.run s with
    | .ok g s => Option.map g (x.run' s)
    | .error _ _ => none := by
  simp only [seq_eq_bind, run'_bind, run'_map]
  cases f.run s <;> rfl

@[simp] theorem run_seqLeft (x : EStateM ε σ α) (y : EStateM ε σ β) (s : σ) :
    (x <* y).run s = match x.run s with
    | .ok v s => Result.map (fun _ => v) (y.run s)
    | .error e s => .error e s := by
  simp [seqLeft_eq_bind]

@[simp] theorem run'_seqLeft (x : EStateM ε σ α) (y : EStateM ε σ β) (s : σ) :
    (x <* y).run' s = match x.run s with
    | .ok v s => Option.map (fun _ => v) (y.run' s)
    | .error _ _ => none := by
  simp [seqLeft_eq_bind]

@[simp] theorem run_seqRight (x : EStateM ε σ α) (y : EStateM ε σ β) (s : σ) :
    (x *> y).run s = match x.run s with
    | .ok _ s => y.run s
    | .error e s => .error e s := rfl

@[simp] theorem run'_seqRight (x : EStateM ε σ α) (y : EStateM ε σ β) (s : σ) :
    (x *> y).run' s = match x.run s with
    | .ok _ s => y.run' s
    | .error _ _ => none := by
  rw [run', run_seqRight]
  cases x.run s <;> rfl

@[simp] theorem run_get (s : σ) :
    (get : EStateM ε σ σ).run s = Result.ok s s := rfl

@[simp] theorem run'_get (s : σ) :
    (get : EStateM ε σ σ).run' s = some s := rfl

@[simp] theorem run_set (v s : σ) :
    (set v : EStateM ε σ PUnit).run s = Result.ok PUnit.unit v := rfl

@[simp] theorem run'_set (v s : σ) :
    (set v : EStateM ε σ PUnit).run' s = some PUnit.unit := rfl

@[simp] theorem run_modify (f : σ → σ) (s : σ) :
    (modify f : EStateM ε σ PUnit).run s = Result.ok PUnit.unit (f s) := rfl

@[simp] theorem run'_modify (f : σ → σ) (s : σ) :
    (modify f : EStateM ε σ PUnit).run' s = some PUnit.unit := rfl

@[simp] theorem run_modifyGet (f : σ → α × σ) (s : σ) :
    (modifyGet f : EStateM ε σ α).run s = Result.ok (f s).1 (f s).2 := rfl

@[simp] theorem run'_modifyGet (f : σ → α × σ) (s : σ) :
    (modifyGet f : EStateM ε σ α).run' s = some (f s).1 := rfl

@[simp] theorem run_getModify (f : σ → σ) :
    (getModify f : EStateM ε σ σ).run s = Result.ok s (f s) := rfl

@[simp] theorem run'_getModify (f : σ → σ) (s : σ) :
    (getModify f : EStateM ε σ σ).run' s = some s := rfl

@[simp] theorem run_throw (e : ε) (s : σ) :
    (throw e : EStateM ε σ α).run s = Result.error e s := rfl

@[simp] theorem run'_throw (e : ε) (s : σ) :
    (throw e : EStateM ε σ α).run' s = none := rfl

@[simp] theorem run_orElse {δ} [h : Backtrackable δ σ] (x₁ x₂ : EStateM ε σ α) (s : σ) :
    (x₁ <|> x₂).run s = match x₁.run s with
    | .ok x s => .ok x s
    | .error _ s' => x₂.run (restore s' (save s)) := by
  show (EStateM.orElse _ _).run _ = _
  unfold EStateM.orElse
  simp only [EStateM.run]
  match x₁ s with | .ok _ _ => rfl | .error _ _ => simp

@[simp] theorem run'_orElse {δ} [h : Backtrackable δ σ] (x₁ x₂ : EStateM ε σ α) (s : σ) :
    (x₁ <|> x₂).run' s = match x₁.run s with
    | .ok x _ => some x
    | .error _ s' => x₂.run' (restore s' (save s)) := by
  rw [run', run_orElse]
  cases x₁.run s <;> rfl

@[simp] theorem run_tryCatch {δ} [h : Backtrackable δ σ]
    (body : EStateM ε σ α) (handler : ε → EStateM ε σ α) (s : σ) :
    (tryCatch body handler).run s = match body.run s with
    | .ok x s => .ok x s
    | .error e s' => (handler e).run (restore s' (save s)) := by
  show (EStateM.tryCatch _ _).run _ = _
  unfold EStateM.tryCatch
  simp only [EStateM.run]
  cases body s <;> rfl

@[simp] theorem run'_tryCatch {δ} [h : Backtrackable δ σ]
    (body : EStateM ε σ α) (handler : ε → EStateM ε σ α) (s : σ) :
    (tryCatch body handler).run' s = match body.run s with
    | .ok x _ => some x
    | .error e s' => (handler e).run' (restore s' (save s)) := by
  rw [run', run_tryCatch]
  cases body.run s <;> rfl

@[simp] theorem run_adaptExcept (f : ε → ε) (x : EStateM ε σ α) (s : σ) :
    (adaptExcept f x).run s = match x.run s with
    | .ok x s => .ok x s
    | .error e s => .error (f e) s := by
  show (EStateM.adaptExcept _ _).run _ = _
  unfold EStateM.adaptExcept
  simp only [EStateM.run]
  cases x s <;> rfl

@[simp] theorem run'_adaptExcept (f : ε → ε) (x : EStateM ε σ α) (s : σ) :
    (adaptExcept f x).run' s = x.run' s := by
  rw [run', run', run_adaptExcept]
  cases x.run s <;> rfl

@[simp] theorem run_tryFinally' (x : EStateM ε σ α)
    (h : Option α → EStateM ε σ β) (s : σ) : (tryFinally' x h).run s = match x.run s with
    | .ok a s => match (h (some a)).run s with
      | .ok b s => Result.ok (a, b) s
      | .error e s => Result.error e s
    | .error e₁ s => match (h none).run s with
      | .ok _ s => Result.error e₁ s
      | .error e₂ s => Result.error e₂ s := rfl

@[simp] theorem run'_tryFinally' (x : EStateM ε σ α)
    (h : Option α → EStateM ε σ β) (s : σ) :
    (tryFinally' x h).run' s = match x.run s with
    | .ok a s => Option.map (a, ·) ((h (some a)).run' s)
    | .error _ _ => none := by
  simp [run', run_tryFinally']
  match x.run s with
  | .ok a s => simp only; cases (h (some a)).run s <;> rfl
  | .error e s => simp only; cases (h none).run s <;> rfl

@[simp] theorem run_fromStateM (x : StateM σ α) (s : σ) :
    (fromStateM x : EStateM ε σ α).run s =
    Result.ok (x.run s).1 (x.run s).2 := rfl

@[simp] theorem run'_fromStateM (x : StateM σ α) (s : σ) :
    (fromStateM x : EStateM ε σ α).run' s = some (x.run' s) := rfl

@[ext] theorem ext {ε σ α} {x y : EStateM ε σ α} (h : ∀ s, x.run s = y.run s) : x = y := by
  funext s
  exact h s

end EStateM



=== LEAN SOURCE: Except.lean ===
/-
Copyright (c) 2023 Lean FRO, LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Lean.Util.Trace

open Lean

namespace Except

/-- Visualize an `Except` using a checkmark or a cross. -/
def emoji : Except ε α → String
  | .error _ => crossEmoji
  | .ok _ => checkEmoji

@[simp] theorem map_error {ε : Type u} (f : α → β) (e : ε) :
    f <$> (.error e : Except ε α) = .error e := rfl

@[simp] theorem map_ok {ε : Type u} (f : α → β) (x : α) :
    f <$> (.ok x : Except ε α) = .ok (f x) := rfl

/-- Map a function over an `Except` value, using a proof that the value is `.ok`. -/
def pmap {ε : Type u} {α β : Type v} (x : Except ε α) (f : (a : α) → x = .ok a → β) : Except ε β :=
  match x with
  | .error e => .error e
  | .ok a => .ok (f a rfl)

@[simp] theorem pmap_error {ε : Type u} {α β : Type v} (e : ε)
    (f : (a : α) → Except.error e = Except.ok a → β) :
    Except.pmap (.error e) f = .error e := rfl

@[simp] theorem pmap_ok {ε : Type u} {α β : Type v} (a : α)
    (f : (a' : α) → (.ok a : Except ε α) = .ok a' → β) :
    Except.pmap (.ok a) f = .ok (f a rfl) := rfl

@[simp] theorem pmap_id {ε : Type u} {α : Type v} (x : Except ε α) :
    x.pmap (fun a _ => a) = x := by cases x <;> simp

@[simp] theorem map_pmap (g : β → γ) (x : Except ε α) (f : (a : α) → x = .ok a → β) :
    g <$> x.pmap f = x.pmap fun a h => g (f a h) := by
  cases x <;> simp

end Except

namespace ExceptT

-- This will be redundant after nightly-2024-11-08.
attribute [ext] ExceptT.ext

@[simp] theorem run_mk {m : Type u → Type v} (x : m (Except ε α)) : (ExceptT.mk x).run = x := rfl
@[simp] theorem mk_run (x : ExceptT ε m α) : ExceptT.mk (ExceptT.run x) = x := rfl

@[simp]
theorem map_mk [Monad m] [LawfulMonad m] (f : α → β) (x : m (Except ε α)) :
    f <$> ExceptT.mk x = ExceptT.mk ((f <$> · ) <$> x) := by
  simp only [Functor.map, Except.map, ExceptT.map, map_eq_pure_bind]
  congr
  funext a
  split <;> simp

end ExceptT



=== LEAN SOURCE: Expr.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Lean.Elab.Term

/-!
# Additional operations on Expr and related types

This file defines basic operations on the types expr, name, declaration, level, environment.

This file is mostly for non-tactics.
-/

namespace Lean.Expr

open Lean.Elab.Term in
/-- Converts an `Expr` into a `Syntax`, by creating a fresh metavariable
assigned to the expr and  returning a named metavariable syntax `?a`. -/
def toSyntax (e : Expr) : TermElabM Syntax.Term := withFreshMacroScope do
  let stx ← `(?a)
  let mvar ← elabTermEnsuringType stx (← Meta.inferType e)
  mvar.mvarId!.assign e
  pure stx

/-- Like `withApp` but ignores metadata. -/
@[inline]
def withApp' (e : Expr) (k : Expr → Array Expr → α) : α :=
  let dummy := mkSort levelZero
  let nargs := e.getAppNumArgs'
  go e (.replicate nargs dummy) (nargs - 1)
where
  /-- Auxiliary definition for `withApp'`. -/
  @[specialize]
  go : Expr → Array Expr → Nat → α
    | mdata _ b, as, i => go b as i
    | app f a  , as, i => go f (as.set! i a) (i-1)
    | f        , as, _ => k f as

/-- Like `getAppArgs` but ignores metadata. -/
@[inline]
def getAppArgs' (e : Expr) : Array Expr :=
  e.withApp' λ _ as => as

/-- Like `traverseApp` but ignores metadata. -/
def traverseApp' {m} [Monad m]
  (f : Expr → m Expr) (e : Expr) : m Expr :=
  e.withApp' λ fn args => return mkAppN (← f fn) (← args.mapM f)

/-- Like `withAppRev` but ignores metadata. -/
@[inline]
def withAppRev' (e : Expr) (k : Expr → Array Expr → α) : α :=
  go e (Array.mkEmpty e.getAppNumArgs')
where
  /-- Auxiliary definition for `withAppRev'`. -/
  @[specialize]
  go : Expr → Array Expr → α
    | mdata _ b, as => go b as
    | app f a  , as => go f (as.push a)
    | f        , as => k f as

/-- Like `getAppRevArgs` but ignores metadata. -/
@[inline]
def getAppRevArgs' (e : Expr) : Array Expr :=
  e.withAppRev' λ _ as => as

/-- Like `getRevArgD` but ignores metadata. -/
def getRevArgD' : Expr → Nat → Expr → Expr
  | mdata _ b, n  , v => getRevArgD' b n v
  | app _ a  , 0  , _ => a
  | app f _  , i+1, v => getRevArgD' f i v
  | _        , _  , v => v

/-- Like `getArgD` but ignores metadata. -/
@[inline]
def getArgD' (e : Expr) (i : Nat) (v₀ : Expr) (n := e.getAppNumArgs') : Expr :=
  getRevArgD' e (n - i - 1) v₀

/-- Like `isAppOf` but ignores metadata. -/
def isAppOf' (e : Expr) (n : Name) : Bool :=
  match e.getAppFn' with
  | const c .. => c == n
  | _ => false

/-- Turns an expression that is a natural number literal into a natural number. -/
def natLit! : Expr → Nat
  | lit (Literal.natVal v) => v
  | _                      => panic! "nat literal expected"

/-- Turns an expression that is a constructor of `Int` applied to a natural number literal
into an integer. -/
def intLit! (e : Expr) : Int :=
  if e.isAppOfArity ``Int.ofNat 1 then
    e.appArg!.natLit!
  else if e.isAppOfArity ``Int.negOfNat 1 then
    .negOfNat e.appArg!.natLit!
  else
    panic! "not a raw integer literal"



=== LEAN SOURCE: Float.lean ===
/-
 Copyright (c) 2023 Mario Carneiro. All rights reserved.
 Released under Apache 2.0 license as described in the file LICENSE.
 Authors: Mario Carneiro
-/

namespace Float

/--
The floating point value "positive infinity", also used to represent numerical computations
which produce finite values outside of the representable range of `Float`.
-/
def inf : Float := 1/0

/--
The floating point value "not a number", used to represent erroneous numerical computations
such as `0 / 0`. Using `nan` in any float operation will return `nan`, and all comparisons
involving `nan` return `false`, including in particular `nan == nan`.
-/
def nan : Float := 0/0

/-- Returns `v, exp` integers such that `f = v * 2^exp`.
(`e` is not minimal, but `v.abs` will be at most `2^53 - 1`.)
Returns `none` when `f` is not finite (i.e. `inf`, `-inf` or a `nan`). -/
def toRatParts (f : Float) : Option (Int × Int) :=
  if f.isFinite then
    let (f', exp) := f.frExp
    let x := (2^53:Nat).toFloat * f'
    let v := if x < 0 then
      (-(-x).floor.toUInt64.toNat : Int)
    else
      (x.floor.toUInt64.toNat : Int)
    some (v, exp - 53)
  else none

/-- Returns `v, exp` integers such that `f = v * 2^exp`.
Like `toRatParts`, but `e` is guaranteed to be minimal (`n` is always odd), unless `n = 0`.
`n.abs` will be at most `2^53 - 1` because `Float` has 53 bits of precision.
Returns `none` when `f` is not finite (i.e. `inf`, `-inf` or a `nan`). -/
partial def toRatParts' (f : Float) : Option (Int × Int) :=
  f.toRatParts.map fun (n, e) =>
    if n == 0 then (0, 0) else
      let neg : Bool := n < 0
      let v := n.natAbs.toUInt64
      let c := trailingZeros v 0
      let v := (v >>> c.toUInt64).toNat
      (if neg then -v else v, e + c.toNat)
where
  /-- Calculates the number of trailing bits in a `UInt64`. Requires `v ≠ 0`. -/
  -- Note: it's a bit dumb to be using a loop here, but it is hopefully written
  -- such that LLVM can tell we are computing trailing bits and do good things to it
  -- TODO: prove termination under suitable assumptions (only relevant if `Float` is not opaque)
  trailingZeros (v : UInt64) (c : UInt8) :=
    if v &&& 1 == 0 then trailingZeros (v >>> 1) (c + 1) else c

/-- Converts `f` to a string, including all decimal digits. -/
def toStringFull (f : Float) : String :=
  if let some (v, exp) := toRatParts f then
    let v' := v.natAbs
    let s := if exp ≥ 0 then
      Nat.repr (v' * (2^exp.toNat:Nat))
    else
      let e := (-exp).toNat
      let intPart := v' / 2^e
      let rem := v' % 2^e
      if rem == 0 then
        Nat.repr intPart
      else
        let rem := Nat.repr ((2^e + v' % 2^e) * 5^e)
        let rem := rem.dropRightWhile (· == '0')
        s!"{intPart}.{rem.extract ⟨1⟩ rem.endPos}"
    if v < 0 then s!"-{s}" else s
  else f.toString -- inf, -inf, nan

end Float

/--
Divide two natural numbers, to produce a correctly rounded (nearest-ties-to-even) `Float` result.
-/
protected def Nat.divFloat (a b : Nat) : Float :=
  if b = 0 then
    if a = 0 then Float.nan else Float.inf
  else
    let ea := a.log2
    let eb := b.log2
    if eb + 1024 < ea then Float.inf else
    let eb' := if b <<< ea ≤ a <<< eb then eb else eb + 1
    let mantissa : UInt64 := (a <<< (eb' + 53) / b <<< ea).toUInt64
    let rounded := if mantissa &&& 3 == 1 && a <<< (eb' + 53) == mantissa.toNat * (b <<< ea) then
      mantissa >>> 1
    else
      (mantissa + 1) >>> 1
    rounded.toFloat.scaleB (ea - (eb' + 52))

/--
Divide two integers, to produce a correctly rounded (nearest-ties-to-even) `Float` result.
-/
protected def Int.divFloat (a b : Int) : Float :=
  if (a ≥ 0) == (b ≥ 0) then
    a.natAbs.divFloat b.natAbs
  else
    -a.natAbs.divFloat b.natAbs



=== LEAN SOURCE: HashMap.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Std.Data.HashMap.Basic
namespace Std.HashMap

variable [BEq α] [Hashable α]

/--
`O(|other|)` amortized. Merge two `HashMap`s.
The values of keys which appear in both maps are combined using the monadic function `f`.
-/
@[specialize]
def mergeWithM {m α β} [BEq α] [Hashable α] [Monad m] (f : α → β → β → m β)
    (self other : HashMap α β) : m (HashMap α β) :=
  other.foldM (init := self) fun map k v₂ =>
    match map[k]? with
    | none => return map.insert k v₂
    | some v₁ => return map.insert k (← f k v₁ v₂)

/--
`O(|other|)` amortized. Merge two `HashMap`s.
The values of keys which appear in both maps are combined using `f`.
-/
@[inline]
def mergeWith (f : α → β → β → β) (self other : HashMap α β) : HashMap α β :=
  -- Implementing this function directly, rather than via `mergeWithM`, gives
  -- us less constrained universes.
  other.fold (init := self) fun map k v₂ =>
    match map[k]? with
    | none => map.insert k v₂
    | some v₁ => map.insert k <| f k v₁ v₂



=== LEAN SOURCE: HashSet.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Std.Data.HashSet.Basic

namespace Std.HashSet

variable [BEq α] [Hashable α]

/--
`O(n)`. Returns `true` if `f` returns `true` for any element of the set.
-/
@[specialize]
def anyM [Monad m] (s : HashSet α) (f : α → m Bool) : m Bool := do
  for a in s do
    if ← f a then
      return true
  return false

/--
`O(n)`. Returns `true` if `f` returns `true` for all elements of the set.
-/
@[specialize]
def allM [Monad m] (s : HashSet α) (f : α → m Bool) : m Bool := do
  for a in s do
    if !(← f a) then
      return false
  return true

instance : BEq (HashSet α) where
  beq s t := s.all (t.contains ·) && t.all (s.contains ·)



=== LEAN SOURCE: Json.lean ===
/-
 Copyright (c) 2022 E.W.Ayers. All rights reserved.
 Released under Apache 2.0 license as described in the file LICENSE.
 Authors: E.W.Ayers, Mario Carneiro
-/
import Lean.Data.Json.FromToJson
import Batteries.Lean.Float

open Lean

instance : OfScientific JsonNumber where
  ofScientific mantissa exponentSign decimalExponent :=
    if exponentSign then
      { mantissa := mantissa, exponent := decimalExponent }
    else
      { mantissa := (mantissa * 10 ^ decimalExponent : Nat), exponent := 0 }

instance : Neg JsonNumber where
  neg jn := ⟨-jn.mantissa, jn.exponent⟩

instance : ToJson Float where
  toJson x :=
    match x.toRatParts' with
    | none => Json.null
    | some (n, d) =>
      if d < 0 then
        Json.num { mantissa := n * (5^d.natAbs : Nat), exponent := d.natAbs }
      else
        Json.num { mantissa := n * (2^d.natAbs : Nat), exponent := 0 }



=== LEAN SOURCE: LawfulMonad.lean ===
/-
Copyright (c) 2024 Lean FRO, LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Lean.Elab.Command

/-!
# Construct `LawfulMonad` instances for the Lean monad stack.
-/

open Lean Elab Term Tactic Command

instance : LawfulMonad (EIO ε) := inferInstanceAs <| LawfulMonad (EStateM _ _)
instance : LawfulMonad BaseIO := inferInstanceAs <| LawfulMonad (EIO _)
instance : LawfulMonad IO := inferInstanceAs <| LawfulMonad (EIO _)

instance : LawfulMonad (EST ε σ) := inferInstanceAs <| LawfulMonad (EStateM _ _)

instance : LawfulMonad CoreM :=
  inferInstanceAs <| LawfulMonad (ReaderT _ <| StateRefT' _ _ (EIO Exception))
instance : LawfulMonad MetaM :=
  inferInstanceAs <| LawfulMonad (ReaderT _ <| StateRefT' _ _ CoreM)
instance : LawfulMonad TermElabM :=
  inferInstanceAs <| LawfulMonad (ReaderT _ <| StateRefT' _ _ MetaM)
instance : LawfulMonad TacticM :=
  inferInstanceAs <| LawfulMonad (ReaderT _ $ StateRefT' _ _ $ TermElabM)
instance : LawfulMonad CommandElabM :=
  inferInstanceAs <| LawfulMonad (ReaderT _ $ StateRefT' _ _ $ EIO _)



=== LEAN SOURCE: LawfulMonadLift.lean ===
/-
Copyright (c) 2025 Quang Dao. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Quang Dao
-/
import Lean.Elab.Command

/-!
# Lawful instances of `MonadLift` for the Lean monad stack.
-/

open Lean Elab Term Tactic Command

instance : LawfulMonadLift BaseIO (EIO ε) where
  monadLift_pure _ := rfl
  monadLift_bind ma f := by
    simp only [MonadLift.monadLift, bind]
    unfold BaseIO.toEIO EStateM.bind IO.RealWorld
    simp only
    funext x
    rcases ma x with a | a
    · simp only
    · contradiction

instance : LawfulMonadLift (ST σ) (EST ε σ) where
  monadLift_pure a := rfl
  monadLift_bind ma f := by
    simp only [MonadLift.monadLift, bind]
    unfold EStateM.bind
    simp only
    funext x
    rcases ma x with a | a
    · simp only
    · contradiction

instance : LawfulMonadLift IO CoreM where
  monadLift_pure _ := rfl
  monadLift_bind ma f := by
    simp only [MonadLift.monadLift, bind, pure, Core.liftIOCore, liftM, monadLift, getRef, read,
      readThe, MonadReaderOf.read, IO.toEIO]
    unfold StateRefT'.lift ReaderT.read ReaderT.bind ReaderT.pure
    simp only [Function.comp_apply, bind, pure]
    unfold ReaderT.bind ReaderT.pure
    simp only [bind, pure]
    unfold EStateM.adaptExcept EStateM.bind EStateM.pure
    simp only
    funext _ _ s
    rcases ma s with a | a <;> simp only

instance : LawfulMonadLiftT (EIO Exception) CommandElabM := inferInstance
instance : LawfulMonadLiftT (EIO Exception) CoreM := inferInstance
instance : LawfulMonadLiftT CoreM MetaM := inferInstance
instance : LawfulMonadLiftT MetaM TermElabM := inferInstance
instance : LawfulMonadLiftT TermElabM TacticM := inferInstance



=== LEAN SOURCE: MonadBacktrack.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Lean.Util.MonadBacktrack

namespace Lean

/--
Execute the action `x`, then restore the initial state. Returns the state after
`x` finished.
-/
def withoutModifyingState' [Monad m] [MonadBacktrack s m] [MonadFinally m]
    (x : m α) : m (α × s) :=
  withoutModifyingState do
    let result ← x
    let finalState ← saveState
    return (result, finalState)

end Lean



=== LEAN SOURCE: NameMapAttribute.lean ===
/-
Copyright (c) 2022 E.W.Ayers. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: E.W.Ayers
-/
import Lean.Attributes

namespace Lean

/-- Maps declaration names to `α`. -/
def NameMapExtension (α : Type) := SimplePersistentEnvExtension (Name × α) (NameMap α)

instance : Inhabited (NameMapExtension α) :=
  inferInstanceAs <| Inhabited (SimplePersistentEnvExtension ..)

/-- Look up a value in the given extension in the environment. -/
def NameMapExtension.find? (ext : NameMapExtension α) (env : Environment) : Name → Option α :=
  (SimplePersistentEnvExtension.getState ext env).find?

/-- Add the given k,v pair to the NameMapExtension. -/
def NameMapExtension.add [Monad M] [MonadEnv M] [MonadError M]
  (ext : NameMapExtension α) (k : Name) (v : α) :  M Unit := do
  if let some _ := ext.find? (← getEnv) k then
    throwError "Already exists entry for {ext.name} {k}"
  else
     ext.addEntry (← getEnv) (k, v) |> setEnv

/-- Registers a new extension with the given name and type. -/
def registerNameMapExtension (α) (name : Name := by exact decl_name%) :
    IO (NameMapExtension α) := do
  registerSimplePersistentEnvExtension {
    name
    addImportedFn := fun ass =>
      ass.foldl (init := ∅) fun names as =>
        as.foldl (init := names) fun names (a, b) => names.insert a b
    addEntryFn    := fun s n => s.insert n.1 n.2
    toArrayFn     := fun es => es.toArray
  }

/-- The inputs to `registerNameMapAttribute`. -/
structure NameMapAttributeImpl (α : Type) where
  /-- The name of the attribute -/
  name : Name
  /-- The declaration which creates the attribute -/
  ref : Name := by exact decl_name%
  /-- The description of the attribute -/
  descr : String
  /-- This function is called when the attribute is applied.
  It should produce a value of type `α` from the given attribute syntax. -/
  add (src : Name) (stx : Syntax) : AttrM α
  deriving Inhabited

/-- Similar to `registerParametricAttribute` except that attributes do not
have to be assigned in the same file as the declaration. -/
def registerNameMapAttribute (impl : NameMapAttributeImpl α) : IO (NameMapExtension α) := do
  let ext ← registerNameMapExtension α impl.ref
  registerBuiltinAttribute {
    name := impl.name
    descr := impl.descr
    add := fun src stx _kind => do
      let a : α ← impl.add src stx
      ext.add src a
  }
  return ext



=== LEAN SOURCE: PersistentHashMap.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Lean.Data.PersistentHashMap

namespace Lean.PersistentHashMap

variable [BEq α] [Hashable α]

/--
Builds a `PersistentHashMap` from a list of key-value pairs. Values of
duplicated keys are replaced by their respective last occurrences.
-/
def ofList (xs : List (α × β)) : PersistentHashMap α β :=
  xs.foldl (init := {}) fun m (k, v) => m.insert k v

/--
Variant of `ofList` which accepts a function that combines values of duplicated
keys.
-/
def ofListWith (xs : List (α × β)) (f : α → β → β → β) :
    PersistentHashMap α β :=
  xs.foldl (init := {}) fun m (k, v) =>
    match m.find? k with
    | none    => m.insert k v
    | some v' => m.insert k <| f k v v'

/--
Builds a `PersistentHashMap` from an array of key-value pairs. Values of
duplicated keys are replaced by their respective last occurrences.
-/
def ofArray (xs : Array (α × β)) : PersistentHashMap α β :=
  xs.foldl (init := {}) fun m (k, v) => m.insert k v

/--
Variant of `ofArray` which accepts a function that combines values of duplicated
keys.
-/
def ofArrayWith (xs : Array (α × β)) (f : α → β → β → β) :
    PersistentHashMap α β :=
  xs.foldl (init := {}) fun m (k, v) =>
    match m.find? k with
    | none    => m.insert k v
    | some v' => m.insert k <| f k v v'

/--
Merge two `PersistentHashMap`s. The values of keys which appear in both maps are
combined using the monadic function `f`.
-/
@[specialize]
def mergeWithM [Monad m] (self other : PersistentHashMap α β)
    (f : α → β → β → m β) : m (PersistentHashMap α β) :=
  other.foldlM (init := self) fun map k v₂ =>
    match map.find? k with
    | none => return map.insert k v₂
    | some v₁ => return map.insert k (← f k v₁ v₂)

/--
Merge two `PersistentHashMap`s. The values of keys which appear in both maps are
combined using `f`.
-/
@[inline]
def mergeWith (self other : PersistentHashMap α β) (f : α → β → β → β) :
    PersistentHashMap α β :=
  -- Implementing this function directly, rather than via `mergeWithM`, gives
  -- us less constrained universes.
  other.foldl (init := self) fun map k v₂ =>
    match map.find? k with
    | none => map.insert k v₂
    | some v₁ => map.insert k <| f k v₁ v₂



=== LEAN SOURCE: PersistentHashSet.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Lean.Data.PersistentHashSet

namespace Lean.PersistentHashSet

variable [BEq α] [Hashable α]

instance : ForIn m (PersistentHashSet α) α where
  forIn s init step := do
    let mut state := init
    for (k, _) in s.set do
      match ← step k state with
      | .done state' => return state'
      | .yield state' => state := state'
    return state

/--
Returns `true` if `f` returns `true` for any element of the set.
-/
@[specialize]
def anyM [Monad m] (s : PersistentHashSet α) (f : α → m Bool) : m Bool := do
  for a in s do
    if ← f a then
      return true
  return false

/--
Returns `true` if `f` returns `true` for any element of the set.
-/
@[inline]
def any (s : PersistentHashSet α) (f : α → Bool) : Bool :=
  Id.run <| s.anyM f

/--
Returns `true` if `f` returns `true` for all elements of the set.
-/
@[specialize]
def allM [Monad m] (s : PersistentHashSet α) (f : α → m Bool) : m Bool := do
  for a in s do
    if ! (← f a) then
      return false
  return true

/--
Returns `true` if `f` returns `true` for all elements of the set.
-/
@[inline]
def all (s : PersistentHashSet α) (f : α → Bool) : Bool :=
  Id.run <| s.allM f

instance : BEq (PersistentHashSet α) where
  beq s t := s.all (t.contains ·) && t.all (s.contains ·)

/--
Insert all elements from a collection into a `PersistentHashSet`.
-/
def insertMany [ForIn Id ρ α] (s : PersistentHashSet α) (as : ρ) :
    PersistentHashSet α := Id.run do
  let mut s := s
  for a in as do
    s := s.insert a
  return s

/--
Obtain a `PersistentHashSet` from an array.
-/
@[inline]
protected def ofArray [BEq α] [Hashable α] (as : Array α) : PersistentHashSet α :=
  PersistentHashSet.empty.insertMany as

/--
Obtain a `PersistentHashSet` from a list.
-/
@[inline]
protected def ofList [BEq α] [Hashable α] (as : List α) : PersistentHashSet α :=
  PersistentHashSet.empty.insertMany as

/--
Merge two `PersistentHashSet`s.
-/
@[inline]
def merge (s t : PersistentHashSet α) : PersistentHashSet α :=
  s.insertMany t



=== LEAN SOURCE: Position.lean ===
/-
Copyright (c) 2023 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Lean.Syntax
import Lean.Data.Lsp.Utf16

/-- Gets the LSP range of syntax `stx`. -/
def Lean.FileMap.rangeOfStx? (text : FileMap) (stx : Syntax) : Option Lsp.Range :=
  text.utf8RangeToLspRange <$> stx.getRange?

/-- Return the beginning of the line contatining character `pos`. -/
def Lean.findLineStart (s : String) (pos : String.Pos) : String.Pos :=
  match s.revFindAux (· = '\n') pos with
  | none => 0
  | some n => ⟨n.byteIdx + 1⟩

/--
Return the indentation (number of leading spaces) of the line containing `pos`,
and whether `pos` is the first non-whitespace character in the line.
-/
def Lean.findIndentAndIsStart (s : String) (pos : String.Pos) : Nat × Bool :=
  let start := findLineStart s pos
  let body := s.findAux (· ≠ ' ') pos start
  ((body - start).1, body == pos)



=== LEAN SOURCE: SatisfiesM.lean ===
/-
Copyright (c) 2024 Lean FRO, LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Batteries.Classes.SatisfiesM
import Batteries.Lean.LawfulMonad
import Lean.Elab.Command

/-!
# Construct `MonadSatisfying` instances for the Lean monad stack.
-/

open Lean Elab Term Tactic Command

instance : MonadSatisfying (EIO ε) := inferInstanceAs <| MonadSatisfying (EStateM _ _)
instance : MonadSatisfying BaseIO := inferInstanceAs <| MonadSatisfying (EIO _)
instance : MonadSatisfying IO := inferInstanceAs <| MonadSatisfying (EIO _)

instance : MonadSatisfying (EST ε σ) := inferInstanceAs <| MonadSatisfying (EStateM _ _)

instance : MonadSatisfying CoreM :=
  inferInstanceAs <| MonadSatisfying (ReaderT _ <| StateRefT' _ _ (EIO _))

instance : MonadSatisfying MetaM :=
  inferInstanceAs <| MonadSatisfying (ReaderT _ <| StateRefT' _ _ CoreM)

instance : MonadSatisfying TermElabM :=
  inferInstanceAs <| MonadSatisfying (ReaderT _ <| StateRefT' _ _ MetaM)

instance : MonadSatisfying TacticM :=
  inferInstanceAs <| MonadSatisfying (ReaderT _ $ StateRefT' _ _ TermElabM)

instance : MonadSatisfying CommandElabM :=
  inferInstanceAs <| MonadSatisfying (ReaderT _ $ StateRefT' _ _ (EIO _))



=== LEAN SOURCE: Syntax.lean ===
/-
Copyright (c) 2022 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Gabriel Ebner
-/
import Lean.Syntax

/-!
# Helper functions for working with typed syntaxes.
-/

namespace Lean

/--
Applies the given function to every subsyntax.

Like `Syntax.replaceM` but for typed syntax.
(Note there are no guarantees of type correctness here.)
-/
def TSyntax.replaceM [Monad M] (f : Syntax → M (Option Syntax)) (stx : TSyntax k) : M (TSyntax k) :=
  .mk <$> stx.1.replaceM f



=== LEAN SOURCE: TagAttribute.lean ===
/-
Copyright (c) 2022 Gabriel Ebner. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Gabriel Ebner
-/
import Lean.Attributes

/-- Get the list of declarations tagged with the tag attribute `attr`. -/
def Lean.TagAttribute.getDecls (attr : TagAttribute) (env : Environment) : Array Name :=
  core <| attr.ext.toEnvExtension.getState env
where
  /-- Implementation of `TagAttribute.getDecls`. -/
  core (st : PersistentEnvExtensionState Name NameSet) : Array Name := Id.run do
    let mut decls := st.state.toArray
    for ds in st.importedEntries do
      decls := decls ++ ds
    decls



=== LEAN SOURCE: Process.lean ===
/-
Copyright (c) 2023 Kim Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/

/-!
# Running external commands.
-/

namespace IO.Process

open System (FilePath)

/--
Pipe `input` into stdin of the spawned process,
then return `(exitCode, stdout, stdErr)` upon completion.
-/
def runCmdWithInput' (cmd : String) (args : Array String)
    (input : String := "") (throwFailure := true) : IO Output := do
  let child ← spawn
    { cmd := cmd, args := args, stdin := .piped, stdout := .piped, stderr := .piped }
  let (stdin, child) ← child.takeStdin
  stdin.putStr input
  stdin.flush
  let stdout ← IO.asTask child.stdout.readToEnd Task.Priority.dedicated
  let err ← child.stderr.readToEnd
  let exitCode ← child.wait
  if exitCode != 0 && throwFailure then
    throw $ IO.userError err
  else
    let out ← IO.ofExcept stdout.get
    return ⟨exitCode, out, err⟩

/--
Pipe `input` into stdin of the spawned process,
then return the entire content of stdout as a `String` upon completion.
-/
def runCmdWithInput (cmd : String) (args : Array String)
    (input : String := "") (throwFailure := true) : IO String := do
  return (← runCmdWithInput' cmd args input throwFailure).stdout



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro, Jannis Limperg
-/
import Lean.Meta.Tactic.Intro

open Lean Lean.Meta

namespace Lean

/--
Sort the given `FVarId`s by the order in which they appear in the current local
context. If any of the `FVarId`s do not appear in the current local context, the
result is unspecified.
-/
def Meta.sortFVarsByContextOrder [Monad m] [MonadLCtx m]
    (hyps : Array FVarId) : m (Array FVarId) :=
  return (← getLCtx).sortFVarsByContextOrder hyps


namespace MetavarContext

/--
Get the `MetavarDecl` of `mvarId`. If `mvarId` is not a declared metavariable
in the given `MetavarContext`, throw an error.
-/
def getExprMVarDecl [Monad m] [MonadError m] (mctx : MetavarContext)
    (mvarId : MVarId) : m MetavarDecl := do
  if let some mdecl := mctx.decls.find? mvarId then
    return mdecl
  else
    throwError "unknown metavariable '?{mvarId.name}'"

/--
Declare a metavariable. You must make sure that the metavariable is not already
declared.
-/
def declareExprMVar (mctx : MetavarContext) (mvarId : MVarId)
    (mdecl : MetavarDecl) : MetavarContext :=
  { mctx with decls := mctx.decls.insert mvarId mdecl }

/--
Check whether a metavariable is assigned or delayed-assigned. A
delayed-assigned metavariable is already 'solved' but the solution cannot be
substituted yet because we have to wait for some other metavariables to be
assigned first. So in most situations you want to treat a delayed-assigned
metavariable as assigned.
-/
def isExprMVarAssignedOrDelayedAssigned (mctx : MetavarContext)
    (mvarId : MVarId) : Bool :=
  mctx.eAssignment.contains mvarId || mctx.dAssignment.contains mvarId

/--
Check whether a metavariable is declared in the given `MetavarContext`.
-/
def isExprMVarDeclared (mctx : MetavarContext) (mvarId : MVarId) : Bool :=
  mctx.decls.contains mvarId

/--
Erase any assignment or delayed assignment of the given metavariable.
-/
def eraseExprMVarAssignment (mctx : MetavarContext) (mvarId : MVarId) :
    MetavarContext :=
  { mctx with
    eAssignment := mctx.eAssignment.erase mvarId
    dAssignment := mctx.dAssignment.erase mvarId }

/--
Obtain all unassigned metavariables from the given `MetavarContext`. If
`includeDelayed` is `true`, delayed-assigned metavariables are considered
unassigned.
-/
def unassignedExprMVars (mctx : MetavarContext) (includeDelayed := false) :
    Array MVarId := Id.run do
  let mut result := #[]
  for (mvarId, _) in mctx.decls do
    if ! mctx.eAssignment.contains mvarId &&
        (includeDelayed || ! mctx.dAssignment.contains mvarId) then
      result := result.push mvarId
  return result

end MetavarContext


namespace MVarId

/--
Check whether a metavariable is declared.
-/
def isDeclared [Monad m] [MonadMCtx m] (mvarId : MVarId) : m Bool :=
  return (← getMCtx).isExprMVarDeclared mvarId

/--
Erase any assignment or delayed assignment of the given metavariable.
-/
def eraseAssignment [MonadMCtx m] (mvarId : MVarId) : m Unit :=
  modifyMCtx (·.eraseExprMVarAssignment mvarId)

/-- Solve a goal by synthesizing an instance. -/
-- FIXME: probably can just be `g.inferInstance` once leanprover/lean4#2054 is fixed
def synthInstance (g : MVarId) : MetaM Unit := do
  g.assign (← Lean.Meta.synthInstance (← g.getType))

/-- Get the type the given metavariable after instantiating metavariables and cleaning up
annotations. -/
def getTypeCleanup (mvarId : MVarId) : MetaM Expr :=
  return (← instantiateMVars (← mvarId.getType)).cleanupAnnotations

end MVarId


namespace Meta

/--
Obtain all unassigned metavariables. If `includeDelayed` is `true`,
delayed-assigned metavariables are considered unassigned.
-/
def getUnassignedExprMVars [Monad m] [MonadMCtx m] (includeDelayed := false) :
    m (Array MVarId) :=
  return (← getMCtx).unassignedExprMVars (includeDelayed := includeDelayed)

/--
Run a computation with hygiene turned off.
-/
def unhygienic [MonadWithOptions m] (x : m α) : m α :=
  withOptions (tactic.hygienic.set · false) x

/--
A variant of `mkFreshId` which generates names with a particular prefix. The
generated names are unique and have the form `<prefix>.<N>` where `N` is a
natural number. They are not suitable as user-facing names.
-/
def mkFreshIdWithPrefix [Monad m] [MonadNameGenerator m] («prefix» : Name) :
    m Name := do
  let ngen ← getNGen
  let r := { ngen with namePrefix := «prefix» }.curr
  setNGen ngen.next
  pure r

/--
`saturate1 goal tac` runs `tac` on `goal`, then on the resulting goals, etc.,
until `tac` does not apply to any goal any more (i.e. it returns `none`). The
order of applications is depth-first, so if `tac` generates goals `[g₁, g₂, ⋯]`,
we apply `tac` to `g₁` and recursively to all its subgoals before visiting `g₂`.
If `tac` does not apply to `goal`, `saturate1` returns `none`. Otherwise it
returns the generated subgoals to which `tac` did not apply. `saturate1`
respects the `MonadRecDepth` recursion limit.
-/
partial def saturate1 [Monad m] [MonadError m] [MonadRecDepth m] [MonadLiftT (ST IO.RealWorld) m]
    (goal : MVarId) (tac : MVarId → m (Option (Array MVarId))) : m (Option (Array MVarId)) := do
  let some goals ← tac goal | return none
  let acc ← ST.mkRef #[]
  goals.forM (go acc)
  return some (← acc.get)
where
  /-- Auxiliary definition for `saturate1`. -/
  go (acc : IO.Ref (Array MVarId)) (goal : MVarId) : m Unit :=
    withIncRecDepth do
      match ← tac goal with
      | none => acc.modify fun s => s.push goal
      | some goals => goals.forM (go acc)



=== LEAN SOURCE: DiscrTree.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg, Kim Morrison
-/

import Lean.Meta.DiscrTree
import Batteries.Data.Array.Merge
import Batteries.Lean.Meta.Expr
import Batteries.Lean.PersistentHashMap

namespace Lean.Meta.DiscrTree

namespace Key

/--
Compare two `Key`s. The ordering is total but otherwise arbitrary. (It uses
`Name.quickCmp` internally.)
-/
protected def cmp : Key → Key → Ordering
  | .lit v₁,        .lit v₂        => compare v₁ v₂
  | .fvar n₁ a₁,    .fvar n₂ a₂    => n₁.name.quickCmp n₂.name |>.then <| compare a₁ a₂
  | .const n₁ a₁,   .const n₂ a₂   => n₁.quickCmp n₂ |>.then <| compare a₁ a₂
  | .proj s₁ i₁ a₁, .proj s₂ i₂ a₂ =>
    s₁.quickCmp s₂ |>.then <| compare i₁ i₂ |>.then <| compare a₁ a₂
  | k₁,             k₂             => compare k₁.ctorIdx k₂.ctorIdx

instance : Ord Key := ⟨Key.cmp⟩

end Key


namespace Trie

/--
Merge two `Trie`s. Duplicate values are preserved.
-/
partial def mergePreservingDuplicates : Trie α → Trie α → Trie α
  | node vs₁ cs₁, node vs₂ cs₂ =>
    node (vs₁ ++ vs₂) (mergeChildren cs₁ cs₂)
where
  /-- Auxiliary definition for `mergePreservingDuplicates`. -/
  mergeChildren (cs₁ cs₂ : Array (Key × Trie α)) :
      Array (Key × Trie α) :=
    Array.mergeDedupWith
      (ord := ⟨compareOn (·.fst)⟩) cs₁ cs₂
      (fun (k₁, t₁) (_, t₂) => (k₁, mergePreservingDuplicates t₁ t₂))

end Trie

/--
Merge two `DiscrTree`s. Duplicate values are preserved.
-/
@[inline]
def mergePreservingDuplicates (t u : DiscrTree α) : DiscrTree α :=
  ⟨t.root.mergeWith u.root fun _ trie₁ trie₂ =>
    trie₁.mergePreservingDuplicates trie₂⟩



=== LEAN SOURCE: Expr.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Lean.Expr

namespace Lean.Literal

instance : Ord Literal where
  compare
    | natVal n₁, natVal n₂ => compare n₁ n₂
    | strVal s₁, strVal s₂ => compare s₁ s₂
    | natVal _, strVal _ => .lt
    | strVal _, natVal _ => .gt



=== LEAN SOURCE: Inaccessible.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/
import Lean.Meta.Basic

open Lean Lean.Meta Std

/--
Obtain the inaccessible fvars from the given local context. An fvar is
inaccessible if (a) its user name is inaccessible or (b) it is shadowed by a
later fvar with the same user name.
-/
def Lean.LocalContext.inaccessibleFVars (lctx : LocalContext) :
    Array LocalDecl :=
  let (result, _) :=
    lctx.foldr (β := Array LocalDecl × Std.HashSet Name)
      (init := (Array.mkEmpty lctx.numIndices, {}))
      fun ldecl (result, seen) =>
        if ldecl.isImplementationDetail then
          (result, seen)
        else
          let result :=
            if ldecl.userName.hasMacroScopes || seen.contains ldecl.userName then
              result.push ldecl
            else
              result
          (result, seen.insert ldecl.userName)
  result.reverse

/--
Obtain the inaccessible fvars from the current local context. An fvar is
inaccessible if (a) its user name is inaccessible or (b) it is shadowed by a
later fvar with the same user name.
-/
def Lean.Meta.getInaccessibleFVars [Monad m] [MonadLCtx m] :
    m (Array LocalDecl) :=
  return (← getLCtx).inaccessibleFVars

/--
Rename all inaccessible fvars. An fvar is inaccessible if (a) its user name is
inaccessible or (b) it is shadowed by a later fvar with the same user name. This
function gives all inaccessible fvars a unique, accessible user name. It returns
the new goal and the fvars that were renamed.
-/
def Lean.MVarId.renameInaccessibleFVars (mvarId : MVarId) :
    MetaM (MVarId × Array FVarId) := do
  let mdecl ← mvarId.getDecl
  let mut lctx := mdecl.lctx
  let inaccessibleFVars := lctx.inaccessibleFVars
  if inaccessibleFVars.isEmpty then
    return (mvarId, #[])
  let mut renamedFVars := Array.mkEmpty lctx.decls.size
  for ldecl in inaccessibleFVars do
    let newName := lctx.getUnusedName ldecl.userName
    lctx := lctx.setUserName ldecl.fvarId newName
    renamedFVars := renamedFVars.push ldecl.fvarId
  let newMVar ← mkFreshExprMVarAt lctx mdecl.localInstances mdecl.type
  mvarId.assign newMVar
  return (newMVar.mvarId!, renamedFVars)



=== LEAN SOURCE: InstantiateMVars.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/
import Batteries.Lean.Meta.Basic

open Lean Lean.Meta

namespace Lean.MVarId

/--
Instantiate metavariables in the type of the given metavariable, update the
metavariable's declaration and return the new type.
-/
def instantiateMVarsInType [Monad m] [MonadMCtx m] [MonadError m]
    (mvarId : MVarId) : m Expr := do
  let mdecl ← (← getMCtx).getExprMVarDecl mvarId
  let type := mdecl.type
  if type.hasMVar then
    let type ← instantiateMVars type
    let mdecl := { mdecl with type }
    modifyMCtx (·.declareExprMVar mvarId mdecl)
    return type
  else
    return type

/--
Instantiate metavariables in the `LocalDecl` of the given fvar, update the
`LocalDecl` and return the new `LocalDecl.`
-/
def instantiateMVarsInLocalDecl [Monad m] [MonadMCtx m] [MonadError m]
    (mvarId : MVarId) (fvarId : FVarId) : m LocalDecl := do
  let mdecl ← (← getMCtx).getExprMVarDecl mvarId
  let (some ldecl) := mdecl.lctx.find? fvarId | throwError
    "unknown fvar '{fvarId.name}' (in local context of mvar '?{mvarId.name}')"
  let ldecl ← Lean.instantiateLocalDeclMVars ldecl
  let mdecl :=
    { mdecl with lctx := mdecl.lctx.modifyLocalDecl fvarId fun _ => ldecl }
  modifyMCtx (·.declareExprMVar mvarId mdecl)
  return ldecl

/--
Instantiate metavariables in the local context of the given metavariable, update
the metavariable's declaration and return the new local context.
-/
def instantiateMVarsInLocalContext [Monad m] [MonadMCtx m] [MonadError m]
    (mvarId : MVarId) : m LocalContext := do
  let mdecl ← (← getMCtx).getExprMVarDecl mvarId
  let lctx ← instantiateLCtxMVars mdecl.lctx
  modifyMCtx (·.declareExprMVar mvarId { mdecl with lctx })
  return lctx

/--
Instantiate metavariables in the local context and type of the given
metavariable.
-/
def instantiateMVars [Monad m] [MonadMCtx m] [MonadError m] (mvarId : MVarId) :
    m Unit := do
  discard $ (← getMCtx).getExprMVarDecl mvarId
    -- The line above throws an error if the `mvarId` is not declared. The line
    -- below panics.
  instantiateMVarDeclMVars mvarId

end Lean.MVarId



=== LEAN SOURCE: SavedState.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Batteries.Lean.Meta.Basic
import Batteries.Lean.MonadBacktrack

namespace Lean.Meta.SavedState

/--
Run the action `x` in state `s`. Returns the result of `x` and the state after
`x` was executed. The global state remains unchanged.
-/
def runMetaM (s : Meta.SavedState) (x : MetaM α) :
    MetaM (α × Meta.SavedState) :=
  withoutModifyingState' do restoreState s; x

/--
Run the action `x` in state `s`. Returns the result of `x`. The global state
remains unchanged.
-/
def runMetaM' (s : Meta.SavedState) (x : MetaM α) : MetaM α :=
  withoutModifyingState do restoreState s; x

end SavedState


/--
Returns the mvars that are not declared in `preState`, but declared and
unassigned in `postState`. Delayed-assigned mvars are considered assigned.
-/
def getIntroducedExprMVars (preState postState : SavedState) :
    MetaM (Array MVarId) := do
  let unassignedPost ← postState.runMetaM' getUnassignedExprMVars
  preState.runMetaM' do
    unassignedPost.filterM fun mvarId => return ! (← mvarId.isDeclared)

/--
Returns the mvars that are declared but unassigned in `preState`, and
assigned in `postState`. Delayed-assigned mvars are considered assigned.
-/
def getAssignedExprMVars (preState postState : SavedState) :
    MetaM (Array MVarId) := do
  let unassignedPre ← preState.runMetaM' getUnassignedExprMVars
  postState.runMetaM' do
    unassignedPre.filterM (·.isAssignedOrDelayedAssigned)

end Lean.Meta



=== LEAN SOURCE: Simp.lean ===
/-
Copyright (c) 2022 Kim Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison, Gabriel Ebner, Floris van Doorn
-/
import Lean.Elab.Tactic.Simp
import Batteries.Tactic.OpenPrivate

/-!
# Helper functions for using the simplifier.

[TODO] Reunification of `mkSimpContext'` with core.
-/

namespace Lean

namespace Meta.Simp
open Elab.Tactic

/-- Flip the proof in a `Simp.Result`. -/
def mkEqSymm (e : Expr) (r : Simp.Result) : MetaM Simp.Result :=
  ({ expr := e, proof? := · }) <$>
  match r.proof? with
  | none => pure none
  | some p => some <$> Meta.mkEqSymm p

/-- Construct the `Expr` `cast h e`, from a `Simp.Result` with proof `h`. -/
def mkCast (r : Simp.Result) (e : Expr) : MetaM Expr := do
  mkAppM ``cast #[← r.getProof, e]

export private mkDischargeWrapper from Lean.Elab.Tactic.Simp

/-- Construct a `Simp.DischargeWrapper` from the `Syntax` for a `simp` discharger. -/
add_decl_doc mkDischargeWrapper

-- copied from core
/--
If `ctx == false`, the config argument is assumed to have type `Meta.Simp.Config`,
and `Meta.Simp.ConfigCtx` otherwise.
If `ctx == false`, the `discharge` option must be none
-/
def mkSimpContext' (simpTheorems : SimpTheorems) (stx : Syntax) (eraseLocal : Bool)
    (kind := SimpKind.simp) (ctx := false) (ignoreStarArg : Bool := false) :
    TacticM MkSimpContextResult := do
  if ctx && !stx[2].isNone then
    if kind == SimpKind.simpAll then
      throwError "'simp_all' tactic does not support 'discharger' option"
    if kind == SimpKind.dsimp then
      throwError "'dsimp' tactic does not support 'discharger' option"
  let dischargeWrapper ← mkDischargeWrapper stx[2]
  let simpOnly := !stx[3].isNone
  let simpTheorems ← if simpOnly then
    simpOnlyBuiltins.foldlM (·.addConst ·) {}
  else
    pure simpTheorems
  let simprocs ← if simpOnly then pure {} else Simp.getSimprocs
  let congrTheorems ← Meta.getSimpCongrTheorems
  let ctx ← Simp.mkContext (← elabSimpConfig stx[1] (kind := kind)) #[simpTheorems] congrTheorems
  let r ← elabSimpArgs stx[4] (simprocs := #[simprocs]) ctx eraseLocal kind
    (ignoreStarArg := ignoreStarArg)
  return { r with dischargeWrapper }


end Simp

end Lean.Meta



=== LEAN SOURCE: UnusedNames.lean ===
/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/
import Lean.LocalContext

open Lean Lean.Meta

namespace Lean.Name

private def parseIndexSuffix (s : Substring) : Option Nat :=
  if s.isEmpty then
    none
  else if s.front == '_' then
    s.drop 1 |>.toNat?
  else
    none

/--
Result type of `Lean.Name.matchUpToIndexSuffix`. See there for details.
-/
inductive MatchUpToIndexSuffix
  /-- Exact match. -/
  |  exactMatch
  /-- No match. -/
  | noMatch
  /-- Match up to suffix. -/
  | suffixMatch (i : Nat)

/--
Succeeds if `n` is equal to `query`, except `n` may have an additional `_i`
suffix for some natural number `i`. More specifically:

- If `n = query`, the result is `exactMatch`.
- If `n = query ++ "_i"` for some natural number `i`, the result is
  `suffixMatch i`.
- Otherwise the result is `noMatch`.
-/
def matchUpToIndexSuffix (n : Name) (query : Name) :
    MatchUpToIndexSuffix :=
  match n, query with
  | .str pre₁ s₁, .str pre₂ s₂ =>
    if pre₁ != pre₂ then
      .noMatch
    else
      if let some suffix := s₁.dropPrefix? s₂ then
        if suffix.isEmpty then
          .exactMatch
        else
          if let some i := parseIndexSuffix suffix then
            .suffixMatch i
          else
            .noMatch
      else
        .noMatch
  | n, query => if n == query then .exactMatch else .noMatch

end Name


namespace LocalContext

/--
Obtain the least natural number `i` such that `suggestion ++ "_i"` is an unused
name in the given local context. If `suggestion` itself is unused, the result
is `none`.
-/
def getUnusedUserNameIndex (lctx : LocalContext) (suggestion : Name) :
    Option Nat := Id.run do
  let mut minSuffix := none
  for ldecl in lctx do
    let hypName := ldecl.userName
    if hypName.hasMacroScopes then
      continue
    match ldecl.userName.matchUpToIndexSuffix suggestion with
    | .exactMatch => minSuffix := updateMinSuffix minSuffix 1
    | .noMatch => continue
    | .suffixMatch i => minSuffix := updateMinSuffix minSuffix (i + 1)
  minSuffix
where
  /-- Auxiliary definition for `getUnusedUserNameIndex`. -/
  @[inline]
  updateMinSuffix : Option Nat → Nat → Option Nat
    | none, j => some j
    | some i, j => some $ i.max j

/--
Obtain a name `n` such that `n` is unused in the given local context and
`suggestion` is a prefix of `n`. This is similar to `getUnusedName` but uses
a different algorithm which may or may not be faster.
-/
def getUnusedUserName (lctx : LocalContext) (suggestion : Name) : Name :=
  let suggestion := suggestion.eraseMacroScopes
  match lctx.getUnusedUserNameIndex suggestion with
  | none => suggestion
  | some i => suggestion.appendIndexAfter i

/--
Obtain `n` distinct names such that each name is unused in the given local
context and `suggestion` is a prefix of each name.
-/
def getUnusedUserNames (lctx : LocalContext) (n : Nat) (suggestion : Name) :
    Array Name :=
  if n == 0 then
    #[]
  else
    let suggestion := suggestion.eraseMacroScopes
    let acc := Array.mkEmpty n
    match lctx.getUnusedUserNameIndex suggestion with
    | none => loop (acc.push suggestion) (n - 1) 1
    | some i => loop acc n i
where
  /-- Auxiliary definition for `getUnusedUserNames`. -/
  loop (acc : Array Name) (n i : Nat) : Array Name :=
    match n with
    | 0 => acc
    | n + 1 => loop (acc.push $ suggestion.appendIndexAfter i) n (i + 1)

end Lean.LocalContext


namespace Lean.Meta

/--
Obtain a name `n` such that `n` is unused in the current local context and
`suggestion` is a prefix of `n`.
-/
def getUnusedUserName [Monad m] [MonadLCtx m] (suggestion : Name) : m Name :=
  return (← getLCtx).getUnusedUserName suggestion

/--
Obtain `n` distinct names such that each name is unused in the current local
context and `suggestion` is a prefix of each name.
-/
def getUnusedUserNames [Monad m] [MonadLCtx m] (n : Nat) (suggestion : Name) :
    m (Array Name) :=
  return (← getLCtx).getUnusedUserNames n suggestion



=== LEAN SOURCE: IO.lean ===
/-
Copyright (c) 2023 Kim Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/

/-!
# Functions for manipulating a list of tasks

* `IO.waitAny'` is a wrapper for `IO.waitAny` that also returns the remaining tasks.
* `List.waitAll : List (Task α) → Task (List α)` gathers a list of tasks into a task returning
  the list of all results.
-/

set_option autoImplicit true

-- duplicated from `lean4/src/Init/System/IO.lean`
local macro "nonempty_list" : tactic =>
  `(tactic| exact Nat.zero_lt_succ _)

/--
Given a non-empty list of tasks, wait for the first to complete.
Return the value and the list of remaining tasks.
-/
def IO.waitAny' (tasks : List (Task α)) (h : 0 < tasks.length := by nonempty_list) :
    BaseIO (α × List (Task α)) := do
  let (i, a) ← IO.waitAny
    (tasks.mapIdx fun i t => t.map (prio := .max) fun a => (i, a))
    (by simp_all)
  return (a, tasks.eraseIdx i)

/--
Given a list of tasks, create the task returning the list of results,
by waiting for each.
-/
def List.waitAll (tasks : List (Task α)) : Task (List α) :=
  match tasks with
  | [] => .pure []
  | task :: tasks => task.bind (prio := .max) fun a =>
      tasks.waitAll.map (prio := .max) fun as => a :: as



=== LEAN SOURCE: EnvSearch.lean ===
/-
Copyright (c) 2021 Shing Tak Lam. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Shing Tak Lam, Daniel Selsam, Mario Carneiro
-/
import Batteries.Tactic.Lint.Misc

namespace Lean

/--
Find constants in current environment that match find options and predicate.
-/
def getMatchingConstants {m} [Monad m] [MonadEnv m]
    (p : ConstantInfo → m Bool)
    (includeImports := true)
    : m (Array ConstantInfo) := do
  let matches_ ←
    if includeImports then
      (← getEnv).constants.map₁.foldM (init := #[]) check
    else
      pure #[]
  (← getEnv).constants.map₂.foldlM (init := matches_) check
where
  /-- Check constant should be returned -/
  @[nolint unusedArguments]
  check matches_ (_name : Name) cinfo := do
    if ← p cinfo then
      pure $ matches_.push cinfo
    else
      pure matches_



=== LEAN SOURCE: UnnecessarySeqFocus.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Lean.Elab.Command
import Batteries.Lean.AttributeExtra

namespace Batteries.Linter
open Lean Elab Command Linter Std

/--
Enables the 'unnecessary `<;>`' linter. This will warn whenever the `<;>` tactic combinator
is used when `;` would work.

```
example : True := by apply id <;> trivial
```
The `<;>` is unnecessary here because `apply id` only makes one subgoal.
Prefer `apply id; trivial` instead.

In some cases, the `<;>` is syntactically necessary because a single tactic is expected:
```
example : True := by
  cases () with apply id <;> apply id
  | unit => trivial
```
In this case, you should use parentheses, as in `(apply id; apply id)`:
```
example : True := by
  cases () with (apply id; apply id)
  | unit => trivial
```
-/
register_option linter.unnecessarySeqFocus : Bool := {
  defValue := true
  descr := "enable the 'unnecessary <;>' linter"
}
example : True := by
  cases () with apply id <;> apply id
  | unit => trivial

namespace UnnecessarySeqFocus

/-- Gets the value of the `linter.unnecessarySeqFocus` option. -/
def getLinterUnnecessarySeqFocus (o : LinterOptions) : Bool :=
  getLinterValue linter.unnecessarySeqFocus o

/--
The `multigoal` attribute keeps track of tactics that operate on multiple goals,
meaning that `tac` acts differently from `focus tac`. This is used by the
'unnecessary `<;>`' linter to prevent false positives where `tac <;> tac'` cannot
be replaced by `(tac; tac')` because the latter would expose `tac` to a different set of goals.
-/
initialize multigoalAttr : TagAttributeExtra ←
  registerTagAttributeExtra `multigoal "this tactic acts on multiple goals" [
    ``Parser.Tactic.«tacticNext_=>_»,
    ``Parser.Tactic.allGoals,
    ``Parser.Tactic.anyGoals,
    ``Parser.Tactic.case,
    ``Parser.Tactic.case',
    ``Parser.Tactic.Conv.«convNext__=>_»,
    ``Parser.Tactic.Conv.allGoals,
    ``Parser.Tactic.Conv.anyGoals,
    ``Parser.Tactic.Conv.case,
    ``Parser.Tactic.Conv.case',
    ``Parser.Tactic.rotateLeft,
    ``Parser.Tactic.rotateRight,
    ``Parser.Tactic.show,
    ``Parser.Tactic.tacticStop_
  ]

/-- The information we record for each `<;>` node appearing in the syntax. -/
structure Entry where
  /-- The `<;>` node itself. -/
  stx : Syntax
  /--
  * `true`: this `<;>` has been used unnecessarily at least once
  * `false`: it has never been executed
  * If it has been used properly at least once, the entry is removed from the table.
  -/
  used : Bool

/-- The monad for collecting used tactic syntaxes. -/
abbrev M (ω) := StateRefT (Std.HashMap String.Range Entry) (ST ω)

/-- True if this is a `<;>` node in either `tactic` or `conv` classes. -/
@[inline] def isSeqFocus (k : SyntaxNodeKind) : Bool :=
  k == ``Parser.Tactic.«tactic_<;>_» || k == ``Parser.Tactic.Conv.«conv_<;>_»

/-- Accumulates the set of tactic syntaxes that should be evaluated at least once. -/
@[specialize] partial def getTactics {ω} (stx : Syntax) : M ω Unit := do
  if let .node _ k args := stx then
    if isSeqFocus k then
      let r := stx.getRange? true
      if let some r := r then
        modify fun m => m.insert r { stx, used := false }
    args.forM getTactics

/--
Traverse the info tree down a given path.
Each `(n, i)` means that the array must have length `n` and we will descend into the `i`'th child.
-/
def getPath : Info → PersistentArray InfoTree → List ((n : Nat) × Fin n) → Option Info
  | i, _, [] => some i
  | _, c, ⟨n, i, h⟩::ns =>
    if e : c.size = n then
      if let .node i c' := c[i] then getPath i c' ns else none
    else none

mutual
variable (env : Environment)
/-- Search for tactic executions in the info tree and remove executed tactic syntaxes. -/
partial def markUsedTacticsList (trees : PersistentArray InfoTree) : M ω Unit :=
  trees.forM markUsedTactics

/-- Search for tactic executions in the info tree and remove executed tactic syntaxes. -/
partial def markUsedTactics : InfoTree → M ω Unit
  | .node i c => do
    if let .ofTacticInfo i := i then
      if let some r := i.stx.getRange? true then
      if let some entry := (← get)[r]? then
      if i.stx.getKind == ``Parser.Tactic.«tactic_<;>_» then
        let isBad := do
          unless i.goalsBefore.length == 1 || !multigoalAttr.hasTag env i.stx[0].getKind do
            none
          -- Note: this uses the exact sequence of tactic applications
          -- in the macro expansion of `<;> : tactic`
          let .ofTacticInfo i ← getPath (.ofTacticInfo i) c
            [⟨1, 0⟩, ⟨2, 1⟩, ⟨1, 0⟩, ⟨5, 0⟩] | none
          guard <| i.goalsAfter.length == 1
        modify fun s => if isBad.isSome then s.insert r { entry with used := true } else s.erase r
      else if i.stx.getKind == ``Parser.Tactic.Conv.«conv_<;>_» then
        let isBad := do
          unless i.goalsBefore.length == 1 || !multigoalAttr.hasTag env i.stx[0].getKind do
            none
          -- Note: this uses the exact sequence of tactic applications
          -- in the macro expansion of `<;> : conv`
          let .ofTacticInfo i ← getPath (.ofTacticInfo i) c
            [⟨1, 0⟩, ⟨1, 0⟩, ⟨1, 0⟩, ⟨1, 0⟩, ⟨1, 0⟩, ⟨2, 1⟩, ⟨1, 0⟩, ⟨5, 0⟩] | none
          guard <| i.goalsAfter.length == 1
        modify fun s => if isBad.isSome then s.insert r { entry with used := true } else s.erase r
    markUsedTacticsList c
  | .context _ t => markUsedTactics t
  | .hole _ => pure ()

end

@[inherit_doc Batteries.Linter.linter.unnecessarySeqFocus]
def unnecessarySeqFocusLinter : Linter where run := withSetOptionIn fun stx => do
  unless getLinterUnnecessarySeqFocus (← getLinterOptions) && (← getInfoState).enabled do
    return
  if (← get).messages.hasErrors then
    return
  let trees ← getInfoTrees
  let env ← getEnv
  let go {ω} : M ω Unit := do
    getTactics stx
    markUsedTacticsList env trees
  let (_, map) := runST fun _ => go.run {}
  let unused := map.fold (init := #[]) fun acc r { stx, used } =>
    if used then acc.push (stx[1].getRange?.getD r, stx[1]) else acc
  let key (r : String.Range) := (r.start.byteIdx, (-r.stop.byteIdx : Int))
  let mut last : String.Range := ⟨0, 0⟩
  for (r, stx) in let _ := @lexOrd; let _ := @ltOfOrd.{0}; unused.qsort (key ·.1 < key ·.1) do
    if last.start ≤ r.start && r.stop ≤ last.stop then continue
    logLint linter.unnecessarySeqFocus stx
      "Used `tac1 <;> tac2` where `(tac1; tac2)` would suffice"
    last := r

initialize addLinter unnecessarySeqFocusLinter



=== LEAN SOURCE: UnreachableTactic.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Lean.Elab.Command
import Lean.Parser.Syntax
import Batteries.Tactic.Unreachable

namespace Batteries.Linter
open Lean Elab Command Linter Std

/--
Enables the 'unreachable tactic' linter. This will warn on any tactics that are never executed.
For example, in `example : True := by trivial <;> done`, the tactic `done` is never executed
because `trivial` produces no subgoals; you could put `sorry` or `apply I_don't_exist`
or anything else there and no error would result.

A common source of such things is `simp <;> tac` in the case that `simp` improves and
closes a subgoal that was previously being closed by `tac`.
-/
register_option linter.unreachableTactic : Bool := {
  defValue := true
  descr := "enable the 'unreachable tactic' linter"
}

namespace UnreachableTactic
/-- Gets the value of the `linter.unreachableTactic` option. -/
def getLinterUnreachableTactic (o : LinterOptions) : Bool :=
  getLinterValue linter.unreachableTactic o

/-- The monad for collecting used tactic syntaxes. -/
abbrev M := StateRefT (Std.HashMap String.Range Syntax) IO

/--
A list of blacklisted syntax kinds, which are expected to have subterms that contain
unevaluated tactics.
-/
initialize ignoreTacticKindsRef : IO.Ref NameHashSet ←
  IO.mkRef <| (∅ : NameHashSet)
    |>.insert ``Parser.Term.binderTactic
    |>.insert ``Lean.Parser.Term.dynamicQuot
    |>.insert ``Lean.Parser.Tactic.quotSeq
    |>.insert ``Lean.Parser.Tactic.tacticStop_
    |>.insert ``Lean.Parser.Command.notation
    |>.insert ``Lean.Parser.Command.mixfix
    |>.insert ``Lean.Parser.Tactic.discharger

/-- Is this a syntax kind that contains intentionally unevaluated tactic subterms? -/
def isIgnoreTacticKind (ignoreTacticKinds : NameHashSet) (k : SyntaxNodeKind) : Bool :=
  match k with
  | .str _ "quot" => true
  | _ => ignoreTacticKinds.contains k

/--
Adds a new syntax kind whose children will be ignored by the `unreachableTactic` linter.
This should be called from an `initialize` block.
-/
def addIgnoreTacticKind (kind : SyntaxNodeKind) : IO Unit :=
  ignoreTacticKindsRef.modify (·.insert kind)

variable (ignoreTacticKinds : NameHashSet) (isTacKind : SyntaxNodeKind → Bool) in
/-- Accumulates the set of tactic syntaxes that should be evaluated at least once. -/
@[specialize] partial def getTactics (stx : Syntax) : M Unit := do
  if let .node _ k args := stx then
    if !isIgnoreTacticKind ignoreTacticKinds k then
      args.forM getTactics
    if isTacKind k then
      if let some r := stx.getRange? true then
        modify fun m => m.insert r stx

mutual
variable (isTacKind : SyntaxNodeKind → Bool)
/-- Search for tactic executions in the info tree and remove executed tactic syntaxes. -/
partial def eraseUsedTacticsList (trees : PersistentArray InfoTree) : M Unit :=
  trees.forM eraseUsedTactics

/-- Search for tactic executions in the info tree and remove executed tactic syntaxes. -/
partial def eraseUsedTactics : InfoTree → M Unit
  | .node i c => do
    if let .ofTacticInfo i := i then
      if let some r := i.stx.getRange? true then
        modify (·.erase r)
    eraseUsedTacticsList c
  | .context _ t => eraseUsedTactics t
  | .hole _ => pure ()

end

@[inherit_doc Batteries.Linter.linter.unreachableTactic]
def unreachableTacticLinter : Linter where run := withSetOptionIn fun stx => do
  unless getLinterUnreachableTactic (← getLinterOptions) && (← getInfoState).enabled do
    return
  if (← get).messages.hasErrors then
    return
  let cats := (Parser.parserExtension.getState (← getEnv)).categories
  -- These lookups may fail when the linter is run in a fresh, empty environment
  let some tactics := Parser.ParserCategory.kinds <$> cats.find? `tactic
    | return
  let some convs := Parser.ParserCategory.kinds <$> cats.find? `conv
    | return
  let trees ← getInfoTrees
  let go : M Unit := do
    getTactics (← ignoreTacticKindsRef.get) (fun k => tactics.contains k || convs.contains k) stx
    eraseUsedTacticsList trees
  let (_, map) ← go.run {}
  let unreachable := map.toArray
  let key (r : String.Range) := (r.start.byteIdx, (-r.stop.byteIdx : Int))
  let mut last : String.Range := ⟨0, 0⟩
  for (r, stx) in let _ := @lexOrd; let _ := @ltOfOrd.{0}; unreachable.qsort (key ·.1 < key ·.1) do
    if stx.getKind ∈ [``Batteries.Tactic.unreachable, ``Batteries.Tactic.unreachableConv] then
      continue
    if last.start ≤ r.start && r.stop ≤ last.stop then continue
    logLint linter.unreachableTactic stx "this tactic is never executed"
    last := r

initialize addLinter unreachableTacticLinter



=== LEAN SOURCE: Alias.lean ===
/-
Copyright (c) 2017 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro, David Renshaw, François G. Dorais
-/
import Lean.Elab.Command
import Lean.Elab.DeclarationRange
import Lean.Compiler.NoncomputableAttr
import Lean.DocString
import Batteries.CodeAction.Deprecated

/-!
# The `alias` command

The `alias` command is used to create synonyms. The plain command can create a synonym of any
declaration. There is also a version to create synonyms for the forward and reverse implications of
an iff theorem.
-/

namespace Batteries.Tactic.Alias

open Lean Elab Parser.Command

/-- An alias can be in one of three forms -/
inductive AliasInfo where
  /-- Plain alias -/
  | plain (n : Name)
  /-- Forward direction of an iff alias -/
  | forward (n : Name)
  /-- Reverse direction of an iff alias -/
  | reverse (n : Name)
deriving Inhabited

/-- The name underlying an alias target -/
def AliasInfo.name : AliasInfo → Name
  | plain n => n
  | forward n => n
  | reverse n => n

/-- The docstring for an alias. -/
def AliasInfo.toString : AliasInfo → String
  | plain n => s!"**Alias** of `{n}`."
  | forward n => s!"**Alias** of the forward direction of `{n}`."
  | reverse n => s!"**Alias** of the reverse direction of `{n}`."


/-- Environment extension for registering aliases -/
initialize aliasExt : SimpleScopedEnvExtension (Name × AliasInfo) (NameMap AliasInfo) ←
  registerSimpleScopedEnvExtension {
    addEntry := fun st (n, i) => st.insert n i
    initial := {}
  }

/-- Get the alias information for a name -/
def getAliasInfo [Monad m] [MonadEnv m] (name : Name) : m (Option AliasInfo) := do
  return aliasExt.getState (← getEnv) |>.find? name

/-- Set the alias info for a new declaration -/
def setAliasInfo [MonadEnv m] (info : AliasInfo) (declName : Name) : m Unit :=
  modifyEnv (aliasExt.addEntry · (declName, info))

/-- Updates the `deprecated` declaration to point to `target` if no target is provided. -/
def setDeprecatedTarget (target : Name) (arr : Array Attribute) : Array Attribute × Bool :=
  StateT.run (m := Id) (s := false) do
    arr.mapM fun s => do
      if s.name == `deprecated then
        if let `(deprecated| deprecated%$tk $[$desc:str]? $[(since := $since)]?) := s.stx then
          set true
          let stx := Unhygienic.run
            `(deprecated| deprecated%$tk $(mkCIdent target) $[$desc:str]? $[(since := $since)]?)
          pure { s with stx }
        else pure s
      else pure s

/--
  The command `alias name := target` creates a synonym of `target` with the given name.

  The command `alias ⟨fwd, rev⟩ := target` creates synonyms for the forward and reverse directions
  of an iff theorem. Use `_` if only one direction is required.

  These commands accept all modifiers and attributes that `def` and `theorem` do.
 -/
elab (name := alias) mods:declModifiers "alias " alias:ident " := " name:ident : command =>
  Command.liftTermElabM do
    let name ← realizeGlobalConstNoOverloadWithInfo name
    let cinfo ← getConstInfo name
    let declMods ← elabModifiers mods
    let (attrs, machineApplicable) := setDeprecatedTarget name declMods.attrs
    let declMods := { declMods with
      computeKind :=
        if isNoncomputable (← getEnv) name then .noncomputable
        else declMods.computeKind
      isUnsafe := declMods.isUnsafe || cinfo.isUnsafe
      attrs
    }
    let (declName, _) ← mkDeclName (← getCurrNamespace) declMods alias.getId
    let decl : Declaration := if let .thmInfo t := cinfo then
      .thmDecl { t with
        name := declName
        value := mkConst name (t.levelParams.map mkLevelParam)
      }
    else
      .defnDecl { cinfo.toConstantVal with
        name := declName
        value := mkConst name (cinfo.levelParams.map mkLevelParam)
        hints := .regular 0 -- FIXME
        safety := if declMods.isUnsafe then .unsafe else .safe
      }
    checkNotAlreadyDeclared declName
    if declMods.isNoncomputable then
      addDecl decl
    else
      addAndCompile decl
    addDeclarationRangesFromSyntax declName (← getRef) alias
    Term.addTermInfo' alias (← mkConstWithLevelParams declName) (isBinder := true)
    addDocString' declName declMods.docString?
    enableRealizationsForConst declName
    Term.applyAttributes declName declMods.attrs
    let info := (← getAliasInfo name).getD <| AliasInfo.plain name
    setAliasInfo info declName
    if machineApplicable then
      modifyEnv (machineApplicableDeprecated.tag · declName)
    /- alias doesn't trigger the missing docs linter so we add a default. We can't just check
      `declMods` because a docstring may have been added by an attribute. -/
    if (← findDocString? (← getEnv) declName).isNone then
      let mut doc := info.toString
      if let some origDoc ← findDocString? (← getEnv) name then
        doc := s!"{doc}\n\n---\n\n{origDoc}"
      addDocStringCore declName doc

/--
Given a possibly forall-quantified iff expression `prf`, produce a value for one
of the implication directions (determined by `mp`).
-/
def mkIffMpApp (mp : Bool) (ty prf : Expr) : MetaM Expr := do
  Meta.forallTelescope ty fun xs ty => do
    let some (lhs, rhs) := ty.iff?
      | throwError "Target theorem must have the form `∀ x y z, a ↔ b`"
    Meta.mkLambdaFVars xs <|
      mkApp3 (mkConst (if mp then ``Iff.mp else ``Iff.mpr)) lhs rhs (mkAppN prf xs)

private def addSide (mp : Bool) (declName : Name) (declMods : Modifiers) (thm : TheoremVal) :
    TermElabM Unit := do
  checkNotAlreadyDeclared declName
  let value ← mkIffMpApp mp thm.type thm.value
  let type ← Meta.inferType value
  addDecl <| Declaration.thmDecl { thm with
    name := declName
    value := value
    type := type
  }
  addDocString' declName declMods.docString?
  Term.applyAttributes declName declMods.attrs
  let info := match ← getAliasInfo thm.name with
    | some (.plain name) => if mp then AliasInfo.forward name else AliasInfo.reverse name
    | _ => if mp then AliasInfo.forward thm.name else AliasInfo.reverse thm.name
  setAliasInfo info declName
  /- alias doesn't trigger the missing docs linter so we add a default. We can't just check
    `declMods` because a docstring may have been added by an attribute. -/
  if (← findDocString? (← getEnv) declName).isNone then
    let mut doc := info.toString
    if let some origDoc ← findDocString? (← getEnv) thm.name then
      doc := s!"{doc}\n\n---\n\n{origDoc}"
    addDocStringCore declName doc

@[inherit_doc «alias»]
elab (name := aliasLR) mods:declModifiers "alias "
    "⟨" aliasFwd:binderIdent ", " aliasRev:binderIdent "⟩" " := " name:ident : command =>
  Command.liftTermElabM do
    let name ← realizeGlobalConstNoOverloadWithInfo name
    let declMods ← elabModifiers mods
    let declMods := { declMods with attrs := (setDeprecatedTarget name declMods.attrs).1 }
    let .thmInfo thm ← getConstInfo name | throwError "Target must be a theorem"
    if let `(binderIdent| $idFwd:ident) := aliasFwd then
      let (declName, _) ← mkDeclName (← getCurrNamespace) declMods idFwd.getId
      addSide true declName declMods thm
      addDeclarationRangesFromSyntax declName (← getRef) idFwd
      Term.addTermInfo' idFwd (← mkConstWithLevelParams declName) (isBinder := true)
    if let `(binderIdent| $idRev:ident) := aliasRev then
      let (declName, _) ← mkDeclName (← getCurrNamespace) declMods idRev.getId
      addSide false declName declMods thm
      addDeclarationRangesFromSyntax declName (← getRef) idRev
      Term.addTermInfo' idRev (← mkConstWithLevelParams declName) (isBinder := true)



=== LEAN SOURCE: Basic.lean ===
import Lean.Elab.Tactic.ElabTerm
import Batteries.Linter
import Batteries.Tactic.Init
import Batteries.Tactic.SeqFocus
import Batteries.Util.ProofWanted

-- This is an import only file for common tactics used throughout Batteries



=== LEAN SOURCE: Case.lean ===
/-
Copyright (c) 2023 Kyle Miller. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kyle Miller
-/
import Lean.Elab.Tactic.BuiltinTactic

/-!
# Extensions to the `case` tactic

Adds a variant of `case` that looks for a goal with a particular type, rather than a goal
with a particular tag.
For consistency with `case`, it takes a tag as well, but the tag can be a hole `_`.

Also adds `case'` extensions.
-/

namespace Batteries.Tactic
open Lean Meta Elab Tactic

/-- Clause for a `case ... : ...` tactic. -/
syntax casePattArg := Parser.Tactic.caseArg (" : " term)?

/-- The body of a `case ... | ...` tactic that's a tactic sequence (or hole). -/
syntax casePattTac := " => " (hole <|> syntheticHole <|> tacticSeq)

/-- The body of a `case ... | ...` tactic that's an exact term. -/
syntax casePattExpr := " := " colGt term

/-- The body of a `case ... : ...` tactic. -/
syntax casePattBody := casePattTac <|> casePattExpr

/--
* `case _ : t => tac` finds the first goal that unifies with `t` and then solves it
  using `tac` or else fails. Like `show`, it changes the type of the goal to `t`.
  The `_` can optionally be a case tag, in which case it only looks at goals
  whose tag would be considered by `case` (goals with an exact tag match,
  followed by goals with the tag as a suffix, followed by goals with the tag as a prefix).

* `case _ n₁ ... nₘ : t => tac` additionally names the `m` most recent hypotheses with
  inaccessible names to the given names. The names are renamed before matching against `t`.
  The `_` can optionally be a case tag.

* `case _ : t := e` is short for `case _ : t => exact e`.

* `case _ : t₁ | _ : t₂ | ... => tac`
  is equivalent to `(case _ : t₁ => tac); (case _ : t₂ => tac); ...`
  but with all matching done on the original list of goals --
  each goal is consumed as they are matched, so patterns may repeat or overlap.

* `case _ : t` will make the matched goal be the first goal.
  `case _ : t₁ | _ : t₂ | ...` makes the matched goals be the first goals in the given order.

* `case _ : t := _` and `case _ : t := ?m` are the same as `case _ : t` but in the `?m` case the
  goal tag is changed to `m`.
  In particular, the goal becomes metavariable `?m`.
-/
-- Low priority so that type-free `case` doesn't conflict with core `case`,
-- though it should be a drop-in replacement.
syntax (name := casePatt) (priority := low)
  "case " sepBy1(casePattArg, " | ") (casePattBody)? : tactic

macro_rules
  | `(tactic| case $[$ps:casePattArg]|* := $t) => `(tactic| case $[$ps:casePattArg]|* => exact $t)
  | `(tactic| case $[$ps:casePattArg]|*) => `(tactic| case $[$ps:casePattArg]|* => ?_)

/-- `case' _ : t => tac` is similar to the `case _ : t => tac` tactic,
but it does not ensure the goal has been solved after applying `tac`,
nor does it admit the goal if `tac` failed.
Recall that `case` closes the goal using `sorry` when `tac` fails,
and the tactic execution is not interrupted. -/
syntax (name := casePatt') (priority := low)
  "case' " sepBy1(casePattArg, " | ") casePattTac : tactic

/-- Filter the `mvarIds` by tag. Returns those `MVarId`s that have `tag`
either as its user name, as a suffix of its user name, or as a prefix of its user name.
The results are sorted in this order.
This is like `Lean.Elab.Tactic.findTag?` but it returns all results rather than just the first. -/
private def filterTag (mvarIds : List MVarId) (tag : Name) : TacticM (List MVarId) := do
  let gs ← mvarIds.toArray.filterMapM fun mvarId => do
    let userName := (← mvarId.getDecl).userName
    if tag == userName then
      return some (0, mvarId)
    else if tag.isSuffixOf userName then
      return some (1, mvarId)
    else if tag.isPrefixOf userName then
      return some (2, mvarId)
    else
      return none
  -- Insertion sort is a stable sort:
  let gs := gs.insertionSort (·.1 < ·.1)
  return gs |>.map (·.2) |>.toList

/-- Find the first goal among those matching `tag` whose type unifies with `patt`.
The `renameI` array consists of names to use to rename inaccessibles.
The `patt` term is elaborated in the context where the inaccessibles have been renamed.

Returns the found goal, goals caused by elaborating `patt`, and the remaining goals. -/
def findGoalOfPatt (gs : List MVarId)
    (tag : TSyntax ``binderIdent) (patt? : Option Term) (renameI : TSyntaxArray `Lean.binderIdent) :
    TacticM (MVarId × List MVarId × List MVarId) :=
  Term.withoutErrToSorry do
    let fgs ← match tag with
      | `(binderIdent|$tag:ident) => filterTag gs tag.getId
      | _ => pure gs
    for g in fgs do
      let gs := gs.erase g
      if let some patt := patt? then
        let s ← saveState
        try
          let g ← renameInaccessibles g renameI
          -- Make a copy of `g` so that we don't assign type hints to `g` if we don't need to.
          let gCopy ← g.withContext <| mkFreshExprSyntheticOpaqueMVar (← g.getType) (← g.getTag)
          let g' :: gs' ← run gCopy.mvarId! <| withoutRecover <|
                            evalTactic (← `(tactic| refine_lift show $patt from ?_))
            | throwNoGoalsToBeSolved -- This should not happen
          -- Avoid assigning the type hint if the original type and the new type are
          -- defeq at reducible transparency.
          if ← g.withContext <| withReducible <| isDefEq (← g.getType) (← g'.getType) then
            g.assign (.mvar g')
          else
            g.assign gCopy
          return (g', gs', gs)
        catch _ =>
          restoreState s
      else
        let g ← renameInaccessibles g renameI
        return (g, [], gs)
    throwError "\
      No goals with tag {tag} unify with the term {patt?.getD (← `(_))}, \
      or too many names provided for renaming inaccessible variables."

/-- Given a `casePattBody`, either give a synthetic hole or a tactic sequence
(along with the syntax for the `=>`).
Converts holes into synthetic holes since they are processed with `elabTermWithHoles`. -/
def processCasePattBody (stx : TSyntax ``casePattTac) :
    TacticM (Term ⊕ (Syntax × TSyntax ``Parser.Tactic.tacticSeq)) := do
  match stx with
  | `(casePattTac| => $t:hole) => return Sum.inl ⟨← withRef t `(?_)⟩
  | `(casePattTac| => $t:syntheticHole) => return Sum.inl ⟨t⟩
  | `(casePattTac| =>%$arr $tac:tacticSeq) => return Sum.inr (arr, tac)
  | _ => throwUnsupportedSyntax

/-- Implementation for `case` and `case'`. -/
def evalCase (close : Bool) (stx : Syntax)
    (tags : Array (TSyntax `Lean.binderIdent))
    (hss : Array (TSyntaxArray `Lean.binderIdent))
    (patts? : Array (Option Term))
    (caseBody : TSyntax `Batteries.Tactic.casePattTac) :
    TacticM Unit := do
  let body ← processCasePattBody caseBody
  -- Accumulated goals in the hole cases.
  let mut acc : List MVarId := []
  -- Accumulated goals from refining patterns
  let mut pattref : List MVarId := []
  for tag in tags, hs in hss, patt? in patts? do
    let (g, gs', gs) ← findGoalOfPatt (← getUnsolvedGoals) tag patt? hs
    setGoals gs
    pattref := pattref ++ gs'
    match body with
    | Sum.inl hole =>
      let gs' ← run g <| withRef hole do
        let (val, gs') ← elabTermWithHoles hole (← getMainTarget) `case
        unless ← occursCheck g val do
          throwError "\
            'case' tactic failed, value{indentExpr val}\n\
            depends on the main goal metavariable '{Expr.mvar g}'"
        g.assign val
        setGoals gs'
      acc := acc ++ gs'
    | Sum.inr (arr, tac) =>
      if close then
        if tag matches `(binderIdent|$_:ident) then
          -- If a tag is provided, follow the behavior of the core `case` tactic and clear the tag.
          g.setTag .anonymous
        discard <| run g do
          withCaseRef arr tac do
            closeUsingOrAdmit (withTacticInfoContext stx (evalTactic tac))
      else
        let mvarTag ← g.getTag
        let gs' ← run g <| withCaseRef arr tac (evalTactic tac)
        if let [g'] := gs' then
          -- If a single goal is remaining, follow the core `case'` tactic and preserve the tag.
          g'.setTag mvarTag
        acc := acc ++ gs'
  setGoals (acc ++ pattref ++ (← getUnsolvedGoals))

elab_rules : tactic
  | `(tactic| case $[$tags $hss* $[: $patts?]?]|* $caseBody:casePattTac) => do
    evalCase (close := true) (← getRef) tags hss patts? caseBody

elab_rules : tactic
  | `(tactic| case' $[$tags $hss* $[: $patts?]?]|* $caseBody:casePattTac) => do
    evalCase (close := false) (← getRef) tags hss patts? caseBody



=== LEAN SOURCE: Congr.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro, Miyahara Kō
-/
import Lean.Meta.Tactic.Congr
import Lean.Elab.Tactic.Config
import Lean.Elab.Tactic.Ext

/-! # `congr with` tactic, `rcongr` tactic -/

namespace Batteries.Tactic
open Lean Meta Elab Tactic

/-- Configuration options for `congr` & `rcongr` -/
structure Congr.Config where
  /-- If `closePre := true`, it will attempt to close new goals using `Eq.refl`, `HEq.refl`, and
  `assumption` with reducible transparency. -/
  closePre : Bool := true
  /-- If `closePost := true`, it will try again on goals on which `congr` failed to make progress
  with default transparency. -/
  closePost : Bool := true

/-- Function elaborating `Congr.Config` -/
declare_config_elab Congr.elabConfig Congr.Config

@[inherit_doc Lean.Parser.Tactic.congr]
syntax (name := congrConfig) "congr" Parser.Tactic.config (ppSpace num)? : tactic

/--
Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ f as ≍ f bs`.
* `congr n` controls the depth of the recursive applications.
  This is useful when `congr` is too aggressive in breaking down the goal.
  For example, given `⊢ f (g (x + y)) = f (g (y + x))`,
  `congr` produces the goals `⊢ x = y` and `⊢ y = x`,
  while `congr 2` produces the intended `⊢ x + y = y + x`.
* If, at any point, a subgoal matches a hypothesis then the subgoal will be closed.
* You can use `congr with p (: n)?` to call `ext p (: n)?` to all subgoals generated by `congr`.
  For example, if the goal is `⊢ f '' s = g '' s` then `congr with x` generates the goal
  `x : α ⊢ f x = g x`.
-/
syntax (name := congrConfigWith) "congr" (Parser.Tactic.config)? (ppSpace colGt num)?
  " with" (ppSpace colGt rintroPat)* (" : " num)? : tactic

elab_rules : tactic
  | `(tactic| congr $cfg:config $[$n?]?) => do
    let config ← Congr.elabConfig (mkOptionalNode cfg)
    let hugeDepth := 1000000
    let depth := n?.map (·.getNat) |>.getD hugeDepth
    liftMetaTactic fun mvarId =>
      mvarId.congrN depth (closePre := config.closePre) (closePost := config.closePost)

macro_rules
  | `(tactic| congr $(cfg)? $(depth)? with $ps* $[: $n]?) =>
    match cfg with
    | none => `(tactic| congr $(depth)? <;> ext $ps* $[: $n]?)
    | some cfg => `(tactic| congr $cfg $(depth)? <;> ext $ps* $[: $n]?)

/--
Recursive core of `rcongr`. Calls `ext pats <;> congr` and then itself recursively,
unless `ext pats <;> congr` made no progress.
-/
partial def rcongrCore (g : MVarId) (config : Congr.Config) (pats : List (TSyntax `rcasesPat))
    (acc : Array MVarId) : TermElabM (Array MVarId) := do
  let mut acc := acc
  for (g, qs) in (← Ext.extCore g pats (failIfUnchanged := false)).2 do
    let s ← saveState
    let gs ← g.congrN 1000000 (closePre := config.closePre) (closePost := config.closePost)
    if ← not <$> g.isAssigned <||> gs.anyM fun g' => return (← g'.getType).eqv (← g.getType) then
      s.restore
      acc := acc.push g
    else
      for g in gs do
        acc ← rcongrCore g config qs acc
  pure acc

/--
Repeatedly apply `congr` and `ext`, using the given patterns as arguments for `ext`.

There are two ways this tactic stops:
* `congr` fails (makes no progress), after having already applied `ext`.
* `congr` canceled out the last usage of `ext`. In this case, the state is reverted to before
  the `congr` was applied.

For example, when the goal is
```
⊢ (fun x => f x + 3) '' s = (fun x => g x + 3) '' s
```
then `rcongr x` produces the goal
```
x : α ⊢ f x = g x
```
This gives the same result as `congr; ext x; congr`.

In contrast, `congr` would produce
```
⊢ (fun x => f x + 3) = (fun x => g x + 3)
```
and `congr with x` (or `congr; ext x`) would produce
```
x : α ⊢ f x + 3 = g x + 3
```
-/
elab (name := rcongr) "rcongr" cfg:((Parser.Tactic.config)?) ps:(ppSpace colGt rintroPat)* :
    tactic => do
  let gs ← rcongrCore (← getMainGoal) (← Congr.elabConfig cfg)
    (RCases.expandRIntroPats ps).toList #[]
  replaceMainGoal gs.toList



=== LEAN SOURCE: Exact.lean ===
/-
Copyright (c) 2023 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Batteries.Tactic.Alias

/-! # `exact` tactic (`MetaM` version) -/

open Lean Meta

/--
`MetaM` version of `Lean.Elab.Tactic.evalExact`: add `mvarId := x` to the metavariable assignment.
This method wraps `Lean.MVarId.assign`, checking whether `mvarId` is already assigned, and whether
the expression has the right type. -/
def Lean.MVarId.assignIfDefEq (g : MVarId) (e : Expr) : MetaM Unit := do
  guard <| ← isDefEq (← g.getType) (← inferType e)
  g.checkNotAssigned `assignIfDefEq
  g.assign e

@[deprecated (since := "2025-04-09")]
alias Lean.MVarId.assignIfDefeq := Lean.MVarId.assignIfDefEq



=== LEAN SOURCE: HelpCmd.lean ===
/-
Copyright (c) 2024 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro, Edward van de Meent
-/
import Lean.Elab.Syntax
import Lean.DocString
import Batteries.Util.LibraryNote

/-!

# The `#help` command

The `#help` command can be used to list all definitions in a variety of extensible aspects of lean.

* `#help option` lists options (used in `set_option myOption`)
* `#help attr` lists attributes (used in `@[myAttr] def foo := ...`)
* `#help cats` lists syntax categories (like `term`, `tactic`, `stx` etc)
* `#help cat C` lists elements of syntax category C
  * `#help term`, `#help tactic`, `#help conv`, `#help command`
    are shorthand for `#help cat term` etc.
  * `#help cat+ C` also shows `elab` and `macro` definitions associated to the syntaxes
* `#help note "some note"` lists library notes for which "some note" is a prefix of the label

Most forms take an optional identifier to narrow the search; for example `#help option pp` shows
only `pp.*` options. However, `#help cat` makes the identifier mandatory, while `#help note` takes
a mandatory string literal, rather than an identifier.

-/

namespace Batteries.Tactic
open Lean Meta Elab Tactic Command

/--
The command `#help option` shows all options that have been defined in the current environment.
Each option has a format like:
```
option pp.all : Bool := false
  (pretty printer) display coercions, implicit parameters, proof terms, fully qualified names,
  universe, and disable beta reduction and notations during pretty printing
```
This says that `pp.all` is an option which can be set to a `Bool` value, and the default value is
`false`. If an option has been modified from the default using e.g. `set_option pp.all true`,
it will appear as a `(currently: true)` note next to the option.

The form `#help option id` will show only options that begin with `id`.
-/
syntax withPosition("#help " colGt &"option" (colGt ppSpace Parser.rawIdent)?) : command

private def elabHelpOption (id : Option Ident) : CommandElabM Unit := do
  let id := id.map (·.raw.getId.toString false)
  let mut decls : Lean.RBMap _ _ compare := {}
  for (name, decl) in show Lean.RBMap .. from ← getOptionDecls do
    let name := name.toString false
    if let some id := id then
      if !id.isPrefixOf name then
        continue
    decls := decls.insert name decl
  let mut msg := Format.nil
  let opts ← getOptions
  if decls.isEmpty then
    match id with
    | some id => throwError "no options start with {id}"
    | none => throwError "no options found (!)"
  for (name, decl) in decls do
    let mut msg1 := match decl.defValue with
    | .ofString val => s!"String := {repr val}"
    | .ofBool val => s!"Bool := {repr val}"
    | .ofName val => s!"Name := {repr val}"
    | .ofNat val => s!"Nat := {repr val}"
    | .ofInt val => s!"Int := {repr val}"
    | .ofSyntax val => s!"Syntax := {repr val}"
    if let some val := opts.find (.mkSimple name) then
      msg1 := s!"{msg1} (currently: {val})"
    msg := msg ++ .nest 2 (f!"option {name} : {msg1}" ++ .line ++ decl.descr) ++ .line ++ .line
  logInfo msg

elab_rules : command | `(#help option $(id)?) => elabHelpOption id

/--
The command `#help attribute` (or the short form `#help attr`) shows all attributes that have been
defined in the current environment.
Each attribute has a format like:
```
[inline]: mark definition to always be inlined
```
This says that `inline` is an attribute that can be placed on definitions like
`@[inline] def foo := 1`. (Individual attributes may have restrictions on where they can be
applied; see the attribute's documentation for details.) Both the attribute's `descr` field as well
as the docstring will be displayed here.

The form `#help attr id` will show only attributes that begin with `id`.
-/
syntax withPosition("#help " colGt (&"attr" <|> &"attribute")
    (colGt ppSpace Parser.rawIdent)?) : command

private def elabHelpAttr (id : Option Ident) : CommandElabM Unit := do
  let id := id.map (·.raw.getId.toString false)
  let mut decls : Lean.RBMap _ _ compare := {}
  /-
  #adaptation_note
  On nightly-2024-06-21, added the `.toList` here:
  without it the requisite `ForIn` instance can't be found.
  -/
  for (name, decl) in (← attributeMapRef.get).toList do
    let name := name.toString false
    if let some id := id then
      if !id.isPrefixOf name then
        continue
    decls := decls.insert name decl
  let mut msg := Format.nil
  let env ← getEnv
  if decls.isEmpty then
    match id with
    | some id => throwError "no attributes start with {id}"
    | none => throwError "no attributes found (!)"
  for (name, decl) in decls do
    let mut msg1 := s!"[{name}]: {decl.descr}"
    if let some doc ← findDocString? env decl.ref then
      msg1 := s!"{msg1}\n{doc.trim}"
    msg := msg ++ .nest 2 msg1 ++ .line ++ .line
  logInfo msg

elab_rules : command
  | `(#help attr $(id)?) => elabHelpAttr id
  | `(#help attribute $(id)?) => elabHelpAttr id

/-- Gets the initial string token in a parser description. For example, for a declaration like
`syntax "bla" "baz" term : tactic`, it returns `some "bla"`. Returns `none` for syntax declarations
that don't start with a string constant. -/
partial def getHeadTk (e : Expr) : Option String :=
  match e.getAppFnArgs with
  | (``ParserDescr.node, #[_, _, p])
  | (``ParserDescr.trailingNode, #[_, _, _, p])
  | (``ParserDescr.unary, #[.app _ (.lit (.strVal "withPosition")), p])
  | (``ParserDescr.unary, #[.app _ (.lit (.strVal "atomic")), p])
  | (``ParserDescr.unary, #[.app _ (.lit (.strVal "ppRealGroup")), p])
  | (``ParserDescr.unary, #[.app _ (.lit (.strVal "ppRealFill")), p])
  | (``Parser.ppRealFill, #[p])
  | (``Parser.withAntiquot, #[_, p])
  | (``Parser.leadingNode, #[_, _, p])
  | (``Parser.trailingNode, #[_, _, _, p])
  | (``Parser.group, #[p])
  | (``Parser.withCache, #[_, p])
  | (``Parser.withResetCache, #[p])
  | (``Parser.withPosition, #[p])
  | (``Parser.withOpen, #[p])
  | (``Parser.withPositionAfterLinebreak, #[p])
  | (``Parser.suppressInsideQuot, #[p])
  | (``Parser.ppRealGroup, #[p])
  | (``Parser.ppIndent, #[p])
  | (``Parser.ppDedent, #[p])
    => getHeadTk p
  | (``ParserDescr.binary, #[.app _ (.lit (.strVal "andthen")), p, q])
  | (``HAndThen.hAndThen, #[_, _, _, _, p, .lam _ _ q _])
    => getHeadTk p <|> getHeadTk q
  | (``ParserDescr.nonReservedSymbol, #[.lit (.strVal tk), _])
  | (``ParserDescr.symbol, #[.lit (.strVal tk)])
  | (``Parser.nonReservedSymbol, #[.lit (.strVal tk), _])
  | (``Parser.symbol, #[.lit (.strVal tk)])
  | (``Parser.unicodeSymbol, #[.lit (.strVal tk), _])
    => pure tk
  | _ => none

/--
The command `#help cats` shows all syntax categories that have been defined in the
current environment.
Each syntax has a format like:
```
category command [Lean.Parser.initFn✝]
```
The name of the syntax category in this case is `command`, and `Lean.Parser.initFn✝` is the
name of the declaration that introduced it. (It is often an anonymous declaration like this,
but you can click to go to the definition.) It also shows the doc string if available.

The form `#help cats id` will show only syntax categories that begin with `id`.
-/
syntax withPosition("#help " colGt &"cats" (colGt ppSpace Parser.rawIdent)?) : command

private def elabHelpCats (id : Option Ident) : CommandElabM Unit := do
  let id := id.map (·.raw.getId.toString false)
  let mut decls : Lean.RBMap _ _ compare := {}
  for (name, cat) in (Parser.parserExtension.getState (← getEnv)).categories do
    let name := name.toString false
    if let some id := id then
      if !id.isPrefixOf name then
        continue
    decls := decls.insert name cat
  let mut msg := MessageData.nil
  let env ← getEnv
  if decls.isEmpty then
    match id with
    | some id => throwError "no syntax categories start with {id}"
    | none => throwError "no syntax categories found (!)"
  for (name, cat) in decls do
    let mut msg1 := m!"category {name} [{mkConst cat.declName}]"
    if let some doc ← findDocString? env cat.declName then
      msg1 := msg1 ++ Format.line ++ doc.trim
    msg := msg ++ .nest 2 msg1 ++ (.line ++ .line : Format)
  logInfo msg

elab_rules : command | `(#help cats $(id)?) => elabHelpCats id

/--
The command `#help cat C` shows all syntaxes that have been defined in syntax category `C` in the
current environment.
Each syntax has a format like:
```
syntax "first"... [Parser.tactic.first]
  `first | tac | ...` runs each `tac` until one succeeds, or else fails.
```
The quoted string is the leading token of the syntax, if applicable. It is followed by the full
name of the syntax (which you can also click to go to the definition), and the documentation.

* The form `#help cat C id` will show only attributes that begin with `id`.
* The form `#help cat+ C` will also show information about any `macro`s and `elab`s
  associated to the listed syntaxes.
-/
syntax withPosition("#help " colGt &"cat" "+"? colGt ident
    (colGt ppSpace (Parser.rawIdent <|> str))?) : command

private def elabHelpCat (more : Option Syntax) (catStx : Ident) (id : Option String) :
    CommandElabM Unit := do
  let mut decls : Lean.RBMap _ _ compare := {}
  let mut rest : Lean.RBMap _ _ compare := {}
  let catName := catStx.getId.eraseMacroScopes
  let some cat := (Parser.parserExtension.getState (← getEnv)).categories.find? catName
    | throwErrorAt catStx "{catStx} is not a syntax category"
  liftTermElabM <| Term.addCategoryInfo catStx catName
  let env ← getEnv
  for (k, _) in cat.kinds do
    let mut used := false
    if let some tk := do getHeadTk (← (← env.find? k).value?) then
      let tk := tk.trim
      if let some id := id then
        if !id.isPrefixOf tk then
          continue
      used := true
      decls := decls.insert tk ((decls.findD tk #[]).push k)
    if !used && id.isNone then
      rest := rest.insert (k.toString false) k
  let mut msg := MessageData.nil
  if decls.isEmpty && rest.isEmpty then
    match id with
    | some id => throwError "no {catName} declarations start with {id}"
    | none => throwError "no {catName} declarations found"
  let env ← getEnv
  let addMsg (k : SyntaxNodeKind) (msg msg1 : MessageData) : CommandElabM MessageData := do
    let mut msg1 := msg1
    if let some doc ← findDocString? env k then
      msg1 := msg1 ++ Format.line ++ doc.trim
    msg1 := .nest 2 msg1
    if more.isSome then
      let addElabs {α} (type : String) (attr : KeyedDeclsAttribute α)
          (msg : MessageData) : CommandElabM MessageData := do
        let mut msg := msg
        for e in attr.getEntries env k do
          let x := e.declName
          msg := msg ++ Format.line ++ m!"+ {type} {mkConst x}"
          if let some doc ← findDocString? env x then
            msg := msg ++ .nest 2 (Format.line ++ doc.trim)
        pure msg
      msg1 ← addElabs "macro" macroAttribute msg1
      match catName with
      | `term => msg1 ← addElabs "term elab" Term.termElabAttribute msg1
      | `command => msg1 ← addElabs "command elab" commandElabAttribute msg1
      | `tactic | `conv => msg1 ← addElabs "tactic elab" tacticElabAttribute msg1
      | _ => pure ()
    return msg ++ msg1 ++ (.line ++ .line : Format)
  for (name, ks) in decls do
    for k in ks do
      msg ← addMsg k msg m!"syntax {repr name}... [{mkConst k}]"
  for (_, k) in rest do
    msg ← addMsg k msg m!"syntax ... [{mkConst k}]"
  logInfo msg

elab_rules : command
  | `(#help cat $[+%$more]? $cat) => elabHelpCat more cat none
  | `(#help cat $[+%$more]? $cat $id:ident) => elabHelpCat more cat (id.getId.toString false)
  | `(#help cat $[+%$more]? $cat $id:str) => elabHelpCat more cat id.getString

/--
format the string to be included in a single markdown bullet
-/
def _root_.String.makeBullet (s:String) := "* " ++ ("\n  ").intercalate (s.splitOn "\n")

open Lean Parser Batteries.Util.LibraryNote in
/--
`#help note "foo"` searches for all library notes whose
label starts with "foo", then displays those library notes sorted alphabetically by label,
grouped by label.
The command only displays the library notes that are declared in
imported files or in the same file above the line containing the command.
-/
elab "#help " colGt &"note" colGt ppSpace name:strLit : command => do
  let env ← getEnv

  -- get the library notes from both this and imported files
  let local_entries := (libraryNoteExt.getEntries env).reverse
  let imported_entries := (libraryNoteExt.toEnvExtension.getState env).importedEntries

  -- filter for the appropriate notes while casting to list
  let label_prefix := name.getString
  let imported_entries_filtered := imported_entries.flatten.toList.filterMap
    fun x => if label_prefix.isPrefixOf x.fst then some x else none
  let valid_entries := imported_entries_filtered ++ local_entries.filterMap
    fun x => if label_prefix.isPrefixOf x.fst then some x else none
  let grouped_valid_entries := valid_entries.mergeSort (·.fst ≤ ·.fst)
    |>.splitBy (·.fst == ·.fst)

  -- display results in a readable style
  if grouped_valid_entries.isEmpty then
    logError "Note not found"
  else
    logInfo <| "\n\n".intercalate <|
      grouped_valid_entries.map
        fun l => "library_note \"" ++ l.head!.fst ++ "\"\n" ++
          "\n\n".intercalate (l.map (·.snd.trim.makeBullet))

/--
The command `#help term` shows all term syntaxes that have been defined in the current environment.
See `#help cat` for more information.
-/
syntax withPosition("#help " colGt &"term" "+"?
    (colGt ppSpace (Parser.rawIdent <|> str))?) : command
macro_rules
  | `(#help term%$tk $[+%$more]? $(id)?) =>
    `(#help cat$[+%$more]? $(mkIdentFrom tk `term) $(id)?)

/--
The command `#help tactic` shows all tactics that have been defined in the current environment.
See `#help cat` for more information.
-/
syntax withPosition("#help " colGt &"tactic" "+"?
    (colGt ppSpace (Parser.rawIdent <|> str))?) : command
macro_rules
  | `(#help tactic%$tk $[+%$more]? $(id)?) =>
    `(#help cat$[+%$more]? $(mkIdentFrom tk `tactic) $(id)?)

/--
The command `#help conv` shows all tactics that have been defined in the current environment.
See `#help cat` for more information.
-/
syntax withPosition("#help " colGt &"conv" "+"?
    (colGt ppSpace (Parser.rawIdent <|> str))?) : command
macro_rules
  | `(#help conv%$tk $[+%$more]? $(id)?) =>
    `(#help cat$[+%$more]? $(mkIdentFrom tk `conv) $(id)?)

/--
The command `#help command` shows all commands that have been defined in the current environment.
See `#help cat` for more information.
-/
syntax withPosition("#help " colGt &"command" "+"?
    (colGt ppSpace (Parser.rawIdent <|> str))?) : command
macro_rules
  | `(#help command%$tk $[+%$more]? $(id)?) =>
    `(#help cat$[+%$more]? $(mkIdentFrom tk `command) $(id)?)



=== LEAN SOURCE: Init.lean ===
/-
Copyright (c) 2021 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Lean.Elab.Tactic.ElabTerm

/-!
# Simple tactics that are used throughout Batteries.
-/

namespace Batteries.Tactic
open Lean Parser.Tactic Elab Elab.Tactic Meta

/--
`_` in tactic position acts like the `done` tactic: it fails and gives the list
of goals if there are any. It is useful as a placeholder after starting a tactic block
such as `by _` to make it syntactically correct and show the current goal.
-/
macro "_" : tactic => `(tactic| {})

/--
Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.
-/
elab (name := exacts) "exacts " "[" hs:term,* "]" : tactic => do
  for stx in hs.getElems do
    evalTactic (← `(tactic| exact $stx))
  evalTactic (← `(tactic| done))

/--
`by_contra h` proves `⊢ p` by contradiction,
introducing a hypothesis `h : ¬p` and proving `False`.
* If `p` is a negation `¬q`, `h : q` will be introduced instead of `¬¬q`.
* If `p` is decidable, it uses `Decidable.byContradiction` instead of `Classical.byContradiction`.
* If `h` is omitted, the introduced variable `_: ¬p` will be anonymous.
-/
macro (name := byContra) tk:"by_contra" e?:(ppSpace colGt binderIdent)? : tactic => do
  let e := match e? with
    | some e => match e with
      | `(binderIdent| $e:ident) => e
      | e => Unhygienic.run `(_%$e) -- HACK: hover fails without Unhygienic here
    | none => Unhygienic.run `(_%$tk)
  `(tactic| first
    | guard_target = Not _; intro $e:term
    | refine @Decidable.byContradiction _ _ fun $e => ?_
    | refine @Classical.byContradiction _ fun $e => ?_)

/--
Given a proof `h` of `p`, `absurd h` changes the goal to `⊢ ¬ p`.
If `p` is a negation `¬q` then the goal is changed to `⊢ q` instead.
-/
macro "absurd " h:term : tactic =>
  -- we can't use `( :)` here as that would make `·` behave weirdly.
  `(tactic|
    first
    | refine @absurd _ _ ?_ $h
    | refine @absurd _ _ $h ?_)

/-- `split_ands` applies `And.intro` until it does not make progress. -/
syntax "split_ands" : tactic
macro_rules | `(tactic| split_ands) => `(tactic| repeat' refine And.intro ?_ ?_)

/--
`fapply e` is like `apply e` but it adds goals in the order they appear,
rather than putting the dependent goals first.
-/
elab "fapply " e:term : tactic =>
  evalApplyLikeTactic (·.apply (cfg := {newGoals := .all})) e

/--
`eapply e` is like `apply e` but it does not add subgoals for variables that appear
in the types of other goals. Note that this can lead to a failure where there are
no goals remaining but there are still metavariables in the term:
```
example (h : ∀ x : Nat, x = x → True) : True := by
  eapply h
  rfl
  -- no goals
-- (kernel) declaration has metavariables '_example'
```
-/
elab "eapply " e:term : tactic =>
  evalApplyLikeTactic (·.apply (cfg := {newGoals := .nonDependentOnly})) e

/-- Deprecated variant of `trivial`. -/
elab (name := triv) "triv" : tactic => throwError "`triv` has been removed; use `trivial` instead"

/-- `conv` tactic to close a goal using an equality theorem. -/
macro (name := Conv.exact) "exact " t:term : conv => `(conv| tactic => exact $t)

/-- The `conv` tactic `equals` claims that the currently focused subexpression is equal
 to the given expression, and proves this claim using the given tactic.
```
example (P : (Nat → Nat) → Prop) : P (fun n => n - n) := by
  conv in (_ - _) => equals 0 =>
    -- current goal: ⊢ n - n = 0
    apply Nat.sub_self
  -- current goal: P (fun n => 0)
```
-/
macro (name := Conv.equals) "equals " t:term " => " tac:tacticSeq : conv =>
  `(conv| tactic => show (_ = $t); next => $tac)



=== LEAN SOURCE: Instances.lean ===
/-
Copyright (c) 2023 Kyle Miller. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kyle Miller
-/
import Lean.Elab.Command
import Lean.PrettyPrinter

/-! # `#instances` command

The `#instances` command prints lists all instances that apply to the given type, if it is a class.
It is similar to `#synth` but it only does the very first step of the instance synthesis algorithm,
which is to enumerate potential instances.
-/

open Lean Elab Command Meta

namespace Batteries.Tactic.Instances

/-- `#instances term` prints all the instances for the given class.
For example, `#instances Add _` gives all `Add` instances, and `#instances Add Nat` gives the
`Nat` instance. The `term` can be any type that can appear in `[...]` binders.

Trailing underscores can be omitted, and `#instances Add` and `#instances Add _` are equivalent;
the command adds metavariables until the argument is no longer a function.

The `#instances` command is closely related to `#synth`, but `#synth` does the full
instance synthesis algorithm and `#instances` does the first step of finding potential instances. -/
elab (name := instancesCmd) tk:"#instances " stx:term : command => runTermElabM fun _ => do
  let type ← Term.elabTerm stx none
  -- Throw in missing arguments using metavariables.
  let (args, _, _) ← withDefault <| forallMetaTelescopeReducing (← inferType type)
  -- Use free variables for explicit quantifiers
  withDefault <| forallTelescopeReducing (mkAppN type args) fun _ type => do
    let some className ← isClass? type
      | throwErrorAt stx "type class instance expected{indentExpr type}"
    let globalInstances ← getGlobalInstancesIndex
    let result ← globalInstances.getUnify type
    let erasedInstances ← getErasedInstances
    let mut msgs := #[]
    for e in result.insertionSort fun e₁ e₂ => e₁.priority < e₂.priority do
      let Expr.const c _ := e.val | unreachable!
      if erasedInstances.contains c then
        continue
      let mut msg := m!"\n"
      if e.priority != 1000 then -- evalPrio default := 1000
        msg := msg ++ m!"(prio {e.priority}) "
      msgs := msgs.push <| msg ++ MessageData.signature c
    for linst in ← getLocalInstances do
      if linst.className == className then
        msgs := msgs.push m!"(local) {linst.fvar} : {← inferType linst.fvar}"
    if msgs.isEmpty then
      logInfoAt tk m!"No instances"
    else
      let instances := if msgs.size == 1 then "instance" else "instances"
      logInfoAt tk <| msgs.reverse.foldl (·++·) m!"{msgs.size} {instances}:\n"

@[inherit_doc instancesCmd]
macro tk:"#instances" bi:(ppSpace bracketedBinder)* " : " t:term : command =>
  `(command| variable $bi* in #instances%$tk $t)



=== LEAN SOURCE: Lemma.lean ===
/-
Copyright (c) 2024 Johan Commelin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin, Damiano Testa
-/
import Lean.Meta.Tactic.TryThis

/-!
#  Control for `lemma` command

The `lemma` command exists in `Mathlib`, but not in `Std`.

This file enforces the convention by introducing a code-action
to replace `lemma` by `theorem`.
-/

namespace Batteries.Tactic.Lemma

open Lean Elab.Command Meta.Tactic

/-- Enables the use of `lemma` as a synonym for `theorem` -/
register_option lang.lemmaCmd : Bool := {
  defValue := false
  descr := "enable the use of the `lemma` command as a synonym for `theorem`"
}

/-- Check whether `lang.lemmaCmd` option is enabled -/
def checkLangLemmaCmd (o : Options) : Bool := o.get `lang.lemmaCmd lang.lemmaCmd.defValue

/-- `lemma` is not supported, please use `theorem` instead -/
syntax (name := lemmaCmd) declModifiers
  group("lemma " declId ppIndent(declSig) declVal) : command

/-- Elaborator for the `lemma` command, if the option `lang.lemmaCmd` is false the command
emits a warning and code action instructing the user to use `theorem` instead.-/
@[command_elab «lemmaCmd»] def elabLemma : CommandElab := fun stx => do
  unless checkLangLemmaCmd (← getOptions) do
    let lemmaStx := stx[1][0]
    Elab.Command.liftTermElabM <|
      TryThis.addSuggestion lemmaStx { suggestion := "theorem" }
    logErrorAt lemmaStx
      "`lemma` is not supported by default, please use `theorem` instead.\n\
      Use `set_option lang.lemmaCmd true` to enable the use of the `lemma` command in a file.\n\
      Use the command line option `-Dlang.lemmaCmd=true` to enable the use of `lemma` globally."
  let out ← Elab.liftMacroM <| do
    let stx := stx.modifyArg 1 fun stx =>
      let stx := stx.modifyArg 0 (mkAtomFrom · "theorem" (canonical := true))
      stx.setKind ``Parser.Command.theorem
    pure <| stx.setKind ``Parser.Command.declaration
  Elab.Command.elabCommand out



=== LEAN SOURCE: Lint.lean ===
import Batteries.Tactic.Lint.Misc
import Batteries.Tactic.Lint.Simp
import Batteries.Tactic.Lint.TypeClass
import Batteries.Tactic.Lint.Frontend



=== LEAN SOURCE: NoMatch.lean ===
/-
Copyright (c) 2021 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Lean.DocString
import Lean.Elab.Tactic.Basic

/-!
Deprecation warnings for `match ⋯ with.`, `fun.`, `λ.`, and `intro.`.
-/
namespace Batteries.Tactic
open Lean Elab Term Tactic Parser.Term

/--
The syntax `match ⋯ with.` has been deprecated in favor of `nomatch ⋯`.

Both now support multiple discriminants.
-/
elab (name := matchWithDot) tk:"match " t:term,* " with" "." : term <= expectedType? => do
  logWarningAt tk (← findDocString? (← getEnv) ``matchWithDot).get!
  elabTerm (← `(nomatch%$tk $[$t],*)) expectedType?

/-- The syntax `fun.` has been deprecated in favor of `nofun`. -/
elab (name := funDot) tk:"fun" "." : term <= expectedType? => do
  logWarningAt tk (← findDocString? (← getEnv) ``funDot).get!
  elabTerm (← `(nofun)) expectedType?

/-- The syntax `λ.` has been deprecated in favor of `nofun`. -/
elab (name := lambdaDot) tk:"fun" "." : term <= expectedType? => do
  logWarningAt tk (← findDocString? (← getEnv) ``lambdaDot).get!
  elabTerm (← `(nofun)) expectedType?

@[inherit_doc matchWithDot]
macro "match " discrs:term,* " with" "." : tactic =>
  `(tactic| exact match $discrs,* with.)

/--
The syntax `intro.` is deprecated in favor of `nofun`.
-/
elab (name := introDot) tk:"intro" "." : tactic => do
  logWarningAt tk (← findDocString? (← getEnv) ``introDot).get!
  evalTactic (← `(tactic| nofun))



=== LEAN SOURCE: OpenPrivate.lean ===
/-
Copyright (c) 2021 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Lean.Elab.Command
import Lean.Util.FoldConsts
import Lean.Parser.Module

open Lean Parser.Tactic Elab Command

namespace Lean

/-- Collects the names of private declarations referenced in definition `n`. -/
def Meta.collectPrivateIn [Monad m] [MonadEnv m] [MonadError m]
  (n : Name) (set := NameSet.empty) : m NameSet := do
  let c ← getConstInfo n
  let traverse value := Expr.foldConsts value set fun c a =>
    if isPrivateName c then a.insert c else a
  if let some value := c.value? then return traverse value
  if let some c := (← getEnv).find? (n ++ `_cstage1) then
    if let some value := c.value? then return traverse value
  return traverse c.type

/-- Get the module index given a module name. -/
def Environment.moduleIdxForModule? (env : Environment) (mod : Name) : Option ModuleIdx :=
  (env.allImportedModuleNames.idxOf? mod).map fun idx => idx

instance : DecidableEq ModuleIdx := instDecidableEqNat

/-- Get the list of declarations in a module (referenced by index). -/
def Environment.declsInModuleIdx (env : Environment) (idx : ModuleIdx) : List Name :=
  env.const2ModIdx.fold (fun acc n i => if i = idx then n :: acc else acc) []

/-- Add info to the info tree corresponding to a module name. -/
def Elab.addModuleInfo [Monad m] [MonadInfoTree m] (stx : Ident) : m Unit := do
  -- HACK: The server looks specifically for ofCommandInfo nodes on `import` syntax
  -- to do go-to-def for modules, so we have to add something that looks like an import
  -- to the info tree. (Ideally this would be an `.ofModuleInfo` node instead.)
  pushInfoLeaf <| .ofCommandInfo {
    elaborator := `import
    stx := Unhygienic.run `(Parser.Module.import| import $stx) |>.raw.copyHeadTailInfoFrom stx
  }

namespace Elab.Command

/-- Core elaborator for `open private` and `export private`. -/
def elabOpenPrivateLike (ids : Array Ident) (tgts mods : Option (Array Ident))
  (f : (priv full user : Name) → CommandElabM Name) : CommandElabM Unit := do
  let mut names := NameSet.empty
  for tgt in tgts.getD #[] do
    let n ← liftCoreM <| realizeGlobalConstNoOverloadWithInfo tgt
    names ← Meta.collectPrivateIn n names
  for mod in mods.getD #[] do
    let some modIdx := (← getEnv).moduleIdxForModule? mod.getId
      | throwError "unknown module {mod}"
    addModuleInfo mod
    for declName in (← getEnv).declsInModuleIdx modIdx do
      if isPrivateName declName then
        names := names.insert declName
  let appendNames (msg : String) : String := Id.run do
    let mut msg := msg
    for c in names do
      if let some name := privateToUserName? c then
        msg := msg ++ s!"{name}\n"
    msg
  if ids.isEmpty && !names.isEmpty then
    logInfo (appendNames "found private declarations:\n")
  let mut decls := #[]
  for id in ids do
    let n := id.getId
    let mut found := []
    for c in names do
      if n.isSuffixOf c then
        addConstInfo id c
        found := c::found
    match found with
    | [] => throwError appendNames s!"'{n}' not found in the provided declarations:\n"
    | [c] =>
      if let some name := privateToUserName? c then
        let new ← f c name n
        decls := decls.push (OpenDecl.explicit n new)
      else unreachable!
    | _ => throwError s!"provided name is ambiguous: found {found.map privateToUserName?}"
  modifyScope fun scope => Id.run do
    let mut openDecls := scope.openDecls
    for decl in decls do
      openDecls := decl::openDecls
    { scope with openDecls := openDecls }

/--
The command `open private a b c in foo bar` will look for private definitions named `a`, `b`, `c`
in declarations `foo` and `bar` and open them in the current scope. This does not make the
definitions public, but rather makes them accessible in the current section by the short name `a`
instead of the (unnameable) internal name for the private declaration, something like
`_private.Other.Module.0.Other.Namespace.foo.a`, which cannot be typed directly because of the `0`
name component.

It is also possible to specify the module instead with
`open private a b c from Other.Module`.
-/
syntax (name := openPrivate) "open" ppSpace "private" (ppSpace ident)*
  (" in" (ppSpace ident)*)? (" from" (ppSpace ident)*)? : command

/-- Elaborator for `open private`. -/
@[command_elab openPrivate] def elabOpenPrivate : CommandElab
| `(open private $ids* $[in $tgts*]? $[from $mods*]?) =>
  elabOpenPrivateLike ids tgts mods fun c _ _ => pure c
| _ => throwUnsupportedSyntax

/--
The command `export private a b c in foo bar` is similar to `open private`, but instead of opening
them in the current scope it will create public aliases to the private definition. The definition
will exist at exactly the original location and name, as if the `private` keyword was not used
originally.

It will also open the newly created alias definition under the provided short name, like
`open private`.
It is also possible to specify the module instead with
`export private a b c from Other.Module`.
-/
syntax (name := exportPrivate) "export" ppSpace "private" (ppSpace ident)*
  (" in" (ppSpace ident)*)? (" from" (ppSpace ident)*)? : command

/-- Elaborator for `export private`. -/
@[command_elab exportPrivate] def elabExportPrivate : CommandElab
| `(export private $ids* $[in $tgts*]? $[from $mods*]?) =>
  elabOpenPrivateLike ids tgts mods fun c name _ => liftCoreM do
    let cinfo ← getConstInfo c
    if (← getEnv).contains name then
      throwError s!"'{name}' has already been declared"
    let decl := Declaration.defnDecl {
      name := name,
      levelParams := cinfo.levelParams,
      type := cinfo.type,
      value := mkConst c (cinfo.levelParams.map mkLevelParam),
      hints := ReducibilityHints.abbrev,
      safety := if cinfo.isUnsafe then DefinitionSafety.unsafe else DefinitionSafety.safe
    }
    addDecl decl
    compileDecl decl
    pure name
| _ => throwUnsupportedSyntax



=== LEAN SOURCE: PermuteGoals.lean ===
/-
Copyright (c) 2022 Arthur Paulino. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Arthur Paulino, Mario Carneiro
-/
import Lean.Elab.Tactic.Basic

/-!
# The `on_goal`, `pick_goal`, and `swap` tactics.

`pick_goal n` moves the `n`-th goal to the front. If `n` is negative this is counted from the back.

`on_goal n => tacSeq` focuses on the `n`-th goal and runs a tactic block `tacSeq`.
If `tacSeq` does not close the goal any resulting subgoals are inserted back into the list of goals.
If `n` is negative this is counted from the back.

`swap` is a shortcut for `pick_goal 2`, which interchanges the 1st and 2nd goals.
-/

namespace Batteries.Tactic

open Lean Elab.Tactic

/--
If the current goals are `g₁ ⋯ gᵢ ⋯ gₙ`, `splitGoalsAndGetNth i` returns
`(gᵢ, [g₁, ⋯, gᵢ₋₁], [gᵢ₊₁, ⋯, gₙ])`.

If `reverse` is passed as `true`, the `i`-th goal is picked by counting backwards.
For instance, `splitGoalsAndGetNth 1 true` puts the last goal in the first component
of the returned term.
-/
def splitGoalsAndGetNth (nth : Nat) (reverse : Bool := false) :
    TacticM (MVarId × List MVarId × List MVarId) := do
  if nth = 0 then throwError "goals are 1-indexed"
  let goals ← getGoals
  let nGoals := goals.length
  if nth > nGoals then throwError "goal index out of bounds"
  let n := if ¬reverse then nth - 1 else nGoals - nth
  let (gl, g :: gr) := goals.splitAt n | throwNoGoalsToBeSolved
  pure (g, gl, gr)

/--
`pick_goal n` will move the `n`-th goal to the front.

`pick_goal -n` will move the `n`-th goal (counting from the bottom) to the front.

See also `Tactic.rotate_goals`, which moves goals from the front to the back and vice-versa.
-/
elab "pick_goal " reverse:"-"? n:num : tactic => do
  let (g, gl, gr) ← splitGoalsAndGetNth n.1.toNat !reverse.isNone
  setGoals $ g :: (gl ++ gr)

/-- `swap` is a shortcut for `pick_goal 2`, which interchanges the 1st and 2nd goals. -/
macro "swap" : tactic => `(tactic| pick_goal 2)

/--
`on_goal n => tacSeq` creates a block scope for the `n`-th goal and tries the sequence
of tactics `tacSeq` on it.

`on_goal -n => tacSeq` does the same, but the `n`-th goal is chosen by counting from the
bottom.

The goal is not required to be solved and any resulting subgoals are inserted back into the
list of goals, replacing the chosen goal.
-/
elab "on_goal " reverse:"-"? n:num " => " seq:tacticSeq : tactic => do
  let (g, gl, gr) ← splitGoalsAndGetNth n.1.toNat !reverse.isNone
  setGoals [g]
  evalTactic seq
  setGoals $ gl ++ (← getUnsolvedGoals) ++ gr



=== LEAN SOURCE: PrintDependents.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Lean.Elab.Command
import Lean.Util.FoldConsts

/-!
# `#print dependents` command

This is a variation on `#print axioms` where one instead specifies the axioms to avoid,
and it prints a list of all the theorems in the file that depend on that axiom, and the list
of all theorems directly referenced that are "to blame" for this dependency. Useful for debugging
unexpected dependencies.
-/
namespace Batteries.Tactic
open Lean Elab Command

namespace CollectDependents

/-- Collects the result of a `CollectDependents` query. -/
structure State where
  /-- If true, an axiom not in the initial list will be considered as marked. -/
  otherAxiom : Bool := true
  /-- The cached results on visited constants. -/
  result : NameMap Bool := {}

/-- The monad used by `CollectDependents`. -/
abbrev M := ReaderT Environment $ StateM State

/--
Constructs the initial state, marking the constants in `cs`. The result of `collect` will say
whether a given declaration depends transitively on one of these constants.

If `otherAxiom` is true, any axiom not specified in `cs` will also be tracked.
-/
def mkState (cs : Array (Name × Bool)) (otherAxiom := true) : State :=
  { otherAxiom, result := cs.foldl (fun r (c, b) => r.insert c b) {} }

/-- Collect the results for a given constant. -/
partial def collect (c : Name) : M Bool := do
  let collectExpr (e : Expr) : M Bool := e.getUsedConstants.anyM collect
  let s ← get
  if let some b := s.result.find? c then return b
  modify fun s => { s with result := s.result.insert c false }
  let env ← read
  let r ← match env.find? c with
    | some (ConstantInfo.axiomInfo _)  => pure s.otherAxiom
    | some (ConstantInfo.defnInfo v)   => collectExpr v.type <||> collectExpr v.value
    | some (ConstantInfo.thmInfo v)    => collectExpr v.type <||> collectExpr v.value
    | some (ConstantInfo.opaqueInfo v) => collectExpr v.type <||> collectExpr v.value
    | some (ConstantInfo.quotInfo _)   => pure false
    | some (ConstantInfo.ctorInfo v)   => collectExpr v.type
    | some (ConstantInfo.recInfo v)    => collectExpr v.type
    | some (ConstantInfo.inductInfo v) => collectExpr v.type <||> v.ctors.anyM collect
    | none                             => pure false
  modify fun s => { s with result := s.result.insert c r }
  pure r

end CollectDependents

/--
The command `#print dependents X Y` prints a list of all the declarations in the file that
transitively depend on `X` or `Y`. After each declaration, it shows the list of all declarations
referred to directly in the body which also depend on `X` or `Y`.

For example, `#print axioms bar'` below shows that `bar'` depends on `Classical.choice`, but not
why. `#print dependents Classical.choice` says that `bar'` depends on `Classical.choice` because
it uses `foo` and `foo` uses `Classical.em`. `bar` is not listed because it is proved without using
`Classical.choice`.
```
import Batteries.Tactic.PrintDependents

theorem foo : x = y ∨ x ≠ y := Classical.em _
theorem bar : 1 = 1 ∨ 1 ≠ 1 := by simp
theorem bar' : 1 = 1 ∨ 1 ≠ 1 := foo

#print axioms bar'
-- 'bar'' depends on axioms: [Classical.choice, Quot.sound, propext]

#print dependents Classical.choice
-- foo: Classical.em
-- bar': foo
```

-/
elab tk:"#print" &"dependents" ids:(ppSpace colGt ident)* : command => do
  let env ← getEnv
  let ids ← ids.mapM fun c => return (← liftCoreM <| realizeGlobalConstNoOverloadWithInfo c, true)
  let init := CollectDependents.mkState ids false
  let mut state := init
  let mut out := #[]
  for (c, _) in env.constants.map₂ do
    let (b, state') := CollectDependents.collect c |>.run env |>.run state
    state := state'
    if b then
      if let some ranges ← findDeclarationRanges? c then
        out := out.push (c, ranges.range.pos.1)
  let msg ← out.qsort (·.2 < ·.2) |>.mapM fun (c, _) => do
    let mut msg := m!"{MessageData.ofConst (← mkConstWithLevelParams c)}: "
    if init.result.contains c then
      msg := msg ++ m!"<specified>"
    else
      let consts := match env.find? c with
      | some (ConstantInfo.defnInfo v)   => v.type.getUsedConstants ++ v.value.getUsedConstants
      | some (ConstantInfo.thmInfo v)    => v.type.getUsedConstants ++ v.value.getUsedConstants
      | some (ConstantInfo.opaqueInfo v) => v.type.getUsedConstants ++ v.value.getUsedConstants
      | some (ConstantInfo.ctorInfo v)   => v.type.getUsedConstants
      | some (ConstantInfo.recInfo v)    => v.type.getUsedConstants
      | some (ConstantInfo.inductInfo v) => v.type.getUsedConstants ++ v.ctors
      | _                                => #[]
      for c in RBTree.fromArray consts Name.cmp do
        if state.result.find? c = some true then
          msg := msg ++ m!"{MessageData.ofConst (← mkConstWithLevelParams c)} "
    return msg
  logInfoAt tk (.joinSep msg.toList "\n")



=== LEAN SOURCE: PrintOpaques.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Lean.Elab.Command
import Lean.Util.FoldConsts

open Lean Elab Command

namespace Batteries.Tactic.CollectOpaques

/-- Collects the result of a `CollectOpaques` query. -/
structure State where
  /-- The set visited constants. -/
  visited : NameSet := {}
  /-- The collected opaque defs. -/
  opaques : Array Name := #[]

/-- The monad used by `CollectOpaques`. -/
abbrev M := ReaderT Environment <| StateT State MetaM

/-- Collect the results for a given constant. -/
partial def collect (c : Name) : M Unit := do
  let collectExpr (e : Expr) : M Unit := e.getUsedConstants.forM collect
  let s ← get
  unless s.visited.contains c do
    modify fun s => { s with visited := s.visited.insert c }
    let env ← read
    match env.find? c with
    | some (ConstantInfo.ctorInfo _)
    | some (ConstantInfo.recInfo _)
    | some (ConstantInfo.inductInfo _)
    | some (ConstantInfo.quotInfo _)   =>
      pure ()
    | some (ConstantInfo.defnInfo v)
    | some (ConstantInfo.thmInfo v)    =>
      unless ← Meta.isProp v.type do collectExpr v.value
    | some (ConstantInfo.axiomInfo v)
    | some (ConstantInfo.opaqueInfo v) =>
      unless ← Meta.isProp v.type do
        modify fun s => { s with opaques := s.opaques.push c }
    | none                             =>
      throwUnknownConstant c

end CollectOpaques

/--
The command `#print opaques X` prints all opaque definitions that `X` depends on.

Opaque definitions include partial definitions and axioms. Only dependencies that occur in a
computationally relevant context are listed, occurrences within proof terms are omitted. This is
useful to determine whether and how a definition is possibly platform dependent, possibly partial,
or possibly noncomputable.

The command `#print opaques Std.HashMap.insert` shows that `Std.HashMap.insert` depends on the
opaque definitions: `System.Platform.getNumBits` and `UInt64.toUSize`. Thus `Std.HashMap.insert`
may have different behavior when compiled on a 32 bit or 64 bit platform.

The command `#print opaques Stream.forIn` shows that `Stream.forIn` is possibly partial since it
depends on the partial definition `Stream.forIn.visit`. Indeed, `Stream.forIn` may not terminate
when the input stream is unbounded.

The command `#print opaques Classical.choice` shows that `Classical.choice` is itself an opaque
definition: it is an axiom. However, `#print opaques Classical.axiomOfChoice` returns nothing
since it is a proposition, hence not computationally relevant. (The command `#print axioms` does
reveal that `Classical.axiomOfChoice` depends on the `Classical.choice` axiom.)
-/
elab "#print" &"opaques" name:ident : command => do
  let constName ← liftCoreM <| realizeGlobalConstNoOverloadWithInfo name
  let env ← getEnv
  let (_, s) ← liftTermElabM <| ((CollectOpaques.collect constName).run env).run {}
  if s.opaques.isEmpty then
    logInfo m!"'{constName}' does not use any opaque or partial definitions"
  else
    logInfo m!"'{constName}' depends on opaque or partial definitions: {s.opaques.toList}"



=== LEAN SOURCE: PrintPrefix.lean ===
/-
Copyright (c) 2021 Shing Tak Lam. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Shing Tak Lam, Daniel Selsam, Mario Carneiro
-/
import Batteries.Lean.Util.EnvSearch
import Lean.Elab.Tactic.Config

namespace Batteries.Tactic
open Lean Elab Command

/--
Options to control `#print prefix` command and `getMatchingConstants`.
-/
structure PrintPrefixConfig where
  /-- Include declarations in imported environment. -/
  imported : Bool := true
  /-- Include declarations whose types are propositions. -/
  propositions : Bool := true
  /-- Exclude declarations whose types are not propositions. -/
  propositionsOnly : Bool := false
  /-- Print the type of a declaration. -/
  showTypes : Bool := true
  /--
  Include internal declarations (names starting with `_`, `match_` or `proof_`)
  -/
  internals : Bool := false

/-- Function elaborating `Config`. -/
declare_command_config_elab elabPrintPrefixConfig PrintPrefixConfig

/--
`reverseName name` reverses the components of a name.
-/
private def reverseName : Name → (pre : Name := .anonymous) → Name
| .anonymous, p => p
| .str q s, p => reverseName q (.str p s)
| .num q n, p => reverseName q (.num p n)

/--
`takeNameSuffix n name` returns a pair `(pre, suf)` where `suf` contains the last `n` components
of the name and `pre` contains the rest.
-/
private def takeNameSuffix (cnt : Nat) (name : Name) (pre : Name := .anonymous) : Name × Name :=
  match cnt, name with
  | .succ cnt, .str q s => takeNameSuffix cnt q (.str pre s)
  | .succ cnt, .num q n => takeNameSuffix cnt q (.num pre n)
  | _, name => (name, reverseName pre)

/--
`matchName opts pre cinfo` returns true if the search options should include the constant.
-/
private def matchName (opts : PrintPrefixConfig)
                      (pre : Name) (cinfo : ConstantInfo) : MetaM Bool := do
  let name := cinfo.name
  unless (← hasConst name) do  -- some compiler decls are not known to the elab env, ignore them
    return false
  let preCnt := pre.getNumParts
  let nameCnt := name.getNumParts
  if preCnt > nameCnt then return false
  let (root, post) := takeNameSuffix (nameCnt - preCnt) name
  if root ≠ pre then return false
  if !opts.internals && post.isInternalDetail then return false
  if opts.propositions != opts.propositionsOnly then return opts.propositions
  let isProp := (Expr.isProp <$> Lean.Meta.inferType cinfo.type) <|> pure false
  pure <| opts.propositionsOnly == (← isProp)

private def lexNameLt : Name -> Name -> Bool
| _, .anonymous => false
| .anonymous, _ => true
| .num p m, .num q n => m < n || m == n && lexNameLt p q
| .num _ _, .str _ _ => true
| .str _ _, .num _ _ => false
| .str p m, .str q n => m < n || m == n && lexNameLt p q

private def matchingConstants (opts : PrintPrefixConfig) (pre : Name)
     : MetaM (Array MessageData) := do
  let cinfos ← getMatchingConstants (matchName opts pre) opts.imported
  let cinfos := cinfos.qsort fun p q => lexNameLt (reverseName p.name) (reverseName q.name)
  cinfos.mapM fun cinfo => do
    if opts.showTypes then
      pure <| MessageData.signature cinfo.name ++ "\n"
    else
      pure m!"{MessageData.ofConst (← mkConstWithLevelParams cinfo.name)}\n"

/--
The command `#print prefix foo` will print all definitions that start with
the namespace `foo`.

For example, the command below will print out definitions in the `List` namespace:

```lean
#print prefix List
```

`#print prefix` can be controlled by flags in `PrintPrefixConfig`.  These provide
options for filtering names and formatting.   For example,
`#print prefix` by default excludes internal names, but this can be controlled
via config:
```lean
#print prefix (config := {internals := true}) List
```

By default, `#print prefix` prints the type after each name.  This can be controlled
by setting `showTypes` to `false`:
```lean
#print prefix (config := {showTypes := false}) List
```

The complete set of flags can be seen in the documentation
for `Lean.Elab.Command.PrintPrefixConfig`.
-/
elab (name := printPrefix) tk:"#print " colGt "prefix"
    cfg:Lean.Parser.Tactic.optConfig name:(ident)? : command => do
  if let some name := name then
    let opts ← elabPrintPrefixConfig cfg
    liftTermElabM do
      let mut msgs ← matchingConstants opts name.getId
      if msgs.isEmpty then
        if let [name] ← resolveGlobalConst name then
          msgs ← matchingConstants opts name
      logInfoAt tk (.joinSep msgs.toList "")



=== LEAN SOURCE: SeqFocus.lean ===
/-
Copyright (c) 2022 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad
-/
import Lean.Elab.Tactic.Basic

open Lean Elab Meta Tactic

namespace Batteries.Tactic

/-- Assuming there are `n` goals, `map_tacs [t1; t2; ...; tn]` applies each `ti` to the respective
goal and leaves the resulting subgoals. -/
elab "map_tacs " "[" ts:sepBy(tactic, "; ") "]" : tactic => do
  let goals ← getUnsolvedGoals
  let tacs := ts.getElems
  let length := tacs.size
  if length < goals.length then
    throwError "not enough tactics"
  else if length > goals.length then
    throwError "too many tactics"
  let mut goalsNew := #[]
  for tac in tacs, goal in goals do
    if ← goal.isAssigned then continue
    setGoals [goal]
    try
      evalTactic tac
      goalsNew := goalsNew ++ (← getUnsolvedGoals)
    catch ex =>
      if (← read).recover then
        logException ex
        goalsNew := goalsNew.push goal
      else
        throw ex
  setGoals goalsNew.toList

/-- `t <;> [t1; t2; ...; tn]` focuses on the first goal and applies `t`, which should result in `n`
subgoals. It then applies each `ti` to the corresponding goal and collects the resulting
subgoals. -/
macro:1 (name := seq_focus) t:tactic " <;> " "[" ts:sepBy(tactic, "; ") "]" : tactic =>
  `(tactic| focus ( $t:tactic; map_tacs [$ts;*]) )



=== LEAN SOURCE: ShowUnused.lean ===
/-
Copyright (c) 2024 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Lean.Util.FoldConsts
import Lean.Linter.UnusedVariables

/-!
# The `#show_unused` command

`#show_unused decl1 decl2 ..` will highlight every theorem or definition in the current file
not involved in the definition of declarations `decl1`, `decl2`, etc. The result is shown
both in the message on `#show_unused`, as well as on the declarations themselves.
-/

namespace Batteries.Tactic.ShowUnused
open Lean Elab Command

variable (env : Environment) in
private partial def visit (n : Name) : StateM NameSet Unit := do
  if (← get).contains n then
    modify (·.erase n)
    let rec visitExpr (e : Expr) : StateM NameSet Unit := e.getUsedConstants.forM visit
    match env.find? n with
    | some (ConstantInfo.axiomInfo v)  => visitExpr v.type
    | some (ConstantInfo.defnInfo v)   => visitExpr v.type *> visitExpr v.value
    | some (ConstantInfo.thmInfo v)    => visitExpr v.type *> visitExpr v.value
    | some (ConstantInfo.opaqueInfo v) => visitExpr v.type *> visitExpr v.value
    | some (ConstantInfo.quotInfo _)   => pure ()
    | some (ConstantInfo.ctorInfo v)   => visitExpr v.type
    | some (ConstantInfo.recInfo v)    => visitExpr v.type
    | some (ConstantInfo.inductInfo v) => visitExpr v.type *> v.ctors.forM visit
    | none                             => pure ()

/--
`#show_unused decl1 decl2 ..` will highlight every theorem or definition in the current file
not involved in the definition of declarations `decl1`, `decl2`, etc. The result is shown
both in the message on `#show_unused`, as well as on the declarations themselves.
```
def foo := 1
def baz := 2
def bar := foo
#show_unused bar -- highlights `baz`
```
-/
elab tk:"#show_unused" ids:(ppSpace colGt ident)* : command => do
  let ns ← ids.mapM fun s => liftCoreM <| realizeGlobalConstNoOverloadWithInfo s
  let env ← getEnv
  let decls := env.constants.map₂.foldl (fun m n _ => m.insert n) {}
  let mut unused := #[]
  let fileMap ← getFileMap
  for c in ((ns.forM (visit env)).run decls).2 do
    if let some { selectionRange := range, .. } := declRangeExt.find? env c then
      unused := unused.push (c, {
        start := fileMap.ofPosition range.pos
        stop := fileMap.ofPosition range.endPos
      })
  unused := unused.qsort (·.2.start < ·.2.start)
  let pos := fileMap.toPosition <| (tk.getPos? <|> (← getRef).getPos?).getD 0
  let pfx := m!"#show_unused (line {pos.line}) says:\n"
  let post := m!" is not used transitively by \
    {← ns.mapM (MessageData.ofConst <$> mkConstWithLevelParams ·)}"
  for (c, range) in unused do
    logWarningAt (Syntax.ofRange range) <|
      .tagged Linter.linter.unusedVariables.name <|
        m!"{pfx}{MessageData.ofConst (← mkConstWithLevelParams c)}{post}"
  if unused.isEmpty then
    logInfoAt tk "No unused definitions"
  else
    logWarningAt tk <| m!"unused definitions in this file:\n" ++
      m!"\n".joinSep (← unused.toList.mapM (toMessageData <$> mkConstWithLevelParams ·.1))



=== LEAN SOURCE: SqueezeScope.lean ===
/-
Copyright (c) 2022 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Lean.Elab.Tactic.SimpTrace

/-!
# `squeeze_scope` tactic

The `squeeze_scope` tactic allows aggregating multiple calls to `simp` coming from the same syntax
but in different branches of execution, such as in `cases x <;> simp`.
The reported `simp` call covers all simp lemmas used by this syntax.
-/
namespace Batteries.Tactic
open Lean Elab Parser Tactic Meta.Tactic

/--
`squeeze_scope a => tacs` is part of the implementation of `squeeze_scope`.
Inside `tacs`, invocations of `simp` wrapped with `squeeze_wrap a _ => ...` will contribute
to the accounting associated to scope `a`.
-/
local syntax (name := squeezeScopeIn) "squeeze_scope " ident " => " tacticSeq : tactic
/--
`squeeze_wrap a x => tac` is part of the implementation of `squeeze_scope`.
Here `tac` will be a `simp` or `dsimp` syntax, and `squeeze_wrap` will run the tactic
and contribute the generated `usedSimps` to the `squeezeScopes[a][x]` variable.
-/
local syntax (name := squeezeWrap) "squeeze_wrap " ident ppSpace ident " => " tactic : tactic

open TSyntax.Compat in
/--
The `squeeze_scope` tactic allows aggregating multiple calls to `simp` coming from the same syntax
but in different branches of execution, such as in `cases x <;> simp`.
The reported `simp` call covers all simp lemmas used by this syntax.
```
@[simp] def bar (z : Nat) := 1 + z
@[simp] def baz (z : Nat) := 1 + z

@[simp] def foo : Nat → Nat → Nat
  | 0, z => bar z
  | _+1, z => baz z

example : foo x y = 1 + y := by
  cases x <;> simp? -- two printouts:
  -- "Try this: simp only [foo, bar]"
  -- "Try this: simp only [foo, baz]"

example : foo x y = 1 + y := by
  squeeze_scope
    cases x <;> simp -- only one printout: "Try this: simp only [foo, baz, bar]"
```
-/
macro (name := squeezeScope) "squeeze_scope " seq:tacticSeq : tactic => do
  let a ← withFreshMacroScope `(a)
  let seq ← seq.raw.rewriteBottomUpM fun stx =>
    match stx.getKind with
    | ``dsimp | ``simpAll | ``simp => do
      withFreshMacroScope `(tactic| squeeze_wrap $a x => $stx)
    | _ => pure stx
  `(tactic| squeeze_scope $a => $seq)

open Meta

/--
We implement `squeeze_scope` using a global variable that tracks all `squeeze_scope` invocations
in flight. It is a map `a => (x => (stx, simps))` where `a` is a unique identifier for
the `squeeze_scope` invocation which is shared with all contained simps, and `x` is a unique
identifier for a particular piece of simp syntax (which can be called multiple times).
Within that, `stx` is the simp syntax itself, and `simps` is the aggregated list of simps used
so far.
-/
initialize squeezeScopes : IO.Ref (NameMap (NameMap (Syntax × List Simp.UsedSimps))) ← IO.mkRef {}

elab_rules : tactic
  | `(tactic| squeeze_scope $a => $tac) => do
    let a := a.getId
    let old ← squeezeScopes.modifyGet fun map => (map.find? a, map.insert a {})
    let reset map := match old with | some old => map.insert a old | none => map.erase a
    let new ← try
      Elab.Tactic.evalTactic tac
      squeezeScopes.modifyGet fun map => (map.find? a, reset map)
    catch e =>
      squeezeScopes.modify reset
      throw e
    if let some new := new then
      for (_, stx, usedSimps) in new do
        let usedSimps := usedSimps.reverse.foldl
          (fun s usedSimps => usedSimps.toArray.foldl .insert s) {}
        let stx' ← mkSimpCallStx stx usedSimps
        TryThis.addSuggestion stx[0] stx' (origSpan? := stx)

elab_rules : tactic
  | `(tactic| squeeze_wrap $a $x => $tac) => do
    let stx := tac.raw
    let stats ← match stx.getKind with
    | ``Parser.Tactic.simp => do
      let { ctx, simprocs, dischargeWrapper, .. } ←
        withMainContext <| mkSimpContext stx (eraseLocal := false)
      dischargeWrapper.with fun discharge? =>
        simpLocation ctx simprocs discharge? (expandOptLocation stx[5])
    | ``Parser.Tactic.simpAll => do
      let { ctx, simprocs, .. } ← mkSimpContext stx
        (eraseLocal := true) (kind := .simpAll) (ignoreStarArg := true)
      let (result?, stats) ← simpAll (← getMainGoal) ctx simprocs
      match result? with
      | none => replaceMainGoal []
      | some mvarId => replaceMainGoal [mvarId]
      pure stats
    | ``Parser.Tactic.dsimp => do
      let { ctx, simprocs, .. } ← withMainContext <|
        mkSimpContext stx (eraseLocal := false) (kind := .dsimp)
      dsimpLocation' ctx simprocs (expandOptLocation stx[5])
    | _ => Elab.throwUnsupportedSyntax
    let a := a.getId; let x := x.getId
    squeezeScopes.modify fun map => Id.run do
      let some map1 := map.find? a | return map
      let newSimps := match map1.find? x with
      | some (stx, oldSimps) => (stx, stats.usedTheorems :: oldSimps)
      | none => (stx, [stats.usedTheorems])
      map.insert a (map1.insert x newSimps)



=== LEAN SOURCE: Trans.lean ===
/-
Copyright (c) 2022 Siddhartha Gadgil. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Siddhartha Gadgil, Mario Carneiro
-/
import Lean.Elab.Tactic.ElabTerm

/-!
# `trans` tactic

This implements the `trans` tactic, which can apply transitivity theorems with an optional middle
variable argument.
-/

/-- Compose using transitivity, homogeneous case. -/
def Trans.simple {r : α → α → Sort _} [Trans r r r] : r a b → r b c → r a c := trans

namespace Batteries.Tactic
open Lean Meta Elab

initialize registerTraceClass `Tactic.trans

/-- Environment extension storing transitivity lemmas -/
initialize transExt :
    SimpleScopedEnvExtension (Name × Array DiscrTree.Key) (DiscrTree Name) ←
  registerSimpleScopedEnvExtension {
    addEntry := fun dt (n, ks) => dt.insertCore ks n
    initial := {}
  }

initialize registerBuiltinAttribute {
  name := `trans
  descr := "transitive relation"
  add := fun decl _ kind => MetaM.run' do
    let declTy := (← getConstInfo decl).type
    let (xs, _, targetTy) ← withReducible <| forallMetaTelescopeReducing declTy
    let fail := throwError
      "@[trans] attribute only applies to lemmas proving
      x ∼ y → y ∼ z → x ∼ z, got {indentExpr declTy} with target {indentExpr targetTy}"
    let .app (.app rel _) _ := targetTy | fail
    let some yzHyp := xs.back? | fail
    let some xyHyp := xs.pop.back? | fail
    let .app (.app _ _) _ ← inferType yzHyp | fail
    let .app (.app _ _) _ ← inferType xyHyp | fail
    let key ← withReducible <| DiscrTree.mkPath rel
    transExt.add (decl, key) kind
}

open Lean.Elab.Tactic

/-- solving `e ← mkAppM' f #[x]` -/
def getExplicitFuncArg? (e : Expr) : MetaM (Option <| Expr × Expr) := do
  match e with
  | Expr.app f a => do
    if ← isDefEq (← mkAppM' f #[a]) e then
      return some (f, a)
    else
      getExplicitFuncArg? f
  | _ => return none

/-- solving `tgt ← mkAppM' rel #[x, z]` given `tgt = f z` -/
def getExplicitRelArg? (tgt f z : Expr) : MetaM (Option <| Expr × Expr) := do
  match f with
  | Expr.app rel x => do
    let check: Bool ← do
      try
        let folded ← mkAppM' rel #[x, z]
        isDefEq folded tgt
      catch _ =>
        pure false
    if check then
      return some (rel, x)
    else
      getExplicitRelArg? tgt rel z
  | _ => return none

/-- refining `tgt ← mkAppM' rel #[x, z]` dropping more arguments if possible -/
def getExplicitRelArgCore (tgt rel x z : Expr) : MetaM (Expr × Expr) := do
  match rel with
  | Expr.app rel' _ => do
    let check: Bool ← do
      try
        let folded ← mkAppM' rel' #[x, z]
        isDefEq folded tgt
      catch _ =>
        pure false
    if !check then
      return (rel, x)
    else
      getExplicitRelArgCore tgt rel' x z
  | _ => return (rel ,x)

/-- Internal definition for `trans` tactic. Either a binary relation or a non-dependent
arrow. -/
inductive TransRelation
  /-- Expression for transitive relation. -/
  | app (rel : Expr)
  /-- Constant name for transitive relation. -/
  | implies (name : Name) (bi : BinderInfo)

/-- Finds an explicit binary relation in the argument, if possible. -/
def getRel (tgt : Expr) : MetaM (Option (TransRelation × Expr × Expr)) := do
  match tgt with
  | .forallE name binderType body info => return .some (.implies name info, binderType, body)
  | .app f z =>
    match (← getExplicitRelArg? tgt f z) with
    | some (rel, x) =>
      let (rel, x) ← getExplicitRelArgCore tgt rel x z
      return some (.app rel, x, z)
    | none =>
      return none
  | _ => return none

/--
`trans` applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation,
that is, a relation which has a transitivity lemma tagged with the attribute [trans].

* `trans s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`.
* If `s` is omitted, then a metavariable is used instead.

Additionally, `trans` also applies to a goal whose target has the form `t → u`,
in which case it replaces the goal with `t → s` and `s → u`.
-/
elab "trans" t?:(ppSpace colGt term)? : tactic => withMainContext do
  let tgt := (← instantiateMVars (← (← getMainGoal).getType)).cleanupAnnotations
  let .some (rel, x, z) ← getRel tgt |
    throwError (m!"transitivity lemmas only apply to binary relations and " ++
                m!"non-dependent arrows, not {indentExpr tgt}")
  match rel with
  | .implies name info =>
    -- only consider non-dependent arrows
    if z.hasLooseBVars then
      throwError "`trans` is not implemented for dependent arrows{indentExpr tgt}"
    -- parse the intermeditate term
    let middleType ← mkFreshExprMVar none
    let t'? ← t?.mapM (elabTermWithHoles · middleType (← getMainTag))
    let middle ← (t'?.map (pure ·.1)).getD (mkFreshExprMVar middleType)
    liftMetaTactic fun goal => do
      -- create two new goals
      let g₁ ← mkFreshExprMVar (some <| .forallE name x middle info) .synthetic
      let g₂ ← mkFreshExprMVar (some <| .forallE name middle z info) .synthetic
      -- close the original goal with `fun x => g₂ (g₁ x)`
      goal.assign (.lam name x (.app g₂ (.app g₁ (.bvar 0))) .default)
      pure <| [g₁.mvarId!, g₂.mvarId!] ++ if let some (_, gs') := t'? then gs' else [middle.mvarId!]
    return
  | .app rel =>
    trace[Tactic.trans]"goal decomposed"
    trace[Tactic.trans]"rel: {indentExpr rel}"
    trace[Tactic.trans]"x: {indentExpr x}"
    trace[Tactic.trans]"z: {indentExpr z}"
    -- first trying the homogeneous case
    try
      let ty ← inferType x
      let t'? ← t?.mapM (elabTermWithHoles · ty (← getMainTag))
      let s ← saveState
      trace[Tactic.trans]"trying homogeneous case"
      let lemmas :=
        (← (transExt.getState (← getEnv)).getUnify rel).push ``Trans.simple
      for lem in lemmas do
        trace[Tactic.trans]"trying lemma {lem}"
        try
          liftMetaTactic fun g => do
            let lemTy ← inferType (← mkConstWithLevelParams lem)
            let arity ← withReducible <| forallTelescopeReducing lemTy fun es _ => pure es.size
            let y ← (t'?.map (pure ·.1)).getD (mkFreshExprMVar ty)
            let g₁ ← mkFreshExprMVar (some <| ← mkAppM' rel #[x, y]) .synthetic
            let g₂ ← mkFreshExprMVar (some <| ← mkAppM' rel #[y, z]) .synthetic
            g.assign (← mkAppOptM lem (.replicate (arity - 2) none ++ #[some g₁, some g₂]))
            pure <| [g₁.mvarId!, g₂.mvarId!] ++
              if let some (_, gs') := t'? then gs' else [y.mvarId!]
          return
        catch _ => s.restore
      pure ()
    catch _ =>
    trace[Tactic.trans]"trying heterogeneous case"
    let t'? ← t?.mapM (elabTermWithHoles · none (← getMainTag))
    let s ← saveState
    for lem in (← (transExt.getState (← getEnv)).getUnify rel).push
        ``HEq.trans |>.push ``Trans.trans do
      try
        liftMetaTactic fun g => do
          trace[Tactic.trans]"trying lemma {lem}"
          let lemTy ← inferType (← mkConstWithLevelParams lem)
          let arity ← withReducible <| forallTelescopeReducing lemTy fun es _ => pure es.size
          trace[Tactic.trans]"arity: {arity}"
          trace[Tactic.trans]"lemma-type: {lemTy}"
          let y ← (t'?.map (pure ·.1)).getD (mkFreshExprMVar none)
          trace[Tactic.trans]"obtained y: {y}"
          trace[Tactic.trans]"rel: {indentExpr rel}"
          trace[Tactic.trans]"x:{indentExpr x}"
          trace[Tactic.trans]"z:  {indentExpr z}"
          let g₂ ← mkFreshExprMVar (some <| ← mkAppM' rel #[y, z]) .synthetic
          trace[Tactic.trans]"obtained g₂: {g₂}"
          let g₁ ← mkFreshExprMVar (some <| ← mkAppM' rel #[x, y]) .synthetic
          trace[Tactic.trans]"obtained g₁: {g₁}"
          g.assign (← mkAppOptM lem (.replicate (arity - 2) none ++ #[some g₁, some g₂]))
          pure <| [g₁.mvarId!, g₂.mvarId!] ++ if let some (_, gs') := t'? then gs' else [y.mvarId!]
        return
      catch e =>
        trace[Tactic.trans]"failed: {e.toMessageData}"
        s.restore
    throwError m!"no applicable transitivity lemma found for {indentExpr tgt}"

/-- Synonym for `trans` tactic. -/
syntax "transitivity" (ppSpace colGt term)? : tactic
set_option hygiene false in
macro_rules
  | `(tactic| transitivity) => `(tactic| trans)
  | `(tactic| transitivity $e) => `(tactic| trans $e)

end Batteries.Tactic



=== LEAN SOURCE: Unreachable.lean ===
/-
Copyright (c) 2021 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Lean.Elab.Tactic.Basic

namespace Batteries.Tactic

/--
This tactic causes a panic when run (at compile time).
(This is distinct from `exact unreachable!`, which inserts code which will panic at run time.)

It is intended for tests to assert that a tactic will never be executed, which is otherwise an
unusual thing to do (and the `unreachableTactic` linter will give a warning if you do).

The `unreachableTactic` linter has a special exception for uses of `unreachable!`.
```
example : True := by trivial <;> unreachable!
```
-/
elab (name := unreachable) "unreachable!" : tactic => do
  panic! "unreachable tactic has been reached"
  -- Note that `panic!` does not actually halt execution or early exit,
  -- so we still have to throw an error after panicking.
  throwError "unreachable tactic has been reached"

@[inherit_doc unreachable] macro (name := unreachableConv) "unreachable!" : conv =>
  `(conv| tactic' => unreachable!)



=== LEAN SOURCE: Basic.lean ===
/-
Copyright (c) 2020 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn, Robert Y. Lewis, Gabriel Ebner
-/
import Lean.Structure
import Lean.Elab.InfoTree.Main
import Lean.Elab.Exception

open Lean Meta

namespace Batteries.Tactic.Lint

/-!
# Basic linter types and attributes

This file defines the basic types and attributes used by the linting
framework.  A linter essentially consists of a function
`(declaration : Name) → MetaM (Option MessageData)`, this function together with some
metadata is stored in the `Linter` structure. We define two attributes:

 * `@[env_linter]` applies to a declaration of type `Linter`
   and adds it to the default linter set.

 * `@[nolint linterName]` omits the tagged declaration from being checked by
   the linter with name `linterName`.
-/

/--
Returns true if `decl` is an automatically generated declaration.

Also returns true if `decl` is an internal name or created during macro
expansion.
-/
def isAutoDecl (decl : Name) : CoreM Bool := do
  if decl.hasMacroScopes then return true
  if decl.isInternal then return true
  let env ← getEnv
  if isReservedName env decl then return true
  if let Name.str n s := decl then
    if (← isAutoDecl n) then return true
    if s.startsWith "proof_" || s.startsWith "match_" || s.startsWith "unsafe_" then return true
    if env.isConstructor n && ["injEq", "inj", "sizeOf_spec"].any (· == s) then
      return true
    if let ConstantInfo.inductInfo _ := (← getEnv).find? n then
      if s.startsWith "brecOn_" || s.startsWith "below_" then return true
      if [casesOnSuffix, recOnSuffix, brecOnSuffix, belowSuffix,
          "ndrec", "ndrecOn", "noConfusionType", "noConfusion", "ofNat", "toCtorIdx"
        ].any (· == s) then
        return true
      if let some _ := isSubobjectField? env n (.mkSimple s) then
        return true
  pure false

/-- A linting test for the `#lint` command. -/
structure Linter where
  /-- `test` defines a test to perform on every declaration. It should never fail. Returning `none`
  signifies a passing test. Returning `some msg` reports a failing test with error `msg`. -/
  test : Name → MetaM (Option MessageData)
  /-- `noErrorsFound` is the message printed when all tests are negative -/
  noErrorsFound : MessageData
  /-- `errorsFound` is printed when at least one test is positive -/
  errorsFound : MessageData
  /-- If `isFast` is false, this test will be omitted from `#lint-`. -/
  isFast := true

/-- A `NamedLinter` is a linter associated to a particular declaration. -/
structure NamedLinter extends Linter where
  /-- The name of the named linter. This is just the declaration name without the namespace. -/
  name : Name
  /-- The linter declaration name -/
  declName : Name

/-- Gets a linter by declaration name. -/
def getLinter (name declName : Name) : CoreM NamedLinter := unsafe
  return { ← evalConstCheck Linter ``Linter declName with name, declName }

/-- Defines the `env_linter` extension for adding a linter to the default set. -/
initialize batteriesLinterExt :
    PersistentEnvExtension (Name × Bool) (Name × Bool) (NameMap (Name × Bool)) ←
  let addEntryFn := fun m (n, b) => m.insert (n.updatePrefix .anonymous) (n, b)
  registerPersistentEnvExtension {
    mkInitial := pure {}
    addImportedFn := fun nss => pure <|
      nss.foldl (init := {}) fun m ns => ns.foldl (init := m) addEntryFn
    addEntryFn
    exportEntriesFn := fun es => es.fold (fun a _ e => a.push e) #[]
  }

/--
Defines the `@[env_linter]` attribute for adding a linter to the default set.
The form `@[env_linter disabled]` will not add the linter to the default set,
but it will be shown by `#list_linters` and can be selected by the `#lint` command.

Linters are named using their declaration names, without the namespace. These must be distinct.
-/
syntax (name := env_linter) "env_linter" &" disabled"? : attr

initialize registerBuiltinAttribute {
  name := `env_linter
  descr := "Use this declaration as a linting test in #lint"
  add   := fun decl stx kind => do
    let dflt := stx[1].isNone
    unless kind == .global do throwError "invalid attribute 'env_linter', must be global"
    let shortName := decl.updatePrefix .anonymous
    if let some (declName, _) := (batteriesLinterExt.getState (← getEnv)).find? shortName then
      Elab.addConstInfo stx declName
      throwError
        "invalid attribute 'env_linter', linter '{shortName}' has already been declared"
    let constInfo ← getConstInfo decl
    unless ← (isDefEq constInfo.type (mkConst ``Linter)).run' do
      throwError "must have type Linter, got {constInfo.type}"
    modifyEnv fun env => batteriesLinterExt.addEntry env (decl, dflt)
}

/-- `@[nolint linterName]` omits the tagged declaration from being checked by
the linter with name `linterName`. -/
syntax (name := nolint) "nolint" (ppSpace ident)+ : attr

/-- Defines the user attribute `nolint` for skipping `#lint` -/
initialize nolintAttr : ParametricAttribute (Array Name) ←
  registerParametricAttribute {
    name := `nolint
    descr := "Do not report this declaration in any of the tests of `#lint`"
    getParam := fun _ => fun
      | `(attr| nolint $[$ids]*) => ids.mapM fun id => withRef id <| do
        let shortName := id.getId.eraseMacroScopes
        let some (declName, _) := (batteriesLinterExt.getState (← getEnv)).find? shortName
          | throwError "linter '{shortName}' not found"
        Elab.addConstInfo id declName
        pure shortName
      | _ => Elab.throwUnsupportedSyntax
  }

/-- Returns true if `decl` should be checked
using `linter`, i.e., if there is no `nolint` attribute. -/
def shouldBeLinted [Monad m] [MonadEnv m] (linter : Name) (decl : Name) : m Bool :=
  return !((nolintAttr.getParam? (← getEnv) decl).getD #[]).contains linter



=== LEAN SOURCE: Frontend.lean ===
/-
Copyright (c) 2020 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn, Robert Y. Lewis, Gabriel Ebner
-/
import Lean.Elab.Command
import Batteries.Tactic.Lint.Basic

/-!
# Linter frontend and commands

This file defines the linter commands which spot common mistakes in the code.
* `#lint`: check all declarations in the current file
* `#lint in Pkg`: check all declarations in the package `Pkg`
  (so excluding core or other projects, and also excluding the current file)
* `#lint in all`: check all declarations in the environment
  (the current file and all imported files)

For a list of default / non-default linters, see the "Linting Commands" user command doc entry.

The command `#list_linters` prints a list of the names of all available linters.

You can append a `*` to any command (e.g. `#lint* in Batteries`) to omit the slow tests.

You can append a `-` to any command (e.g. `#lint- in Batteries`) to run a silent lint
that suppresses the output if all checks pass.
A silent lint will fail if any test fails.

You can append a `+` to any command (e.g. `#lint+ in Batteries`) to run a verbose lint
that reports the result of each linter, including  the successes.

You can append a sequence of linter names to any command to run extra tests, in addition to the
default ones. e.g. `#lint doc_blame_thm` will run all default tests and `doc_blame_thm`.

You can append `only name1 name2 ...` to any command to run a subset of linters, e.g.
`#lint only unused_arguments in Batteries`

You can add custom linters by defining a term of type `Linter` with the
`@[env_linter]` attribute.
A linter defined with the name `Batteries.Tactic.Lint.myNewCheck` can be run with `#lint myNewCheck`
or `#lint only myNewCheck`.
If you add the attribute `@[env_linter disabled]` to `linter.myNewCheck` it will be
registered, but not run by default.

Adding the attribute `@[nolint doc_blame unused_arguments]` to a declaration
omits it from only the specified linter checks.

## Tags

sanity check, lint, cleanup, command, tactic
-/

namespace Batteries.Tactic.Lint
open Lean Elab Command

/-- Verbosity for the linter output. -/
inductive LintVerbosity
  /-- `low`: only print failing checks, print nothing on success. -/
  | low
  /-- `medium`: only print failing checks, print confirmation on success. -/
  | medium
  /-- `high`: print output of every check. -/
  | high
  deriving Inhabited, DecidableEq, Repr

/-- `getChecks slow runOnly runAlways` produces a list of linters.
`runOnly` is an optional list of names that should resolve to declarations with type `NamedLinter`.
If populated, only these linters are run (regardless of the default configuration).
`runAlways` is an optional list of names that should resolve to declarations with type
`NamedLinter`. If populated, these linters are always run (regardless of their configuration).
Specifying a linter in `runAlways` but not `runOnly` is an error.
Otherwise, it uses all enabled linters in the environment tagged with `@[env_linter]`.
If `slow` is false, it only uses the fast default tests. -/
def getChecks (slow : Bool) (runOnly : Option (List Name)) (runAlways : Option (List Name)) :
    CoreM (Array NamedLinter) := do
  let mut result := #[]
  for (name, declName, default) in batteriesLinterExt.getState (← getEnv) do
    let shouldRun := match (runOnly, runAlways) with
      | (some only, some always) => only.contains name && (always.contains name || default)
      | (some only, none) => only.contains name
      | (none, some always) => default || always.contains name
      | _ => default
    if shouldRun then
      let linter ← getLinter name declName
      if slow || linter.isFast then
        let _ := Inhabited.mk linter
        result := result.binInsert (·.name.lt ·.name) linter
  pure result

/--
Runs all the specified linters on all the specified declarations in parallel,
producing a list of results.
-/
def lintCore (decls : Array Name) (linters : Array NamedLinter) :
    CoreM (Array (NamedLinter × Std.HashMap Name MessageData)) := do
  let env ← getEnv
  let options ← getOptions -- TODO: sanitize options?

  let tasks : Array (NamedLinter × Array (Name × Task (Option MessageData))) ←
    linters.mapM fun linter => do
      let decls ← decls.filterM (shouldBeLinted linter.name)
      (linter, ·) <$> decls.mapM fun decl => (decl, ·) <$> do
        BaseIO.asTask do
          match ← withCurrHeartbeats (linter.test decl)
              |>.run' mkMetaContext -- We use the context used by `Command.liftTermElabM`
              |>.run' {options, fileName := "", fileMap := default} {env}
              |>.toBaseIO with
          | Except.ok msg? => pure msg?
          | Except.error err => pure m!"LINTER FAILED:\n{err.toMessageData}"

  tasks.mapM fun (linter, decls) => do
    let mut msgs : Std.HashMap Name MessageData := {}
    for (declName, msg?) in decls do
      if let some msg := msg?.get then
        msgs := msgs.insert declName msg
    pure (linter, msgs)

/-- Sorts a map with declaration keys as names by line number. -/
def sortResults (results : Std.HashMap Name α) : CoreM <| Array (Name × α) := do
  let mut key : Std.HashMap Name Nat := {}
  for (n, _) in results.toArray do
    if let some range ← findDeclarationRanges? n then
      key := key.insert n <| range.range.pos.line
  pure $ results.toArray.qsort fun (a, _) (b, _) => key.getD a 0 < key.getD b 0

/-- Formats a linter warning as `#check` command with comment. -/
def printWarning (declName : Name) (warning : MessageData) (useErrorFormat : Bool := false)
  (filePath : System.FilePath := default) : CoreM MessageData := do
  if useErrorFormat then
    if let some range ← findDeclarationRanges? declName then
      let msg ← addMessageContextPartial
        m!"{filePath}:{range.range.pos.line}:{range.range.pos.column + 1}: error: {
          ← mkConstWithLevelParams declName} {warning}"
      return msg
  addMessageContextPartial m!"#check {← mkConstWithLevelParams declName} /- {warning} -/"

/-- Formats a map of linter warnings using `print_warning`, sorted by line number. -/
def printWarnings (results : Std.HashMap Name MessageData) (filePath : System.FilePath := default)
    (useErrorFormat : Bool := false) : CoreM MessageData := do
  (MessageData.joinSep ·.toList Format.line) <$>
    (← sortResults results).mapM fun (declName, warning) =>
      printWarning declName warning (useErrorFormat := useErrorFormat) (filePath := filePath)

/--
Formats a map of linter warnings grouped by filename with `-- filename` comments.
The first `drop_fn_chars` characters are stripped from the filename.
-/
def groupedByFilename (results : Std.HashMap Name MessageData) (useErrorFormat : Bool := false) :
    CoreM MessageData := do
  let sp ← if useErrorFormat then getSrcSearchPath else pure {}
  let grouped : Std.HashMap Name (System.FilePath × Std.HashMap Name MessageData) ←
    results.foldM (init := {}) fun grouped declName msg => do
      let mod ← findModuleOf? declName
      let mod := mod.getD (← getEnv).mainModule
      grouped.insert mod <$>
        match grouped[mod]? with
        | some (fp, msgs) => pure (fp, msgs.insert declName msg)
        | none => do
          let fp ← if useErrorFormat then
            pure <| (← sp.findWithExt "lean" mod).getD (modToFilePath "." mod "lean")
          else pure default
          pure (fp, .insert {} declName msg)
  let grouped' := grouped.toArray.qsort fun (a, _) (b, _) => toString a < toString b
  (MessageData.joinSep · (Format.line ++ Format.line)) <$>
    grouped'.toList.mapM fun (mod, fp, msgs) => do
      pure m!"-- {mod}\n{← printWarnings msgs (filePath := fp) (useErrorFormat := useErrorFormat)}"

/--
Formats the linter results as Lean code with comments and `#check` commands.
-/
def formatLinterResults
    (results : Array (NamedLinter × Std.HashMap Name MessageData))
    (decls : Array Name)
    (groupByFilename : Bool)
    (whereDesc : String) (runSlowLinters : Bool)
    (verbose : LintVerbosity) (numLinters : Nat) (useErrorFormat : Bool := false) :
    CoreM MessageData := do
  let formattedResults ← results.filterMapM fun (linter, results) => do
    if !results.isEmpty then
      let warnings ←
        if groupByFilename || useErrorFormat then
          groupedByFilename results (useErrorFormat := useErrorFormat)
        else
          printWarnings results
      pure $ some m!"/- The `{linter.name}` linter reports:\n{linter.errorsFound} -/\n{warnings}\n"
    else if verbose = LintVerbosity.high then
      pure $ some m!"/- OK: {linter.noErrorsFound} -/"
    else
      pure none
  let mut s := MessageData.joinSep formattedResults.toList Format.line
  let numAutoDecls := (← decls.filterM isAutoDecl).size
  let failed := results.map (·.2.size) |>.foldl (·+·) 0
  unless verbose matches LintVerbosity.low do
    s := m!"-- Found {failed} error{if failed == 1 then "" else "s"
      } in {decls.size - numAutoDecls} declarations (plus {
      numAutoDecls} automatically generated ones) {whereDesc
      } with {numLinters} linters\n\n{s}"
  unless runSlowLinters do s := m!"{s}-- (slow linters skipped)\n"
  pure s

/-- Get the list of declarations in the current module. -/
def getDeclsInCurrModule : CoreM (Array Name) := do
  pure $ (← getEnv).constants.map₂.foldl (init := #[]) fun r k _ => r.push k

/-- Get the list of all declarations in the environment. -/
def getAllDecls : CoreM (Array Name) := do
  pure $ (← getEnv).constants.map₁.fold (init := ← getDeclsInCurrModule) fun r k _ => r.push k

/-- Get the list of all declarations in the specified package. -/
def getDeclsInPackage (pkg : Name) : CoreM (Array Name) := do
  let env ← getEnv
  let mut decls ← getDeclsInCurrModule
  let modules := env.header.moduleNames.map (pkg.isPrefixOf ·)
  return env.constants.map₁.fold (init := decls) fun decls declName _ =>
    if modules[env.const2ModIdx[declName]?.get! (α := Nat)]! then
      decls.push declName
    else decls

/-- The `in foo` config argument allows running the linter on a specified project. -/
syntax inProject := " in " ident

open Elab Command in
/-- The command `#lint` runs the linters on the current file (by default).

`#lint only someLinter` can be used to run only a single linter. -/
elab tk:"#lint" verbosity:("+" <|> "-")? fast:"*"? only:(&" only")?
    linters:(ppSpace ident)* project:(inProject)? : command => do
  let (decls, whereDesc, groupByFilename) ← match project with
    | none => do pure (← liftCoreM getDeclsInCurrModule, "in the current file", false)
    | some cfg => match cfg with
      | `(inProject| in $id) =>
        let id := id.getId.eraseMacroScopes
        if id == `all then
          pure (← liftCoreM getAllDecls, "in all files", true)
        else
          pure (← liftCoreM (getDeclsInPackage id), s!"in {id}", true)
      | _ => throwUnsupportedSyntax
  let verbosity : LintVerbosity ← match verbosity with
    | none => pure .medium
    | some ⟨.node _ `token.«+» _⟩ => pure .high
    | some ⟨.node _ `token.«-» _⟩ => pure .low
    | _ => throwUnsupportedSyntax
  let fast := fast.isSome
  let onlyNames : Option (List Name) := match only.isSome with
    | true => some (linters.map fun l => l.getId).toList
    | false => none
  let linters ← liftCoreM do
    let mut result ← getChecks (slow := !fast) (runOnly := onlyNames) none
    let linterState := batteriesLinterExt.getState (← getEnv)
    for id in linters do
      let name := id.getId.eraseMacroScopes
      let some (declName, _) := linterState.find? name | throwErrorAt id "not a linter: {name}"
      Elab.addConstInfo id declName
      let linter ← getLinter name declName
      result := result.binInsert (·.name.lt ·.name) linter
    pure result
  let results ← liftCoreM <| lintCore decls linters
  let failed := results.any (!·.2.isEmpty)
  let mut fmtResults ← liftCoreM <|
    formatLinterResults results decls (groupByFilename := groupByFilename)
      whereDesc (runSlowLinters := !fast) verbosity linters.size
  if failed then
    logError fmtResults
  else if verbosity != LintVerbosity.low then
    logInfoAt tk m!"{fmtResults}\n-- All linting checks passed!"

open Elab Command in
/-- The command `#list_linters` prints a list of all available linters. -/
elab "#list_linters" : command => do
  let mut result := #[]
  for (name, _, dflt) in batteriesLinterExt.getState (← getEnv) do
    result := result.binInsert (·.1.lt ·.1) (name, dflt)
  let mut msg := m!"Available linters (linters marked with (*) are in the default lint set):"
  for (name, dflt) in result do
    msg := msg ++ m!"\n{name}{if dflt then " (*)" else ""}"
  logInfo msg



=== LEAN SOURCE: Misc.lean ===
/-
Copyright (c) 2020 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn, Robert Y. Lewis, Arthur Paulino, Gabriel Ebner
-/
import Lean.Util.CollectLevelParams
import Lean.Util.ForEachExpr
import Lean.Meta.GlobalInstances
import Lean.Meta.Check
import Lean.Util.Recognizers
import Lean.DocString
import Batteries.Tactic.Lint.Basic

open Lean Meta Std

namespace Batteries.Tactic.Lint

/-!
# Various linters

This file defines several small linters.
-/

/-- A linter for checking whether a declaration has a namespace twice consecutively in its name. -/
@[env_linter] def dupNamespace : Linter where
  noErrorsFound := "No declarations have a duplicate namespace."
  errorsFound := "DUPLICATED NAMESPACES IN NAME:"
  test declName := do
    if ← isAutoDecl declName then return none
    if isGlobalInstance (← getEnv) declName then return none
    let nm := declName.components
    let some (dup, _) := nm.zip nm.tail! |>.find? fun (x, y) => x == y
      | return none
    return m!"The namespace {dup} is duplicated in the name"

/-- A linter for checking for unused arguments.
We skip all declarations that contain `sorry` in their value. -/
@[env_linter] def unusedArguments : Linter where
  noErrorsFound := "No unused arguments."
  errorsFound := "UNUSED ARGUMENTS."
  test declName := do
    if ← isAutoDecl declName then return none
    if ← isProjectionFn declName then return none
    let info ← getConstInfo declName
    let ty := info.type
    let some val := info.value? | return none
    if val.hasSorry || ty.hasSorry then return none
    forallTelescope ty fun args ty => do
      let mut e := (mkAppN val args).headBeta
      e := mkApp e ty
      for arg in args do
        let ldecl ← getFVarLocalDecl arg
        e := mkApp e ldecl.type
        if let some val := ldecl.value? then
          e := mkApp e val
      let unused := args.zip (.range args.size) |>.filter fun (arg, _) =>
        !e.containsFVar arg.fvarId!
      if unused.isEmpty then return none
      addMessageContextFull <| .joinSep (← unused.toList.mapM fun (arg, i) =>
          return m!"argument {i+1} {arg} : {← inferType arg}") m!", "

/-- A linter for checking definition doc strings. -/
@[env_linter] def docBlame : Linter where
  noErrorsFound := "No definitions are missing documentation."
  errorsFound := "DEFINITIONS ARE MISSING DOCUMENTATION STRINGS:"
  test declName := do
    if (← isAutoDecl declName) || isGlobalInstance (← getEnv) declName then
      return none -- FIXME: scoped/local instances should also not be linted
    if let .str _ s := declName then
      if s == "parenthesizer" || s == "formatter" || s == "delaborator" || s == "quot" then
      return none
    let kind ← match ← getConstInfo declName with
      | .axiomInfo .. => pure "axiom"
      | .opaqueInfo .. => pure "constant"
      | .defnInfo info =>
          -- leanprover/lean4#2575:
          -- projections are generated as `def`s even when they should be `theorem`s
          if ← isProjectionFn declName <&&> isProp info.type then
            return none
          pure "definition"
      | .inductInfo .. => pure "inductive"
      | _ => return none
    let (none) ← findDocString? (← getEnv) declName | return none
    return m!"{kind} missing documentation string"

/-- A linter for checking theorem doc strings. -/
@[env_linter disabled] def docBlameThm : Linter where
  noErrorsFound := "No theorems are missing documentation."
  errorsFound := "THEOREMS ARE MISSING DOCUMENTATION STRINGS:"
  test declName := do
    if ← isAutoDecl declName then
      return none
    let kind ← match ← getConstInfo declName with
      | .thmInfo .. => pure "theorem"
      | .defnInfo info =>
          -- leanprover/lean4#2575:
          -- projections are generated as `def`s even when they should be `theorem`s
          if ← isProjectionFn declName <&&> isProp info.type then
            pure "Prop projection"
          else
            return none
      | _ => return none
    let (none) ← findDocString? (← getEnv) declName | return none
    return m!"{kind} missing documentation string"

/-- A linter for checking whether the correct declaration constructor (definition or theorem)
has been used. -/
@[env_linter] def defLemma : Linter where
  noErrorsFound := "All declarations correctly marked as def/lemma."
  errorsFound := "INCORRECT DEF/LEMMA:"
  test declName := do
    if (← isAutoDecl declName) || isGlobalInstance (← getEnv) declName then
      return none
    -- leanprover/lean4#2575:
    -- projections are generated as `def`s even when they should be `theorem`s
    if ← isProjectionFn declName then return none
    let info ← getConstInfo declName
    let isThm ← match info with
      | .defnInfo .. => pure false
      | .thmInfo .. => pure true
      | _ => return none
    match isThm, ← isProp info.type with
    | true, false => pure "is a lemma/theorem, should be a def"
    | false, true => pure "is a def, should be lemma/theorem"
    | _, _ => return none

/-- A linter for checking whether statements of declarations are well-typed. -/
@[env_linter] def checkType : Linter where
  noErrorsFound :=
    "The statements of all declarations type-check with default reducibility settings."
  errorsFound := "THE STATEMENTS OF THE FOLLOWING DECLARATIONS DO NOT TYPE-CHECK."
  isFast := true
  test declName := do
    if ← isAutoDecl declName then return none
    if ← isTypeCorrect (← getConstInfo declName).type then return none
    return m!"the statement doesn't type check."

/--
`univParamsGrouped e` computes for each `level` `u` of `e` the parameters that occur in `u`,
and returns the corresponding set of lists of parameters.
In pseudo-mathematical form, this returns `{{p : parameter | p ∈ u} | (u : level) ∈ e}`
FIXME: We use `Array Name` instead of `HashSet Name`, since `HashSet` does not have an equality
instance. It will ignore `nm₀.proof_i` declarations.
-/
private def univParamsGrouped (e : Expr) (nm₀ : Name) : Std.HashSet (Array Name) :=
  runST fun σ => do
    let res ← ST.mkRef (σ := σ) {}
    e.forEach fun
      | .sort u =>
        res.modify (·.insert (CollectLevelParams.visitLevel u {}).params)
      | .const n us => do
        if let .str n s .. := n then
          if n == nm₀ && s.startsWith "proof_" then
            return
        res.modify <| us.foldl (·.insert <| CollectLevelParams.visitLevel · {} |>.params)
      | _ => pure ()
    res.get

/--
The good parameters are the parameters that occur somewhere in the set as a singleton or
(recursively) with only other good parameters.
All other parameters in the set are bad.
-/
private partial def badParams (l : Array (Array Name)) : Array Name :=
  let goodLevels := l.filterMap fun
    | #[u] => some u
    | _ => none
  if goodLevels.isEmpty then
    l.flatten.toList.eraseDups.toArray
  else
    badParams <| l.map (·.filter (!goodLevels.contains ·))

/-- A linter for checking that there are no bad `max u v` universe levels.
Checks whether all universe levels `u` in the type of `d` are "good".
This means that `u` either occurs in a `level` of `d` by itself, or (recursively)
with only other good levels.
When this fails, usually this means that there is a level `max u v`, where neither `u` nor `v`
occur by themselves in a level. It is ok if *one* of `u` or `v` never occurs alone. For example,
`(α : Type u) (β : Type (max u v))` is a occasionally useful method of saying that `β` lives in
a higher universe level than `α`.
-/
@[env_linter] def checkUnivs : Linter where
  noErrorsFound :=
    "All declarations have good universe levels."
  errorsFound := "THE STATEMENTS OF THE FOLLOWING DECLARATIONS HAVE BAD UNIVERSE LEVELS. \
    This usually means that there is a `max u v` in the type where neither `u` nor `v` \
    occur by themselves. Solution: Find the type (or type bundled with data) that has this \
    universe argument and provide the universe level explicitly. If this happens in an implicit \
    argument of the declaration, a better solution is to move this argument to a `variables` \
    command (then it's not necessary to provide the universe level).\n\n\
    It is possible that this linter gives a false positive on definitions where the value of the \
    definition has the universes occur separately, and the definition will usually be used with \
    explicit universe arguments. In this case, feel free to add `@[nolint checkUnivs]`."
  isFast := true
  test declName := do
    if ← isAutoDecl declName then return none
    let bad := badParams (univParamsGrouped (← getConstInfo declName).type declName).toArray
    if bad.isEmpty then return none
    return m!"universes {bad} only occur together."

/-- A linter for checking that declarations aren't syntactic tautologies.
Checks whether a lemma is a declaration of the form `∀ a b ... z, e₁ = e₂`
where `e₁` and `e₂` are identical exprs.
We call declarations of this form syntactic tautologies.
Such lemmas are (mostly) useless and sometimes introduced unintentionally when proving basic facts
with rfl when elaboration results in a different term than the user intended. -/
@[env_linter] def synTaut : Linter where
  noErrorsFound :=
    "No declarations are syntactic tautologies."
  errorsFound := "THE FOLLOWING DECLARATIONS ARE SYNTACTIC TAUTOLOGIES. \
    This usually means that they are of the form `∀ a b ... z, e₁ = e₂` where `e₁` and `e₂` are \
    identical expressions. We call declarations of this form syntactic tautologies. \
    Such lemmas are (mostly) useless and sometimes introduced unintentionally when proving \
    basic facts using `rfl`, when elaboration results in a different term than the user intended. \
    You should check that the declaration really says what you think it does."
  isFast := true
  test declName := do
    if ← isAutoDecl declName then return none
    forallTelescope (← getConstInfo declName).type fun _ ty => do
      let some (lhs, rhs) := ty.eq?.map (fun (_, l, r) => (l, r)) <|> ty.iff?
        | return none
      if lhs == rhs then
        return m!"LHS equals RHS syntactically"
      return none

/--
Return a list of unused `let_fun` terms in an expression that introduce proofs.
-/
@[nolint unusedArguments]
def findUnusedHaves (_e : Expr) : MetaM (Array MessageData) := do
  -- adaptation note: kmill 2025-06-29. `Expr.letFun?` is deprecated.
  -- This linter needs to be updated for `Expr.letE (nondep := true)`, but it has false
  -- positives, so I am disabling it for now.
  return #[]
  /-
  let res ← IO.mkRef #[]
  forEachExpr e fun e => do
    match e.letFun? with
    | some (n, t, _, b) =>
      if n.isInternal then return
      if b.hasLooseBVars then return
      unless ← Meta.isProp t do return
      let msg ← addMessageContextFull m!"unnecessary have {n.eraseMacroScopes} : {t}"
      res.modify (·.push msg)
    | _ => return
  res.get
  -/

/-- A linter for checking that declarations don't have unused term mode have statements. -/
@[env_linter] def unusedHavesSuffices : Linter where
  noErrorsFound := "No declarations have unused term mode have statements."
  errorsFound := "THE FOLLOWING DECLARATIONS HAVE INEFFECTUAL TERM MODE HAVE/SUFFICES BLOCKS. \
    In the case of `have` this is a term of the form `have h := foo, bar` where `bar` does not \
    refer to `foo`. Such statements have no effect on the generated proof, and can just be \
    replaced by `bar`, in addition to being ineffectual, they may make unnecessary assumptions \
    in proofs appear as if they are used. \
    For `suffices` this is a term of the form `suffices h : foo, proof_of_goal, proof_of_foo` \
    where `proof_of_goal` does not refer to `foo`. \
    Such statements have no effect on the generated proof, and can just be replaced by \
    `proof_of_goal`, in addition to being ineffectual, they may make unnecessary assumptions \
    in proofs appear as if they are used."
  test declName := do
    if ← isAutoDecl declName then return none
    let info ← getConstInfo declName
    let mut unused ← findUnusedHaves info.type
    if let some value := info.value? then
      unused := unused ++ (← findUnusedHaves value)
    unless unused.isEmpty do
      return some <| .joinSep unused.toList ", "
    return none

/--
A linter for checking if variables appearing on both sides of an iff are explicit. Ideally, such
variables should be implicit instead.
-/
@[env_linter disabled] def explicitVarsOfIff : Linter where
  noErrorsFound := "No explicit variables on both sides of iff"
  errorsFound := "EXPLICIT VARIABLES ON BOTH SIDES OF IFF"
  test declName := do
    if ← isAutoDecl declName then return none
    forallTelescope (← getConstInfo declName).type fun args ty => do
      let some (lhs, rhs) := ty.iff? | return none
      let explicit ← args.filterM fun arg =>
        return (← getFVarLocalDecl arg).binderInfo.isExplicit &&
          lhs.containsFVar arg.fvarId! && rhs.containsFVar arg.fvarId!
      if explicit.isEmpty then return none
      addMessageContextFull m!"should be made implicit: {
        MessageData.joinSep (explicit.toList.map (m!"{·}")) ", "}"



=== LEAN SOURCE: Simp.lean ===
/-
Copyright (c) 2020 Gabriel Ebner. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Gabriel Ebner
-/
import Lean.Meta.Tactic.Simp.Main
import Batteries.Tactic.Lint.Basic
import Batteries.Tactic.OpenPrivate
import Batteries.Util.LibraryNote
open Lean Meta

namespace Batteries.Tactic.Lint

/-!
# Linter for simplification lemmas

This files defines several linters that prevent common mistakes when declaring simp lemmas:

 * `simpNF` checks that the left-hand side of a simp lemma is not simplified by a different lemma.
 * `simpVarHead` checks that the head symbol of the left-hand side is not a variable.
 * `simpComm` checks that commutativity lemmas are not marked as simplification lemmas.
-/

/-- The data associated to a simp theorem. -/
structure SimpTheoremInfo where
  /-- The hypotheses of the theorem -/
  hyps : Array Expr
  /-- The thing to replace -/
  lhs : Expr
  /-- The result of replacement -/
  rhs : Expr

/-- Is this hypothesis a condition that might turn into a `simp` side-goal?
i.e. is it a proposition that isn't marked as instance implicit? -/
def isCondition (h : Expr) : MetaM Bool := do
  let ldecl ← h.fvarId!.getDecl
  if ldecl.binderInfo.isInstImplicit then return false
  isProp ldecl.type

open private preprocess from Lean.Meta.Tactic.Simp.SimpTheorems in
/-- Runs the continuation on all the simp theorems encoded in the given type. -/
def withSimpTheoremInfos (ty : Expr) (k : SimpTheoremInfo → MetaM α) : MetaM (Array α) :=
  withReducible do
    let e ← preprocess (← mkSorry ty true) ty (inv := false) (isGlobal := true)
    e.toArray.mapM fun (_, ty') => do
      forallTelescopeReducing ty' fun hyps eq => do
        let some (_, lhs, rhs) := eq.eq? | throwError "not an equality {eq}"
        k { hyps, lhs, rhs }

/-- Checks whether two expressions are equal for the simplifier. That is,
they are reducibly-definitional equal, and they have the same head symbol. -/
def isSimpEq (a b : Expr) (whnfFirst := true) : MetaM Bool := withReducible do
  let a ← if whnfFirst then whnf a else pure a
  let b ← if whnfFirst then whnf b else pure b
  if a.getAppFn.constName? != b.getAppFn.constName? then return false
  isDefEq a b

/-- Constructs a message from all the simp theorems encoded in the given type. -/
def checkAllSimpTheoremInfos (ty : Expr) (k : SimpTheoremInfo → MetaM (Option MessageData)) :
    MetaM (Option MessageData) := do
  let errors :=
    (← withSimpTheoremInfos ty fun i => do (← k i).mapM addMessageContextFull).filterMap id
  if errors.isEmpty then
    return none
  return MessageData.joinSep errors.toList Format.line

/-- Returns true if this is a `@[simp]` declaration. -/
def isSimpTheorem (declName : Name) : MetaM Bool := do
  pure $ (← getSimpTheorems).lemmaNames.contains (.decl declName)

open Lean.Meta.DiscrTree in
/-- Returns the list of elements in the discrimination tree. -/
partial def _root_.Lean.Meta.DiscrTree.elements (d : DiscrTree α) : Array α :=
  d.root.foldl (init := #[]) fun arr _ => trieElements arr
where
  /-- Returns the list of elements in the trie. -/
  trieElements (arr)
  | Trie.node vs children =>
    children.foldl (init := arr ++ vs) fun arr (_, child) => trieElements arr child

/-- Add message `msg` to any errors thrown inside `k`. -/
def decorateError (msg : MessageData) (k : MetaM α) : MetaM α := do
  try k catch e => throw (.error e.getRef m!"{msg}\n{e.toMessageData}")

/-- Render the list of simp lemmas. -/
def formatLemmas (usedSimps : Simp.UsedSimps) (simpName : String) (higherOrder : Option Bool) :
    MetaM MessageData := do
  let mut args := if higherOrder == none then #[] else #[m!"*"]
  let env ← getEnv
  for (thm, _) in usedSimps.map.toArray.qsort (·.2 < ·.2) do
    if let .decl declName := thm then
      if env.contains declName && declName != ``eq_self then
        args := args.push m! "{← mkConstWithFreshMVarLevels declName}"
  let contextual? := if higherOrder == some true then " +contextual" else ""
  return m!"{simpName}{contextual?} only {args.toList}"

/-- A linter for simp lemmas whose lhs is not in simp-normal form, and which hence never fire. -/
@[env_linter] def simpNF : Linter where
  noErrorsFound := "All left-hand sides of simp lemmas are in simp-normal form."
  errorsFound := "SOME SIMP LEMMAS ARE NOT IN SIMP-NORMAL FORM.
see note [simp-normal form] for tips how to debug this.
https://leanprover-community.github.io/mathlib_docs/notes.html#simp-normal%20form"
  test := fun declName => do
    unless ← isSimpTheorem declName do return none
    withConfig Elab.Term.setElabConfig do
      checkAllSimpTheoremInfos (← getConstInfo declName).type fun { lhs, rhs, hyps, .. } => do
        -- we use `simp [*]` so that simp lemmas with hypotheses apply to themselves
        -- higher order simp lemmas need `simp +contextual [*]` to be able to apply to themselves
        let mut simpTheorems ← getSimpTheorems
        let mut higherOrder := false
        for h in hyps do
          if ← isCondition h then
            simpTheorems ← simpTheorems.add (.fvar h.fvarId!) #[] h
            if !higherOrder then
              higherOrder ← forallTelescope (← inferType h) fun hyps _ => hyps.anyM isCondition
        let ctx ← Simp.mkContext (config := { contextual := higherOrder })
          (simpTheorems := #[simpTheorems]) (congrTheorems := ← getSimpCongrTheorems)
        let isRfl ← isRflTheorem declName
        let simplify (e : Expr) (ctx : Simp.Context) (stats : Simp.Stats := {}) :
            MetaM (Simp.Result × Simp.Stats) := do
          if !isRfl then
            simp e ctx (stats := stats)
          else
            let (e, s) ← dsimp e ctx (stats := stats)
            return (Simp.Result.mk e .none .true, s)
        let ({ expr := lhs', proof? := prf1, .. }, prf1Stats) ←
          decorateError "simplify fails on left-hand side:" <| simplify lhs ctx
        if prf1Stats.usedTheorems.map.contains (.decl declName) then return none
        let ({ expr := rhs', .. }, stats) ←
          decorateError "simplify fails on right-hand side:" <| simplify rhs ctx prf1Stats
        let lhs'EqRhs' ← isSimpEq lhs' rhs' (whnfFirst := false)
        let lhsInNF ← isSimpEq lhs' lhs
        let simpName := if !isRfl then "simp" else "dsimp"
        if lhs'EqRhs' then
          if prf1.isNone then return none -- TODO: FP rewriting foo.eq_2 using `simp only [foo]`
          return m!"\
            {simpName} can prove this:\
            \n  by {← formatLemmas stats.usedTheorems simpName higherOrder}\
            \nOne of the lemmas above could be a duplicate.\
            \nIf that's not the case try reordering lemmas or adding @[priority]."
        else if ¬ lhsInNF then
          return m!"\
            Left-hand side simplifies from\
            \n  {lhs}\
            \nto\
            \n  {lhs'}\
            \nusing\
            \n  {← formatLemmas prf1Stats.usedTheorems simpName higherOrder}\
            \nTry to change the left-hand side to the simplified term!"
        else if lhs == lhs' then
          let lhsType ← inferType lhs
          let mut hints := m!""
          for h in hyps do
            let ldecl ← h.fvarId!.getDecl
            let mut name := ldecl.userName
            if name.hasMacroScopes then
              name := sanitizeName name |>.run' { options := ← getOptions }
            if ← isProp ldecl.type then
              -- improve the error message if the hypothesis isn't in `simp` normal form
              let ({ expr := hType', .. }, stats) ←
                decorateError m!"simplify fails on hypothesis ({name} : {ldecl.type}):" <|
                  simplify ldecl.type (← Simp.Context.mkDefault)
              unless ← isSimpEq hType' ldecl.type do
                hints := hints ++ m!"\
                  \nThe simp lemma may be invalid because hypothesis {name} simplifies from\
                  \n  {ldecl.type}\
                  \nto\
                  \n  {hType'}\
                  \nusing\
                  \n  {← formatLemmas stats.usedTheorems simpName none}\
                  \nTry to change the hypothesis to the simplified term!"
            else
              -- improve the error message if the argument can't be filled in by `simp`
              if !ldecl.binderInfo.isInstImplicit &&
                  !lhs.containsFVar h.fvarId! && !lhsType.containsFVar h.fvarId! then
                hints := hints ++ m!"\
                  \nThe simp lemma is invalid because the value of argument\
                  \n  {name} : {ldecl.type}\
                  \ncannot be inferred by `simp`."
          return m!"\
            Left-hand side does not simplify, when using the simp lemma on itself.
            \nThis usually means that it will never apply.{hints}\n"
        else
          return none

library_note "simp-normal form" /--
This note gives you some tips to debug any errors that the simp-normal form linter raises.

The reason that a lemma was considered faulty is because its left-hand side is not in simp-normal
form.
These lemmas are hence never used by the simplifier.

This linter gives you a list of other simp lemmas: look at them!

Here are some tips depending on the error raised by the linter:

  1. 'the left-hand side reduces to XYZ':
     you should probably use XYZ as the left-hand side.

  2. 'simp can prove this':
     This typically means that lemma is a duplicate, or is shadowed by another lemma:

     2a. Always put more general lemmas after specific ones:
      ```
      @[simp] lemma zero_add_zero : 0 + 0 = 0 := rfl
      @[simp] lemma add_zero : x + 0 = x := rfl
      ```

      And not the other way around!  The simplifier always picks the last matching lemma.

     2b. You can also use `@[priority]` instead of moving simp-lemmas around in the file.

      Tip: the default priority is 1000.
      Use `@[priority 1100]` instead of moving a lemma down,
      and `@[priority 900]` instead of moving a lemma up.

     2c. Conditional simp lemmas are tried last. If they are shadowed
         just remove the `simp` attribute.

     2d. If two lemmas are duplicates, the linter will complain about the first one.
         Try to fix the second one instead!
         (You can find it among the other simp lemmas the linter prints out!)

  3. 'try_for tactic failed, timeout':
     This typically means that there is a loop of simp lemmas.
     Try to apply squeeze_simp to the right-hand side (removing this lemma from the simp set) to see
     what lemmas might be causing the loop.

     Another trick is to `set_option trace.simplify.rewrite true` and
     then apply `try_for 10000 { simp }` to the right-hand side.  You will
     see a periodic sequence of lemma applications in the trace message.
-/

/--
A linter for simp lemmas whose lhs has a variable as head symbol,
and which hence never fire.
-/
@[env_linter] def simpVarHead : Linter where
  noErrorsFound :=
    "No left-hand sides of a simp lemma has a variable as head symbol."
  errorsFound := "LEFT-HAND SIDE HAS VARIABLE AS HEAD SYMBOL.
Some simp lemmas have a variable as head symbol of the left-hand side (after whnfR):"
  test := fun declName => do
    unless ← isSimpTheorem declName do return none
    checkAllSimpTheoremInfos (← getConstInfo declName).type fun {lhs, ..} => do
    let lhs ← whnfR lhs
    let headSym := lhs.getAppFn
    unless headSym.isFVar do return none
    return m!"Left-hand side has variable as head symbol: {headSym}"

private def Expr.eqOrIff? : Expr → Option (Expr × Expr)
  | .app (.app (.app (.const ``Eq _) _) lhs) rhs
  | .app (.app (.const ``Iff _) lhs) rhs
    => (lhs, rhs)
  | _ => none

/-- A linter for commutativity lemmas that are marked simp. -/
@[env_linter] def simpComm : Linter where
  noErrorsFound := "No commutativity lemma is marked simp."
  errorsFound := "COMMUTATIVITY LEMMA IS SIMP.
Some commutativity lemmas are simp lemmas:"
  test := fun declName => withSimpGlobalConfig do withReducible do
    unless ← isSimpTheorem declName do return none
    let ty := (← getConstInfo declName).type
    forallTelescopeReducing ty fun _ ty' => do
    let some (lhs, rhs) := ty'.eqOrIff? | return none
    unless lhs.getAppFn.constName? == rhs.getAppFn.constName? do return none
    let (_, _, ty') ← forallMetaTelescopeReducing ty
    let some (lhs', rhs') := ty'.eqOrIff? | return none
    unless ← isDefEq rhs lhs' do return none
    unless ← withNewMCtxDepth (isDefEq rhs lhs') do return none
    -- make sure that the discrimination tree will actually find this match (see #69)
    if (← (← DiscrTree.empty.insert rhs ()).getMatch lhs').isEmpty then
      return none
    -- ensure that the second application makes progress:
    if ← isDefEq lhs' rhs' then return none
    pure m!"should not be marked simp"



=== LEAN SOURCE: TypeClass.lean ===
/-
Copyright (c) 2022 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Gabriel Ebner
-/
import Lean.Meta.Instances
import Batteries.Tactic.Lint.Basic

namespace Batteries.Tactic.Lint
open Lean Meta

/--
Lints for instances with arguments that cannot be filled in, like
```
instance {α β : Type} [Group α] : Mul α where ...
```
-/
@[env_linter] def impossibleInstance : Linter where
  noErrorsFound := "No instance has arguments that are impossible to infer"
  errorsFound := "SOME INSTANCES HAVE ARGUMENTS THAT ARE IMPOSSIBLE TO INFER
These are arguments that are not instance-implicit and do not appear in
another instance-implicit argument or the return type."
  test declName := do
    unless ← isInstance declName do return none
    forallTelescopeReducing (← inferType (← mkConstWithLevelParams declName)) fun args ty => do
    let argTys ← args.mapM inferType
    let impossibleArgs ← args.zipIdx.filterMapM fun (arg, i) => do
      let fv := arg.fvarId!
      if (← fv.getDecl).binderInfo.isInstImplicit then return none
      if ty.containsFVar fv then return none
      if argTys[i+1:].any (·.containsFVar fv) then return none
      return some m!"argument {i+1} {arg} : {← inferType arg}"
    if impossibleArgs.isEmpty then return none
    addMessageContextFull <| .joinSep impossibleArgs.toList ", "

/--
A linter for checking if any declaration whose type is not a class is marked as an instance.
-/
@[env_linter] def nonClassInstance : Linter where
  noErrorsFound := "No instances of non-classes"
  errorsFound := "INSTANCES OF NON-CLASSES"
  test declName := do
    if !(← isInstance declName) then return none
    let info ← getConstInfo declName
    if !(← isClass? info.type).isSome then return "should not be an instance"
    return none



=== LEAN SOURCE: Cache.lean ===
/-
Copyright (c) 2021 Gabriel Ebner. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Gabriel Ebner
-/
import Lean.Meta.DiscrTree

/-!
# Once-per-file cache for tactics

This file defines cache data structures for tactics
that are initialized the first time they are accessed.
Since Lean 4 starts one process per file, these caches are once-per-file
and can for example be used to cache information about the imported modules.

The `Cache α` data structure is the most generic version we define.
It is created using `Cache.mk f` where `f : MetaM α` performs the initialization of the cache:
```
initialize numberOfImports : Cache Nat ← Cache.mk do
  (← getEnv).imports.size

-- (does not work in the same module where the cache is defined)
#eval show MetaM Nat from numberOfImports.get
```

The `DeclCache α` data structure computes a fold over the environment's constants:
`DeclCache.mk empty f` constructs such a cache
where `empty : α` and `f : Name → ConstantInfo → α → MetaM α`.
The result of the constants in the imports is cached between tactic invocations,
while for constants defined in the same file `f` is evaluated again every time.
This kind of cache can be used e.g. to populate discrimination trees.
-/

open Lean Meta

namespace Batteries.Tactic

/-- Once-per-file cache. -/
def Cache (α : Type) := IO.Ref <| MetaM α ⊕ Task (Except Exception α)

-- This instance is required as we use `Cache` with `initialize`.
-- One might expect an `Inhabited` instance here,
-- but there is no way to construct such without using choice anyway.
instance : Nonempty (Cache α) := inferInstanceAs <| Nonempty (IO.Ref _)

/-- Creates a cache with an initialization function. -/
def Cache.mk (init : MetaM α) : IO (Cache α) := IO.mkRef <| Sum.inl init

/--
Access the cache. Calling this function for the first time will initialize the cache
with the function provided in the constructor.
-/
def Cache.get [Monad m] [MonadEnv m] [MonadLog m] [MonadOptions m] [MonadLiftT BaseIO m]
    [MonadExcept Exception m] (cache : Cache α) : m α := do
  let t ← match ← ST.Ref.get (m := BaseIO) cache with
    | .inr t => pure t
    | .inl init =>
      let env ← getEnv
      let fileName ← getFileName
      let fileMap ← getFileMap
      let options ← getOptions -- TODO: sanitize options?
      -- Default heartbeats to a reasonable value.
      -- otherwise exact? times out on mathlib
      -- TODO: add customization option
      let options := maxHeartbeats.set options <|
        options.get? maxHeartbeats.name |>.getD 1000000
      let res ← EIO.asTask <|
        init {} |>.run' {} { options, fileName, fileMap } |>.run' { env }
      cache.set (m := BaseIO) (.inr res)
      pure res
  match t.get with
  | Except.ok res => pure res
  | Except.error err => throw err

/--
Cached fold over the environment's declarations,
where a given function is applied to `α` for every constant.
-/
structure DeclCache (α : Type) where mk' ::
  /-- The cached data. -/
  cache : Cache α
  /-- Function for adding a declaration from the current file to the cache. -/
  addDecl : Name → ConstantInfo → α → MetaM α
  /-- Function for adding a declaration from the library to the cache.
  Defaults to the same behaviour as adding a declaration from the current file. -/
  addLibraryDecl : Name → ConstantInfo → α → MetaM α := addDecl
  deriving Nonempty

/--
Creates a `DeclCache`.

First, if `pre` is nonempty, run that for a value,
and if successful populate the cache with that value.

If `pre` is empty, or it fails,
the cached structure `α` is initialized with `empty`,
and then `addLibraryDecl` is called for every imported constant.
After all imported constants have been added, we run `post`.
Finally, the result is cached.

When `get` is called, `addDecl` is also called for every constant in the current file.
-/
def DeclCache.mk (profilingName : String) (pre : MetaM α := failure) (empty : α)
    (addDecl : Name → ConstantInfo → α → MetaM α)
    (addLibraryDecl : Name → ConstantInfo → α → MetaM α := addDecl)
    (post : α → MetaM α := fun a => pure a) : IO (DeclCache α) := do
  let cache ← Cache.mk do
    try
      -- We allow arbitrary failures in the `pre` tactic,
      -- and fall back on folding over the entire environment.
      -- In practice the `pre` tactic may be unpickling an `.olean`,
      -- and may fail after leanprover/lean4#2766 because the embedded hash is incorrect.
      pre
    catch _ =>
      profileitM Exception profilingName (← getOptions) do
        post <|← (← getEnv).constants.map₁.foldM (init := empty) fun a n c =>
          addLibraryDecl n c a
  pure { cache, addDecl }

/--
Access the cache. Calling this function for the first time will initialize the cache
with the function provided in the constructor.
-/
def DeclCache.get (cache : DeclCache α) : MetaM α := do
  (← getEnv).constants.map₂.foldlM (init := ← cache.cache.get) fun a n c =>
    cache.addDecl n c a

/--
A type synonym for a `DeclCache` containing a pair of discrimination trees.
The first will store declarations in the current file,
the second will store declarations from imports (and will hopefully be "read-only" after creation).
-/
@[reducible] def DiscrTreeCache (α : Type) : Type := DeclCache (DiscrTree α × DiscrTree α)

/--
Build a `DiscrTreeCache`,
from a function that returns a collection of keys and values for each declaration.
-/
def DiscrTreeCache.mk [BEq α] (profilingName : String)
    (processDecl : Name → ConstantInfo → MetaM (Array (Array DiscrTree.Key × α)))
    (post? : Option (Array α → Array α) := none)
    (init : MetaM (DiscrTree α) := failure) :
    IO (DiscrTreeCache α) :=
  let updateTree := fun name constInfo tree => do
    return (← processDecl name constInfo).foldl (init := tree) fun t (k, v) =>
      t.insertCore k v
  let addDecl := fun name constInfo (tree₁, tree₂) =>
    return (← updateTree name constInfo tree₁, tree₂)
  let addLibraryDecl := fun name constInfo (tree₁, tree₂) =>
    return (tree₁, ← updateTree name constInfo tree₂)
  let post := match post? with
  | some f => fun (T₁, T₂) => return (T₁, T₂.mapArrays f)
  | none => fun T => pure T
  let init' := return ({}, ← init)
  DeclCache.mk profilingName init' ({}, {}) addDecl addLibraryDecl (post := post)

/--
Get matches from both the discrimination tree for declarations in the current file,
and for the imports.

Note that if you are calling this multiple times with the same environment,
it will rebuild the discrimination tree for the current file multiple times,
and it would be more efficient to call `c.get` once,
and then call `DiscrTree.getMatch` multiple times.
-/
def DiscrTreeCache.getMatch (c : DiscrTreeCache α) (e : Expr) : MetaM (Array α) := do
  let (locals, imports) ← c.get
  -- `DiscrTree.getMatch` returns results in batches, with more specific lemmas coming later.
  -- Hence we reverse this list, so we try out more specific lemmas earlier.
  return (← locals.getMatch e).reverse ++ (← imports.getMatch e).reverse



=== LEAN SOURCE: ExtendedBinder.lean ===
/-
Copyright (c) 2021 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Gabriel Ebner
-/

/-!
Defines an extended binder syntax supporting `∀ ε > 0, ...` etc.
-/

namespace Batteries.ExtendedBinder
open Lean


-- We also provide special versions of ∀/∃ that take a list of extended binders.
-- The built-in binders are not reused because that results in overloaded syntax.

/--
An extended binder has the form `x`, `x : ty`, or `x pred`
where `pred` is a `binderPred` like `< 2`.
-/
syntax extBinder := binderIdent ((" : " term) <|> binderPred)?
/-- A extended binder in parentheses -/
syntax extBinderParenthesized := " (" extBinder ")" -- TODO: inlining this definition breaks
/-- A list of parenthesized binders -/
syntax extBinderCollection := extBinderParenthesized*
/-- A single (unparenthesized) binder, or a list of parenthesized binders -/
syntax extBinders := (ppSpace extBinder) <|> extBinderCollection

/-- The syntax `∃ᵉ (x < 2) (y < 3), p x y` is shorthand for `∃ x < 2, ∃ y < 3, p x y`. -/
syntax "∃ᵉ" extBinders ", " term : term
macro_rules
  | `(∃ᵉ, $b) => pure b
  | `(∃ᵉ ($p:extBinder) $[($ps:extBinder)]*, $b) =>
    `(∃ᵉ $p:extBinder, ∃ᵉ $[($ps:extBinder)]*, $b)
macro_rules -- TODO: merging the two macro_rules breaks expansion
  | `(∃ᵉ $x:binderIdent, $b) => `(∃ $x:binderIdent, $b)
  | `(∃ᵉ $x:binderIdent : $ty:term, $b) => `(∃ $x:binderIdent : $ty:term, $b)
  | `(∃ᵉ $x:binderIdent $p:binderPred, $b) => `(∃ $x:binderIdent $p:binderPred, $b)

/-- The syntax `∀ᵉ (x < 2) (y < 3), p x y` is shorthand for `∀ x < 2, ∀ y < 3, p x y`. -/
syntax "∀ᵉ" extBinders ", " term : term
macro_rules
  | `(∀ᵉ, $b) => pure b
  | `(∀ᵉ ($p:extBinder) $[($ps:extBinder)]*, $b) =>
    `(∀ᵉ $p:extBinder, ∀ᵉ $[($ps:extBinder)]*, $b)
macro_rules -- TODO: merging the two macro_rules breaks expansion
  | `(∀ᵉ _, $b) => `(∀ _, $b)
  | `(∀ᵉ $x:ident, $b) => `(∀ $x:ident, $b)
  | `(∀ᵉ _ : $ty:term, $b) => `(∀ _ : $ty:term, $b)
  | `(∀ᵉ $x:ident : $ty:term, $b) => `(∀ $x:ident : $ty:term, $b)
  | `(∀ᵉ $x:binderIdent $p:binderPred, $b) => `(∀ $x:binderIdent $p:binderPred, $b)



=== LEAN SOURCE: LibraryNote.lean ===
/-
Copyright (c) 2022 Gabriel Ebner. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Gabriel Ebner
-/
import Lean.Elab.Command

/-!
# Define the `library_note` command.
-/

namespace Batteries.Util.LibraryNote

open Lean

/-- A library note consists of a (short) tag and a (long) note. -/
def LibraryNoteEntry := String × String
deriving Inhabited

/-- Environment extension supporting `library_note`. -/
initialize libraryNoteExt : SimplePersistentEnvExtension LibraryNoteEntry (Array LibraryNoteEntry) ←
  registerSimplePersistentEnvExtension {
    addEntryFn := Array.push
    addImportedFn := Array.flatMap id
  }

open Lean Parser Command in
/--
```
library_note "some tag" /--
... some explanation ...
-/
```
creates a new "library note", which can then be cross-referenced using
```
-- See note [some tag]
```
in doc-comments.
Use `#help note "some tag"` to display all notes with the tag `"some tag"` in the infoview.
This command can be imported from Batteries.Tactic.HelpCmd .
-/
elab "library_note " title:strLit ppSpace text:docComment : command => do
  modifyEnv (libraryNoteExt.addEntry · (title.getString, text.getDocString))



=== LEAN SOURCE: Panic.lean ===
/-
Copyright (c) 2024 François G. Dorais. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: François G. Dorais
-/

namespace Batteries

/-- Panic with a specific default value `v`. -/
def panicWith (v : α) (msg : String) : α := @panic α ⟨v⟩ msg

@[simp] theorem panicWith_eq (v : α) (msg) : panicWith v msg = v := rfl



=== LEAN SOURCE: Pickle.lean ===
/-
Copyright (c) 2023 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Lean.Environment

/-!
# Pickling and unpickling objects

By abusing `saveModuleData` and `readModuleData` we can pickle and unpickle objects to disk.
-/

open Lean System

/--
Save an object to disk.
If you need to write multiple objects from within a single declaration,
you will need to provide a unique `key` for each.
-/
def pickle {α : Type} (path : FilePath) (x : α) (key : Name := by exact decl_name%) : IO Unit :=
  saveModuleData path key (unsafe unsafeCast x)

/--
Load an object from disk.
Note: The returned `CompactedRegion` can be used to free the memory behind the value
of type `α`, using `CompactedRegion.free` (which is only safe once all references to the `α` are
released). Ignoring the `CompactedRegion` results in the data being leaked.
Use `withUnpickle` to call `CompactedRegion.free` automatically.

This function is unsafe because the data being loaded may not actually have type `α`, and this
may cause crashes or other bad behavior.
-/
unsafe def unpickle (α : Type) (path : FilePath) : IO (α × CompactedRegion) := do
  let (x, region) ← readModuleData path
  pure (unsafeCast x, region)

/-- Load an object from disk and run some continuation on it, freeing memory afterwards. -/
unsafe def withUnpickle [Monad m] [MonadLiftT IO m] {α β : Type}
    (path : FilePath) (f : α → m β) : m β := do
  let (x, region) ← unpickle α path
  let r ← f x
  region.free
  pure r



=== LEAN SOURCE: ProofWanted.lean ===
/-
Copyright (c) 2023 Lean FRO, LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Thrane Christiansen
-/
import Lean.Elab.Exception
import Lean.Elab.Command


open Lean Parser Elab Command

/-- This proof would be a welcome contribution to the library!

The syntax of `proof_wanted` declarations is just like that of `theorem`, but without `:=` or the
proof. Lean checks that `proof_wanted` declarations are well-formed (e.g. it ensures that all the
mentioned names are in scope, and that the theorem statement is a valid proposition), but they are
discarded afterwards. This means that they cannot be used as axioms.

Typical usage:
```
@[simp] proof_wanted empty_find? [BEq α] [Hashable α] {a : α} :
    (∅ : HashMap α β).find? a = none
```
-/
@[command_parser]
def «proof_wanted» := leading_parser
  declModifiers false >> "proof_wanted" >> declId >> ppIndent declSig

/-- Elaborate a `proof_wanted` declaration. The declaration is translated to an axiom during
elaboration, but it's then removed from the environment.
-/
@[command_elab «proof_wanted»]
def elabProofWanted : CommandElab
  | `($mods:declModifiers proof_wanted $name $args* : $res) => withoutModifyingEnv do
    -- The helper axiom is used instead of `sorry` to avoid spurious warnings
    elabCommand <| ← `(
      section
      set_option linter.unusedVariables false
      axiom helper {α : Sort _} : α
      $mods:declModifiers theorem $name $args* : $res := helper
      end)
  | _ => throwUnsupportedSyntax



=== LEAN SOURCE: absurd.lean ===
import Batteries.Tactic.Basic

/-! Tests for `absurd` tactic -/

-- Basic example
/--
error: unsolved goals
p : Prop
h : p
⊢ ¬p
-/
#guard_msgs in
example {p : Prop} (h : p) : 0 = 0 := by
  absurd h

-- Negative example
/--
error: unsolved goals
p : Prop
h : ¬p
⊢ p
-/
#guard_msgs in
example {p : Prop} (h : ¬p) : 0 = 1 := by
  absurd h

-- Inequality example
/--
error: unsolved goals
n : Nat
h : n ≠ 0
⊢ n = 0
-/
#guard_msgs in
example (h : n ≠ 0) : 0 = 2 := by
  absurd h

-- Example with implies false
/--
error: unsolved goals
p : Prop
h : p → False
⊢ p
-/
#guard_msgs in
example {p : Prop} (h : p → False) : 0 = 3 := by
  absurd h

/--
error: unsolved goals
p : Prop
h : p
⊢ ¬p
-/
#guard_msgs in
example {p : Prop} {h : p} : ∀ {x : True}, 0 = 0 := by
  absurd h

-- `·` should not be legal
/--
error: invalid occurrence of `·` notation, it must be surrounded by parentheses (e.g. `(· + 1)`)
---
error: unsolved goals
p : Prop
h : p
⊢ ∀ {x : True}, 0 = 0
-/
#guard_msgs in
example {p : Prop} {h : p} : ∀ {_ : True}, 0 = 0 := by
  absurd ·



=== LEAN SOURCE: alias.lean ===
import Batteries.Tactic.Alias

set_option linter.unusedVariables false
set_option linter.missingDocs false

open Lean Meta
namespace A

/-- doc string for foo -/
theorem foo : 1 + 1 = 2 := rfl

/-- doc string for `alias foo` -/
alias foo1 := foo
@[deprecated (since := "2038-01-20")] alias foo2 := foo
@[deprecated foo2 (since := "2038-01-20")] alias _root_.B.foo3 := foo
@[deprecated foo2 "it was never a good idea anyway" (since := "last thursday")] alias foo4 := foo

example : 1 + 1 = 2 := foo1
/-- warning: `A.foo2` has been deprecated: use `A.foo` instead -/
#guard_msgs in example : 1 + 1 = 2 := foo2
/-- warning: `B.foo3` has been deprecated: use `A.foo2` instead -/
#guard_msgs in example : 1 + 1 = 2 := B.foo3
/-- warning: `A.foo4` has been deprecated: it was never a good idea anyway -/
#guard_msgs in example : 1 + 1 = 2 := foo4

/-- doc string for bar -/
def bar : Nat := 5
alias bar1 := bar
alias _root_.B.bar2 := bar
example : bar1 = 5 := rfl
example : B.bar2 = 5 := rfl

theorem baz (x : Nat) : x = x := rfl
alias baz1 := baz
example : 3 = 3 := baz1 3

/-- doc string for foobar -/
def foobar : Nat → Nat := id
@[inherit_doc foobar] alias foobar1 := foobar
@[simp] alias foobar2 := foobar
/-- doc string for foobar2 -/
def foobar3 (n : Nat) := foobar1 n

/-- error: simp made no progress -/
#guard_msgs in
example : foobar1 x = foobar x := by simp
example : foobar2 x = foobar x := by simp

/- Test protected -/

/-- doc string for Foo.barbaz -/
protected alias Foo.barbaz := trivial
/-- error: unknown identifier 'barbaz' -/
#guard_msgs in example : True := barbaz
example : True := Foo.barbaz

/- Test noncomputable -/

/-- doc string for foobaz -/
noncomputable def foobaz : Nat → Nat := id
alias foobaz1 := foobaz

/--
error: failed to compile definition, compiler IR check failed at 'A.foobaz2'. Error: depends on declaration 'A.foobaz1', which has no executable code; consider marking definition as 'noncomputable'
-/
#guard_msgs in def foobaz2 (n : Nat) := foobaz1 n

noncomputable alias foobaz3 := id
/--
error: failed to compile definition, compiler IR check failed at 'A.foobaz4'. Error: depends on declaration 'A.foobaz3', which has no executable code; consider marking definition as 'noncomputable'
-/
#guard_msgs in def foobaz4 (n : Nat) := foobaz3 n

/- Test unsafe -/

/-- doc string for barbaz -/
unsafe def barbaz : Nat → Nat := id
alias barbaz1 := barbaz
/-- error: (kernel) invalid declaration, it uses unsafe declaration 'A.barbaz1' -/
#guard_msgs in def barbaz2 (n : Nat) := barbaz1 n

unsafe alias barbaz3 := id
/-- error: (kernel) invalid declaration, it uses unsafe declaration 'A.barbaz3' -/
#guard_msgs in def barbaz4 (n : Nat) := barbaz3 n

/- iff version -/

@[deprecated (since := "2038-01-20")] alias ⟨mpId, mprId⟩ := Iff.rfl

/-- info: A.mpId {a : Prop} : a → a -/
#guard_msgs in #check mpId
/-- info: A.mprId {a : Prop} : a → a -/
#guard_msgs in #check mprId

/--
warning: `A.mpId` has been deprecated: use `Iff.rfl` instead
---
warning: `A.mprId` has been deprecated: use `Iff.rfl` instead
-/
#guard_msgs in example := And.intro @mpId @mprId

/- Test environment extension -/

/-- info: **Alias** of `A.foo`. -/
#guard_msgs in
#eval show MetaM _ from do
  match ← Batteries.Tactic.Alias.getAliasInfo `A.foo1 with
  | some i => IO.println i.toString
  | none => IO.println "alias not found"



=== LEAN SOURCE: array.lean ===
import Batteries.Data.Array

section
variable {α : Type _}
variable [Inhabited α]
variable (a : Array α)
variable (i j : Nat)
variable (v d : α)
variable (g : i < (a.set! i v).size)
variable (j_lt : j < (a.set! i v).size)

#check_simp (a.set! i v)[i] ~> v
#check_simp (a.set! i v)[i]! ~> (a.setIfInBounds i v)[i]!
#check_simp (a.set! i v).getD i d ~> if i < a.size then v else d
#check_simp (a.set! i v)[i] ~> v

-- Checks with different index values.
#check_simp (a.set! i v)[j]'j_lt  ~> (a.setIfInBounds i v)[j]'_
#check_simp (a.setIfInBounds i v)[j]'j_lt !~>

-- This doesn't work currently.
-- It will be address in the comprehensive overhaul of array lemmas.
-- #check_simp (a.set! i v)[i]? ~> .some v

end



=== LEAN SOURCE: ArrayMap.lean ===
import Batteries.Data.List.ArrayMap

open List

/-- info: #[3, 4, 5, 6] -/
#guard_msgs in
#eval List.toArrayMap [0, 1, 2, 3] (fun n => n + 3)

/-- info: #[7, 9, 15, 25] -/
#guard_msgs in
#eval toArrayMap [0, 1, 2, 3] (fun n => 2 * n ^ 2 + 7)



=== LEAN SOURCE: by_contra.lean ===
import Batteries.Tactic.Basic

private def nonDecid (P : Prop) (x : P) : P := by
  by_contra h
  guard_hyp h : ¬P
  guard_target = False
  exact h x

private def decid (P : Prop) [Decidable P] (x : P) : P := by
  by_contra h
  guard_hyp h : ¬P
  guard_target = False
  exact h x

example (P : Prop) [Decidable P] : nonDecid P = decid P := by
  delta nonDecid decid
  guard_target =ₛ
    (fun x : P => Classical.byContradiction fun h => h x) =
    (fun x : P => Decidable.byContradiction fun h => h x)
  rfl

example (P : Prop) : P → P := by
  by_contra
  guard_hyp ‹_› : ¬(P → P)
  exact ‹¬(P → P)› id

example (P : Prop) : {_ : P} → P := by
  by_contra
  guard_hyp ‹_› : ¬(P → P)
  exact ‹¬(P → P)› id

/-!
https://github.com/leanprover-community/batteries/issues/1196:

Previously the second error had a `Decidable True` subgoal, which only appeared in the presence of
the first unclosed goal.
-/
/--
error: unsolved goals
case left
⊢ True
---
error: unsolved goals
case right
x✝ : ¬True
⊢ False
-/
#guard_msgs in
example : True ∧ True := by
  constructor
  · skip
  · by_contra



=== LEAN SOURCE: case.lean ===
import Batteries.Tactic.Case

set_option linter.missingDocs false

example (h : x = y) (h' : z = w) : x = y ∧ z = w := by
  constructor
  fail_if_success show z = z
  case _ : z = _
  · exact h'
  exact h

example (h : x = y) (h' : z = w) : x = y ∧ z = w := by
  constructor
  case _ : z = _ =>
    exact h'
  case left =>
    exact h

example (h : x = y) (h' : z = w) : x = y ∧ z = w := by
  constructor
  case _ : z = _ | left => assumption

example (h : x = y) (h' : z = w) : x = y ∧ z = w := by
  constructor
  case _ : _ | _ : _ => assumption

example (h : x = y) (h' : z = w) : x = y ∧ z = w := by
  constructor
  case left | _ : z = _ => assumption

example (h : x = y) (h' : z = w) : x = y ∧ z = w := by
  constructor
  case _ : z = _ => ?foo
  case foo := h'
  case left := h

example (h : x = y) (h' : z = w) : x = y ∧ z + 0 = w := by
  constructor
  case right : z = _ =>
    guard_target =ₛ z = w
    exact h'
  case _ : x = y := h

example (h : x = y) : x = y ∧ x = y := by
  constructor
  case _ : x = y | _ : x = y => ?foo
  -- Closes both
  case foo => exact h

example (h : x = y) : x = y ∧ x = y ∧ x = y := by
  refine ⟨?foo, ?_, ?_⟩
  · exact h
  case _ : x = y | _ : x = y => ?foo
  -- This metavariable was already assigned, so no more goals.

/--
error: 'case' tactic failed, value
  ?left
depends on the main goal metavariable '?left'
-/
#guard_msgs in
example : False ∧ True := by
  constructor
  case _ : False => ?left

/--
error: type mismatch
  ?right
has type
  True : Prop
but is expected to have type
  False : Prop
-/
#guard_msgs in
example : False ∧ True := by
  constructor
  case _ : False => ?right

/--
error: 'case' tactic failed, value
  ?right
depends on the main goal metavariable '?right'
-/
#guard_msgs in
example : False ∧ False := by
  constructor
  case left => ?right
  case right => ?left

example (h : x = y) (h' : z = w) : x = y ∧ z + 0 = w := by
  constructor
  case _ : z = _ =>
    guard_target =ₛ z = w
    exact h'
  case left =>
    exact h

example (x y z : α) (h : x = y) (h' : y = z) : x = z := by
  apply Eq.trans
  case _ : id α := y
  -- Note: `case` inserts a `let_fun` since `id α` and `α` aren't defeq with reducible transparency
  · guard_target =ₛ x = show id α from y
    exact h
  · guard_target = y = z
    exact h'

example (x y z : α) (h : x = y) (h' : y = z) : x = z := by
  apply Eq.trans
  case _ : α := y
  -- Note: `case` detects defeq with reducible transparency, so doesn't insert type hint
  · guard_target =ₛ x = y
    exact h
  · guard_target = y = z
    exact h'

def Injective (f : α → β) : Prop := ∀ ⦃a₁ a₂⦄, f a₁ = f a₂ → a₁ = a₂

theorem cancel_injective (h : Injective f) : f x = f y ↔ x = y := by
  refine ⟨fun e => h e, ?_⟩
  intro h
  cases h
  rfl

example (h : Injective f) (h' : f x = f y) : x = y := by
  rw [cancel_injective] at h'
  case _ : Injective f := h
  exact h'

example (h : Injective f) (h' : f x = f y) : x = y := by
  rw [cancel_injective] at h'
  case _ : Injective f
  · exact h
  exact h'

example (hf : Injective f) (hg : Injective g) (h : g (f x) = g (f y)) : x = y := by
  rw [cancel_injective, cancel_injective] at h
  case _ : Injective f | _ : Injective g => assumption
  exact h

example (hf : Injective f) (hg : Injective g) (h : g (f x) = g (f y)) : x = y := by
  rw [cancel_injective, cancel_injective] at h
  repeat case _ : Injective _ => assumption
  exact h

example (hf : Injective f) (hg : Injective g) (h : g (f x) = g (f y)) : x = y := by
  rw [cancel_injective, cancel_injective] at h
  case _ : Injective f | _ : Injective g
  · guard_target = Injective f
    assumption
  · guard_target = Injective g
    assumption
  exact h

example (hf : Injective f) (hg : Injective g) (h : g (f x) = g (f y)) : x = y := by
  rw [cancel_injective, cancel_injective] at h
  case _ : Injective f | _ : Injective g => _
  · guard_target = Injective f
    assumption
  · guard_target = Injective g
    assumption
  exact h

example (a : Nat) : 0 + a = a := by
  induction a
  case _ n ih : 0 + (n + 1) = n + 1 =>
    guard_target =ₛ 0 + (n + 1) = n + 1
    rw [← Nat.add_assoc, ih]
  case _ : 0 + 0 = 0 := rfl

example (a : Nat) : 0 + a = a := by
  induction a
  case _ n ih : 0 + (n + 1) = n + 1 | _ : 0 + 0 = 0
  · rw [← Nat.add_assoc, ih]
  · rfl

example : True ∧ ∀ x : Nat, x = x := by
  constructor
  case' _ : ∀ _, _ =>
    intro z
  case left => trivial
  guard_target =ₛ z = z
  rfl

-- Test focusing by full match, suffix match, and prefix match
#guard_msgs in
example : True := by
  have x : Bool := ?a
  have y : Nat := ?a.b.c
  have z : String := ?c.b.a
  case a : Bool := true
  case a : Nat := 0
  case a : String := ""
  trivial

-- Test priorities when focusing by full match, suffix match, and prefix match
example : True := by
  let x : Nat := ?a
  let y : Nat := ?c.b.a
  let z : Nat := ?c'.b.a
  let w : Nat := ?a.b.c
  case a : Nat := 0
  case a : Nat := 1
  case a : Nat := 2
  case a : Nat := 3
  guard_hyp x : Nat := 0
  guard_hyp y : Nat := 2
  guard_hyp z : Nat := 1
  guard_hyp w : Nat := 3
  trivial

-- Test renaming when not pattern matching
example (n : Nat) : 0 ≤ n := by
  induction n
  case _ : 0 ≤ 0 | succ n ih
  · guard_target =ₛ 0 ≤ 0
    constructor
  · guard_target =ₛ 0 ≤ n + 1
    guard_hyp ih : 0 ≤ n
    simp



=== LEAN SOURCE: Char.lean ===
import Batteries.Data.Char

#guard Char.caseFoldAsciiOnly 'A' == 'a'
#guard Char.caseFoldAsciiOnly 'a' == 'a'
#guard Char.caseFoldAsciiOnly 'À' == 'À'
#guard Char.caseFoldAsciiOnly 'à' == 'à'
#guard Char.caseFoldAsciiOnly '$' == '$'

#guard Char.beqCaseInsensitiveAsciiOnly 'a' 'A' == true
#guard Char.beqCaseInsensitiveAsciiOnly 'a' 'a' == true
#guard Char.beqCaseInsensitiveAsciiOnly '$' '$' == true
#guard Char.beqCaseInsensitiveAsciiOnly 'a' 'b' == false
#guard Char.beqCaseInsensitiveAsciiOnly 'γ' 'Γ' == false
#guard Char.beqCaseInsensitiveAsciiOnly 'ä' 'Ä' == false

#guard Char.cmpCaseInsensitiveAsciiOnly 'a' 'A' == .eq
#guard Char.cmpCaseInsensitiveAsciiOnly 'a' 'a' == .eq
#guard Char.cmpCaseInsensitiveAsciiOnly '$' '$' == .eq
#guard Char.cmpCaseInsensitiveAsciiOnly 'a' 'b' == .lt
#guard Char.cmpCaseInsensitiveAsciiOnly 'γ' 'Γ' == .gt
#guard Char.cmpCaseInsensitiveAsciiOnly 'ä' 'Ä' == .gt



=== LEAN SOURCE: congr.lean ===
import Batteries.Tactic.Congr

section congr

example (c : Prop → Prop → Prop → Prop) (x x' y z z' : Prop)
    (h₀ : x ↔ x') (h₁ : z ↔ z') : c x y z ↔ c x' y z' := by
  apply Iff.of_eq -- FIXME: not needed in lean 3
  congr
  · guard_target =ₐ x = x'
    apply_ext_theorem
    assumption
  · guard_target =ₐ z = z'
    ext
    assumption

example {α β γ δ} {F : ∀ {α β}, (α → β) → γ → δ} {f g : α → β} {s : γ}
    (h : ∀ x : α, f x = g x) : F f s = F g s := by
  congr with x
  -- apply_assumption -- FIXME
  apply h

example {α β : Type _} {f : _ → β} {x y : { x : { x : α // x = x } // x = x }}
    (h : x.1 = y.1) : f x = f y := by
  congr with : 1
  exact h

example {α β : Type _} {F : _ → β} {f g : { f : α → β // f = f }}
    (h : ∀ x : α, (f : α → β) x = (g : α → β) x) : F f = F g := by
  rcongr x
  revert x
  guard_target = type_of% h
  exact h

section

-- Adaptation note: the next two examples have always failed if `List.ext` was in scope,
-- but until nightly-2024-04-24 (when `List.ext` was upstreamed), it wasn't in scope.
-- In order to preserve the test behaviour we locally remove the `ext` attribute.
attribute [-ext] List.ext_getElem?

example {ls : List Nat} :
    (ls.map fun _ => (ls.map fun y => 1 + y).sum + 1) =
    (ls.map fun _ => (ls.map fun y => Nat.succ y).sum + 1) := by
  rcongr (_x y)
  guard_target =ₐ 1 + y = y.succ
  rw [Nat.add_comm]

example {ls : List Nat} {f g : Nat → Nat} {h : ∀ x, f x = g x} :
    (ls.map fun x => f x + 3) = ls.map fun x => g x + 3 := by
  rcongr x
  exact h x

end

-- succeed when either `ext` or `congr` can close the goal
example : () = () := by rcongr

example : 0 = 0 := by rcongr

example {α} (a : α) : a = a := by congr

example : { f : Nat → Nat // f = id } :=
  ⟨_, by
    congr (config := { closePre := false, closePost := false }) with x
    exact Nat.zero_add x⟩

-- FIXME(?): congr doesn't fail
-- example {α} (a b : α) (h : False) : a = b := by
--   fail_if_success congr
--   cases h

end congr



=== LEAN SOURCE: conv_equals.lean ===
/-
Copyright (c) 2023 Joachim Breitner. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joachim Breitner
-/

import Batteries.Tactic.Basic

-- The example from the doc string, for quick comparision
-- and keeping the doc up-to-date
-- (only `guard_target` added)

/-- warning: declaration uses 'sorry' -/
#guard_msgs in
example (P : (Nat → Nat) → Prop) : P (fun n => n - n) := by
  conv in (_ - _) => equals 0 =>
    -- current goal: ⊢ n - n = 0
    guard_target =ₛ n - n = 0
    apply Nat.sub_self
  guard_target =ₛ P (fun n => 0)
  -- current goal: P (fun n => 0)
  sorry

-- This tests that the goal created by equals must be closed

-- Using #guard_msgs below triggers this linter
set_option linter.unreachableTactic false

/--
error: unsolved goals
P : (Nat → Nat) → Prop
n : Nat
⊢ n - n = 0
---
error: no goals to be solved
-/
#guard_msgs in
example (P : (Nat → Nat) → Prop) : P (fun n => n - n) := by
  conv in (_ - _) =>
    equals 0 => skip -- this should complain
    -- and at this point, there should be no goal left
    tactic => sorry
  sorry



=== LEAN SOURCE: exfalso.lean ===
import Batteries.Tactic.Basic

private axiom test_sorry : ∀ {α}, α

example {A} (h : False) : A := by
  exfalso
  exact h

example {A} : False → A := by
  exfalso
  show False -- exfalso is not supposed to close the goal yet
  exact test_sorry



=== LEAN SOURCE: float.lean ===
import Batteries.Lean.Float

#guard 0.0.toRatParts == some (0, -53)
#guard (2^(-1000):Float).toRatParts == some (4503599627370496, -1052)
#guard (2^(-30):Float).toRatParts == some (4503599627370496, -82)
#guard 0.1.toRatParts == some (7205759403792794, -56)
#guard 0.5.toRatParts == some (4503599627370496, -53)
#guard 5.0.toRatParts == some (5629499534213120, -50)
#guard (-5.0).toRatParts == some (-5629499534213120, -50)
#guard 5.5.toRatParts == some (6192449487634432, -50)
#guard 500000000000000.5.toRatParts == some (8000000000000008, -4)
#guard 5000000000000000.5.toRatParts == some (5000000000000000, 0)
#guard 1e1000.toRatParts == none
#guard (-1e1000).toRatParts == none
#guard (-0/0:Float).toRatParts == none

#guard 0.0.toRatParts' == some (0, 0)
#guard (2^(-1000):Float).toRatParts' == some (1, -1000)
#guard (2^(-30):Float).toRatParts' == some (1, -30)
#guard 0.1.toRatParts' == some (3602879701896397, -55)
#guard 0.5.toRatParts' == some (1, -1)
#guard 5.0.toRatParts' == some (5, 0)
#guard (-5.0).toRatParts' == some (-5, 0)
#guard 5.5.toRatParts' == some (11, -1)
#guard 500000000000000.5.toRatParts' == some (1000000000000001, -1)
#guard 5000000000000000.5.toRatParts' == some (152587890625, 15)
#guard 1e1000.toRatParts' == none
#guard (-1e1000).toRatParts' == none
#guard (-0/0:Float).toRatParts' == none

#guard 0.0.toStringFull == "0"
#guard (2^(-1000):Float).toStringFull.length == 1002
#guard (2^(-30):Float).toStringFull == "0.000000000931322574615478515625"
#guard 0.1.toStringFull == "0.1000000000000000055511151231257827021181583404541015625"
#guard 0.5.toStringFull == "0.5"
#guard 5.0.toStringFull == "5"
#guard (-5.0).toStringFull == "-5"
#guard 5.5.toStringFull == "5.5"
#guard 500000000000000.5.toStringFull == "500000000000000.5"
#guard 5000000000000000.5.toStringFull == "5000000000000000"
#guard 1e1000.toStringFull == "inf"
#guard (-1e1000).toStringFull == "-inf"
#guard (-0/0:Float).toStringFull == "NaN"

#guard Nat.divFloat 1 0 == Float.inf
#guard Nat.divFloat 50 0 == Float.inf
#guard (Nat.divFloat 0 0).isNaN
#guard Nat.divFloat 1 3 == (1 / 3 : Float)
#guard Nat.divFloat 1 6 == (1 / 6 : Float)
#guard Nat.divFloat 2 3 == (2 / 3 : Float)
#guard Nat.divFloat 100 17 == (100 / 17 : Float)
#guard Nat.divFloat 5000000000000000 1 == (5000000000000000 : Float)
#guard [0,0,0,1,1,1,2,2,2,2,2,3,3,3,4,4,4].zipIdx.all fun p =>
  Nat.divFloat (5000000000000000*4+p.2) 4 == (5000000000000000+p.1).toFloat
#guard Nat.divFloat ((2^53-1)*(2^(1024-53))) 1 == ((2^53-1)*(2^(1024-53)))
#guard Nat.divFloat (((2^53-1)*4+1)*(2^(1024-53))) 4 == ((2^53-1)*(2^(1024-53)))
#guard Nat.divFloat (((2^53-1)*4+2)*(2^(1024-53))) 4 == Float.inf
#guard Nat.divFloat (((2^53-1)*4+3)*(2^(1024-53))) 4 == Float.inf
#guard Nat.divFloat (((2^53-1)*4+4)*(2^(1024-53))) 4 == Float.inf

#guard Int.divFloat 1 3 == (1 / 3 : Float)
#guard Int.divFloat (-1) 3 == (-1 / 3 : Float)
#guard Int.divFloat 1 (-3) == (1 / -3 : Float)
#guard Int.divFloat (-1) (-3) == (-1 / -3 : Float)
#guard Int.divFloat (-1) 0 == -Float.inf
#guard (Int.divFloat 0 0).isNaN
#guard (Int.divFloat 0 1).toString == "0.000000"
#guard (Int.divFloat 0 (-1)).toString == "-0.000000"



=== LEAN SOURCE: help_cmd.lean ===
import Batteries.Tactic.HelpCmd

/-! The `#help` command

The `#help` command family currently contains these subcommands:

* `#help attr` / `#help attribute`
* `#help cat`
* `#help cats`
* `#help command` (abbrev for `#help cat command`)
* `#help conv` (abbrev for `#help cat conv`)
* `#help option`
* `#help tactic` (abbrev for `#help cat tactic`)
* `#help term` (abbrev for `#help cat term`)

All forms take an optional identifier prefix to narrow the search. The `#help cat` command has a
variant `#help cat+` that displays additional information, similarly for commands derived from
`#help cat`.

WARNING: Some of these tests will need occasional updates when new features are added and even when
some documentation is edited. This type of break will be unexpected but the fix will not be
unexpected! Just update the guard text to match the output after your addition.
-/

/-! `#help attr` -/

-- this is a long and constantly updated listing, we don't check the output
#guard_msgs(error, drop info) in
#help attr

/--
error: no attributes start with foobarbaz
-/
#guard_msgs in
#help attr foobarbaz

/--
info: [inline]: mark definition to be inlined
  Changes the inlining behavior. This attribute comes in several variants:
  - `@[inline]`: marks the definition to be inlined when it is appropriate.
  - `@[inline_if_reduce]`: marks the definition to be inlined if an application of it after inlining
    and applying reduction isn't a `match` expression. This attribute can be used for inlining
    structurally recursive functions.
  - `@[noinline]`: marks the definition to never be inlined.
  - `@[always_inline]`: marks the definition to always be inlined.
  - `@[macro_inline]`: marks the definition to always be inlined at the beginning of compilation.
    This makes it possible to define functions that evaluate some of their parameters lazily.
    Example:
    ```
    @[macro_inline]
    def test (x y : Nat) : Nat :=
      if x = 42 then x else y
  ⏎
    #eval test 42 (2^1000000000000) -- doesn't compute 2^1000000000000
    ```
    Only non-recursive functions may be marked `@[macro_inline]`.

[inline_if_reduce]: mark definition to be inlined when resultant term after reduction is not a `cases_on` application
  Changes the inlining behavior. This attribute comes in several variants:
  - `@[inline]`: marks the definition to be inlined when it is appropriate.
  - `@[inline_if_reduce]`: marks the definition to be inlined if an application of it after inlining
    and applying reduction isn't a `match` expression. This attribute can be used for inlining
    structurally recursive functions.
  - `@[noinline]`: marks the definition to never be inlined.
  - `@[always_inline]`: marks the definition to always be inlined.
  - `@[macro_inline]`: marks the definition to always be inlined at the beginning of compilation.
    This makes it possible to define functions that evaluate some of their parameters lazily.
    Example:
    ```
    @[macro_inline]
    def test (x y : Nat) : Nat :=
      if x = 42 then x else y
  ⏎
    #eval test 42 (2^1000000000000) -- doesn't compute 2^1000000000000
    ```
    Only non-recursive functions may be marked `@[macro_inline]`.
-/
#guard_msgs in
#help attr inl

/-! `#help cat` -/

-- this is a long and constantly updated listing, we don't check the output
#guard_msgs(error, drop info) in
#help cat term

/--
error: foobarbaz is not a syntax category
-/
#guard_msgs in
#help cat foobarbaz

/--
info:
syntax "("... [«prec(_)»]
  Parentheses are used for grouping precedence expressions.

syntax "+"... [Lean.Parser.Syntax.addPrec]
  Addition of precedences. This is normally used only for offsetting, e.g. `max + 1`.

syntax "-"... [Lean.Parser.Syntax.subPrec]
  Subtraction of precedences. This is normally used only for offsetting, e.g. `max - 1`.

syntax "arg"... [precArg]
  Precedence used for application arguments (`do`, `by`, ...).

syntax "lead"... [precLead]
  Precedence used for terms not supposed to be used as arguments (`let`, `have`, ...).

syntax "max"... [precMax]
  Maximum precedence used in term parsers, in particular for terms in
  function position (`ident`, `paren`, ...)

syntax "min"... [precMin]
  Minimum precedence used in term parsers.

syntax "min1"... [precMin1]
  `(min+1)` (we can only write `min+1` after `Meta.lean`)

syntax ... [Lean.Parser.Syntax.numPrec]
-/
#guard_msgs in
#help cat prec

/--
info:
syntax "("... [«prec(_)»]
  Parentheses are used for grouping precedence expressions.
+ macro «_aux_Init_Notation___macroRules_prec(_)_1»
  Parentheses are used for grouping precedence expressions.

syntax "+"... [Lean.Parser.Syntax.addPrec]
  Addition of precedences. This is normally used only for offsetting, e.g. `max + 1`.
+ macro Lean._aux_Init_Meta___macroRules_Lean_Parser_Syntax_addPrec_1

syntax "-"... [Lean.Parser.Syntax.subPrec]
  Subtraction of precedences. This is normally used only for offsetting, e.g. `max - 1`.
+ macro Lean._aux_Init_Meta___macroRules_Lean_Parser_Syntax_subPrec_1

syntax "arg"... [precArg]
  Precedence used for application arguments (`do`, `by`, ...).
+ macro _aux_Init_Notation___macroRules_precArg_1
  Precedence used for application arguments (`do`, `by`, ...).

syntax "lead"... [precLead]
  Precedence used for terms not supposed to be used as arguments (`let`, `have`, ...).
+ macro _aux_Init_Notation___macroRules_precLead_1
  Precedence used for terms not supposed to be used as arguments (`let`, `have`, ...).

syntax "max"... [precMax]
  Maximum precedence used in term parsers, in particular for terms in
  function position (`ident`, `paren`, ...)
+ macro _aux_Init_Notation___macroRules_precMax_1
  Maximum precedence used in term parsers, in particular for terms in
  function position (`ident`, `paren`, ...)

syntax "min"... [precMin]
  Minimum precedence used in term parsers.
+ macro _aux_Init_Notation___macroRules_precMin_1
  Minimum precedence used in term parsers.

syntax "min1"... [precMin1]
  `(min+1)` (we can only write `min+1` after `Meta.lean`)
+ macro _aux_Init_Notation___macroRules_precMin1_1
  `(min+1)` (we can only write `min+1` after `Meta.lean`)

syntax ... [Lean.Parser.Syntax.numPrec]
-/
#guard_msgs in
#help cat+ prec

/-! `#help cats` -/

-- this is a long and constantly updated listing, we don't check the output
#guard_msgs(error, drop info) in
#help cats

/--
error: no syntax categories start with foobarbaz
-/
#guard_msgs in
#help cats foobarbaz

/--
info: category prec [Lean.Parser.Category.prec]
  `prec` is a builtin syntax category for precedences. A precedence is a value
  that expresses how tightly a piece of syntax binds: for example `1 + 2 * 3` is
  parsed as `1 + (2 * 3)` because `*` has a higher precedence than `+`.
  Higher numbers denote higher precedence.
  In addition to literals like `37`, there are some special named precedence levels:
  * `arg` for the precedence of function arguments
  * `max` for the highest precedence used in term parsers (not actually the maximum possible value)
  * `lead` for the precedence of terms not supposed to be used as arguments
  and you can also add and subtract precedences.

category prio [Lean.Parser.Category.prio]
  `prio` is a builtin syntax category for priorities.
  Priorities are used in many different attributes.
  Higher numbers denote higher priority, and for example typeclass search will
  try high priority instances before low priority.
  In addition to literals like `37`, you can also use `low`, `mid`, `high`, as well as
  add and subtract priorities.
-/
#guard_msgs in
#help cats pr

/-! `#help command` -/

-- this is a long and constantly updated listing, we don't check the output
#guard_msgs(error, drop info) in
#help command

/--
error: no command declarations start with foobarbaz
-/
#guard_msgs in
#help command foobarbaz

/--
info: syntax "#eval"... [Lean.Parser.Command.eval]
  `#eval e` evaluates the expression `e` by compiling and evaluating it.
  ⏎
  * The command attempts to use `ToExpr`, `Repr`, or `ToString` instances to print the result.
  * If `e` is a monadic value of type `m ty`, then the command tries to adapt the monad `m`
    to one of the monads that `#eval` supports, which include `IO`, `CoreM`, `MetaM`, `TermElabM`, and `CommandElabM`.
    Users can define `MonadEval` instances to extend the list of supported monads.
  ⏎
  The `#eval` command gracefully degrades in capability depending on what is imported.
  Importing the `Lean.Elab.Command` module provides full capabilities.
  ⏎
  Due to unsoundness, `#eval` refuses to evaluate expressions that depend on `sorry`, even indirectly,
  since the presence of `sorry` can lead to runtime instability and crashes.
  This check can be overridden with the `#eval! e` command.
  ⏎
  Options:
  * If `eval.pp` is true (default: true) then tries to use `ToExpr` instances to make use of the
    usual pretty printer. Otherwise, only tries using `Repr` and `ToString` instances.
  * If `eval.type` is true (default: false) then pretty prints the type of the evaluated value.
  * If `eval.derive.repr` is true (default: true) then attempts to auto-derive a `Repr` instance
    when there is no other way to print the result.
  ⏎
  See also: `#reduce e` for evaluation by term reduction.

syntax "#eval!"... [Lean.Parser.Command.evalBang]
  `#eval e` evaluates the expression `e` by compiling and evaluating it.
  ⏎
  * The command attempts to use `ToExpr`, `Repr`, or `ToString` instances to print the result.
  * If `e` is a monadic value of type `m ty`, then the command tries to adapt the monad `m`
    to one of the monads that `#eval` supports, which include `IO`, `CoreM`, `MetaM`, `TermElabM`, and `CommandElabM`.
    Users can define `MonadEval` instances to extend the list of supported monads.
  ⏎
  The `#eval` command gracefully degrades in capability depending on what is imported.
  Importing the `Lean.Elab.Command` module provides full capabilities.
  ⏎
  Due to unsoundness, `#eval` refuses to evaluate expressions that depend on `sorry`, even indirectly,
  since the presence of `sorry` can lead to runtime instability and crashes.
  This check can be overridden with the `#eval! e` command.
  ⏎
  Options:
  * If `eval.pp` is true (default: true) then tries to use `ToExpr` instances to make use of the
    usual pretty printer. Otherwise, only tries using `Repr` and `ToString` instances.
  * If `eval.type` is true (default: false) then pretty prints the type of the evaluated value.
  * If `eval.derive.repr` is true (default: true) then attempts to auto-derive a `Repr` instance
    when there is no other way to print the result.
  ⏎
  See also: `#reduce e` for evaluation by term reduction.  syntax "#exit"... [Lean.Parser.Command.exit]
-/
#guard_msgs in
#help command "#e"

/--
info: syntax "#eval"... [Lean.Parser.Command.eval]
  `#eval e` evaluates the expression `e` by compiling and evaluating it.
  ⏎
  * The command attempts to use `ToExpr`, `Repr`, or `ToString` instances to print the result.
  * If `e` is a monadic value of type `m ty`, then the command tries to adapt the monad `m`
    to one of the monads that `#eval` supports, which include `IO`, `CoreM`, `MetaM`, `TermElabM`, and `CommandElabM`.
    Users can define `MonadEval` instances to extend the list of supported monads.
  ⏎
  The `#eval` command gracefully degrades in capability depending on what is imported.
  Importing the `Lean.Elab.Command` module provides full capabilities.
  ⏎
  Due to unsoundness, `#eval` refuses to evaluate expressions that depend on `sorry`, even indirectly,
  since the presence of `sorry` can lead to runtime instability and crashes.
  This check can be overridden with the `#eval! e` command.
  ⏎
  Options:
  * If `eval.pp` is true (default: true) then tries to use `ToExpr` instances to make use of the
    usual pretty printer. Otherwise, only tries using `Repr` and `ToString` instances.
  * If `eval.type` is true (default: false) then pretty prints the type of the evaluated value.
  * If `eval.derive.repr` is true (default: true) then attempts to auto-derive a `Repr` instance
    when there is no other way to print the result.
  ⏎
  See also: `#reduce e` for evaluation by term reduction.
+ command elab Lean.Elab.Command.elabEval

syntax "#eval!"... [Lean.Parser.Command.evalBang]
  `#eval e` evaluates the expression `e` by compiling and evaluating it.
  ⏎
  * The command attempts to use `ToExpr`, `Repr`, or `ToString` instances to print the result.
  * If `e` is a monadic value of type `m ty`, then the command tries to adapt the monad `m`
    to one of the monads that `#eval` supports, which include `IO`, `CoreM`, `MetaM`, `TermElabM`, and `CommandElabM`.
    Users can define `MonadEval` instances to extend the list of supported monads.
  ⏎
  The `#eval` command gracefully degrades in capability depending on what is imported.
  Importing the `Lean.Elab.Command` module provides full capabilities.
  ⏎
  Due to unsoundness, `#eval` refuses to evaluate expressions that depend on `sorry`, even indirectly,
  since the presence of `sorry` can lead to runtime instability and crashes.
  This check can be overridden with the `#eval! e` command.
  ⏎
  Options:
  * If `eval.pp` is true (default: true) then tries to use `ToExpr` instances to make use of the
    usual pretty printer. Otherwise, only tries using `Repr` and `ToString` instances.
  * If `eval.type` is true (default: false) then pretty prints the type of the evaluated value.
  * If `eval.derive.repr` is true (default: true) then attempts to auto-derive a `Repr` instance
    when there is no other way to print the result.
  ⏎
  See also: `#reduce e` for evaluation by term reduction.
+ command elab Lean.Elab.Command.elabEvalBang

syntax "#exit"... [Lean.Parser.Command.exit]
+ command elab Lean.Elab.Command.elabExit
-/
#guard_msgs in
#help command+ "#e"

/-! #help conv -/

-- this is a long and constantly updated listing, we don't check the output
#guard_msgs(error, drop info) in
#help conv

/--
error: no conv declarations start with foobarbaz
-/
#guard_msgs in
#help conv foobarbaz

/--
info:
syntax "reduce"... [Lean.Parser.Tactic.Conv.reduce]
  Puts term in normal form, this tactic is meant for debugging purposes only.

syntax "repeat"... [Lean.Parser.Tactic.Conv.convRepeat_]
  `repeat convs` runs the sequence `convs` repeatedly until it fails to apply.

syntax "rewrite"... [Lean.Parser.Tactic.Conv.rewrite]
  `rw [thm]` rewrites the target using `thm`. See the `rw` tactic for more information.
-/
#guard_msgs in
#help conv "re"

/--
info:
syntax "reduce"... [Lean.Parser.Tactic.Conv.reduce]
  Puts term in normal form, this tactic is meant for debugging purposes only.
+ tactic elab Lean.Elab.Tactic.Conv.evalReduce

syntax "repeat"... [Lean.Parser.Tactic.Conv.convRepeat_]
  `repeat convs` runs the sequence `convs` repeatedly until it fails to apply.
+ macro Lean.Parser.Tactic.Conv._aux_Init_Conv___macroRules_Lean_Parser_Tactic_Conv_convRepeat__1

syntax "rewrite"... [Lean.Parser.Tactic.Conv.rewrite]
  `rw [thm]` rewrites the target using `thm`. See the `rw` tactic for more information.
+ tactic elab Lean.Elab.Tactic.Conv.evalRewrite
-/
#guard_msgs in
#help conv+ "re"

/-! `#help option` -/

-- this is a long and constantly updated listing, we don't check the output
#guard_msgs(error, drop info) in
#help option

/--
error: no options start with foobarbaz
-/
#guard_msgs in
#help option foobarbaz

/--
info:
option pp.instanceTypes : Bool := false
  (pretty printer) when printing explicit applications, show the types of inst-implicit arguments

option pp.instances : Bool := true
  (pretty printer) if set to false, replace inst-implicit arguments to explicit applications with
placeholders

option pp.instantiateMVars : Bool := true
  (pretty printer) instantiate mvars before delaborating
-/
#guard_msgs in
#help option pp.ins

/-! `#help tactic` -/

-- this is a long and constantly updated listing, we don't check the output
#guard_msgs(error, drop info) in
#help tactic

/--
error: no tactic declarations start with foobarbaz
-/
#guard_msgs in
#help tactic foobarbaz

/--
info:
syntax "by_cases"... [«tacticBy_cases_:_»]
  `by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch,
and `h : ¬ p` in the second branch.
-/
#guard_msgs in
#help tactic by

/--
info:
syntax "by_cases"... [«tacticBy_cases_:_»]
  `by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.
+ macro «_aux_Init_ByCases___macroRules_tacticBy_cases_:__2»
+ macro «_aux_Init_ByCases___macroRules_tacticBy_cases_:__1»
-/
#guard_msgs in
#help tactic+ by

/-! #help term -/

-- this is a long and constantly updated listing, we don't check the output
#guard_msgs(error, drop info) in
#help term

/--
error: no term declarations start with foobarbaz
-/
#guard_msgs in
#help term foobarbaz

/--
info: syntax "debug_assert!"... [Lean.Parser.Term.debugAssert]
  `debug_assert! cond` panics if `cond` evaluates to `false` and the executing code has been built
  with debug assertions enabled (see the `debugAssertions` option).

syntax "decl_name%"... [Lean.Parser.Term.declName]
  A macro which evaluates to the name of the currently elaborating declaration.

syntax "default_or_ofNonempty%"... [Lean.Parser.Term.defaultOrOfNonempty]
-/
#guard_msgs in
#help term de

/--
info: syntax "debug_assert!"... [Lean.Parser.Term.debugAssert]
  `debug_assert! cond` panics if `cond` evaluates to `false` and the executing code has been built
  with debug assertions enabled (see the `debugAssertions` option).
+ term elab Lean.Elab.Term.elabDebugAssert

syntax "decl_name%"... [Lean.Parser.Term.declName]
  A macro which evaluates to the name of the currently elaborating declaration.
+ term elab Lean.Elab.Term.elabDeclName

syntax "default_or_ofNonempty%"... [Lean.Parser.Term.defaultOrOfNonempty]
+ term elab Lean.Elab.Term.Op.elabDefaultOrNonempty
-/
#guard_msgs in
#help term+ de



=== LEAN SOURCE: import_lean.lean ===
import Lean
import Batteries

/-!
This file ensures that we can import all of `Lean` and `Batteries` without name conflicts.
-/



=== LEAN SOURCE: instances.lean ===
import Batteries.Tactic.Instances

set_option linter.missingDocs false

/--
error: type class instance expected
  Fin 1
-/
#guard_msgs in
#instances Fin 1

/--
info: 3 instances:

instAddNat : Add Nat
(prio 100) Lean.Grind.Semiring.toAdd.{u} {α : Type u} [self : Lean.Grind.Semiring α] : Add α
(prio 100) Lean.Grind.AddCommMonoid.toAdd.{u} {M : Type u} [self : Lean.Grind.AddCommMonoid M] : Add M
-/
#guard_msgs in
#instances Add Nat

namespace Testing
class A (α : Type)

/-- info: No instances -/
#guard_msgs in
#instances A

instance (priority := high) : A Nat := ⟨⟩
instance : A Int := ⟨⟩
instance : A Bool := ⟨⟩

/--
info: 3 instances:

(prio 10000) Testing.instANat : A Nat
Testing.instABool : A Bool
Testing.instAInt : A Int
-/
#guard_msgs in
#instances A _

/--
info: 3 instances:

(prio 10000) Testing.instANat : A Nat
Testing.instABool : A Bool
Testing.instAInt : A Int
-/
#guard_msgs in
#instances A

/-- info: No instances -/
#guard_msgs in
#instances (α : Type) → A α

instance : A α := ⟨⟩

/--
info: 5 instances:
(local) inst✝ : A β
(prio 10000) Testing.instANat : A Nat
Testing.instABool : A Bool
Testing.instAInt : A Int
Testing.instA {α : Type} : A α
-/
#guard_msgs in
#instances [A β] : A

/--
info: 1 instance:

Testing.instA {α : Type} : A α
-/
#guard_msgs in
#instances (α : Type) → A α

end Testing



=== LEAN SOURCE: isIndependentOf.lean ===
import Batteries.Lean.Meta.Basic
import Batteries.Tactic.PermuteGoals
import Lean.Meta.Tactic.IndependentOf

open Lean Meta Elab.Tactic

elab "check_indep" : tactic => do
  match ← getGoals with
  | [] => throwError "Expected goal"
  | g :: l =>
    let res := if ←g.isIndependentOf l then "" else "not "
    let t ← instantiateMVars (← g.getType)
    logWarning s!"{←ppExpr (.mvar g)} : {←ppExpr t} is {res}independent of:"
    l.forM fun g' => do
      logInfo s!"  {←ppExpr (.mvar g')} : {←ppExpr (← g'.getType)}"
      let ppD (l : LocalDecl) : TacticM PUnit := do
        logInfo s!"    {←ppExpr (.fvar l.fvarId)} : {←ppExpr l.type}"
      let _ ← (←g'.getDecl).lctx.forM ppD
      pure ()

/-- warning: ?w : Nat is not independent of: -/
#guard_msgs(warning, drop info) in
example : ∃ (n : Nat), ∀(x : Fin n), x.val = 0 := by
  apply Exists.intro
  intro x
  swap
  check_indep
  exact 0
  revert x
  intro ⟨x, lt⟩
  contradiction

-- This is a tricker one, where the dependency is via a hypothesis.
/-- warning: ?w : Nat is not independent of: -/
#guard_msgs(warning, drop info) in
example : ∃ (n : Nat), ∀(x : Fin n) (y : Nat), x.val = y → y = 0 := by
  apply Exists.intro
  intro x y p
  swap
  check_indep
  exact 0
  revert x
  intro ⟨x, lt⟩
  contradiction



=== LEAN SOURCE: kmp_matcher.lean ===
import Batteries.Data.String.Matcher
import Batteries.Data.List.Matcher

/-! # Tests for the Knuth-Morris-Pratt (KMP) matching algorithm -/

/-! ### String API -/

/-- Matcher for pattern "abba" -/
def m := String.Matcher.ofString "abba"

#guard ! Option.isSome (m.find? "AbbabbA")

#guard Option.isSome (m.find? "aabbaa")

#guard Array.size (m.findAll "abbabba") = 2

#guard Array.size (m.findAll "abbabbabba") = 3

#guard Option.isSome ("xyyxx".findSubstr? "xy")

#guard ! Option.isSome ("xyyxx".findSubstr? "xyx")

#guard Array.size ("xyyxx".findAllSubstr "xyx") = 0

#guard Array.size ("xyyxxyx".findAllSubstr "xyx") = 1

#guard Array.size ("xyxyyxxyx".findAllSubstr "xyx") = 2

#guard Array.size ("xyxyxyyxxyxyx".findAllSubstr "xyx") = 4

/-! ### List API -/

def lm := List.Matcher.ofList [0,1,1,0]

#guard lm.find? [2,1,1,0,1,1,2] == none

#guard lm.find? [0,0,1,1,0,0] == some (1, 5)

#guard (lm.findAll [0,1,1,0,1,1,0]).size == 2

#guard (lm.findAll [0,1,1,0,1,1,0,1,1,0]).size == 3



=== LEAN SOURCE: lemma_cmd.lean ===
import Batteries.Tactic.Lemma

-- lemma disabled by default
/--
info: Try this: theorem
---
error: `lemma` is not supported by default, please use `theorem` instead.
Use `set_option lang.lemmaCmd true` to enable the use of the `lemma` command in a file.
Use the command line option `-Dlang.lemmaCmd=true` to enable the use of `lemma` globally.
-/
#guard_msgs in
lemma test1 : 3 < 7 := by decide

-- lemma enabled for one command
set_option lang.lemmaCmd true in
lemma test2 : 3 < 7 := by decide

-- lemma disabled again
/--
info: Try this: theorem
---
error: `lemma` is not supported by default, please use `theorem` instead.
Use `set_option lang.lemmaCmd true` to enable the use of the `lemma` command in a file.
Use the command line option `-Dlang.lemmaCmd=true` to enable the use of `lemma` globally.
-/
#guard_msgs in
lemma test3 : 3 < 7 := by decide

-- lemma enabled for rest of file
set_option lang.lemmaCmd true

lemma test4 : 3 < 7 := by decide

lemma test5 : 3 < 7 := by decide



=== LEAN SOURCE: library_note.lean ===
import Batteries.Tactic.HelpCmd
import BatteriesTest.Internal.DummyLibraryNote2

/--
error: Note not found
-/
#guard_msgs in
#help note "no note"

/--
info: library_note "Other"
* 1: this is a testnote with a label not starting with "te",
  so it shouldn't appear when looking for notes with label starting with "te".
-/
#guard_msgs in
#help note "Other"

library_note "test"/--
4: This note was not imported, and therefore appears below the imported notes.
-/

library_note "test"/--
5: This note was also not imported, and therefore appears below the imported notes,
and the previously added note.
-/


/--
info: library_note "temporary note"
* 1: This is a testnote whose label also starts with "te", but gets sorted before "test"

library_note "test"
* 1: This is a testnote for testing the library note feature of batteries.
  The `#help note` command should be able to find this note when imported.

* 2: This is a second testnote for testing the library note feature of batteries.

* 3: this is a note in a different file importing the above testnotes,
  but still imported by the actual testfile.

* 4: This note was not imported, and therefore appears below the imported notes.

* 5: This note was also not imported, and therefore appears below the imported notes,
  and the previously added note.
-/
#guard_msgs in
#help note "te"



=== LEAN SOURCE: lintsimp.lean ===
import Batteries.Tactic.Lint

open Batteries.Tactic.Lint
set_option linter.missingDocs false

def f : Nat := 0
def g : Nat := 0
def h : Nat := 0
@[simp] theorem fg : f = g := rfl
@[simp] theorem fh : f = h := rfl

run_meta guard (← [``fg, ``fh].anyM fun n => return (← simpNF.test n).isSome)

@[simp] theorem test_and_comm : a ∧ b ↔ b ∧ a := And.comm
run_meta guard (← simpComm.test ``test_and_comm).isSome

@[simp] theorem Prod.mk_fst : (a, b).1 = id a := rfl
run_meta guard (← simpVarHead.test ``Prod.mk_fst).isSome

def SemiconjBy [Mul M] (a x y : M) : Prop :=
  a * x = y * a

structure MulOpposite (α : Type u) : Type u where
  op :: unop : α

postfix:max "ᵐᵒᵖ" => MulOpposite

namespace MulOpposite

instance [Mul α] : Mul αᵐᵒᵖ where mul x y := op (unop y * unop x)

@[simp] theorem unop_inj {x y : αᵐᵒᵖ} : unop x = unop y ↔ x = y := by
  cases x; cases y; simp

#guard_msgs (drop warning) in
@[simp] theorem semiconj_by_unop [Mul α] {a x y : αᵐᵒᵖ} :
    SemiconjBy (unop a) (unop y) (unop x) ↔ SemiconjBy a x y := sorry

run_meta guard (← simpComm.test ``unop_inj).isNone

run_meta guard (← simpComm.test ``semiconj_by_unop).isNone

end MulOpposite

section

def MyPred (_ : Nat → Nat) : Prop := True

@[simp] theorem bad1 (f : Unit → Nat → Nat) : MyPred (f ()) ↔ True := by
  rw [MyPred]

@[simp] theorem bad2 (f g : Nat → Nat) : MyPred (fun x => f (g x)) ↔ True := by
  rw [MyPred]

-- Note, this is not a proper regression test because #671 depends on how the `MetaM` is
-- executed, and `run_meta` sets the options appropriately. But setting the config
-- explicitly here would amount to replicating the fix in the test itself.
run_meta guard (← simpNF.test ``bad1).isNone
run_meta guard (← simpNF.test ``bad2).isNone

end



=== LEAN SOURCE: lintTC.lean ===
import Batteries.Tactic.Lint.TypeClass
import Lean.Elab.Command

open Batteries.Tactic.Lint

namespace A

/--
warning: unused variable `β`

Note: This linter can be disabled with `set_option linter.unusedVariables false`
-/
#guard_msgs in
local instance impossible {α β : Type} [Inhabited α] : Nonempty α := ⟨default⟩

run_meta guard (← impossibleInstance.test ``impossible).isSome

end A

namespace B
instance bad : Nat := 1

run_meta guard (← nonClassInstance.test ``bad).isSome
instance good : Inhabited Nat := ⟨1⟩

run_meta guard (← nonClassInstance.test ``good).isNone
end B



=== LEAN SOURCE: lintunused.lean ===
import Batteries.Tactic.Lint

-- should be ignored as the proof contains sorry
/-- warning: declaration uses 'sorry' -/
#guard_msgs in
theorem Foo (h : 1 = 1) : True :=
  sorry

#lint- only unusedArguments



=== LEAN SOURCE: lint_docBlame.lean ===
import Batteries.Tactic.Lint

set_option linter.missingDocs false

/-- A docstring is needed here -/
structure AtLeastThirtySeven where
  /-- and here -/
  val : Nat := 1
  -- but not here
  prop : 37 ≤ val

-- or here
theorem AtLeastThirtySeven.lt (x : AtLeastThirtySeven) : 36 < x.val := x.prop

#lint- only docBlame



=== LEAN SOURCE: lint_docBlameThm.lean ===
import Batteries.Tactic.Lint

set_option linter.missingDocs false

-- A docstring is not needed here
structure AtLeastThirtySeven where
  -- or here
  val : Nat := 1
  /-- but is needed here -/
  prop : 37 ≤ val

/-- and here -/
theorem AtLeastThirtySeven.lt (x : AtLeastThirtySeven) : 36 < x.val := x.prop

#lint- only docBlameThm



=== LEAN SOURCE: lint_dupNamespace.lean ===
import Batteries.Tactic.Lint

-- internal names should be ignored
theorem Foo.Foo._bar : True := trivial

#lint- only dupNamespace



=== LEAN SOURCE: lint_empty.lean ===
import Batteries
import Lean.Elab

set_option linter.all true

/-- Some syntax to elaborate in a fresh env -/
def natDef : String :=
"prelude

inductive Nat where
  | zero
  | succ (n : Nat) : Nat

def id (x : α) := x
"

open Lean Parser Elab in
/--
Test that the linters imported from Batteries all work when run on a declaration in an empty environment.

This runs the linters because there's a global IO.Ref that contains them, rather than having them
be in a field of the environment itself, precisely so they can run in situations like this. However,
a linter that assumes it's run in an environment with the Lean prelude available may use of things
like `find!` and `get!` in linters, with the result that the linter panics.

This test elaborates the definition of the natural numbers and the identity function in a fresh
environment with all linters enabled. Running the tests in an environment with `LEAN_ABORT_ON_PANIC`
set ensures that the linters can at least run.
-/
elab "#testInEmptyEnv" : command => do
  let context := mkInputContext natDef "test"
  let (header, state, msgs) ← parseHeader context
  let opts := Options.empty |>.setBool `linter.all true
  let (env, msgs) ← processHeader header opts msgs context
  if msgs.hasErrors then
    for msg in msgs.toList do logMessage msg
    liftM (m := IO) <| throw <| IO.userError "Errors in header"
  let cmdState := Command.mkState env msgs
  let s ← IO.processCommands context state cmdState
  for t in s.commandState.infoState.trees do
    pushInfoTree t
  for msg in s.commandState.messages.toList do
    logMessage msg

#testInEmptyEnv



=== LEAN SOURCE: lint_lean.lean ===
import Batteries.Tactic.Lint

/-!
This test file runs the environment linters set up in Batteries on the core Lean4 repository.

Everything is commented out as it is too slow to run in regular Batteries CI
(and in any case there are many failures still),
but it is useful to run locally to see what the linters would catch.
-/

-- We can't apply `nolint` attributes to imported declarations,
-- but if we move the environment linters up to Lean,
-- these nolints should be installed there.
-- (And in the meantime you can "manually" ignore them!)
-- attribute [nolint dupNamespace] Lean.Elab.Tactic.Tactic
-- attribute [nolint dupNamespace] Lean.Parser.Parser Lean.Parser.Parser.rec Lean.Parser.Parser.mk
--   Lean.Parser.Parser.info Lean.Parser.Parser.fn
-- attribute [nolint explicitVarsOfIff] Iff.refl

/-! Failing lints that need work. -/

-- Many fixed in https://github.com/leanprover/lean4/pull/4620 and subsequent PRs
-- and should be checked again.
-- #lint only simpNF in all -- Found 22 errors

/-! Lints that fail, but that we're not intending to do anything about. -/

-- Mostly fixed in https://github.com/leanprover/lean4/pull/4621
-- There are many false positives here.
-- To run this properly we would need to ignore all declarations with `@[extern]`.
-- #lint only unusedArguments in all -- Found 89 errors

-- After https://github.com/leanprover/lean4/pull/4616, these are all intentional and have
-- `nolint` attributes above.
-- #lint only dupNamespace in all -- Found 6 errors

-- After https://github.com/leanprover/lean4/pull/4619 all of these should be caused by `abbrev`.
-- Unless we decide to upstream something like `alias`, we're not planning on fixing these.
-- #lint only defLemma in all -- Found 31 errors

/-! Lints that have succeeded in the past, and hopefully still do! -/

-- #lint only explicitVarsOfIff in all -- Found 1 errors, `Iff.refl`, which could be nolinted.
-- #lint only impossibleInstance  in all -- Found 0 errors
-- #lint only simpVarHead in all -- Found 0 error
-- #lint only unusedHavesSuffices in all  -- Found 0 errors
-- #lint only checkUnivs in all -- Found 0 errors



=== LEAN SOURCE: lint_simpNF.lean ===
import Batteries.Tactic.Lint

set_option linter.missingDocs false

structure Equiv (α : Sort _) (β : Sort _) where
  toFun : α → β
  invFun : β → α

infixl:25 " ≃ " => Equiv

namespace Equiv

instance : CoeFun (α ≃ β) fun _ => α → β := ⟨toFun⟩

protected def symm (e : α ≃ β) : β ≃ α := ⟨e.invFun, e.toFun⟩

def sumCompl {α : Type _} (p : α → Prop) [DecidablePred p] :
    Sum { a // p a } { a // ¬p a } ≃ α where
  toFun := Sum.elim Subtype.val Subtype.val
  invFun a := if h : p a then Sum.inl ⟨a, h⟩ else Sum.inr ⟨a, h⟩

@[simp]
theorem sumCompl_apply_symm_of_pos (p : α → Prop) [DecidablePred p] (a : α) (h : p a) :
    (sumCompl p).symm a = Sum.inl ⟨a, h⟩ :=
  dif_pos h

def foo (n : Nat) : Nat := if n = n then n else 0

@[simp]
theorem foo_eq_id : foo = id := by
  funext n
  simp [foo]

-- The following `dsimp`-lemma is (correctly) not flagged by the linter
@[defeq, simp]
theorem foo_eq_ite (n : Nat) : foo n = if n = n then n else 0 := by
  rfl

end Equiv

namespace List

private axiom test_sorry : ∀ {α}, α

@[simp]
theorem ofFn_getElem_eq_map {β : Type _} (l : List α) (f : α → β) :
    ofFn (fun i : Fin l.length => f <| l[(i : Nat)]) = l.map f := test_sorry

example {β : Type _} (l : List α) (f : α → β) :
    ofFn (fun i : Fin l.length => f <| l[(i : Nat)]) = l.map f := by simp only [ofFn_getElem_eq_map]

end List

/-! This tests that `simpNF` is not accidentally using `quasiPatternApprox := true`. -/

def eqToFun {X Y : Type} (p : X = Y) : X → Y := by rw [p]; exact id

@[simp]
theorem eqToFun_comp_eq_self {β} {X : Type} {f : β → Type}
    (z : ∀ b, X → f b) {j j' : β} (w : j = j') :
    eqToFun (by simp [w]) ∘ z j' = z j := by
  cases w; rfl

@[simp]
theorem eqToFun_comp_iso_hom_eq_self {β} {X : Type} {f : β → Type}
    (z : ∀ b, X ≃ f b) {j j' : β} (w : j = j') :
    eqToFun (by simp [w]) ∘ (z j').toFun = (z j).toFun := by
  cases w; rfl

#lint- only simpNF



=== LEAN SOURCE: lint_unreachableTactic.lean ===
import Batteries.Linter.UnreachableTactic

-- The warning generated by `linter.unreachableTactic` is not suppressed by `#guard_msgs`,
-- because the linter is run on `#guard_msgs` itself. This is a known issue, see
-- https://leanprover.zulipchat.com/#narrow/stream/348111-batteries/topic/unreachableTactic.20linter.20not.20suppressed.20by.20.60.23guard_msgs.60
-- We jump through an extra hoop here to silence the warning.
set_option linter.unreachableTactic false in
#guard_msgs(drop warning) in
set_option linter.unreachableTactic true in
/--
warning: this tactic is never executed

Note: This linter can be disabled with `set_option linter.unreachableTactic false`
-/
#guard_msgs in
example : 1 = 1 := by
  rfl <;> simp

/--
warning: declaration uses 'sorry'
-/
#guard_msgs in
example : 1 = 1 := by
  stop
  rfl

#guard_msgs (drop warning) in
def t : Nat → Nat := sorry

#guard_msgs (drop warning) in
@[simp]
theorem a : aa = 0 → t aa = 0 := sorry

#guard_msgs in
example (ha : aa = 0) : t aa = 0 := by
  simp (disch := assumption)



=== LEAN SOURCE: list_sublists.lean ===
import Batteries.Data.List.Basic

-- this times out with `sublistsFast`
set_option maxRecDepth 562 in
example : [1, 2, 3].sublists.sublists.length = 256 := rfl

-- TODO(batteries#307): until we have the `csimp` lemma in batteries,
-- this is a sanity check that these two are equal.
example : ([] : List Nat).sublists = [].sublistsFast := rfl
example : [1, 2, 3].sublists = [1, 2, 3].sublistsFast := rfl



=== LEAN SOURCE: mersenne_twister.lean ===
import Batteries.Data.Random.MersenneTwister
import Batteries.Data.Stream

open Batteries.Random.MersenneTwister

#guard (Stream.take mt19937.init 5).1 == [874448474, 2424656266, 2174085406, 1265871120, 3155244894]

/- Sample output was generated using `numpy`'s implementation of MT19937:
```python
from numpy import array, uint32
from numpy.random import MT19937

mt = MT19937()
mt.state = {
  'bit_generator' : 'MT19937',
  'state' : {
    'pos' : 624,
    'key' : array([
      4357, 1673174024, 1301878288, 1129097449, 2180885271, 2495295730, 3729202114, 3451529139, 2624228201, 696045212,
      2296245684, 4097888573, 2110311931, 1672374534, 381896678, 2887874951, 3859861197, 420983856, 1691952728, 4233606289,
      1707944415, 3515687962, 4265198858, 1433261659, 1131854641, 228846788, 3811811324, 873525989, 588291779, 2854617646,
      948269870, 3798261295, 3422826645, 340138072, 3671734944, 3961007161, 2839350439, 3264455490, 310719058, 2570596611,
      3750039289, 648992492, 3816674884, 2210726029, 371217291, 196912982, 3046892150, 470118103, 1302935133, 362465408,
      1360220904, 2946174945, 1630294895, 3570642538, 1798333338, 1196832683, 226789057, 2740096276, 1062441100, 1875507765,
      2599873619, 1037523070, 4029519294, 3231722367, 2232344613, 3458909352, 2906353456, 3064815497, 3166305847,
      3658630546, 3632421090, 885320275, 1621369481, 1258557244, 2827734740, 3209486301, 131295515, 2191201702, 44141830,
      1183978535, 4202966509, 801836240, 2303299448, 333191985, 4114943231, 1490315450, 453120554, 759253243, 1381163601,
      3455606116, 1027445020, 1144697221, 3040135651, 4176273102, 798935118, 49817807, 2492997557, 3171983608, 2742334400,
      1282687705, 1047297991, 3697219554, 1400278898, 3276297123, 843040281, 354711436, 4156544868, 2873126701, 3990490795,
      3966874614, 1376536470, 4189022583, 2283386237, 3645931808, 1312021512, 679663233, 3054458511, 1152865034, 1927729338,
      538380875, 374984161, 2453495220, 514433452, 1271601365, 3737270131, 630101278, 1292962526, 2908018207, 1209528133,
      413117768, 3762161744, 2194986537, 1414304087, 379722290, 2862208514, 3551161587, 3402627497, 2411204572, 3033657332,
      4161252989, 2267825211, 963150406, 2081690150, 4014304967, 1977732365, 2412979568, 613038232, 418857425, 3682807839,
      3416550746, 3692470090, 2764012443, 3255912817, 2160692740, 3914318396, 3437441061, 2828481795, 3655629678, 582770030,
      2946380655, 3506851541, 612362648, 3394202848, 1530337657, 3360830183, 570641538, 153365650, 1624454723, 80526649,
      1365694508, 2272925828, 34250189, 3066169803, 631734422, 3706776758, 3443270679, 659846301, 3707435456, 3573851432,
      1017208097, 1100519855, 1824765866, 3284762074, 2887949547, 569464065, 3057970772, 1726477004, 3119183733, 3349922451,
      4162228670, 249085950, 3854319807, 1155219045, 811161064, 207675760, 50531529, 141911159, 3819613906, 2655884066,
      3517624211, 514724041, 2094583932, 3681571092, 3518053661, 2207473499, 961982182, 1423628102, 628853095, 3823741997,
      1450180112, 1817911736, 384378993, 1749521215, 4080873978, 2604100714, 2468900411, 1718743185, 3679944356, 623522652,
      2974445253, 351789091, 776787982, 4087231118, 395771407, 2634989045, 2547249720, 2502583808, 3550523417, 648947207,
      2361409826, 2639137202, 4179155171, 3136025689, 3233151180, 3765213604, 459508845, 412632299, 3365801270, 1208603094,
      1978375863, 3608769469, 2648322656, 994422344, 1463198657, 1938300111, 1983437898, 3617090298, 582545291, 604707873,
      615071476, 1976468460, 4251555349, 2373160371, 4138683998, 927249694, 4178996063, 3071856005, 3264724616, 2539911824,
      1383596905, 3639900055, 2590770034, 1029541954, 369472051, 3757991913, 1470517532, 2317808180, 1065978813, 3301489275,
      4087716742, 2662718566, 678716423, 274451277, 1625396912, 3598469848, 3639725841, 726808159, 1490990746, 4062476682,
      2411471067, 1395972017, 1390554948, 1854727292, 2494590309, 1377225539, 2540041390, 3288614830, 706906287, 1416719637,
      609008344, 2311429920, 821102265, 2034260263, 3587569090, 3115591378, 3545840515, 4166871929, 139581804, 2421643972,
      1250638605, 4212965387, 2794805718, 3306616566, 2466109783, 2200482525, 1496197888, 381089640, 2743249505, 4221427695,
      1247199466, 1746114586, 2065302059, 1348936513, 2997505940, 3911013644, 428274869, 2816055507, 580438782, 135588414,
      916674047, 445684901, 1016784680, 654791600, 1282652681, 92916407, 1411782674, 1367985506, 1207661779, 3531669257,
      627085756, 1857409876, 4107311709, 1384928667, 2576697382, 2875531654, 4151312039, 116927085, 1281879888, 414036984,
      3931190705, 4100135295, 1170799418, 3130902186, 4055536507, 3692691153, 480878564, 2201474460, 3663014917, 4155766371,
      1987039566, 4121861326, 2525025103, 2465094709, 2536129400, 1843468352, 2926058841, 533253191, 1988389474, 1209435122,
      4141112867, 2699109017, 2373614092, 1694129124, 2730600877, 2249161515, 1355638390, 3319290902, 2209534967,
      1463955965, 204923808, 1025015944, 214266113, 3382305551, 2455594378, 1861944634, 1820710091, 449145441, 4119339060,
      2660525612, 3515028309, 3466454003, 1024657310, 50945886, 2913140895, 721595333, 3416444872, 2701847760, 2352361641,
      234184151, 3927502002, 3834792578, 3469473651, 4193637929, 2873594460, 1994191988, 1690724605, 1956524219, 476427462,
      212379302, 1370380615, 327076237, 1984104432, 682581272, 2521259089, 3543809183, 3275489242, 241390538, 3496199707,
      2497799665, 770560132, 1626015420, 2776148645, 3717161347, 3970592238, 710750702, 3421625839, 876972885, 2108460056,
      1195168096, 1195766777, 3121053543, 2819333890, 1916084498, 717897923, 3627489721, 1970264748, 1813355780, 4148615245,
      556824139, 411448086, 4228776246, 1732939415, 3206934813, 1949588544, 3291105704, 1044314017, 222045743, 3079457322,
      638497370, 1849452395, 921039233, 1115861204, 3019093836, 2828923381, 4185943827, 3344827454, 3923907710, 760572735,
      3828284133, 1559197800, 724485616, 1828677449, 2985767159, 4119101778, 1077348258, 3518446099, 2585587017, 1855673084,
      3495712148, 3265984413, 2998815707, 760668518, 2487249862, 3060757479, 3249514669, 4222804112, 1010910776, 3893641969,
      395812799, 2591540346, 1194664170, 49789115, 1363873041, 1005502756, 1164343260, 3646613829, 459869347, 3679832718,
      1137706766, 4189431951, 1412889205, 622040248, 1536739968, 3066727065, 666661511, 1672188834, 2714762802, 4135248739,
      35606745, 2775710540, 4083752484, 3680159469, 1950331243, 251641782, 1501029974, 486869303, 1720971325, 241603808,
      28070600, 2737782337, 910469455, 3810848458, 118398842, 3078470155, 2559096993, 2933522804, 2264615020, 3793195157,
      1614887475, 45727966, 3193899422, 1157273055, 2178255365, 2646663432, 724754192, 168779241, 4048503831, 3483948530,
      3996648642, 939343027, 917914729, 3030111132, 3908302516, 29247037, 3568084731, 1034472966, 1408004326, 1693666951,
      3712665549, 3120003376, 3374542680, 2868373905, 1362838239, 1421625626, 4275252746, 548825947, 622261297, 3152835012,
      2926192892, 423356389, 151058371, 3820087086, 1673993262, 252457775, 1317185941, 2594135384, 817169312, 2016796985,
      2292688295, 1654933570, 2158435154, 2703640067, 3260663801, 3267419116, 2293555012, 2721936781, 1727868043, 91884630,
      265685878, 1143096279, 961294173, 403541376, 2338233320, 1725318369, 4101205103, 4268086122, 3418016922, 1065995435,
      1936572353, 265163284, 3043694988, 2167402293, 2057323859, 4033232254, 3258990270, 1137868927, 2142656805, 4216785320,
      1188509744, 1051071625, 196974391, 2445666962, 3092595170, 2833121107, 2474761097, 2190021692, 1852037076, 3577763037,
      3794354715, 2124118694, 2641147398, 1551493415, 1913661165, 1313919440, 2232801400, 1781682225, 1340417535, 994676154,
      251493162, 2162155003, 1678056273, 3810976356, 1505106460, 3361449605, 1041703651, 1727972302, 3959583054, 3140845007,
      3202914485, 2878334456, 2354150592, 3334993881, 1015617735, 506838242, 4168775794, 839674019, 4238769945, 849116300,
      4189642852, 1596908589, 556328875, 2369067254, 2431152278, 1004682871], dtype=uint32)}}

print(mt.random_raw(5))
```
-/



=== LEAN SOURCE: MLList.lean ===
import Lean.Meta.Basic
import Batteries.Data.MLList.IO
import Batteries.Data.List.Basic

set_option linter.missingDocs false

/-! ### Test fix to performance problem in `asArray`. -/

def g (n : Nat) : MLList Lean.Meta.MetaM Nat := do
  for _ in [:n] do
    if true then
      continue
  return n

/-- info: #[3000] -/
-- This used to fail before add the `uncons?` field to the implementation of `MLList`.
#guard_msgs in
#eval MLList.asArray $ (g 3000)

/-!
### Test `MLList.ofTaskList`.

We generate three tasks which sleep for `100`, `50`, and `1` milliseconds respectively,
and then verify that `MLList.ofTaskList` return their results in the order they complete.
-/

/- This test is very flaky, so it's disabled for now.

def sleep (n : UInt32) : BaseIO (Task UInt32) :=
  IO.asTask (do IO.sleep n; return n) |>.map fun t => t.map fun
  | .ok n => n
  | .error _ => 0

def sleeps : MLList BaseIO UInt32 := .squash fun _ => do
  let r ← [100,50,1].map sleep |>.traverse id
  return .ofTaskList r

/-- info: [1, 50, 100] -/
#guard_msgs in
#eval sleeps.force
-/



=== LEAN SOURCE: nondet.lean ===
import Batteries.Control.Nondet.Basic

set_option linter.missingDocs false

open Lean Meta

def M := StateT (List Nat) MetaM

deriving instance Monad for M
deriving instance Alternative for M

instance : MonadBacktrack (List Nat) M where
  saveState := StateT.get
  restoreState := StateT.set

def record (n : Nat) : M Unit := do
  discard <| restoreState (n :: (← saveState))

def iotaM [Monad m] [Alternative m] [MonadBacktrack σ m] (n : Nat) : Nondet m Nat :=
  Nondet.ofList (List.range' 1 n).reverse

/-- info: (52, []) -/
#guard_msgs in
#eval show MetaM (Nat × List Nat) from StateT.run (iotaM 52 : Nondet M Nat).head []

/-- info: ((), [52]) -/
#guard_msgs in
#eval show MetaM (Unit × List Nat) from StateT.run (((iotaM 52).mapM record).head) []

def x : Nondet M Nat :=
  (iotaM 52).filterMapM fun x => do
    record x
    if x % 7 = 0 then
      return some (x^2)
    else
      return none

/-- info: (2401, [49]) -/
#guard_msgs in
#eval show MetaM (Nat × List Nat) from StateT.run x.head []

def divisors (n : Nat) : List Nat := List.range' 1 (n - 1) |>.reverse.filter fun m => n % m = 0
example : divisors 52 = [26, 13, 4, 2, 1] := rfl

def divisorsM [Monad m] [MonadBacktrack σ m] (n : Nat) : Nondet m Nat :=
  Nondet.ofList (divisors n)

/-- Take the numbers `32, ..., 1`, replace each with their divisors, then replace again. -/
def y : Nondet M Nat :=
  (iotaM 32)
  |>.bind fun x => do
    record x
    divisorsM x
  |>.bind fun x => do
    record x
    divisorsM x

/-- info: [8, 4, 2, 1, 4, 2, 1, 2, 1, 1, 5, 3, 1, 5, 2, 1, 3, 2, 1, 1, 1, 1, 7] -/
#guard_msgs in
#eval show MetaM (List Nat) from StateT.run' (y.toMLList'.takeAsList 23) []

-- All ways to find `4 ∣ a ∣ b`, with `b = 32, ..., 1`.
/-- info: ([(4, [16, 32]), (4, [8, 32]), (4, [12, 24]), (4, [8, 24]), (4, [8, 16])], [1]) -/
#guard_msgs in
#eval show MetaM (List (Nat × List Nat) × List Nat) from
  StateT.run (y.filter (· = 4)).toMLList.force []

/-- info: [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1] -/
#guard_msgs in
#eval (iotaM 15 : Nondet MetaM Nat).toList'

-- Depth first search of the divisors of 255.
/-- info: [255, 85, 17, 1, 5, 1, 1, 51, 17, 1, 3, 1, 1, 17, 1, 15, 5, 1, 3, 1, 1, 5, 1, 3, 1, 1] -/
#guard_msgs in
#eval (Nondet.iterate divisorsM 255 : Nondet Id Nat).toList'



=== LEAN SOURCE: norm_cast.lean ===
import Batteries.Data.Rat.Lemmas

/-!
# Tests for norm_cast involving `Rat`.
-/

set_option linter.missingDocs false

-- set_option trace.Meta.Tactic.simp true

variable (aq bq cq dq : Rat)

example : az = bz ↔ (az : Rat) = bz := by norm_cast

-- zero and one cause special problems
example : aq < (1 : Nat) ↔ (aq : Rat) < (1 : Int) := by norm_cast

--testing numerals
example : ((42 : Nat) : Rat) = 42 := by norm_cast
example : ((42 : Int) : Rat) = 42 := by norm_cast

-- We don't yet have `{n m : Int} : (↑n : Rat) ≤ ↑m ↔ n ≤ m` in Batteries
-- example (n : Int) (h : n + 1 > 0) : ((n + 1 : Int) : Rat) > 0 := by exact_mod_cast h



=== LEAN SOURCE: on_goal.lean ===
import Batteries.Tactic.PermuteGoals
import Batteries.Tactic.Unreachable

example (p q r : Prop) : p → q → r → p ∧ q ∧ r := by
  intros
  constructor
  on_goal 2 =>
    guard_target = q ∧ r
    constructor
    assumption
    -- Note that we have not closed all the subgoals here.
  guard_target = p
  assumption
  guard_target = r
  assumption

example (p q r : Prop) : p → q → r → p ∧ q ∧ r := by
  intros a b c
  constructor
  fail_if_success on_goal -3 => unreachable!
  fail_if_success on_goal -1 => exact a
  fail_if_success on_goal 0 => unreachable!
  fail_if_success on_goal 2 => exact a
  fail_if_success on_goal 3 => unreachable!
  on_goal 1 => exact a
  constructor
  swap
  exact c
  exact b

example (p q : Prop) : p → q → p ∧ q := by
  intros a b
  constructor
  fail_if_success pick_goal -3
  fail_if_success pick_goal 0
  fail_if_success pick_goal 3
  pick_goal -1
  exact b
  exact a

example (p : Prop) : p → p := by
  intros
  fail_if_success swap -- can't swap with a single goal
  assumption



=== LEAN SOURCE: openPrivate.lean ===

import Batteries.Tactic.OpenPrivate

import BatteriesTest.OpenPrivateDefs



/-- error: unknown identifier 'secretNumber' -/
#guard_msgs in
#eval secretNumber


-- It works with one space between the tokens
/-- info: 2 -/
#guard_msgs in
open private secretNumber from BatteriesTest.OpenPrivateDefs in
#eval secretNumber


-- It also works with other kinds of whitespace between the tokens

/-- info: 2 -/
#guard_msgs in
open      private secretNumber from BatteriesTest.OpenPrivateDefs in
#eval secretNumber


/-- info: 2 -/
#guard_msgs in
open
  private secretNumber from BatteriesTest.OpenPrivateDefs in
#eval secretNumber

/-- info: 2 -/
#guard_msgs in
open /- Being sneaky! -/ private secretNumber from BatteriesTest.OpenPrivateDefs in
#eval secretNumber



=== LEAN SOURCE: OpenPrivateDefs.lean ===
/-!
This file contains a private declaration. It's tested in `openPrivate.lean`.
-/
private def secretNumber : Nat := 2



=== LEAN SOURCE: print_opaques.lean ===
import Batteries.Tactic.PrintOpaques

partial def foo : Unit → Nat := foo
def bar : Unit → Nat := foo

/--
info: 'bar' depends on opaque or partial definitions: [foo]
-/
#guard_msgs in
#print opaques bar

opaque qux : Nat
def quux : Bool := qux == 0

/--
info: 'quux' depends on opaque or partial definitions: [qux]
-/
#guard_msgs in
#print opaques quux

/-! Examples from the documentation. -/

/--
info: 'Classical.choice' depends on opaque or partial definitions: [Classical.choice]
-/
#guard_msgs in
#print opaques Classical.choice

/--
info: 'Classical.axiomOfChoice' does not use any opaque or partial definitions
-/
#guard_msgs in
#print opaques Classical.axiomOfChoice

/--
info: 'Std.HashMap.insert' depends on opaque or partial definitions: [System.Platform.getNumBits]
-/
#guard_msgs in
#print opaques Std.HashMap.insert

/--
info: 'Stream.forIn' depends on opaque or partial definitions: [Stream.forIn.visit]
-/
#guard_msgs in
#print opaques Stream.forIn



=== LEAN SOURCE: print_prefix.lean ===
import Batteries.Tactic.PrintPrefix

inductive TEmpty : Type
/--
info: TEmpty : Type
TEmpty.casesOn.{u} (motive : TEmpty → Sort u) (t : TEmpty) : motive t
TEmpty.noConfusion.{u} {P : Sort u} {x1 x2 : TEmpty} (h12 : x1 = x2) : TEmpty.noConfusionType P x1 x2
TEmpty.noConfusionType.{u} (P : Sort u) (x1 x2 : TEmpty) : Sort u
TEmpty.noConfusionType.withCtor.{u} (P : Type u) (ctorIdx : Nat) (k : TEmpty.noConfusionType.withCtorType P ctorIdx)
  (k' : P) (x : TEmpty) : P
TEmpty.noConfusionType.withCtorType.{u} (P : Type u) (ctorIdx : Nat) : Type (max 1 u)
TEmpty.rec.{u} (motive : TEmpty → Sort u) (t : TEmpty) : motive t
TEmpty.recOn.{u} (motive : TEmpty → Sort u) (t : TEmpty) : motive t
-/
#guard_msgs in
#print prefix TEmpty -- Test type that probably won't change much.

/-- info: -/
#guard_msgs in
#print prefix -imported Empty

namespace EmptyPrefixTest

end EmptyPrefixTest

-- Note.  This error message could be cleaned up, but left during migration from Mathlib
/--
error: unknown constant 'EmptyPrefixTest'
-/
#guard_msgs in
#print prefix EmptyPrefixTest

namespace Prefix.Test

/-- Supress lint -/
def foo (_l:List String) : Int := 0

end Prefix.Test

/-- info: Prefix.Test.foo (_l : List String) : Int -/
#guard_msgs in
#print prefix Prefix.Test

/-- Supress lint -/
structure TestStruct where
  /-- Supress lint -/
  foo : Int
  /-- Supress lint -/
  bar : Int

/--
info: TestStruct : Type
TestStruct.bar (self : TestStruct) : Int
TestStruct.casesOn.{u} {motive : TestStruct → Sort u} (t : TestStruct)
  (mk : (foo bar : Int) → motive { foo := foo, bar := bar }) : motive t
TestStruct.foo (self : TestStruct) : Int
TestStruct.mk (foo bar : Int) : TestStruct
TestStruct.mk.inj {foo bar foo✝ bar✝ : Int} :
  { foo := foo, bar := bar } = { foo := foo✝, bar := bar✝ } → foo = foo✝ ∧ bar = bar✝
TestStruct.mk.injEq (foo bar foo✝ bar✝ : Int) :
  ({ foo := foo, bar := bar } = { foo := foo✝, bar := bar✝ }) = (foo = foo✝ ∧ bar = bar✝)
TestStruct.mk.sizeOf_spec (foo bar : Int) : sizeOf { foo := foo, bar := bar } = 1 + sizeOf foo + sizeOf bar
TestStruct.noConfusion.{u} {P : Sort u} {x1 x2 : TestStruct} (h12 : x1 = x2) : TestStruct.noConfusionType P x1 x2
TestStruct.noConfusionType.{u} (P : Sort u) (x1 x2 : TestStruct) : Sort u
TestStruct.noConfusionType.withCtor.{u} (P : Type u) (ctorIdx : Nat)
  (k : TestStruct.noConfusionType.withCtorType P ctorIdx) (k' : P) (x : TestStruct) : P
TestStruct.noConfusionType.withCtorType.{u} (P : Type u) (ctorIdx : Nat) : Type (max 1 u)
TestStruct.rec.{u} {motive : TestStruct → Sort u} (mk : (foo bar : Int) → motive { foo := foo, bar := bar })
  (t : TestStruct) : motive t
TestStruct.recOn.{u} {motive : TestStruct → Sort u} (t : TestStruct)
  (mk : (foo bar : Int) → motive { foo := foo, bar := bar }) : motive t
-/
#guard_msgs in
#print prefix TestStruct

/--
info: TestStruct : Type
TestStruct.bar (self : TestStruct) : Int
TestStruct.casesOn.{u} {motive : TestStruct → Sort u} (t : TestStruct)
  (mk : (foo bar : Int) → motive { foo := foo, bar := bar }) : motive t
TestStruct.foo (self : TestStruct) : Int
TestStruct.mk (foo bar : Int) : TestStruct
TestStruct.noConfusion.{u} {P : Sort u} {x1 x2 : TestStruct} (h12 : x1 = x2) : TestStruct.noConfusionType P x1 x2
TestStruct.noConfusionType.{u} (P : Sort u) (x1 x2 : TestStruct) : Sort u
TestStruct.noConfusionType.withCtor.{u} (P : Type u) (ctorIdx : Nat)
  (k : TestStruct.noConfusionType.withCtorType P ctorIdx) (k' : P) (x : TestStruct) : P
TestStruct.noConfusionType.withCtorType.{u} (P : Type u) (ctorIdx : Nat) : Type (max 1 u)
TestStruct.rec.{u} {motive : TestStruct → Sort u} (mk : (foo bar : Int) → motive { foo := foo, bar := bar })
  (t : TestStruct) : motive t
TestStruct.recOn.{u} {motive : TestStruct → Sort u} (t : TestStruct)
  (mk : (foo bar : Int) → motive { foo := foo, bar := bar }) : motive t
-/
#guard_msgs in
#print prefix -propositions TestStruct

/--
info: TestStruct.mk.inj {foo bar foo✝ bar✝ : Int} :
  { foo := foo, bar := bar } = { foo := foo✝, bar := bar✝ } → foo = foo✝ ∧ bar = bar✝
TestStruct.mk.injEq (foo bar foo✝ bar✝ : Int) :
  ({ foo := foo, bar := bar } = { foo := foo✝, bar := bar✝ }) = (foo = foo✝ ∧ bar = bar✝)
TestStruct.mk.sizeOf_spec (foo bar : Int) : sizeOf { foo := foo, bar := bar } = 1 + sizeOf foo + sizeOf bar
-/
#guard_msgs in
#print prefix +propositionsOnly TestStruct

/--
info: TestStruct
TestStruct.bar
TestStruct.casesOn
TestStruct.foo
TestStruct.mk
TestStruct.mk.inj
TestStruct.mk.injEq
TestStruct.mk.sizeOf_spec
TestStruct.noConfusion
TestStruct.noConfusionType
TestStruct.noConfusionType.withCtor
TestStruct.noConfusionType.withCtorType
TestStruct.rec
TestStruct.recOn
-/
#guard_msgs in
#print prefix -showTypes TestStruct

/--
Artificial test function to show #print prefix filters out internals
including match_/proof_.

Note.  Internal names are inherently subject to change.  This test case may
fail regularly when the Lean version is changed.  If so, we should disable
the test case using this function below until a more robust solution is found.
-/
def testMatchProof : (n : Nat) → Fin n → Unit
  | _,  ⟨0, _⟩ => ()
  | Nat.succ as, ⟨Nat.succ i, h⟩ => testMatchProof as ⟨i, Nat.le_of_succ_le_succ h⟩

/-- info: testMatchProof (n : Nat) : Fin n → Unit -/
#guard_msgs in
#print prefix testMatchProof

/--
info: testMatchProof (n : Nat) : Fin n → Unit
testMatchProof._proof_1 (as i : Nat) (h : i.succ < as.succ) : i.succ ≤ as
testMatchProof._sunfold (n : Nat) : Fin n → Unit
testMatchProof._unsafe_rec (n : Nat) : Fin n → Unit
testMatchProof.match_1.{u_1} (motive : (x : Nat) → Fin x → Sort u_1) (x✝ : Nat) (x✝¹ : Fin x✝)
  (h_1 : (n : Nat) → (isLt : 0 < n) → motive n ⟨0, isLt⟩)
  (h_2 : (as i : Nat) → (h : i.succ < as.succ) → motive as.succ ⟨i.succ, h⟩) : motive x✝ x✝¹
-/
#guard_msgs in
#print prefix +internals testMatchProof

private inductive TestInd where
| foo : TestInd
| bar : TestInd

/--
info: TestInd : Type
TestInd.bar : TestInd
TestInd.bar.sizeOf_spec : sizeOf TestInd.bar = 1
TestInd.casesOn.{u} {motive : TestInd → Sort u} (t : TestInd) (foo : motive TestInd.foo) (bar : motive TestInd.bar) :
  motive t
TestInd.foo : TestInd
TestInd.foo.sizeOf_spec : sizeOf TestInd.foo = 1
TestInd.noConfusion.{v✝} {P : Sort v✝} {x y : TestInd} (h : x = y) : TestInd.noConfusionType P x y
TestInd.noConfusionType.{v✝} (P : Sort v✝) (x y : TestInd) : Sort v✝
TestInd.rec.{u} {motive : TestInd → Sort u} (foo : motive TestInd.foo) (bar : motive TestInd.bar) (t : TestInd) :
  motive t
TestInd.recOn.{u} {motive : TestInd → Sort u} (t : TestInd) (foo : motive TestInd.foo) (bar : motive TestInd.bar) :
  motive t
TestInd.toCtorIdx : TestInd → Nat
-/
#guard_msgs in
#print prefix TestInd

-- `#print prefix` does nothing if no identifier is provided
#guard_msgs in
#print prefix



=== LEAN SOURCE: proof_wanted.lean ===
import Batteries.Util.ProofWanted

/-!
No unused variable warnings.
-/
#guard_msgs in proof_wanted foo (x : Nat) : True

/-!
When not a proposition, rely on `theorem` command failing.
-/
/--
error: type of theorem 'foo' is not a proposition
  Nat → Nat
-/
#guard_msgs in proof_wanted foo (x : Nat) : Nat



=== LEAN SOURCE: register_label_attr.lean ===
import BatteriesTest.Internal.DummyLabelAttr
import Lean.LabelAttribute

set_option linter.missingDocs false

open Lean

def f := 0

/-- info: #[] -/ #guard_msgs in #eval labelled `dummy_label_attr

attribute [dummy_label_attr] f

/-- info: #[`f] -/ #guard_msgs in #eval labelled `dummy_label_attr

section

attribute [-dummy_label_attr] f

/-- info: #[] -/ #guard_msgs in #eval labelled `dummy_label_attr

end

/-- info: #[`f] -/ #guard_msgs in #eval labelled `dummy_label_attr

-- Adding the label again is a no-op
attribute [dummy_label_attr] f

/-- info: #[`f] -/ #guard_msgs in #eval labelled `dummy_label_attr



=== LEAN SOURCE: rfl.lean ===
import Lean.Elab.Tactic.Rfl
-- Adaptation note: we should be able to remove this import after nightly-2024-03-19

set_option linter.missingDocs false

example (a : Nat) : a = a := rfl

example (a : Nat) : a = a := by rfl

open Setoid

universe u
variable {α : Sort u} [Setoid α]

@[refl] def iseqv_refl (a : α) : a ≈ a :=
  iseqv.refl a

example (a : α) : a ≈ a := by rfl

example (a : Nat) : a ≤ a := by (fail_if_success rfl); apply Nat.le_refl

attribute [refl] Nat.le_refl

example (a : Nat) : a ≤ a := by rfl

structure Foo

def Foo.le (_ _ : Foo) := Unit → True
instance : LE Foo := ⟨Foo.le⟩

@[refl] theorem Foo.le_refl (a : Foo) : a ≤ a := fun _ => trivial

example (a : Foo) : a ≤ a := by apply Foo.le_refl
example (a : Foo) : a ≤ a := by rfl

example (x : Nat) : x ≤ x := by
  show _
  rfl



=== LEAN SOURCE: satisfying.lean ===
import Batteries.Lean.SatisfiesM
import Batteries.Data.Array.Monadic

open Lean Meta Array Elab Term Tactic Command

example (xs : Array Expr) : MetaM { ts : Array Expr // ts.size = xs.size } := do
  let r ← satisfying (xs.size_mapM inferType)
  return r



=== LEAN SOURCE: seq_focus.lean ===
import Batteries.Tactic.SeqFocus

example : (True ∧ (∃ x : Nat, x = x)) ∧ True := by
  constructor
  constructor
  -- error: too many tactics
  fail_if_success map_tacs [trivial; exact ⟨0, rfl⟩; trivial; trivial]
  -- error: not enough tactics
  fail_if_success map_tacs [trivial; exact ⟨0, rfl⟩]
  map_tacs [trivial; exact ⟨0, rfl⟩; trivial]

example : ((True ∧ True) ∧ (∃ x : Nat, x = x)) ∧ (True ∧ (∃ x : Nat, x = x)) := by
  constructor
  constructor
  map_tacs [(constructor; trivial); exact ⟨0, rfl⟩; constructor]
  trivial
  trivial
  exact ⟨0, rfl⟩

example : (True ∧ (∃ x : Nat, x = x)) ∧ True := by
  constructor
  -- error: not enough tactics
  fail_if_success constructor <;> [trivial]
  map_tacs [constructor <;> [trivial; exact ⟨0, rfl⟩]; constructor]



=== LEAN SOURCE: show_term.lean ===
/-
Copyright (c) 2021 Kim Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/

/-- info: Try this: exact (n, 37) -/
#guard_msgs in example (n : Nat) : Nat × Nat := by
  show_term
    constructor
    exact n
    exact 37

/-- info: Try this: refine (?_, ?_) -/
#guard_msgs in example : Nat × Nat := by
  show_term constructor
  repeat exact 42

/-- info: Try this: fun {X} => X -/
#guard_msgs in example : {_a : Nat} → Nat :=
  show_term by
    intro X
    exact X



=== LEAN SOURCE: show_unused.lean ===
import Batteries.Tactic.ShowUnused

def foo := 1
def baz := 2
def bar := foo

/--
warning: #show_unused (line 14) says:
baz is not used transitively by [bar]
---
warning: unused definitions in this file:
baz
-/
#guard_msgs in #show_unused bar



=== LEAN SOURCE: simpa.lean ===
/-
Copyright (c) 2022 Arthur Paulino. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Arthur Paulino, Gabriel Ebner
-/

set_option linter.missingDocs false

example {P : Prop} (p : P) : P := by simpa

example {P : Prop} (p : False) : P := by simp at p

def foo (n : α) := [n]

section unnecessarySimpa

/--
warning: try 'simp' instead of 'simpa'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
-/
#guard_msgs in
example : foo n = [n] := by
  simpa only [foo]

/--
warning: try 'simp at h' instead of 'simpa using h'

Note: This linter can be disabled with `set_option linter.unnecessarySimpa false`
-/
#guard_msgs in
example (h : foo n ≠ [n]) : False := by
  simpa [foo] using h

end unnecessarySimpa

example (p : Nat → Prop) (h : p (a + b)) : p (b + a) := by
  have : a + b = b + a := Nat.add_comm _ _
  simpa [this] using h

def Injective (f : α → β) : Prop := ∀ ⦃a₁ a₂⦄, f a₁ = f a₂ → a₁ = a₂

namespace div_left_inj_issue

class Inv (α : Type u) where
  inv : α → α

class Group (α) extends Mul α, Div α, Inv α

variable [Group G]

axiom div_eq_mul_inv (a b : G) : a / b = a * Inv.inv b

axiom mul_left_injective (a : G) : Injective (· * a)

theorem div_left_injective (b : G) : Injective fun a => a / b := by
  simpa only [div_eq_mul_inv] using fun a a' h => mul_left_injective (Inv.inv b) h

end div_left_inj_issue

namespace Prod

theorem mk.inj_iff {a₁ a₂ : α} {b₁ b₂ : β} : (a₁, b₁) = (a₂, b₂) ↔ a₁ = a₂ ∧ b₁ = b₂ :=
  Iff.of_eq (mk.injEq _ _ _ _)

theorem mk.inj_left {α β : Type _} (a : α) : Injective (Prod.mk a : β → α × β) := by
  intro b₁ b₂ h
  simpa only [true_and, Prod.mk.inj_iff, eq_self] using h

end Prod

theorem implicit_lambda (h : ∀ {x : Nat}, a = x) : a = 2 := by
  simpa using h

theorem implicit_lambda2 (h : a = 2) : ∀ {_ : Nat}, a = 2 := by
  simpa using h

theorem no_implicit_lambda (h : ∀ {x : Nat}, a = x) : ∀ {x : Nat}, a = x := by
  simpa using @h

#guard_msgs (drop warning) in
theorem thm : (a : Int) ≤ b - c ↔ a + b ≤ c := sorry

#guard_msgs (drop warning) in
theorem thm2 : (b : Int) - c ≤ (a - b) - (a - c) := sorry

example : (b - c : Int) + (a - b) + a ≤ c := by
  simpa only [thm] using thm2

example : (b - c : Int) + (a - b) + a ≤ c := by
  simpa only [thm] using @thm2

example (P : Bool) (h : ¬ ¬ P) : P := by
  have : ¬ ¬ P := h
  simpa

/-- info: Try this: simpa only using h -/
#guard_msgs in
example (p : Prop) (h : p) : p := by simpa? using h

/-- info: Try this: simpa only [and_true] using h -/
#guard_msgs in
example (p : Prop) (h : p ∧ True) : p := by simpa? using h



=== LEAN SOURCE: simp_trace.lean ===
import Batteries.Tactic.SqueezeScope

-- undo changes to simp set after test was written
attribute [-simp] Nat.add_left_cancel_iff Nat.add_right_cancel_iff

set_option linter.missingDocs false

/-- info: Try this: simp only [Nat.add_comm] -/
#guard_msgs in
example : x + 1 = 1 + x := by simp? [Nat.add_comm, Nat.mul_comm]
/-- info: Try this: dsimp only [Nat.reduceAdd] -/
#guard_msgs in
example : 1 + 1 = 2 := by dsimp?

@[simp] def bar (z : Nat) := 1 + z
@[simp] def baz (z : Nat) := 1 + z

@[simp] def foo : Nat → Nat → Nat
  | 0, z => bar z
  | _+1, z => baz z

/--
info: Try this: simp only [foo, bar]
---
info: Try this: simp only [foo, baz]
-/
#guard_msgs in
example : foo x y = 1 + y := by
  cases x <;> simp? -- two printouts:
  -- "Try this: simp only [foo, bar]"
  -- "Try this: simp only [foo, baz]"

/-- info: Try this: simp only [foo, bar, baz] -/
#guard_msgs in
example : foo x y = 1 + y := by
  squeeze_scope
    cases x <;> simp -- only one printout: "Try this: simp only [foo, baz, bar]"



=== LEAN SOURCE: solve_by_elim.lean ===
/-
Copyright (c) 2021 Kim Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Batteries.Tactic.PermuteGoals
import BatteriesTest.Internal.DummyLabelAttr
import Lean.Meta.Tactic.Constructor
import Lean.Elab.SyntheticMVars
import Lean.Elab.Tactic.SolveByElim -- FIXME we need to make SolveByElimConfig builtin

set_option autoImplicit true

open Lean Elab Tactic in
/--
`fconstructor` is like `constructor`
(it calls `apply` using the first matching constructor of an inductive datatype)
except that it does not reorder goals.
-/
elab "fconstructor" : tactic => withMainContext do
  let mvarIds' ← (← getMainGoal).constructor {newGoals := .all}
  Term.synthesizeSyntheticMVarsNoPostponing
  replaceMainGoal mvarIds'

-- Test that `solve_by_elim*`, which works on multiple goals,
-- successfully uses the relevant local hypotheses for each goal.
example (f g : Nat → Prop) : (∃ k : Nat, f k) ∨ (∃ k : Nat, g k) ↔ ∃ k : Nat, f k ∨ g k := by
  fconstructor
  rintro (⟨n, fn⟩ | ⟨n, gn⟩)
  on_goal 3 => rintro ⟨n, hf | hg⟩
  solve_by_elim* (config := {maxDepth := 13}) [Or.inl, Or.inr, Exists.intro]

section «using»

/-- -/
@[dummy_label_attr] axiom foo : 1 = 2

example : 1 = 2 := by
  fail_if_success solve_by_elim
  solve_by_elim using dummy_label_attr

end «using»

section issue1581

/-- -/
axiom mySorry {α} : α

@[dummy_label_attr] theorem le_rfl [LE α] {b c : α} (_h : b = c) : b ≤ c := mySorry

example : 5 ≤ 7 := by
  apply_rules using dummy_label_attr
  guard_target = 5 = 7
  exact mySorry

example : 5 ≤ 7 := by
  apply_rules [le_rfl]
  guard_target = 5 = 7
  exact mySorry

end issue1581



=== LEAN SOURCE: trans.lean ===
import Batteries.Tactic.Trans

-- testing that the attribute is recognized and used
def nleq (a b : Nat) : Prop := a ≤ b

@[trans] def nleq_trans : nleq a b → nleq b c → nleq a c := Nat.le_trans

example (a b c : Nat) : nleq a b → nleq b c → nleq a c := by
  intro h₁ h₂
  trans b
  assumption
  assumption

example (a b c : Nat) : nleq a b → nleq b c → nleq a c := by intros; trans <;> assumption

-- using `Trans` typeclass
@[trans] def eq_trans {a b c : α} : a = b → b = c → a = c := by
  intro h₁ h₂
  apply Eq.trans h₁ h₂

example (a b c : Nat) : a = b → b = c → a = c := by intros; trans <;> assumption

example (a b c : Nat) : a = b → b = c → a = c := by
  intro h₁ h₂
  trans b
  assumption
  assumption

example : @Trans Nat Nat Nat (· ≤ ·) (· ≤ ·) (· ≤ ·) := inferInstance

example (a b c : Nat) : a ≤ b → b ≤ c → a ≤ c := by
  intros h₁ h₂
  trans ?b
  case b => exact b
  exact h₁
  exact h₂

example (a b c : α) (R : α → α → Prop) [Trans R R R] : R a b → R b c → R a c := by
  intros h₁ h₂
  trans ?b
  case b => exact b
  exact h₁
  exact h₂

example (a b c : Nat) : a ≤ b → b ≤ c → a ≤ c := by
  intros h₁ h₂
  trans
  exact h₁
  exact h₂

example (a b c : Nat) : a ≤ b → b ≤ c → a ≤ c := by intros; trans <;> assumption

example (a b c : Nat) : a < b → b < c → a < c := by
  intro h₁ h₂
  trans b
  assumption
  assumption

example (a b c : Nat) : a < b → b < c → a < c := by intros; trans <;> assumption

example (x n p : Nat) (h₁ : n * Nat.succ p ≤ x) : n * p ≤ x := by
  trans
  · apply Nat.mul_le_mul_left; apply Nat.le_succ
  · apply h₁

example (a : α) (c : γ) : ∀ b : β, a ≍ b → b ≍ c → a ≍ c := by
    intro b h₁ h₂
    trans b
    assumption
    assumption

def MyLE (n m : Nat) := ∃ k, n + k = m

@[trans] theorem MyLE.trans {n m k : Nat} (h1 : MyLE n m) (h2 : MyLE m k) : MyLE n k := by
  cases h1
  cases h2
  subst_vars
  exact ⟨_, Eq.symm <| Nat.add_assoc _ _ _⟩

example {n m k : Nat} (h1 : MyLE n m) (h2 : MyLE m k) : MyLE n k := by
  trans <;> assumption

/-- `trans` for implications. -/
example {A B C : Prop} (h : A → B) (g : B → C) : A → C := by
  trans B
  · guard_target =ₛ A → B -- ensure we have `B` and not a free metavariable.
    exact h
  · guard_target =ₛ B → C
    exact g

/-- `trans` for arrows between types. -/
example {A B C : Type} (h : A → B) (g : B → C) : A → C := by
  trans
  rotate_right
  · exact B
  · exact h
  · exact g

universe u v w

/-- `trans` for arrows between types. -/
example {A : Type u} {B : Type v} {C : Type w} (h : A → B) (g : B → C) : A → C := by
  trans
  rotate_right
  · exact B
  · exact h
  · exact g



=== LEAN SOURCE: tryThis.lean ===
/-
Copyright (c) 2023 Thomas Murrills. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Thomas Murrills
-/
import Lean.Meta.Tactic.TryThis

open Lean.Meta.Tactic.TryThis

/-!
This test file demonstrates the `Try This:` widget and describes how certain examples should
look. Note that while the evaluations here shouldn't fail, they also aren't tests in the traditional
sense—CI has no way of inspecting the HTML output, and therefore no way of checking that the
output is styled correctly.

All clickables should dim on mouseover without changing color drastically.

Both widgets should provide a (list of) `Try this: rfl` code actions.
-/

/-! # Setup -/

open Lean Meta Elab Term Expr
/-- Add a suggestion. -/
elab "add_suggestion" s:term : tactic => unsafe do
  addSuggestion (← getRef) (← evalTerm Suggestion (.const ``Suggestion []) s)

/-- Add a suggestion with a header. -/
elab "add_suggestion" s:term "with_header" h:str : tactic => unsafe do
  addSuggestion (← getRef) (← evalTerm Suggestion (.const ``Suggestion []) s)
    (header := h.getString)

/-- Add a suggestion. -/
elab "add_suggestions" s:term : tactic => unsafe do
  let s ← evalTerm (Array Suggestion) (.app (.const ``Array [.zero]) (.const ``Suggestion [])) s
  addSuggestions (← getRef) s

/-- Add suggestions with a header. -/
elab "add_suggestions" s:term "with_header" h:str : tactic => unsafe do
  let s ← evalTerm (Array Suggestion) (.app (.const ``Array [.zero]) (.const ``Suggestion [])) s
  addSuggestions (← getRef) s (header := h.getString)

/-- Demo adding a suggestion. -/
macro "#demo1" s:term : command => `(example : True := by add_suggestion $s; trivial)

/-- Demo adding a suggestion with a header. -/
macro "#demo1" s:term "with_header" h:str : command => `(example : True := by
  add_suggestion $s with_header $h; trivial)

/-- Demo adding suggestions. -/
macro "#demo" s:term : command => `(example : True := by
  add_suggestions $s; trivial)

/-- Demo adding suggestions with a header. -/
macro "#demo" s:term "with_header" h:str : command => `(example : True := by
  add_suggestions $s with_header $h; trivial)

/-- A basic suggestion. -/
private def s : Suggestion := Unhygienic.run `(tactic| rfl)

/-! # Demos -/

/-- info: Try this: rfl -/
#guard_msgs in
-- `Try this: rfl` with `rfl` in text-link color.
#demo1 s

/--
info: Try these:
• rfl
• rfl
• rfl
• rfl
-/
#guard_msgs in
/-
```
Try these:
• rfl
• rfl
• rfl
• rfl
```
with `rfl` in text-link color.
-/
#demo #[s,s,s,s]

/--
info: Try these:
• rfl
• rfl
• rfl
• rfl
• rfl
• rfl
• rfl
-/
#guard_msgs in
/-
```
Try these:
• rfl -- red
• rfl -- red-orange
• rfl -- orange
• rfl -- yellow
• rfl -- yellow-green
• rfl -- light green
• rfl -- green
```
-/
#demo #[0.0, 1/6, 2/6, 3/6, 4/6, 5/6, 1.0].map fun t => {s with style? := some <| .value t}

/-- info: Try this: rfl -/
#guard_msgs in
-- `Try this: rfl` -- error color with error squiggle
#demo1 {s with style? := some .error}

/-- info: Try this: rfl -/
#guard_msgs in
-- `Try this: rfl` -- error color, no squiggle
#demo1 {s with style? := some <| .error (decorated := false)}

/-- info: Try this: rfl -/
#guard_msgs in
-- `Try this: rfl` -- gold color with warning squiggle
#demo1 {s with style? := some .warning}

/-- info: Try this: rfl -/
#guard_msgs in
-- `Try this: rfl` -- gold color with no squiggle
#demo1 {s with style? := some <| .warning (decorated := false)}

/-- info: Try this: rfl -/
#guard_msgs in
-- `Try this: rfl` -- Lean green
#demo1 {s with style? := some .success}

/-- info: Try this: rfl -/
#guard_msgs in
-- `Try this: rfl` -- styled like a goal hypothesis
#demo1 {s with style? := some .asHypothesis}

/-- info: Try this: rfl -/
#guard_msgs in
-- `Try this: rfl` -- styled like an inaccessible goal hypothesis
#demo1 {s with style? := some .asInaccessible}

/-- info: Try this: rfl -/
#guard_msgs in
-- `Try this: Starfleet`
#demo1 {s with preInfo? := "Sta", postInfo? := "eet"}

/-- info: Try this: a secret message -/
#guard_msgs in
-- `Try this: rfl`
#demo1 {s with messageData? := m!"a secret message"}

/--
info: Try these:
• a secret message
• another secret message
-/
#guard_msgs in
/-
```
Try these:
• rfl
• rfl
```
-/
#demo #[
  {s with messageData? := m!"a secret message"},
  {s with messageData? := m!"another secret message"}
]

/-- info: Our only hope is rfl -/
#guard_msgs in
#demo1 s with_header "Our only hope is "

/--
info: We've got everything here! Such as:
• rfl
• rfl
• rfl
• rfl
-/
#guard_msgs in
#demo #[s,s,s,s] with_header "We've got everything here! Such as:"

/--
info: Grab bag:
• not a tactic
• This
• rfl
• link-styled
• this
-/
#guard_msgs in
#demo #[
  {s with
    suggestion := "not a tactic",
    preInfo? := "This is ",
    postInfo? := ".",
    style? := some .error},
  {s with
    suggestion := "This",
    postInfo? := " could be a tactic--but watch out!",
    style? := some .warning},
  {s with
    postInfo? := ". Finally, a tactic that just works.",
    style? := some .success},
  {s with
    preInfo? := "I'm just "
    suggestion := "link-styled",
    postInfo? := "."},
  {s with
    preInfo? := "On a scale of 0 to 1, I'd put ",
    suggestion := "this",
    postInfo? := " at 0.166667.",
    style? := some (.value (1/6))}
] with_header "Grab bag:"

/-- error: no suggestions available -/
#guard_msgs in
#demo #[]

/- The messages and suggestion should still read `Try this: rfl`, but the text in the lightbulb
menu should read "Consider rfl, please" -/
/-- info: Try this: rfl -/
#guard_msgs in
#demo1 { s with toCodeActionTitle? := fun text => "Consider " ++ text ++ ", please" }

/-- Add suggestions with a default code action title prefix. -/
elab "add_suggestions" s:term "with_code_action_prefix" h:str : tactic => unsafe do
  let s ← evalTerm (Array Suggestion) (.app (.const ``Array [.zero]) (.const ``Suggestion [])) s
  addSuggestions (← getRef) s (codeActionPrefix? := h.getString)

/-- Demo adding suggestions with a header. -/
macro "#demo" s:term "with_code_action_prefix" h:str : command => `(example : True := by
  add_suggestions $s with_code_action_prefix $h; trivial)

/- The messages and suggestions should still read `Try these: ...`, but the text in the lightbulb
menu should read "Maybe use: rfl"; "Maybe use: rfl"; "Also consider rfl, please!" -/
/--
info: Try these:
• rfl
• rfl
• rfl
-/
#guard_msgs in
#demo #[
  s,
  s,
  { s with toCodeActionTitle? := fun text => "Also consider " ++ text ++ ", please!" }
] with_code_action_prefix "Maybe use: "



=== LEAN SOURCE: vector.lean ===
import Batteries.Data.Vector

/-! ### Testing decidable quantifiers for `Vector`. -/

example : ∃ v : Vector Bool 6, v.toList.count true = 3 := by decide

inductive Gate : Nat → Type
| const : Bool → Gate 0
| if : ∀ {n}, Gate n → Gate n → Gate (n + 1)

namespace Gate

def and : Gate 2 := .if (.if (.const true) (.const false)) (.if (.const false) (.const false))

def eval (g : Gate n) (v : Vector Bool n) : Bool :=
  match g, v with
  | .const b, _ => b
  | .if g₁ g₂, v => if v.1.back! then eval g₁ v.pop else eval g₂ v.pop

example : ∀ v, and.eval v = (v[0] && v[1]) := by decide
example : ∃ v, and.eval v = false := by decide

end Gate



=== LEAN SOURCE: where.lean ===
-- None of these imports are really necessary, except to create namespace mentioned below.
import Lean.Elab.Term
import Lean.Elab.Command
import Batteries.Data.UnionFind.Basic

-- Return to pristine state
set_option linter.missingDocs false
set_option internal.cmdlineSnapshots false

/-- info: -- In root namespace with initial scope -/
#guard_msgs in #where

noncomputable section
/-- info: noncomputable section -/
#guard_msgs in #where
end

namespace WhereTest
variable (x : Nat) (α : Type)
/--
info: namespace WhereTest

variable (x : Nat) (α : Type)
-/
#guard_msgs in #where

universe u v w

/--
info: namespace WhereTest

universe u v w

variable (x : Nat) (α : Type)
-/
#guard_msgs in #where

set_option pp.piBinderTypes false

/--
info: namespace WhereTest

universe u v w

variable (x : Nat) (α : Type)

set_option pp.piBinderTypes false
-/
#guard_msgs in #where
end WhereTest

open Lean Meta

/--
info: open Lean Lean.Meta
-/
#guard_msgs in #where

open Elab hiding TermElabM

/--
info: open Lean Lean.Meta
open Lean.Elab hiding TermElabM
-/
#guard_msgs in #where

open Command Batteries
open Array renaming map -> listMap

/--
info: open Lean Lean.Meta
open Lean.Elab hiding TermElabM
open Lean.Elab.Command Batteries
open Array renaming map → listMap
-/
#guard_msgs in #where



=== LEAN SOURCE: DummyLabelAttr.lean ===
/-
Copyright (c) 2023 Lean FRO, LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Lean.LabelAttribute

/-- A dummy label attribute, which can be used for testing. -/
-- This can't live in `Batteries.Tactic.LabelAttr`
-- (because we can't use the extension in the same file it is initialized)
-- and it can't live in `test/`, because files there can not import other files in `test/`.
register_label_attr dummy_label_attr



=== LEAN SOURCE: DummyLibraryNote.lean ===
import Batteries.Util.LibraryNote

library_note "test" /--
1: This is a testnote for testing the library note feature of batteries.
The `#help note` command should be able to find this note when imported.
-/

library_note "test" /--
2: This is a second testnote for testing the library note feature of batteries.
-/

library_note "temporary note" /--
1: This is a testnote whose label also starts with "te", but gets sorted before "test"
-/



=== LEAN SOURCE: DummyLibraryNote2.lean ===
import BatteriesTest.Internal.DummyLibraryNote

library_note "test" /--
3: this is a note in a different file importing the above testnotes,
but still imported by the actual testfile.
-/

library_note "Test" /--
1: this is a testnote with a label starting with "Te"
-/

library_note "Other" /--
1: this is a testnote with a label not starting with "te",
so it shouldn't appear when looking for notes with label starting with "te".
-/



=== LEAN SOURCE: benchmark.lean ===

/-!
# Benchmarking the `omega` tactic

As it's important that `omega` is fast, particularly when it has nothing to do,
this file maintains a benchmark suite for `omega`. It is particularly low-tech,
and currently only reproducible on Kim Morrison's FRO machine;
nevertheless it seems useful to keep the benchmark history in the repository.

The benchmark file consists of the test suite from `omega`'s initial release,
with one test removed (in which a test-for-failure succeeds with today's `omega`).

The benchmark consists of `lake build && hyperfine "lake env lean test/omega/benchmark.lean"`
run on a freshly rebooted machine!

2024-02-06 feat: omega uses Lean.HashMap instead of Std.Data.HashMap (#588)
kim@carica std4 % lake build && hyperfine "lake env lean test/omega/benchmark.lean"
Benchmark 1: lake env lean test/omega/benchmark.lean
  Time (mean ± σ):      2.530 s ±  0.008 s    [User: 2.249 s, System: 0.276 s]
  Range (min … max):    2.513 s …  2.542 s    10 runs

2024-02-03 feat: omega handles min, max, if (#575)
kim@carica std4 % lake build && hyperfine "lake env lean test/omega/benchmark.lean"
Benchmark 1: lake env lean test/omega/benchmark.lean
  Time (mean ± σ):      2.526 s ±  0.009 s    [User: 2.250 s, System: 0.272 s]
  Range (min … max):    2.513 s …  2.542 s    10 runs

2024-02-02 fix: revert OmegaM state when not multiplying out (#570)
kim@carica std4 % lake build && hyperfine "lake env lean test/omega/benchmark.lean"
Benchmark 1: lake env lean test/omega/benchmark.lean
  Time (mean ± σ):      2.569 s ±  0.004 s    [User: 2.291 s, System: 0.273 s]
  Range (min … max):    2.563 s …  2.574 s    10 runs

2024-01-12 feat: omega handles double negation and implication hypotheses (#522)
kim@carica std4 % lake build && hyperfine "lake env lean test/omega/benchmark.lean"
Benchmark 1: lake env lean test/omega/benchmark.lean
  Time (mean ± σ):      2.575 s ±  0.004 s    [User: 2.302 s, System: 0.268 s]
  Range (min … max):    2.570 s …  2.581 s    10 runs

2024-01-10 feat: omega understands Prod.Lex (#511)
kim@carica std4 % lake build && hyperfine "lake env lean test/omega/benchmark.lean"
Benchmark 1: lake env lean test/omega/benchmark.lean
  Time (mean ± σ):      2.567 s ±  0.006 s    [User: 2.295 s, System: 0.268 s]
  Range (min … max):    2.559 s …  2.576 s    10 runs

2024-01-10 feat: omega handles iff and implications (#503)
kim@carica std4 % lake build && hyperfine "lake env lean test/omega/benchmark.lean"
Benchmark 1: lake env lean test/omega/benchmark.lean
  Time (mean ± σ):      2.348 s ±  0.007 s    [User: 2.060 s, System: 0.282 s]
  Range (min … max):    2.335 s …  2.356 s    10 runs

2023-12-21 feat: omega (#463)
kim@carica std4 % lake build && hyperfine "lake env lean test/omega/benchmark.lean"
Benchmark 1: lake env lean test/omega/benchmark.lean
  Time (mean ± σ):      2.362 s ±  0.008 s    [User: 2.080 s, System: 0.277 s]
  Range (min … max):    2.349 s …  2.372 s    10 runs

-/

example : True := by
  fail_if_success omega
  trivial

-- set_option trace.omega true
example (_ : (1 : Int) < (0 : Int)) : False := by omega

example (_ : (0 : Int) < (0 : Int)) : False := by omega
example (_ : (0 : Int) < (1 : Int)) : True := by (fail_if_success omega); trivial

example {x : Int} (_ : 0 ≤ x) (_ : x ≤ 1) : True := by (fail_if_success omega); trivial
example {x : Int} (_ : 0 ≤ x) (_ : x ≤ -1) : False := by omega

example {x : Int} (_ : x % 2 < x - 2 * (x / 2)) : False := by omega
example {x : Int} (_ : x % 2 > 5) : False := by omega

example {x : Int} (_ : 2 * (x / 2) > x) : False := by omega
example {x : Int} (_ : 2 * (x / 2) ≤ x - 2) : False := by omega

example {x : Nat} : x / 0 = 0 := by omega
example {x : Int} : x / 0 = 0 := by omega

example {x : Int} : x / 2 + x / (-2) = 0 := by omega

example (_ : 7 < 3) : False := by omega
example (_ : 0 < 0) : False := by omega

example {x : Nat} (_ : x > 7) (_ : x < 3) : False := by omega
example {x : Nat} (_ : x ≥ 7) (_ : x ≤ 3) : False := by omega

example {x y : Nat} (_ : x + y > 10) (_ : x < 5) (_ : y < 5) : False := by omega

example {x y : Int} (_ : x + y > 10) (_ : 2 * x < 11) (_ : y < 5) : False := by omega
example {x y : Nat} (_ : x + y > 10) (_ : 2 * x < 11) (_ : y < 5) : False := by omega

example {x y : Int} (_ : 2 * x + 4 * y = 5) : False := by omega
example {x y : Nat} (_ : 2 * x + 4 * y = 5) : False := by omega

example {x y : Int} (_ : 6 * x + 7 * y = 5) : True := by (fail_if_success omega); trivial

example {x y : Nat} (_ : 6 * x + 7 * y = 5) : False := by omega

example {x : Nat} (_ : x < 0) : False := by omega

example {x y z : Int} (_ : x + y > z) (_ : x < 0) (_ : y < 0) (_ : z > 0) : False := by omega

example {x y : Nat} (_ : x - y = 0) (_ : x > y) : False := by
  fail_if_success omega (config := { splitNatSub := false })
  omega

example {x y z : Int} (_ : x - y - z = 0) (_ : x > y + z) : False := by omega

example {x y z : Nat} (_ : x - y - z = 0) (_ : x > y + z) : False := by omega

example {a b c d e f : Nat} (_ : a - b - c - d - e - f = 0) (_ : a > b + c + d + e + f) :
    False := by
  omega

example {x y : Nat} (h₁ : x - y ≤ 0) (h₂ : y < x) : False := by omega

example {x y : Int} (_ : x / 2 - y / 3 < 1) (_ : 3 * x ≥ 2 * y + 6) : False := by omega

example {x y : Nat} (_ : x / 2 - y / 3 < 1) (_ : 3 * x ≥ 2 * y + 6) : False := by omega

example {x y : Nat} (_ : x / 2 - y / 3 < 1) (_ : 3 * x ≥ 2 * y + 4) : False := by omega

example {x y : Nat} (_ : x / 2 - y / 3 < x % 2) (_ : 3 * x ≥ 2 * y + 4) : False := by omega

example {x : Int} (h₁ : 5 ≤ x) (h₂ : x ≤ 4) : False := by omega

example {x : Nat} (h₁ : 5 ≤ x) (h₂ : x ≤ 4) : False := by omega

example {x : Nat} (h₁ : x / 3 ≥ 2) (h₂ : x < 6) : False := by omega

example {x : Int} {y : Nat} (_ : 0 < x) (_ : x + y ≤ 0) : False := by omega

example {a b c : Nat} (_ : a - (b - c) ≤ 5) (_ : b ≥ c + 3) (_ : a + c ≥ b + 6) : False := by omega

example {x : Nat} : 1 < (1 + ((x + 1 : Nat) : Int) + 2) / 2 := by omega

example {x : Nat} : (x + 4) / 2 ≤ x + 2 := by omega

example {x : Int} {m : Nat} (_ : 0 < m) (_ : ¬x % ↑m < (↑m + 1) / 2) : -↑m / 2 ≤ x % ↑m - ↑m := by
  omega


example (h : (7 : Int) = 0) : False := by omega

example (h : (7 : Int) ≤ 0) : False := by omega

example (h : (-7 : Int) + 14 = 0) : False := by omega

example (h : (-7 : Int) + 14 ≤ 0) : False := by omega

example (h : (1 : Int) + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 = 0) : False := by
  omega

example (h : (7 : Int) - 14 = 0) : False := by omega

example (h : (14 : Int) - 7 ≤ 0) : False := by omega

example (h : (1 : Int) - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1 = 0) : False := by
  omega

example (h : -(7 : Int) = 0) : False := by omega

example (h : -(-7 : Int) ≤ 0) : False := by omega

example (h : 2 * (7 : Int) = 0) : False := by omega

example (h : (7 : Int) < 0) : False := by omega

example {x : Int} (h : x + x + 1 = 0) : False := by omega

example {x : Int} (h : 2 * x + 1 = 0) : False := by omega

example {x y : Int} (h : x + x + y + y + 1 = 0) : False := by omega

example {x y : Int} (h : 2 * x + 2 * y + 1 = 0) : False := by omega

example {x : Int} (h₁ : 0 ≤ -7 + x) (h₂ : 0 ≤ 3 - x) : False := by omega

example {x : Int} (h₁ : 0 ≤ -7 + x) (h₂ : 0 < 4 - x) : False := by omega

example {x : Int} (h₁ : 0 ≤ 2 * x + 1) (h₂ : 2 * x + 1 ≤ 0) : False := by omega

example {x : Int} (h₁ : 0 < 2 * x + 2) (h₂ : 2 * x + 1 ≤ 0) : False := by omega

example {x y : Int} (h₁ : 0 ≤ 2 * x + 1) (h₂ : x = y) (h₃ : 2 * y + 1 ≤ 0) : False := by omega

example {x y z : Int} (h₁ : 0 ≤ 2 * x + 1) (h₂ : x = y) (h₃ : y = z) (h₄ : 2 * z + 1 ≤ 0) :
    False := by omega

example {x1 x2 x3 x4 x5 x6 : Int} (h : 0 ≤ 2 * x1 + 1) (h : x1 = x2) (h : x2 = x3) (h : x3 = x4)
    (h : x4 = x5) (h : x5 = x6) (h : 2 * x6 + 1 ≤ 0) : False := by omega

example {x : Int} (_ : 1 ≤ -3 * x) (_ : 1 ≤ 2 * x) : False := by omega

example {x y : Int} (_ : 2 * x + 3 * y = 0) (_ : 1 ≤ x) (_ : 1 ≤ y) : False := by omega

example {x y z : Int} (_ : 2 * x + 3 * y = 0) (_ : 3 * y + 4 * z = 0) (_ : 1 ≤ x) (_ : 1 ≤ -z) :
    False := by omega

example {x y z : Int} (_ : 2 * x + 3 * y + 4 * z = 0) (_ : 1 ≤ x + y) (_ : 1 ≤ y + z)
    (_ : 1 ≤ x + z) : False := by omega

example {x y : Int} (_ : 1 ≤ 3 * x) (_ : y ≤ 2) (_ : 6 * x - 2 ≤ y) : False := by omega

example {x y : Int} (_ : y = x) (_ : 0 ≤ x - 2 * y) (_ : x - 2 * y ≤ 1) (_ : 1 ≤ x) : False := by
  omega
example {x y : Int} (_ : y = x) (_ : 0 ≤ x - 2 * y) (_ : x - 2 * y ≤ 1) (_ : x ≥ 1) : False := by
  omega
example {x y : Int} (_ : y = x) (_ : 0 ≤ x - 2 * y) (_ : x - 2 * y ≤ 1) (_ : 0 < x) : False := by
  omega
example {x y : Int} (_ : y = x) (_ : 0 ≤ x - 2 * y) (_ : x - 2 * y ≤ 1) (_ : x > 0) : False := by
  omega

example {x : Nat} (_ : 10 ∣ x) (_ : ¬ 5 ∣ x) : False := by omega
example {x y : Nat} (_ : 5 ∣ x) (_ : ¬ 10 ∣ x) (_ : y = 7) (_ : x - y ≤ 2) (_ : x ≥ 6) : False := by
  omega

example (x : Nat) : x % 4 - x % 8 = 0 := by omega

example {n : Nat} (_ : n > 0) : (2*n - 1) % 2 = 1 := by omega

example (x : Int) (_ : x > 0 ∧ x < -1) : False := by omega
example (x : Int) (_ : x > 7) : x < 0 ∨ x > 3 := by omega

example (_ : ∃ n : Nat, n < 0) : False := by omega
example (_ : { x : Int // x < 0 ∧ x > 0 }) : False := by omega
example {x y : Int} (_ : x < y) (z : { z : Int // y ≤ z ∧ z ≤ x }) : False := by omega

example (a b c d e : Int)
    (ha : 2 * a + b + c + d + e = 4)
    (hb : a + 2 * b + c + d + e = 5)
    (hc : a + b + 2 * c + d + e = 6)
    (hd : a + b + c + 2 * d + e = 7)
    (he : a + b + c + d + 2 * e = 8) : e = 3 := by omega

example (a b c d e : Int)
    (ha : 2 * a + b + c + d + e = 4)
    (hb : a + 2 * b + c + d + e = 5)
    (hc : a + b + 2 * c + d + e = 6)
    (hd : a + b + c + 2 * d + e = 7)
    (he : a + b + c + d + 2 * e = 8 ∨ e = 3) : e = 3 := by
  fail_if_success omega (config := { splitDisjunctions := false })
  omega

example {a b : Int} (h : a < b) (w : b < a) : False := by omega

example (_e b c a v0 v1 : Int) (_h1 : v0 = 5 * a) (_h2 : v1 = 3 * b) (h3 : v0 + v1 + c = 10) :
    v0 + 5 + (v1 - 3) + (c - 2) = 10 := by omega

example (h : (1 : Int) < 0) (_ : ¬ (37 : Int) < 42) (_ : True) (_ : (-7 : Int) < 5) :
    (3 : Int) < 7 := by omega

example (A B : Int) (h : 0 < A * B) : 0 < 8 * (A * B) := by omega

example (A B : Nat) (h : 7 < A * B) : 0 < A*B/8 := by omega
example (A B : Int) (h : 7 < A * B) : 0 < A*B/8 := by omega

example (ε : Int) (h1 : ε > 0) : ε / 2 + ε / 3 + ε / 7 < ε := by omega

example (x y z : Int) (h1 : 2*x < 3*y) (h2 : -4*x + z/2 < 0) (h3 : 12*y - z < 0) : False := by omega

example (ε : Int) (h1 : ε > 0) : ε / 2 < ε := by omega

example (ε : Int) (_ : ε > 0) : ε - 2 ≤ ε / 3 + ε / 3 + ε / 3 := by omega
example (ε : Int) (_ : ε > 0) : ε / 3 + ε / 3 + ε / 3 ≤ ε := by omega
example (ε : Int) (_ : ε > 0) : ε - 2 ≤ ε / 3 + ε / 3 + ε / 3 ∧ ε / 3 + ε / 3 + ε / 3 ≤ ε := by
  omega

example (x : Int) (h : 0 < x) : 0 < x / 1 := by omega

example (x : Int) (h : 5 < x) : 0 < x/2/3 := by omega

example (_a b _c : Nat) (h2 : b + 2 > 3 + b) : False := by omega
example (_a b _c : Int) (h2 : b + 2 > 3 + b) : False := by omega

example (g v V c h : Int) (_ : h = 0) (_ : v = V) (_ : V > 0) (_ : g > 0)
    (_ : 0 ≤ c) (_ : c < 1) : v ≤ V := by omega

example (x y z : Int) (h1 : 2 * x < 3 * y) (h2 : -4 * x + 2 * z < 0) (h3 : 12 * y - 4 * z < 0) :
    False := by
  omega

example (x y z : Int) (h1 : 2 * x < 3 * y) (h2 : -4 * x + 2 * z < 0) (_h3 : x * y < 5)
    (h3 : 12 * y - 4 * z < 0) : False := by omega

example (a b c : Int) (h1 : a > 0) (h2 : b > 5) (h3 : c < -10) (h4 : a + b - c < 3) : False := by
  omega

example (_ b _ : Int) (h2 : b > 0) (h3 : ¬ b ≥ 0) : False := by
  omega

example (x y z : Int) (hx : x ≤ 3 * y) (h2 : y ≤ 2 * z) (h3 : x ≥ 6 * z) : x = 3 * y := by
  omega

example (x y z : Int) (h1 : 2 * x < 3 * y) (h2 : -4 * x + 2 * z < 0) (_h3 : x * y < 5) :
    ¬ 12 * y - 4 * z < 0 := by
  omega

example (x y z : Int) (hx : ¬ x > 3 * y) (h2 : ¬ y > 2 * z) (h3 : x ≥ 6 * z) : x = 3 * y := by
  omega

example (x y : Int) (h : 6 + ((x + 4) * x + (6 + 3 * y) * y) = 3) (h' : (x + 4) * x ≥ 0)
    (h'' : (6 + 3 * y) * y ≥ 0) : False := by omega

example (a : Int) (ha : 0 ≤ a) : 0 * 0 ≤ 2 * a := by omega

example (x y : Int) (h : x < y) : x ≠ y := by omega

example (x y : Int) (h : x < y) : ¬ x = y := by omega

example (prime : Nat → Prop) (x y z : Int) (h1 : 2 * x + ((-3) * y) < 0) (h2 : (-4) * x + 2*  z < 0)
    (h3 : 12 * y + (-4) * z < 0) (_ : prime 7) : False := by omega

example (i n : Nat) (h : (2 : Int) ^ i ≤ 2 ^ n) : (0 : Int) ≤ 2 ^ n - 2 ^ i := by omega

-- Check we use `exfalso` on non-comparison goals.
example (prime : Nat → Prop) (_ b _ : Nat) (h2 : b > 0) (h3 : b < 0) : prime 10 := by
  omega

example (a b c : Nat) (h2 : (2 : Nat) > 3)  : a + b - c ≥ 3 := by omega

-- Verify that we split conjunctions in hypotheses.
example (x y : Int)
    (h : 6 + ((x + 4) * x + (6 + 3 * y) * y) = 3 ∧ (x + 4) * x ≥ 0 ∧ (6 + 3 * y) * y ≥ 0) :
    False := by omega

example (mess : Nat → Nat) (S n : Nat) :
    mess S + (n * mess S + n * 2 + 1) < n * mess S + mess S + (n * 2 + 2) := by omega

example (p n p' n' : Nat) (h : p + n' = p' + n) : n + p' = n' + p := by
  omega

example (a b c : Int) (h1 : 32 / a < b) (h2 : b < c) : 32 / a < c := by omega



=== LEAN SOURCE: check_imports.lean ===
/-
Copyright (c) 2024 Joe Hendrix. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joe Hendrix
-/
import Batteries

/-!
This test checks that all directories in `Batteries/Data/` have corresponding
`Batteries.Data.<dir>` modules imported by `Batteries` that import all of the submodules
under that directory.

It will also check that `Batteries` imports all the expected modules.

It has a flag (`autofix` below) to automatically fix the errors found.  This
command may need to be rerun to fix all errors; it tries to avoid overwriting
existing files.
-/

open Lean System

/-- Monad to log errors to stderr while record error count. -/
abbrev LogIO := StateRefT (Bool × Bool) IO

def runLogIO (act : LogIO Unit) : MetaM Unit := do
  let ((), (warnings, _)) ← act.run (false, false)
  if warnings then
    throwError "Fatal error"

def warn (fixable : Bool) (msg : String) : LogIO Unit := do
  modify (fun (_, u) => (true, u || not fixable))
  liftM (IO.eprintln msg)

-- | Predicate indicates if warnings are present and if they fixable.
def getWarningInfo : LogIO (Bool × Bool) :=  get

def createModuleHashmap (env : Environment) : Std.HashMap Name ModuleData := Id.run do
  let mut nameMap := {}
  for i in [0:env.header.moduleNames.size] do
    let nm := env.header.moduleNames[i]!
    let md := env.header.moduleData[i]!
    nameMap := nameMap.insert nm md
  pure nameMap

/-- Get the imports we expect in a directory of `Batteries.Data`. -/
partial def addModulesIn (recurse : Bool) (prev : Array Name) (root : Name := .anonymous)
    (path : FilePath) : IO (Array Name) := do
  let mut r := prev
  for entry in ← path.readDir do
    if ← entry.path.isDir then
      if recurse then
        r ← addModulesIn recurse r (root.mkStr entry.fileName) entry.path
    else
      let .some mod := FilePath.fileStem entry.fileName
        | continue
      r := r.push (root.mkStr mod)
  pure r

def modulePath (name : Name) : FilePath :=
  let path := name.toString.replace "." FilePath.pathSeparator.toString
  s!"{path}.lean"

def writeImportModule (path : FilePath) (imports : Array Name) : IO Unit := do
  let imports := imports.qsort (·.toString < ·.toString)
  let lines := imports.map (s!"import {·}\n")
  let contents := String.join lines.toList
  IO.println s!"Generating {path}"
  IO.FS.writeFile path contents

/-- Check for imports and return true if warnings issued. -/
def checkMissingImports (modName : Name) (modData : ModuleData) (reqImports : Array Name) :
    LogIO Bool := do
  let names : Std.HashSet Name := Std.HashSet.ofArray (modData.imports.map (·.module))
  let mut warned := false
  for req in reqImports do
    if !names.contains req then
      warn true s!"Missing import {req} in {modName}"
      warned := true
  pure warned

/-- Check directory entry in `Batteries/Data/` -/
def checkBatteriesDataDir
    (modMap : Std.HashMap Name ModuleData)
    (entry : IO.FS.DirEntry) (autofix : Bool := false) : LogIO Unit := do
  let moduleName := `Batteries.Data ++ .mkSimple entry.fileName
  let requiredImports ← addModulesIn (recurse := true) #[] (root := moduleName) entry.path
  let .some module := modMap[moduleName]?
    | warn true s!"Could not find {moduleName}; Not imported into Batteries."
      let path := modulePath moduleName
      -- We refuse to generate imported modules whose path doesn't exist.
      -- The import failure will be fixed later and the file rerun
      if autofix then
        if ← path.pathExists then
          warn false s!"Skipping writing of {moduleName}: rerun after {moduleName} imported."
        else
          writeImportModule path requiredImports
      return
  let hasDecls : Bool := module.constants.size > 0
  if hasDecls then
    warn false
          s!"Expected {moduleName} to not contain additional declarations.\n\
            Declarations should be moved out.\n\
            This error cannot be automatically fixed."
  let warned ← checkMissingImports moduleName module requiredImports
  if autofix && warned && !hasDecls then
    writeImportModule (modulePath moduleName) requiredImports

/-- Compute imports expected by `Batteries.lean` -/
def expectedBatteriesImports : IO (Array Name) := do
  let mut needed := #[]
  for top in ← FilePath.readDir "Batteries" do
    if top.fileName == "Data" then
      needed ← addModulesIn (recurse := false) needed `Batteries.Data top.path
    else
      let nm := `Batteries
      let rootname := FilePath.withExtension top.fileName ""
      let root :=  nm.mkStr rootname.toString
      if ← top.path.isDir then
        needed ← addModulesIn (recurse := true) needed (root := root) top.path
      else
        needed := needed.push root
  pure needed

def checkBatteriesDataImports : MetaM Unit := do
  -- N.B. This can be used to automatically fix Batteries.lean as well as
  -- other import files.
  -- It uses an environment variable to do that.
  -- The easiest way to use this is run `./scripts/updateBatteries.sh.`
  let autofix := (← IO.getEnv "__LEAN_BATTERIES_AUTOFIX_IMPORTS").isSome
  let env ← getEnv
  let modMap := createModuleHashmap env
  runLogIO do
    for entry in ← FilePath.readDir ("Batteries" / "Data") do
      if ← entry.path.isDir then
        checkBatteriesDataDir (autofix := autofix) modMap entry
    let batteriesImports ← expectedBatteriesImports
    let .some batteriesMod := modMap[`Batteries]?
        | warn false "Missing Batteries module!; Run `lake build`."
    let warned ← checkMissingImports `Batteries batteriesMod batteriesImports
    if autofix && warned then
      writeImportModule "Batteries.lean" batteriesImports
    match ← getWarningInfo with
    | (false, _) =>
      pure ()
    | (_, true) =>
      IO.eprintln s!"Found errors that cannot be automatically fixed.\n\
                     Address unfixable issues and rerun lake build && ./scripts/updateBatteries.sh."
    | _ =>
      if autofix then
        IO.eprintln s!"Found missing imports and attempted fixes.\n\
                       Run lake build && ./scripts/updateBatteries.sh to verify.\n\
                       Multiple runs may be needed."
      else
        IO.eprintln s!"Found missing imports.\n\
                       Run lake build && ./scripts/updateBatteries.sh to attempt automatic fixes."

run_meta checkBatteriesDataImports



=== LEAN SOURCE: runLinter.lean ===
import Lean.Util.SearchPath
import Batteries.Tactic.Lint
import Batteries.Data.Array.Basic
import Lake.CLI.Main

open Lean Core Elab Command Batteries.Tactic.Lint
open System (FilePath)

/-- The list of `nolints` pulled from the `nolints.json` file -/
abbrev NoLints := Array (Name × Name)

/-- Read the given file path and deserialize it as JSON. -/
def readJsonFile (α) [FromJson α] (path : System.FilePath) : IO α := do
  let _ : MonadExceptOf String IO := ⟨throw ∘ IO.userError, fun x _ => x⟩
  liftExcept <| fromJson? <|← liftExcept <| Json.parse <|← IO.FS.readFile path

/-- Serialize the given value `a : α` to the file as JSON. -/
def writeJsonFile [ToJson α] (path : System.FilePath) (a : α) : IO Unit :=
  IO.FS.writeFile path <| toJson a |>.pretty.push '\n'

open Lake

/-- Returns the root modules of `lean_exe` or `lean_lib` default targets in the Lake workspace. -/
def resolveDefaultRootModules : IO (Array Name) := do
  -- load the Lake workspace
  let (elanInstall?, leanInstall?, lakeInstall?) ← findInstall?
  let config ← MonadError.runEIO <| mkLoadConfig { elanInstall?, leanInstall?, lakeInstall? }
  let some workspace ← loadWorkspace config |>.toBaseIO
    | throw <| IO.userError "failed to load Lake workspace"

  -- build an array of all root modules of `lean_exe` and `lean_lib` default targets
  let defaultTargetModules := workspace.root.defaultTargets.flatMap fun target =>
    if let some lib := workspace.root.findLeanLib? target then
      lib.roots
    else if let some exe := workspace.root.findLeanExe? target then
      #[exe.config.root]
    else
      #[]
  return defaultTargetModules

/--
Parse args list for `runLinter`
and return a pair of the update and specified module arguments.

Throws an exception if unable to parse the arguments.
Returns `none` for the specified module if no module is specified.-/
def parseLinterArgs (args: List String) : Except String (Bool × Option Name) :=
  let (update, moreArgs) :=
    match args with
    | "--update" :: args => (true, args)
    | _ => (false, args)
  match moreArgs with
    | [] => Except.ok (update, none)
    | [mod] => match mod.toName with
      | .anonymous => Except.error "cannot convert module to Name"
      | name => Except.ok (update, some name)
    | _ => Except.error "cannot parse arguments"

/--
Return an array of the modules to lint.

If `specifiedModule` is not `none` return an array containing only `specifiedModule`.
Otherwise, resolve the default root modules from the Lake workspace. -/
def determineModulesToLint (specifiedModule : Option Name) : IO (Array Name) := do
  match specifiedModule with
  | some module =>
    println!"Running linter on specified module: {module}"
    return #[module]
  | none =>
    println!"Automatically detecting modules to lint"
    let defaultModules ← resolveDefaultRootModules
    println!"Default modules: {defaultModules}"
    return defaultModules

/-- Run the Batteries linter on a given module and update the linter if `update` is `true`. -/
unsafe def runLinterOnModule (update : Bool) (module : Name): IO Unit := do
  initSearchPath (← findSysroot)
  let mFile ← findOLean module
  unless (← mFile.pathExists) do
    -- run `lake build module` (and ignore result) if the file hasn't been built yet
    let child ← IO.Process.spawn {
      cmd := (← IO.getEnv "LAKE").getD "lake"
      args := #["build", s!"+{module}"]
      stdin := .null
    }
    _ ← child.wait
  -- If the linter is being run on a target that doesn't import `Batteries.Tactic.List`,
  -- the linters are ineffective. So we import it here.
  let lintModule := `Batteries.Tactic.Lint
  let lintFile ← findOLean lintModule
  unless (← lintFile.pathExists) do
    -- run `lake build +Batteries.Tactic.Lint` (and ignore result) if the file hasn't been built yet
    let child ← IO.Process.spawn {
      cmd := (← IO.getEnv "LAKE").getD "lake"
      args := #["build", s!"+{lintModule}"]
      stdin := .null
    }
    _ ← child.wait
  let nolintsFile : FilePath := "scripts/nolints.json"
  let nolints ← if ← nolintsFile.pathExists then
    readJsonFile NoLints nolintsFile
  else
    pure #[]
  unsafe Lean.enableInitializersExecution
  let env ← importModules #[module, lintModule] {} (trustLevel := 1024) (loadExts := true)
  let ctx := { fileName := "", fileMap := default }
  let state := { env }
  Prod.fst <$> (CoreM.toIO · ctx state) do
    let decls ← getDeclsInPackage module.getRoot
    let linters ← getChecks (slow := true) (runAlways := none) (runOnly := none)
    let results ← lintCore decls linters
    if update then
      writeJsonFile (α := NoLints) nolintsFile <|
        .qsort (lt := fun (a, b) (c, d) => a.lt c || (a == c && b.lt d)) <|
        .flatten <| results.map fun (linter, decls) =>
        decls.fold (fun res decl _ => res.push (linter.name, decl)) #[]
    let results := results.map fun (linter, decls) =>
      .mk linter <| nolints.foldl (init := decls) fun decls (linter', decl') =>
        if linter.name == linter' then decls.erase decl' else decls
    let failed := results.any (!·.2.isEmpty)
    if failed then
      let fmtResults ←
        formatLinterResults results decls (groupByFilename := true) (useErrorFormat := true)
          s!"in {module}" (runSlowLinters := true) .medium linters.size
      IO.print (← fmtResults.toString)
      IO.Process.exit 1
    else
      IO.println s!"-- Linting passed for {module}."

/--
Usage: `runLinter [--update] [Batteries.Data.Nat.Basic]`

Runs the linters on all declarations in the given module
(or all root modules of Lake `lean_lib` and `lean_exe` default targets if no module is specified).
If `--update` is set, the `nolints` file is updated to remove any declarations that no longer need
to be nolinted.
-/
unsafe def main (args : List String) : IO Unit := do
  let linterArgs := parseLinterArgs args
  let (update, specifiedModule) ← match linterArgs with
    | Except.ok args => pure args
    | Except.error msg => do
      IO.eprintln s!"Error parsing args: {msg}"
      IO.eprintln "Usage: runLinter [--update] [Batteries.Data.Nat.Basic]"
      IO.Process.exit 1

  let modulesToLint ← determineModulesToLint specifiedModule

  modulesToLint.forM <| runLinterOnModule update



=== LEAN SOURCE: Main.lean ===
/-
Copyright (c) 2023 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Lake.CLI.Main

/-! # `lake exe shake` command

This command will check the current project (or a specified target module) and all dependencies for
unused imports. This works by looking at generated `.olean` files to deduce required imports and
ensuring that every import is used to contribute some constant. Because recompilation is not needed
this is quite fast (about 8 seconds to check `Mathlib` and all dependencies), but it has some known
limitations:

* Tactics that are used during elaboration generally leave no trace in the proof term, so
  they will be incorrectly marked as unused.
* Similarly, files that contribute only notations will not be detected.
* Conversely, files that define tactics and notations are also likely to have false positives
  because the notation itself does not depend on the referenced constant (it elaborates to a
  name literal rather than an actual reference to the target constant).

To mitigate this, the `scripts/noshake.json` file is used to suppress known false positives. See
`ShakeCfg` for information regarding the file format.

-/

/-- help string for the command line interface -/
def help : String := "Lean project tree shaking tool
Usage: lake exe shake [OPTIONS] <MODULE>..

Arguments:
  <MODULE>
    A module path like `Mathlib`. All files transitively reachable from the
    provided module(s) will be checked.

Options:
  --force
    Skips the `lake build --no-build` sanity check

  --fix
    Apply the suggested fixes directly. Make sure you have a clean checkout
    before running this, so you can review the changes.

  --cfg <FILE>   (default: scripts/noshake.json)
    Use FILE to specify which imports we should ignore.

  --update
    Assume that all issues we find are false positives and update the config
    file to include them.

  --no-downstream
    Unless disabled, shake will check downstream files that were transitively
    depending on the import we want to remove and re-add the import to these
    downstream files.

# The noshake.json file

The file passed in the --cfg argument is a JSON file with the following
structure:

  {
    \"ignoreAll\": [NAME],
    \"ignoreImport\": [NAME],
    \"ignore\": {NAME: [NAME]}
  }

The fields can be omitted if empty. They have the following interpretation:

* ignoreAll:
  All imports in these files should be treated as necessary
* ignore[X]:
  All imports in the list should be treated as necessary when processing X
* ignoreImport:
  These files should be treated as necessary when imported into any other file.
"

open Lean

/-- We use `Nat` as a bitset for doing efficient set operations.
The bit indexes will usually be a module index. -/
abbrev Bitset := Nat

/-- The main state of the checker, containing information on all loaded modules. -/
structure State where
  /-- Maps a module name to its index in the module list. -/
  toIdx : Std.HashMap Name USize := {}
  /-- Maps a module index to the module name. -/
  modNames : Array Name := #[]
  /-- Maps a module index to the module data. -/
  mods : Array ModuleData := #[]
  /-- `j ∈ deps[i]` if module `j` is a direct dependency of module `i` -/
  deps : Array (Array USize) := #[]
  /-- `j ∈ transDeps[i]` is the reflexive transitive closure of `deps` -/
  transDeps : Array Bitset := #[]
  /-- `j ∈ needs[i]` if module `i` uses a constant declared in module `j`.
  Note: this is left empty if `args.downstream` is false, we calculate `needs` on demand -/
  needs : Array Bitset := #[]
  /-- Maps a constant name to the module index containing it.
  A value of `none` means the constant was found in multiple modules,
  in which case we do not track it. -/
  constToIdx : Std.HashMap Name (Option USize) := {}

/-- Returns `true` if this is a constant whose body should not be considered for dependency
tracking purposes. -/
def isBlacklisted (name : Name) : Bool :=
  -- Compiler-produced definitions are skipped, because they can sometimes pick up spurious
  -- dependencies due to specializations in unrelated files. Even if we remove these modules
  -- from the import path, the compiler will still just find another way to compile the definition.
  if let .str _ "_cstage2" := name then true else
  if let .str _ "_cstage1" := name then true else
  false

/-- Calculates the value of the `needs[i]` bitset for a given module `mod`.
Bit `j` is set in the result if some constant from module `j` is used in this module. -/
def calcNeeds (constToIdx : Std.HashMap Name (Option USize)) (mod : ModuleData) : Bitset :=
  mod.constants.foldl (init := 0) fun deps ci =>
    if isBlacklisted ci.name then deps else
    let deps := visitExpr ci.type deps
    match ci.value? with
    | some e => visitExpr e deps
    | none => deps
where
  /-- Accumulate the results from expression `e` into `deps`. -/
  visitExpr e deps :=
    Lean.Expr.foldConsts e deps fun c deps => match constToIdx[c]? with
      | some (some i) => deps ||| (1 <<< i.toNat)
      | _ => deps

/-- Calculates the same as `calcNeeds` but tracing each module to a specific constant. -/
def getExplanations (constToIdx : Std.HashMap Name (Option USize)) (mod : ModuleData) :
    Std.HashMap USize (Name × Name) :=
  mod.constants.foldl (init := {}) fun deps ci =>
    if isBlacklisted ci.name then deps else
    let deps := visitExpr ci.name ci.type deps
    match ci.value? with
    | some e => visitExpr ci.name e deps
    | none => deps
where
  /-- Accumulate the results from expression `e` into `deps`. -/
  visitExpr name e deps :=
    Lean.Expr.foldConsts e deps fun c deps => match constToIdx[c]? with
      | some (some i) =>
        if
          if let some (name', _) := deps[i]? then
            decide (name.toString.length < name'.toString.length)
          else true
        then
          deps.insert i (name, c)
        else
          deps
      | _ => deps

/-- Load all the modules in `imports` into the `State`, as well as their transitive dependencies.
Returns a pair `(imps, transImps)` where:

* `j ∈ imps` if `j` is one of the module indexes in `imports`
* `j ∈ transImps` if module `j` is transitively reachable from `imports`
-/
partial def loadModules (imports : Array Import) : StateT State IO (Array USize × Bitset) := do
  let mut imps := #[]
  let mut transImps := 0
  for imp in imports do
    let s ← get
    if let some i := s.toIdx[imp.module]? then
      imps := imps.push i
      transImps := transImps ||| s.transDeps[i]!
    else
      let mFile ← findOLean imp.module
      unless (← mFile.pathExists) do
        throw <| IO.userError s!"object file '{mFile}' of module {imp.module} does not exist"
      let (mod, _) ← readModuleData mFile
      let (deps, transDeps) ← loadModules mod.imports
      let s ← get
      let n := s.mods.size.toUSize
      let transDeps := transDeps ||| (1 <<< n.toNat)
      imps := imps.push n
      transImps := transImps ||| transDeps
      set (σ := State) {
        toIdx := s.toIdx.insert imp.module n
        modNames := s.modNames.push imp.module
        mods := s.mods.push mod
        deps := s.deps.push deps
        transDeps := s.transDeps.push transDeps
        needs := s.needs
        constToIdx := mod.constNames.foldl (init := s.constToIdx) fun m a =>
          match m.getThenInsertIfNew? a n with
          | (some (some _), m) =>
            -- Note: If a constant is found in multiple modules, we assume it is an auto-generated
            -- definition which is created on demand, and therefore it is safe to ignore any
            -- dependencies via this definition because it will just be re-created in the current
            -- module if we don't import it.
            m.insert a none
          | (_, m) => m
      }
  return (imps, transImps)

/-- The list of edits that will be applied in `--fix`. `edits[i] = (removed, added)` where:

* If `j ∈ removed` then we want to delete module named `j` from the imports of `i`
* If `j ∈ added` then we want to add module index `j` to the imports of `i`.
  We keep this as a bitset because we will do transitive reduction before applying it
-/
abbrev Edits := Std.HashMap Name (NameSet × Bitset)

/-- Register that we want to remove `tgt` from the imports of `src`. -/
def Edits.remove (ed : Edits) (src tgt : Name) : Edits :=
  match ed.get? src with
  | none => ed.insert src (RBTree.insert ∅ tgt, 0)
  | some (a, b) => ed.insert src (a.insert tgt, b)

/-- Register that we want to add `tgt` to the imports of `src`. -/
def Edits.add (ed : Edits) (src : Name) (tgt : Nat) : Edits :=
  match ed.get? src with
  | none => ed.insert src (∅, 1 <<< tgt)
  | some (a, b) => ed.insert src (a, b ||| (1 <<< tgt))

/-- Parse a source file to extract the location of the import lines, for edits and error messages.

Returns `(path, inputCtx, imports, endPos)` where `imports` is the `Lean.Parser.Module.import` list
and `endPos` is the position of the end of the header.
-/
def parseHeaderFromString (text path : String) :
    IO (System.FilePath × Parser.InputContext ×
      TSyntaxArray ``Parser.Module.import × String.Pos) := do
  let inputCtx := Parser.mkInputContext text path
  let (header, parserState, msgs) ← Parser.parseHeader inputCtx
  if !msgs.toList.isEmpty then -- skip this file if there are parse errors
    msgs.forM fun msg => msg.toString >>= IO.println
    throw <| .userError "parse errors in file"
  -- the insertion point for `add` is the first newline after the imports
  let insertion := header.raw.getTailPos?.getD parserState.pos
  let insertion := text.findAux (· == '\n') text.endPos insertion + ⟨1⟩
  pure (path, inputCtx, .mk header.raw[2].getArgs, insertion)

/-- Parse a source file to extract the location of the import lines, for edits and error messages.

Returns `(path, inputCtx, imports, endPos)` where `imports` is the `Lean.Parser.Module.import` list
and `endPos` is the position of the end of the header.
-/
def parseHeader (srcSearchPath : SearchPath) (mod : Name) :
    IO (System.FilePath × Parser.InputContext ×
      TSyntaxArray ``Parser.Module.import × String.Pos) := do
  -- Parse the input file
  let some path ← srcSearchPath.findModuleWithExt "lean" mod
    | throw <| .userError "error: failed to find source file for {mod}"
  let text ← IO.FS.readFile path
  parseHeaderFromString text path.toString

/-- Gets the name `Foo` in `import Foo`. -/
def importId : TSyntax ``Parser.Module.import → Name
  | `(Parser.Module.import| import $id) => id.getId
  | stx => panic! s!"unexpected syntax {stx}"

/-- Analyze and report issues from module `i`. Arguments:

* `s`: The main state (contains all the modules and dependency information)
* `srcSearchPath`: Used to find the path for error reporting purposes
* `ignoreImps`: if `j ∈ ignoreImps` then it will be treated as used
* `i`: the module index
* `needs`: this is the same as `s.needs[i]`, except that this array may not
  be initialized if `downstream` mode is disabled so we pass it in here
* `edits`: accumulates the list of edits to apply if `--fix` is true
* `downstream`: if true, then we report downstream files that need to be fixed too
-/
def visitModule (s : State) (srcSearchPath : SearchPath) (ignoreImps : Bitset)
    (i : Nat) (needs : Bitset) (edits : Edits)
    (downstream := true) (githubStyle := false) (explain := false) : IO Edits := do
  -- Do transitive reduction of `needs` in `deps` and transitive closure in `transDeps`.
  -- Include the `ignoreImps` in `transDeps`
  let mut deps := needs
  let mut transDeps := needs ||| ignoreImps
  for j in [0:s.mods.size] do
    if deps &&& (1 <<< j) != 0 then
      let deps2 := s.transDeps[j]!
      deps := deps ^^^ (deps &&& deps2) ^^^ (1 <<< j)
      transDeps := transDeps ||| deps2

  -- Any import which is not in `transDeps` was unused.
  -- Also accumulate `newDeps` which is the transitive closure of the remaining imports
  let mut toRemove := #[]
  let mut newDeps := 0
  for imp in s.mods[i]!.imports do
    let j := s.toIdx[imp.module]!
    if transDeps &&& (1 <<< j.toNat) == 0 then
      toRemove := toRemove.push j
    else
      newDeps := newDeps ||| s.transDeps[j]!

  if toRemove.isEmpty then return edits -- nothing to do

  -- If `newDeps` does not cover `needs`, then we have to add back some imports until it does.
  -- To minimize new imports we pick only new imports which are not transitively implied by
  -- another new import
  let mut toAdd := #[]
  for j in [0:s.mods.size] do
    if deps &&& (1 <<< j) != 0 && newDeps &&& (1 <<< j) == 0 then
      toAdd := toAdd.push j
      newDeps := newDeps ||| s.transDeps[j]!

  -- mark and report the removals
  let mut edits := toRemove.foldl (init := edits) fun edits n =>
    edits.remove s.modNames[i]! s.modNames[n]!
  if githubStyle then
    try
      let (path, inputCtx, imports, endHeader) ← parseHeader srcSearchPath s.modNames[i]!
      for stx in imports do
        if toRemove.any fun i => s.modNames[i]! == importId stx then
          let pos := inputCtx.fileMap.toPosition stx.raw.getPos?.get!
          println! "{path}:{pos.line}:{pos.column+1}: warning: unused import \
            (use `lake exe shake --fix` to fix this, or `lake exe shake --update` to ignore)"
      if !toAdd.isEmpty then
        -- we put the insert message on the beginning of the last import line
        let pos := inputCtx.fileMap.toPosition endHeader
        println! "{path}:{pos.line-1}:1: warning: \
          import {toAdd.map (s.modNames[·]!)} instead"
    catch _ => pure ()
  if let some path ← srcSearchPath.findModuleWithExt "lean" s.modNames[i]! then
    println! "{path}:"
  else
    println! "{s.modNames[i]!}:"
  println! "  remove {toRemove.map (s.modNames[·]!)}"

  -- mark and report the additions
  if !toAdd.isEmpty then
    edits := toAdd.foldl (init := edits) fun edits n =>
      edits.add s.modNames[i]! n
    println! "  add {toAdd.map (s.modNames[·]!)}"

  if downstream && !toRemove.isEmpty then
    -- In `downstream` mode, we should also check all the other modules to find out if
    -- we have a situation like `A -> B -/> C -> D`, where we are removing the `B -> C` import
    -- but `D` depends on `A` and only directly imports `C`.
    -- This situation occurs when `A ∈ needs[D]`, `C ∈ transDeps[D]`, and `A ∉ newTransDeps[D]`,
    -- where `newTransDeps` is the result of recalculating `transDeps` after breaking the `B -> C`
    -- link.

    -- calculate `newTransDeps[C]`, removing all `B -> C` links from `toRemove` and adding `toAdd`
    let mut newTransDepsI := 1 <<< i
    for j in s.deps[i]! do
      if !toRemove.contains j then
        newTransDepsI := newTransDepsI ||| s.transDeps[j]!
    for j in toAdd do
      newTransDepsI := newTransDepsI ||| s.transDeps[j]!

    let mut newTransDeps := s.transDeps.set! i newTransDepsI -- deep copy
    let mut reAdded := #[]
    for j in [i+1:s.mods.size] do -- for each module `D`
      if s.transDeps[j]! &&& (1 <<< i) != 0 then -- which imports `C`
        -- calculate `newTransDeps[D]` assuming no change to the imports of `D`
        let mut newTransDepsJ := s.deps[j]!.foldl (init := 1 <<< j) fun d k =>
          d ||| newTransDeps[k]!
        let diff := s.transDeps[j]! ^^^ newTransDepsJ
        if diff != 0 then -- if the dependency closure of `D` changed
          let mut reAdd := diff &&& s.needs[j]!
          if reAdd != 0 then -- and there are things from `needs[D]` which were lost:
            -- Add them back.
            -- `reAdd` is the set of all files `A` which have to be added back
            -- to the closure of `D`, but some of them might be importing others,
            -- so we take the transitive reduction of `reAdd`.
            let mut reAddArr := []
            let mut k := j
            while reAdd != 0 do -- note: this loop terminates because `reAdd ⊆ [0:k]`
              k := k - 1
              if reAdd &&& (1 <<< k) != 0 then
                reAddArr := k :: reAddArr
                reAdd := reAdd ^^^ (reAdd &&& newTransDeps[k]!)
                -- add these to `newTransDeps[D]` so that files downstream of `D`
                -- (later in the `for j` loop) will take this into account
                newTransDepsJ := newTransDepsJ ||| newTransDeps[k]!
            edits := reAddArr.foldl (init := edits) (·.add s.modNames[j]! ·)
            reAdded := reAdded.push (j, reAddArr)
          newTransDeps := newTransDeps.set! j newTransDepsJ
    if !reAdded.isEmpty then
      println! "  instead"
      for (j, reAddArr) in reAdded do
        println! "    import {reAddArr.map (s.modNames[·]!)} in {s.modNames[j]!}"

  if explain then
    let explanation := getExplanations s.constToIdx s.mods[i]!
    let sanitize n := if n.hasMacroScopes then (sanitizeName n).run' { options := {} } else n
    let run (j : USize) := do
      if let some (n, c) := explanation[j]? then
        println! "  note: {s.modNames[i]!} requires {s.modNames[j]!}\
          \n    because {sanitize n} refers to {sanitize c}"
    for imp in s.mods[i]!.imports do run <| s.toIdx[imp.module]!
    for i in toAdd do run i.toUSize

  return edits

/-- Convert a list of module names to a bitset of module indexes -/
def toBitset (s : State) (ns : List Name) : Bitset :=
  ns.foldl (init := 0) fun c name =>
    match s.toIdx[name]? with
    | some i => c ||| (1 <<< i.toNat)
    | none => c

/-- The parsed CLI arguments. See `help` for more information -/
structure Args where
  /-- `--help`: shows the help -/
  help : Bool := false
  /-- `--force`: skips the `lake build --no-build` sanity check -/
  force : Bool := false
  /-- `--no-downstream`: disables downstream mode -/
  downstream : Bool := true
  /-- `--gh-style`: output messages that can be parsed by `gh-problem-matcher-wrap` -/
  githubStyle : Bool := false
  /-- `--explain`: give constants explaining why each module is needed -/
  explain : Bool := false
  /-- `--fix`: apply the fixes directly -/
  fix : Bool := false
  /-- `--update`: update the config file -/
  update : Bool := false
  /-- `--global`: with `--update`, add imports to `ignoreImport` instead of `ignore` -/
  global : Bool := false
  /-- `--cfg FILE`: choose a custom location for the config file -/
  cfg : Option String := none
  /-- `<MODULE>..`: the list of root modules to check -/
  mods : Array Name := #[]

instance {α} [FromJson α] : FromJson (NameMap α) where
  fromJson? j := do
    (← j.getObj?).foldM (init := mkNameMap _) fun m a b => do
      m.insert a.toName <$> fromJson? b
instance {α} [ToJson α] : ToJson (NameMap α) where
  toJson m := Json.obj <| m.fold (init := ∅) fun m a b =>
      m.insert compare (toString a) (toJson b)

/-- The config file format, which we both read and write. -/
structure ShakeCfg where
  /-- All imports from modules in this list will be ignored -/
  ignoreAll? : Option (List Name) := none
  /-- The modules in this list will be ignored as imports of any other file -/
  ignoreImport? : Option (List Name) := [`Init, `Lean]
  /-- If `X` maps to `Y` then an import of `Y` in module `X` will be ignored -/
  ignore? : Option (NameMap (Array Name)) := none
  deriving FromJson, ToJson

/-- The main entry point. See `help` for more information on arguments. -/
def main (args : List String) : IO UInt32 := do
  initSearchPath (← findSysroot)
  -- Parse the arguments
  let rec parseArgs (args : Args) : List String → Args
    | [] => args
    | "--help" :: rest => parseArgs { args with help := true } rest
    | "--force" :: rest => parseArgs { args with force := true } rest
    | "--no-downstream" :: rest => parseArgs { args with downstream := false } rest
    | "--fix" :: rest => parseArgs { args with fix := true } rest
    | "--explain" :: rest => parseArgs { args with explain := true } rest
    | "--gh-style" :: rest => parseArgs { args with githubStyle := true } rest
    | "--update" :: rest => parseArgs { args with update := true } rest
    | "--global" :: rest => parseArgs { args with global := true } rest
    | "--cfg" :: cfg :: rest => parseArgs { args with cfg := cfg } rest
    | "--" :: rest => { args with mods := args.mods ++ rest.map (·.toName) }
    | other :: rest => parseArgs { args with mods := args.mods.push other.toName } rest
  let args := parseArgs {} args

  -- Bail if `--help` is passed
  if args.help then
    IO.println help
    IO.Process.exit 0

  if !args.force then
    if (← IO.Process.output { cmd := "lake", args := #["build", "--no-build"] }).exitCode != 0 then
      IO.println "There are out of date oleans. Run `lake build` or `lake exe cache get` first"
      IO.Process.exit 1

  -- Determine default module(s) to run shake on
  let defaultTargetModules : Array Name ← try
    let (elanInstall?, leanInstall?, lakeInstall?) ← Lake.findInstall?
    let config ← Lake.MonadError.runEIO <| Lake.mkLoadConfig { elanInstall?, leanInstall?, lakeInstall? }
    let some workspace ← Lake.loadWorkspace config |>.toBaseIO
      | throw <| IO.userError "failed to load Lake workspace"
    let defaultTargetModules := workspace.root.defaultTargets.flatMap fun target =>
      if let some lib := workspace.root.findLeanLib? target then
        lib.roots
      else if let some exe := workspace.root.findLeanExe? target then
        #[exe.config.root]
      else
        #[]
    pure defaultTargetModules
  catch _ =>
    pure #[]

  -- Parse the `--cfg` argument
  let srcSearchPath ← getSrcSearchPath
  let cfgFile ← if let some cfg := args.cfg then
    pure (some ⟨cfg⟩)
  else if let some mod := defaultTargetModules[0]? then
    if let some path ← srcSearchPath.findModuleWithExt "lean" mod then
      pure (some (path.parent.get! / "scripts" / "noshake.json"))
    else
      pure none
  else pure none

  -- Read the config file
  -- `isValidCfgFile` is `false` if and only if the config file is present and invalid.
  let (cfg, isValidCfgFile) ← if let some file := cfgFile then
    try
      pure (← IO.ofExcept (Json.parse (← IO.FS.readFile file) >>= fromJson? (α := ShakeCfg)), true)
    catch e =>
      -- The `cfgFile` is invalid, so we print the error and return `isValidCfgFile = false`.
      println! "{e.toString}"
      pure ({}, false)
    else pure ({}, true)
  if !isValidCfgFile then
    IO.println s!"Invalid config file '{cfgFile.get!}'"
    IO.Process.exit 1
  else
  -- the list of root modules
  let mods := if args.mods.isEmpty then defaultTargetModules else args.mods
  -- Only submodules of `pkg` will be edited or have info reported on them
  let pkg := mods[0]!.components.head!

  -- Load all the modules
  let mut (_, s) ← (loadModules (mods.map ({module := ·}))).run {}

  -- Parse the config file
  let ignoreMods := toBitset s (cfg.ignoreAll?.getD [])
  let ignoreImps := toBitset s (cfg.ignoreImport?.getD [])
  let ignore := (cfg.ignore?.getD {}).fold (init := (∅ : Std.HashMap _ _)) fun m a v =>
    m.insert a (toBitset s v.toList)

  let noIgnore (i : Nat) :=
    !s.mods[i]!.constNames.isEmpty && -- skip import-only mods
    ignoreMods &&& (1 <<< i) == 0 &&
    pkg.isPrefixOf s.modNames[i]!

  -- Run the calculation of the `needs` array in parallel
  let needs := s.mods.mapIdx fun i mod =>
    if args.downstream || noIgnore i then
      some <| Task.spawn fun _ =>
        -- remove the module from its own `needs`
        (calcNeeds s.constToIdx mod ||| (1 <<< i)) ^^^ (1 <<< i)
    else
      none
  if args.downstream then
    s := { s with needs := needs.map (·.get!.get) }

  if args.fix then
    println! "The following changes will be made automatically:"

  -- Check all selected modules
  let mut edits : Edits := ∅
  for i in [0:s.mods.size], t in needs do
    if let some t := t then
      if noIgnore i then
        let ignoreImps := ignoreImps ||| ignore.getD s.modNames[i]! 0
        edits ← visitModule s srcSearchPath ignoreImps i t.get edits
          args.downstream args.githubStyle args.explain

  -- Write the config file
  if args.update then
    if let some cfgFile := cfgFile then
      let mut ignore := cfg.ignore?.getD {}
      let ignoreImport := cfg.ignoreImport?.getD {}
      let mut ignoreImportSet : NameSet := ignoreImport.foldl .insert {}
      -- if `args.fix` is true then we assume the errors will be fixed after,
      -- so it's just reformatting the existing file
      if !args.fix then
        if args.global then
          -- in global mode all the edits are added to `ignoreImport`
          ignoreImportSet := edits.fold (init := ignoreImportSet)
            (fun ignore _ (remove, _) => ignore.union remove)
        else
          -- in local mode all the edits are added to `ignore`
          ignore := edits.fold (init := ignore) fun ignore mod (remove, _) =>
            let ns := (ignore.findD mod #[]).foldl (init := remove) (·.insert ·)
            if ns.isEmpty then ignore.erase mod else
              ignore.insert mod ns.toArray
      -- If an entry is in `ignoreAll`, the `ignore` key is redundant
      for i in cfg.ignoreAll?.getD {} do
        if ignore.contains i then
          ignore := ignore.erase i
      -- If an entry is in `ignoreImport`, the `ignore` value is redundant
      ignore := ignore.fold (init := {}) fun ignore mod ns =>
        let ns := ns.filter (!ignoreImportSet.contains ·)
        if ns.isEmpty then ignore else ignore.insert mod (ns.qsort (·.toString < ·.toString))
      -- Sort the lists alphabetically
      let ignoreImport := (ignoreImportSet.toArray.qsort (·.toString < ·.toString)).toList
      let cfg : ShakeCfg := {
        ignoreAll? := cfg.ignoreAll?.filter (!·.isEmpty)
        ignoreImport? := (some ignoreImport).filter (!·.isEmpty)
        ignore? := (some ignore).filter (!·.isEmpty)
      }
      IO.FS.writeFile cfgFile <| toJson cfg |>.pretty.push '\n'

  if !args.fix then
    -- return error if any issues were found
    return if edits.isEmpty then 0 else 1

  -- Apply the edits to existing files
  let count ← edits.foldM (init := 0) fun count mod (remove, add) => do
    -- Only edit files in the current package
    if !pkg.isPrefixOf mod then
      return count
    -- Compute the transitive reduction of `add` and convert to a list of names
    let add := if add == 0 then #[] else Id.run do
      let mut val := add
      for i in [0:s.mods.size] do
        if val &&& (1 <<< i) != 0 then
          val := val ^^^ (val &&& s.transDeps[i]!) ^^^ (1 <<< i)
      let mut out := #[]
      for i in [0:s.mods.size] do
        if val &&& (1 <<< i) != 0 then
          out := out.push s.modNames[i]!
      out.qsort Name.lt

    -- Parse the input file
    let (path, inputCtx, imports, insertion) ←
      try parseHeader srcSearchPath mod
      catch e => println! e.toString; return count
    let text := inputCtx.input

    -- Calculate the edit result
    let mut pos : String.Pos := 0
    let mut out : String := ""
    let mut seen : NameSet := {}
    for stx in imports do
      let mod := importId stx
      if remove.contains mod || seen.contains mod then
        out := out ++ text.extract pos stx.raw.getPos?.get!
        -- We use the end position of the syntax, but include whitespace up to the first newline
        pos := text.findAux (· == '\n') text.endPos stx.raw.getTailPos?.get! + ⟨1⟩
      seen := seen.insert mod
    out := out ++ text.extract pos insertion
    for mod in add do
      if !seen.contains mod then
        seen := seen.insert mod
        out := out ++ s!"import {mod}\n"
    out := out ++ text.extract insertion text.endPos

    IO.FS.writeFile path out
    return count + 1

  -- Since we throw an error upon encountering issues, we can be sure that everything worked
  -- if we reach this point of the script.
  if count > 0 then
    println! "Successfully applied {count} suggestions."
  else
    println! "No edits required."
  return 0

-- self-test so that future grammar changes cause a build failure
/-- info: #[`Lake.CLI.Main] -/
#guard_msgs (whitespace := lax) in
#eval show MetaM _ from do
  let (_, _, imports, _) ← parseHeaderFromString (← getFileMap).source (← getFileName)
  return imports.map importId



=== LEAN SOURCE: Cli.lean ===
import Cli.Basic
import Cli.Extensions



=== LEAN SOURCE: Basic.lean ===
import Lean.Data.RBTree

namespace Cli

section Utils
  /--
  Matches the lengths of lists `a` and `b` by filling the shorter one with
  `unit` elements at the tail end. The matched lists are returned in the same order
  as they were passed.
  -/
  def List.matchLength (a : List α) (b : List α) (unit : α) : List α × List α :=
    if a.length < b.length then
      (a ++ .replicate (b.length - a.length) unit, b)
    else
      (a, b ++ .replicate (a.length - b.length) unit)

  namespace Array
    def join (xss : Array (Array α)) : Array α := Id.run do
      let mut r := #[]
      for xs in xss do
        r := r ++ xs
      return r

    def flatMap (f : α → Array β) (xs : Array α) : Array β :=
      join (xs.map f)
  end Array

  namespace String
    /--
    Inserts newlines `\n` into `s` after every `maxWidth` characters so that the result
    contains no line longer than `maxWidth` characters. Retains newlines `\n` in `s`.
    Yields `none` if `maxWidth = 0`.
    -/
    def wrapAt? (s : String) (maxWidth : Nat) : Option String := Id.run do
      if maxWidth = 0 then
        return none
      let lines := s.splitOn "\n" |>.map fun line => Id.run do
        let resultLineCount :=
          if line.length % maxWidth = 0 then
            line.length / maxWidth
          else
            line.length / maxWidth + 1
        let mut line := line
        let mut result := #[]
        for _ in [:resultLineCount] do
          result := result.push <| line.take maxWidth
          line := line.drop maxWidth
        return "\n".intercalate result.toList
      return "\n".intercalate lines

    /--
    Inserts newlines `\n` into `s` after every `maxWidth` characters so that the result
    contains no line longer than `maxWidth` characters. Retains newlines `\n` in `s`.
    Panics if `maxWidth = 0`.
    -/
    def wrapAt! (s : String) (maxWidth : Nat) : String :=
      wrapAt? s maxWidth |>.get!

    /--
    Deletes all trailing spaces at the end of every line, as seperated by `\n`.
    -/
    def trimTrailingSpaces (s : String) : String :=
      s.splitOn "\n" |>.map (·.dropRightWhile (· = ' ')) |> "\n".intercalate

    /--
    Inserts newlines `\n` into `s` after every `maxWidth` characters before words
    that would otherwise be broken apart by the newline. The result will contain
    no line longer than `maxWidth` characters and no words except those already
    longer than `maxWidth` characters will be broken up in the middle.
    Removes trailing whitespace before each inserted newline. Retains newlines `\n` in `s`.
    Returns `none` if `maxWidth = 0`.
    -/
    def wrapWordsAt? (s : String) (maxWidth : Nat) : Option String := Id.run do
      if maxWidth = 0 then
        return none
      let wordWrappedLines : List String := s.splitOn "\n" |>.map fun s => Id.run do
        let words                : Array String := s.splitOn.toArray
        let mut currentLineWidth : Nat          := 0
        let mut result           : Array String := #[]
        for i in [:words.size] do
          let w := words[i]!
          -- `w = ""`: we will never insert a newline on a space. this has the effect
          -- of inserting the newline only after a bunch of trailing whitespace, which we remove later.
          -- similarly, `currentLineWidth + w.length ≤ maxWidth` does not count the space after `w` so that
          -- we do not insert a newline before a word that fits except for a trailing space.
          if w = "" ∨ currentLineWidth + w.length ≤ maxWidth then
            -- `+ 1` because we count the space after `w` to accurately keep track of spaces.
            currentLineWidth := currentLineWidth + w.length + 1
            result := result.push w
            continue
          -- if `w` is the first proper word, this will insert a `\n` before the text, which we remove later.
          -- `w.wrapAt! maxWidth` ensures that our new line is not already too large.
          let wordOnNewLine := "\n" ++ wrapAt! w maxWidth
          result := result.push wordOnNewLine
          let wrappedLines : Array String := wordOnNewLine.splitOn "\n" |>.toArray
          currentLineWidth := wrappedLines[wrappedLines.size - 1]!.length + 1
        return " ".intercalate result.toList
      let trimmed : List String :=
        wordWrappedLines.map trimTrailingSpaces |>.map fun line => Id.run do
          if line = "" then
            return ""
          if line.get! 0 ≠ '\n' then
            return line
          return line.drop 1
      return "\n".intercalate trimmed

    /--
    Inserts newlines `\n` into `s` after every `maxWidth` characters before words
    that would otherwise be broken apart by the newline. The result will contain
    no line longer than `maxWidth` characters and no words except those already
    longer than `maxWidth` characters will be broken up in the middle.
    Removes trailing whitespace before each inserted newline. Retains newlines `\n` in `s`.
    Panics if `maxWidth = 0`.
    -/
    def wrapWordsAt! (s : String) (maxWidth : Nat) : String :=
      wrapWordsAt? s maxWidth |>.get!

    /--
    Inserts `n` spaces before each line as seperated by `\n` in `s`.
    Does not indent `s = ""`.
    -/
    def indent (s : String) (n : Nat := 4) : String := Id.run do
      if s = "" then
        return ""
      return s.splitOn "\n" |>.map ("".pushn ' ' n ++ ·) |> "\n".intercalate

    /--
    Intercalates elements `≠ ""` in `xs` using `sep`.
    -/
    def optJoin (xs : Array String) (sep : String) : String :=
      xs.filter (· ≠ "") |>.toList |> sep.intercalate
  end String

  namespace Array
    /--
    Renders `rows` as a table with a maximum row width of `maxWidth` and a margin of `margin`
    between the columns. Wraps words according to `String.wrapWordsAt?` to ensure that no
    rendered row of the table is longer than `maxWidth`.
    Returns `none` if `(maxWidth-margin)/2` < 1, i.e. if there is not enough space for
    text in both columns.
    -/
    def renderTable? (rows : Array (String × String)) (maxWidth : Nat) (margin : Nat := 2)
      : Option String := Id.run do
      if rows.isEmpty then
        return ""
      let rightColumnWidth := rows.map (·.2.length) |>.getMax? (· < ·) |>.get!
      let minRightColumnWidth := Nat.min rightColumnWidth <| Nat.max ((maxWidth-margin)/2) 1
      if maxWidth - margin - minRightColumnWidth < 1 then
        return none
      let rows : Array (List String × String) := rows.map fun (left, right) =>
        (maxWidth - margin - minRightColumnWidth |> String.wrapWordsAt! left |>.splitOn "\n", right)
      let leftColumnWidth :=
        flatMap (·.1.map (·.length) |>.toArray) rows
          |>.getMax? (· < ·)
          |>.get!
      let leftColumnWidth := leftColumnWidth + margin
      let rows : Array (List String × List String) := rows.map fun (left, right) =>
        (left, maxWidth - leftColumnWidth |> String.wrapWordsAt! right |>.splitOn "\n")
      let rows : Array (String × String) := flatMap (xs := rows) fun (left, right) =>
        let (left, right) : List String × List String := List.matchLength left right ""
        left.zip right |>.toArray
      let rows : Array String := rows.map fun (left, right) =>
        if right = "" then
          left
        else
          let padding := "".pushn ' ' (leftColumnWidth - left.length)
          left ++ padding ++ right
      return "\n".intercalate rows.toList

    /--
    Renders `rows` as a table with a maximum row width of `maxWidth` and a margin of `margin`
    between the columns. Wraps words according to `String.wrapWordsAt?` to ensure that no
    rendered row of the table is longer than `maxWidth`.
    Panics if `(maxWidth-margin)/2` < 1, i.e. if there is not enough space for
    text in both columns.
    -/
    def renderTable! (rows : Array (String × String)) (maxWidth : Nat) (margin : Nat := 2)
      : String :=
      renderTable? rows maxWidth margin |>.get!
  end Array

  namespace Option
    def join (x : Option (Option α)) : Option α := do ←x

    /--
    Returns `""` if the passed `Option` is `none`, otherwise
    converts the contained value using a `ToString` instance.
    -/
    def optStr [ToString α] : Option α → String
      | none   => ""
      | some v => toString v
  end Option
end Utils

section Configuration
  /--
  Represents a type that can be parsed to a string and the corresponding name of the type.
  Used for converting parsed user input to the respective expected type.
  -/
  class ParseableType (τ) where
    /-- Name of the type, used when displaying the help. -/
    name   : String
    /-- Function to parse a value to the type that returns `none` if it cannot be parsed. -/
    parse? : String → Option τ

  instance : ParseableType Unit where
    name     := "Unit"
    parse? _ := ()

  instance : ParseableType Bool where
    name := "Bool"
    parse?
    | "true"  => true
    | "false" => false
    | _       => none

  instance : ParseableType String where
    name     := "String"
    parse? s := s

  instance : ParseableType Nat where
    name := "Nat"
    parse?
      -- HACK: temporary workaround for minor bug in String.toNat?
      | "" => none
      | s  => s.toNat?

  instance : ParseableType Int where
    name := "Int"
    parse?
      -- HACK: temporary workaround for minor bug in String.toInt?
      | "" => none
      | s  => s.toInt?

  /-- A type synonym for `Name`, which will carry a `ParseableType ModuleName`
  instance, supporting parsing either a module name (e.g. `Mathlib.Topology.Basic`)
  or a relative path to a Lean file (e.g. `Mathlib/Topology/Basic.lean`). -/
  def ModuleName := Lean.Name
    deriving Inhabited, BEq, Repr, ToString

  /-- Check that a `ModuleName` has no `.num` or empty components, and is not `.anonymous`. -/
  def ModuleName.isValid : ModuleName → Bool
    | .anonymous => false
    | m          => loop m true
  where
    loop : ModuleName → Bool → Bool
      | .anonymous, allValid => allValid
      | .str pre s, allValid => loop pre <| allValid ∧ ¬s.isEmpty
      | .num ..,    _        => false

  open Lean System in
  /-- A custom command-line argument parser that allows either relative paths to Lean files,
  (e.g. `Mathlib/Topology/Basic.lean`) or the module name (e.g. `Mathlib.Topology.Basic`). -/
  instance : ParseableType ModuleName where
    name     := "ModuleName"
    parse? s := do
      if s == ".lean" then
        none
      let name :=
        if s.endsWith ".lean" then
          let pathComponents := (s : FilePath).withExtension "" |>.components
          pathComponents.foldl .mkStr .anonymous
        else
          s.toName
      guard <| ModuleName.isValid name
      return name

  instance [inst : ParseableType α] : ParseableType (Array α) where
    name :=
      if inst.name.contains ' ' then
        s!"Array ({inst.name})"
      else
        s!"Array {inst.name}"
    parse?
    | "" => some #[]
    | s  => do return (← s.splitOn "," |>.mapM inst.parse?).toArray

  /--
  Represents the type of some flag or argument parameter. Typically coerced from types with
  `ParseableType` instances such that `isValid := (ParseableType.parse? · |>.isSome)`.
  -/
  structure ParamType where
    /-- Name of the type, used when displaying the help. -/
    name    : String
    /-- Function to check whether a value conforms to the type. -/
    isValid : String → Bool
    deriving Inhabited

  instance : BEq ParamType where
    beq a b := a.name == b.name

  instance : Repr ParamType where
    reprPrec p _ := p.name

  instance [inst : ParseableType τ] : CoeDep Type τ ParamType where
    coe := ⟨inst.name, (inst.parse? · |>.isSome)⟩

  /--
  Represents a flag, usually known as "option" in standard terminology.
  -/
  structure Flag where
    /-- Designates `x` in `-x`. -/
    shortName?  : Option String := none
    /-- Designates `x` in `--x`. -/
    longName    : String
    /-- Description that is displayed in the help. -/
    description : String
    /--
    Type according to which the parameter is validated.
    `Unit` is used to designate flags without a parameter.
    -/
    type        : ParamType
    deriving Inhabited, BEq, Repr

  namespace Flag
    /--
    Initializes a flag without a parameter. Parameterless flags are
    designated by the `Unit` type.
    - `shortName?`:  Designates `x` in `-x`.
    - `longName`:    Designates `x` in `--x`.
    - `description`: Description that is displayed in the help.
    -/
    def paramless
      (shortName?  : Option String := none)
      (longName    : String)
      (description : String)
      : Flag := {
        shortName?  := shortName?
        longName    := longName
        description := description
        type        := Unit
      }

    /-- Designates `x` in `-x`. -/
    def shortName!   (f : Flag) : String := f.shortName?.get!
    /-- Checks whether `f` has an associated short flag name `x` in `-x`. -/
    def hasShortName (f : Flag) : Bool   := f.shortName?.isSome

    /-- Checks whether `f` has a `Unit` type. -/
    def isParamless  (f : Flag) : Bool := f.type == Unit
  end Flag

  /--
  Represents an argument (either positional or variable),
  usually known as "operand" in standard terminology
  -/
  structure Arg where
    /- Name that is displayed in the help. -/
    name        : String
    /- Description that is displayed in the help. -/
    description : String
    /- Description that is displayed in the help. -/
    type        : ParamType
    deriving Inhabited, BEq, Repr

  namespace Parsed
    /--
    Represents a flag and its parsed value.
    Use `Parsed.Flag.as!` to convert the value to some `ParseableType`.
    -/
    structure Flag where
      /-- Associated flag meta-data. -/
      flag  : Cli.Flag
      /-- Parsed value that was validated and conforms to `flag.type`. -/
      value : String
      deriving Inhabited, BEq, Repr

    instance : ToString Flag where
      toString f := s!"--{f.flag.longName}" ++ (if f.value ≠ "" then s!"={f.value}" else "")

    namespace Flag
      /--
      Converts `f.value` to `τ`, which should be the same type
      that was designated in `f.flag.type`.
      Yields `none` if the conversion was unsuccessful, which can only
      happen if `τ` is not the same type as the one designated in `f.flag.type`.
      -/
      def as? (f : Flag) (τ) [ParseableType τ] : Option τ :=
        ParseableType.parse? f.value
      /--
      Converts `f.value` to `τ`, which should be the same type
      that was designated in `f.flag.type`.
      Panics if the conversion was unsuccessful, which can only
      happen if `τ` is not the same type as the one designated in `f.flag.type`.
      -/
      def as! (f : Flag) (τ) [Inhabited τ] [ParseableType τ] : τ :=
        f.as? τ |>.get!
    end Flag

    /--
    Represents an argument and its parsed value.
    Use `Parsed.Arg.as!` to convert the value to some `ParseableType`.
    -/
    structure Arg where
      /-- Associated argument meta-data. -/
      arg   : Cli.Arg
      /-- Parsed value that was validated and conforms to `arg.type`. -/
      value : String
      deriving Inhabited, BEq, Repr

    instance : ToString Arg where
      toString a := s!"<{a.arg.name}={a.value}>"

    namespace Arg
      /--
      Converts `a.value` to `τ`, which should be the same type
      that was designated in `a.arg.type`.
      Yields `none` if the conversion was unsuccessful, which can only
      happen if `τ` is not the same type as the one designated in `a.arg.type`.
      -/
      def as? (a : Arg) (τ) [ParseableType τ] : Option τ :=
        ParseableType.parse? a.value
      /--
      Converts `a.value` to `τ`, which should be the same type
      that was designated in `a.arg.type`.
      Panics if the conversion was unsuccessful, which can only
      happen if `τ` is not the same type as the one designated in `a.arg.type`.
      -/
      def as! (a : Arg) (τ) [Inhabited τ] [ParseableType τ] : τ :=
        a.as? τ |>.get!
    end Arg
  end Parsed

  /-- Represents all the non-recursive meta-data of a command. -/
  structure Cmd.Meta where
    /-- Name that is displayed in the help. -/
    name                : String
    /--
    Names of the commands of which this command is a subcommand.
    Corresponds to the path from the root to this command.
    -/
    parentNames         : Array String
    /-- Version of the command that is displayed in the help and when the version is queried. -/
    version?            : Option String
    /-- Description that is displayed in the help. -/
    description         : String
    /-- Information appended to the end of the help. Useful for command extensions. -/
    furtherInformation? : Option String := none
    /-- Supported flags ("options" in standard terminology). -/
    flags               : Array Flag
    /-- Supported positional arguments ("operands" in standard terminology). -/
    positionalArgs      : Array Arg
    /-- Variable argument after the end of the positional arguments. -/
    variableArg?        : Option Arg
    deriving Inhabited, BEq, Repr

  namespace Cmd.Meta
    /-- Full name from the root to this command, including the name of the command itself. -/
    def fullName (m : Meta) : String := m.parentNames.push m.name |>.toList |> " ".intercalate

    /-- Version of the command that is displayed in the help and when the version is queried. -/
    def version!            (m : Meta) : String := m.version?.get!
    /-- Information appended to the end of the help. Useful for command extensions. -/
    def furtherInformation! (m : Meta) : String := m.furtherInformation?.get!
    /-- Variable argument after the end of the positional arguments. -/
    def variableArg!        (m : Meta) : Arg    := m.variableArg?.get!

    /-- Checks whether `m` has a version. -/
    def hasVersion            (m : Meta) : Bool := m.version?.isSome
    /-- Checks whether `m` has information appended to the end of the help. -/
    def hasFurtherInformation (m : Meta) : Bool := m.furtherInformation?.isSome
    /-- Checks whether `m` supports a variable argument. -/
    def hasVariableArg        (m : Meta) : Bool := m.variableArg?.isSome

    /-- Finds the flag in `m` with the corresponding `longName`. -/
    def flag?          (m : Meta) (longName : String) : Option Flag   := m.flags.find? (·.longName = longName)
    /-- Finds the positional argument in `m` with the corresponding `name`. -/
    def positionalArg? (m : Meta) (name     : String) : Option Arg    := m.positionalArgs.find? (·.name = name)

    /-- Finds the flag in `m` with the corresponding `longName`. -/
    def flag!          (m : Meta) (longName : String) : Flag   := m.flag? longName |>.get!
    /-- Finds the positional argument in `m` with the corresponding `name`. -/
    def positionalArg! (m : Meta) (name     : String) : Arg    := m.positionalArg? name |>.get!

    /-- Checks whether `m` contains a flag with the corresponding `longName`. -/
    def hasFlag          (m : Meta) (longName : String) : Bool := m.flag? longName |>.isSome
    /-- Checks whether `m` contains a positional argument with the corresponding `name`. -/
    def hasPositionalArg (m : Meta) (name     : String) : Bool := m.positionalArg? name |>.isSome

    /-- Finds the flag in `m` with the corresponding `shortName`. -/
    def flagByShortName? (m : Meta) (name : String) : Option Flag :=
      m.flags.findSome? fun flag => do
        let shortName ← flag.shortName?
        guard <| shortName = name
        return flag

    /-- Finds the flag in `m` with the corresponding `shortName`. -/
    def flagByShortName! (m : Meta) (name : String) : Flag := m.flagByShortName? name |>.get!

    /-- Checks whether `m` has a flag with the corresponding `shortName`. -/
    def hasFlagByShortName (m : Meta) (name : String) : Bool := m.flagByShortName? name |>.isSome

    /--
    Adds help (`-h, --help`) and version (`--version`) flags to `m`. Does not add
    a version flag if `m` does not designate a version.
    -/
    def addHelpAndVersionFlags (m : Meta) : Meta := Id.run do
      let helpFlag := .paramless
        (shortName?  := "h")
        (longName    := "help")
        (description := "Prints this message.")
      let mut fixedFlags := #[helpFlag]
      if m.hasVersion then
        let versionFlag := .paramless
          (longName    := "version")
          (description := "Prints the version.")
        fixedFlags := fixedFlags.push versionFlag
      { m with flags := fixedFlags ++ m.flags }
  end Cmd.Meta

  /--
  Represents a recursive variant of `Cmd.Meta` that is used in `Parsed`
  to replicate the recursive subcommand structure of a command
  without referring to the command itself.
  -/
  inductive Parsed.Cmd
    | init
      («meta»  : Cmd.Meta)
      (subCmds : Array Parsed.Cmd)
    deriving Inhabited

  namespace Parsed.Cmd
    /-- Meta of this command. -/
    def «meta»  : Parsed.Cmd → Cmd.Meta         | init v _ => v
    /-- Subcommands. -/
    def subCmds : Parsed.Cmd → Array Parsed.Cmd | init _ v => v

    /-- Finds the subcommand in `c` with the corresponding `name`. -/
    def subCmd? (c : Parsed.Cmd) (name : String) : Option Parsed.Cmd := c.subCmds.find? (·.meta.name = name)

    /-- Finds the subcommand in `c` with the corresponding `name`. -/
    def subCmd! (c : Parsed.Cmd) (name : String) : Parsed.Cmd := c.subCmd? name |>.get!

    /-- Checks whether `c` contains a subcommand with the corresponding `name`. -/
    def hasSubCmd (c : Parsed.Cmd) (name : String) : Bool := c.subCmd? name |>.isSome
  end Parsed.Cmd

  /-- Represents parsed user input data. -/
  structure Parsed where
    /-- Recursive meta-data of the associated command. -/
    cmd            : Parsed.Cmd
    /-- Parent of the associated command. -/
    parent?        : Option Parsed.Cmd
    /-- Parsed flags. -/
    flags          : Array Parsed.Flag
    /-- Parsed positional arguments. -/
    positionalArgs : Array Parsed.Arg
    /-- Parsed variable arguments. -/
    variableArgs   : Array Parsed.Arg
    deriving Inhabited

  namespace Parsed
    /-- Parent of the associated command. -/
    def parent! (p : Parsed) : Parsed.Cmd := p.parent?.get!

    /-- Checks whether the associated command has a parent, i.e. whether it is not the root command. -/
    def hasParent (p : Parsed) : Bool := p.parent?.isSome

    /-- Finds the parsed flag in `p` with the corresponding `longName`. -/
    def flag?          (p : Parsed) (longName : String) : Option Flag := p.flags.find? (·.flag.longName = longName)
    /-- Finds the parsed positional argument in `p` with the corresponding `name`. -/
    def positionalArg? (p : Parsed) (name     : String) : Option Arg  := p.positionalArgs.find? (·.arg.name = name)

    /-- Finds the parsed flag in `p` with the corresponding `longName`. -/
    def flag!          (p : Parsed) (longName : String) : Flag := p.flag? longName |>.get!
    /-- Finds the parsed positional argument in `p` with the corresponding `name`. -/
    def positionalArg! (p : Parsed) (name     : String) : Arg  := p.positionalArg? name |>.get!

    /-- Checks whether `p` has a parsed flag with the corresponding `longName`. -/
    def hasFlag          (p : Parsed) (longName : String) : Bool := p.flag? longName |>.isSome
    /-- Checks whether `p` has a positional argument with the corresponding `longName`. -/
    def hasPositionalArg (p : Parsed) (name     : String) : Bool := p.positionalArg? name |>.isSome

    /--
    Converts all `p.variableArgs` values to `τ`, which should be the same type
    that was designated in the corresponding `Cli.Arg`.
    Yields `none` if the conversion was unsuccessful, which can only
    happen if `τ` is not the same type as the one designated in the corresponding `Cli.Arg`.
    -/
    def variableArgsAs? (p : Parsed) (τ) [ParseableType τ] : Option (Array τ) :=
      p.variableArgs.mapM (·.as? τ)

    /--
    Converts all `p.variableArgs` values to `τ`, which should be the same type
    that was designated in the corresponding `Cli.Arg`.
    Panics if the conversion was unsuccessful, which can only
    happen if `τ` is not the same type as the one designated in the corresponding `Cli.Arg`.
    -/
    def variableArgsAs! (p : Parsed) (τ) [Inhabited τ] [ParseableType τ] : Array τ :=
      p.variableArgsAs? τ |>.get!

    instance : ToString Parsed where
      toString p :=
        s!"cmd: {p.cmd.meta.fullName}; flags: {toString p.flags}; positionalArgs: {toString p.positionalArgs}; " ++
        s!"variableArgs: {toString p.variableArgs}"
  end Parsed

  open Cmd in
  /--
  Represents a view of `Cmd` that can be passed to `Extension`s, i.e. it does
  not itself reference the `Extension` provided for each `Cmd`.
  -/
  inductive ExtendableCmd
    | init
      («meta»            : Meta)
      (run               : Parsed → IO UInt32)
      (subCmds           : Array ExtendableCmd)
      (originalFullName? : Option String)
    deriving Inhabited

  namespace ExtendableCmd
    /-- Non-recursive meta-data. -/
    def         «meta»            : ExtendableCmd → Cmd.Meta             | init v _ _ _ => v
    /-- Handler to run when the command is called and flags/arguments have been successfully processed. -/
    def         run               : ExtendableCmd → (Parsed → IO UInt32) | init _ v _ _ => v
    /-- Subcommands. May be mutated by extensions. -/
    def         subCmds           : ExtendableCmd → Array ExtendableCmd  | init _ _ v _ => v
    private def originalFullName? : ExtendableCmd → Option String        | init _ _ _ v => v

    /--
    Updates the designated fields in `c`.
    - `«meta»`:  Non-recursive meta-data.
    - `run`:     Handler to run when the command is called and flags/arguments have been successfully processed.
    - `subCmds`: Subcommands.
    -/
    def update'
      (c       : ExtendableCmd)
      («meta»  : Cmd.Meta            := c.meta)
      (run     : Parsed → IO UInt32  := c.run)
      (subCmds : Array ExtendableCmd := c.subCmds)
      : ExtendableCmd :=
        .init «meta» run subCmds c.originalFullName?

    /--
    Updates the designated fields in `c`.
    - `name`:                Name that is displayed in the help.
    - `version?`:            Version that is displayed in the help and when the version is queried.
    - `description`:         Description that is displayed in the help.
    - `furtherInformation?`: Information appended to the end of the help. Useful for command extensions.
    - `flags`:               Supported flags ("options" in standard terminology).
    - `positionalArgs`:      Supported positional arguments ("operands" in standard terminology).
    - `variableArg?`:        Variable argument at the end of the positional arguments.
    - `run`:                 Handler to run when the command is called and flags/arguments have been successfully processed.
    - `subCmds`:             Subcommands.
    -/
    def update
      (c                   : ExtendableCmd)
      (name                : String              := c.meta.name)
      (version?            : Option String       := c.meta.version?)
      (description         : String              := c.meta.description)
      (furtherInformation? : Option String       := c.meta.furtherInformation?)
      (flags               : Array Flag          := c.meta.flags)
      (positionalArgs      : Array Arg           := c.meta.positionalArgs)
      (variableArg?        : Option Arg          := c.meta.variableArg?)
      (run                 : Parsed → IO UInt32  := c.run)
      (subCmds             : Array ExtendableCmd := c.subCmds)
      : ExtendableCmd :=
        .init
          ⟨name, c.meta.parentNames, version?, description, furtherInformation?, flags, positionalArgs, variableArg?⟩
          run subCmds c.originalFullName?

    /--
    Creates a new `ExtendableCmd`. The resulting `ExtendableCmd` will not have an extension.
    - `«meta»`:  Non-recursive meta-data.
    - `run`:     Handler to run when the command is called and flags/arguments have been successfully processed.
    - `subCmds`: Subcommands.
    -/
    def mk'
      («meta»  : Cmd.Meta)
      (run     : Parsed → IO UInt32)
      (subCmds : Array ExtendableCmd := #[])
      : ExtendableCmd :=
        .init «meta» run subCmds none

    /--
    Creates a new `ExtendableCmd`. The resulting `ExtendableCmd` will not have an extension.
    Adds a `-h, --help` and a `--version` flag if `«meta»` designates a version.
    - `«meta»`:  Non-recursive meta-data.
    - `run`:     Handler to run when the command is called and flags/arguments have been successfully processed.
    - `subCmds`: Subcommands.
    -/
    def mkWithHelpAndVersionFlags'
      («meta»  : Cmd.Meta)
      (run     : Parsed → IO UInt32)
      (subCmds : Array ExtendableCmd := #[])
      : ExtendableCmd :=
        .mk' meta.addHelpAndVersionFlags run subCmds

    /--
    Creates a new `ExtendableCmd`. The resulting `ExtendableCmd` will not have an extension.
    - `parent`:              Parent of this command.
    - `name`:                Name that is displayed in the help.
    - `version?`:            Version that is displayed in the help and when the version is queried.
    - `description`:         Description that is displayed in the help.
    - `furtherInformation?`: Information appended to the end of the help. Useful for command extensions.
    - `flags`:               Supported flags ("options" in standard terminology).
    - `positionalArgs`:      Supported positional arguments ("operands" in standard terminology).
    - `variableArg?`:        Variable argument at the end of the positional arguments.
    - `run`:                 Handler to run when the command is called and flags/arguments have been successfully processed.
    - `subCmds`:             Subcommands.
    -/
    def mk
      (parent              : ExtendableCmd)
      (name                : String)
      (version?            : Option String)
      (description         : String)
      (furtherInformation? : Option String := none)
      (flags               : Array Flag    := #[])
      (positionalArgs      : Array Arg     := #[])
      (variableArg?        : Option Arg    := none)
      (run                 : Parsed → IO UInt32)
      (subCmds             : Array ExtendableCmd := #[])
      : ExtendableCmd :=
        .mk'
          ⟨name, parent.meta.parentNames.push parent.meta.name, version?, description, furtherInformation?,
            flags, positionalArgs, variableArg?⟩
          run subCmds

    /--
    Creates a new `ExtendableCmd`. The resulting `ExtendableCmd` will not have an extension.
    Adds a `-h, --help` and a `--version` flag if `version?` is present.
    - `parent`:              Parent of this command.
    - `name`:                Name that is displayed in the help.
    - `version?`:            Version that is displayed in the help and when the version is queried.
    - `description`:         Description that is displayed in the help.
    - `furtherInformation?`: Information appended to the end of the help. Useful for command extensions.
    - `flags`:               Supported flags ("options" in standard terminology).
    - `positionalArgs`:      Supported positional arguments ("operands" in standard terminology).
    - `variableArg?`:        Variable argument at the end of the positional arguments.
    - `run`:                 Handler to run when the command is called and flags/arguments have been successfully processed.
    - `subCmds`:             Subcommands.
    -/
    def mkWithHelpAndVersionFlags
      (parent              : ExtendableCmd)
      (name                : String)
      (version?            : Option String)
      (description         : String)
      (furtherInformation? : Option String := none)
      (flags               : Array Flag    := #[])
      (positionalArgs      : Array Arg     := #[])
      (variableArg?        : Option Arg    := none)
      (run                 : Parsed → IO UInt32)
      (subCmds             : Array ExtendableCmd := #[])
      : ExtendableCmd :=
        .mkWithHelpAndVersionFlags'
          ⟨name, parent.meta.parentNames.push parent.meta.name, version?, description, furtherInformation?,
            flags, positionalArgs, variableArg?⟩
          run subCmds

    /-- Name that is displayed in the help. -/
    def name                (c : ExtendableCmd) : String        := c.meta.name
    /-- Version of the command that is displayed in the help and when the version is queried. -/
    def version?            (c : ExtendableCmd) : Option String := c.meta.version?
    /-- Description that is displayed in the help. -/
    def description         (c : ExtendableCmd) : String        := c.meta.description
    /-- Information appended to the end of the help. Useful for command extensions. -/
    def furtherInformation? (c : ExtendableCmd) : Option String := c.meta.furtherInformation?
    /-- Supported flags ("options" in standard terminology). -/
    def flags               (c : ExtendableCmd) : Array Flag    := c.meta.flags
    /-- Supported positional arguments ("operands" in standard terminology). -/
    def positionalArgs      (c : ExtendableCmd) : Array Arg     := c.meta.positionalArgs
    /-- Variable argument after the end of the positional arguments. -/
    def variableArg?        (c : ExtendableCmd) : Option Arg    := c.meta.variableArg?

    /-- Full name from the root to this command, including the name of the command itself. -/
    def fullName (c : ExtendableCmd) : String := c.meta.fullName

    /-- Version of the command that is displayed in the help and when the version is queried. -/
    def version!            (c : ExtendableCmd) : String := c.meta.version!
    /-- Information appended to the end of the help. Useful for command extensions. -/
    def furtherInformation! (c : ExtendableCmd) : String := c.meta.furtherInformation!
    /-- Variable argument after the end of the positional arguments. -/
    def variableArg!        (c : ExtendableCmd) : Arg    := c.meta.variableArg!

    /-- Checks whether `c` has a version. -/
    def hasVersion            (c : ExtendableCmd) : Bool := c.meta.hasVersion
    /-- Checks whether `c` has information appended to the end of the help. -/
    def hasFurtherInformation (c : ExtendableCmd) : Bool := c.meta.hasFurtherInformation
    /-- Checks whether `c` supports a variable argument. -/
    def hasVariableArg        (c : ExtendableCmd) : Bool := c.meta.hasVariableArg

    /-- Finds the flag in `c` with the corresponding `longName`. -/
    def flag?          (c : ExtendableCmd) (longName : String) : Option Flag          := c.meta.flag? longName
    /-- Finds the positional argument in `c` with the corresponding `name`. -/
    def positionalArg? (c : ExtendableCmd) (name     : String) : Option Arg           := c.meta.positionalArg? name

    /-- Finds the flag in `c` with the corresponding `longName`. -/
    def flag!          (c : ExtendableCmd) (longName : String) : Flag          := c.meta.flag! longName
    /-- Finds the positional argument in `c` with the corresponding `name`. -/
    def positionalArg! (c : ExtendableCmd) (name     : String) : Arg           := c.meta.positionalArg! name

    /-- Checks whether `c` contains a flag with the corresponding `longName`. -/
    def hasFlag          (c : ExtendableCmd) (longName : String) : Bool := c.meta.hasFlag longName
    /-- Checks whether `c` contains a positional argument with the corresponding `name`. -/
    def hasPositionalArg (c : ExtendableCmd) (name     : String) : Bool := c.meta.hasPositionalArg name

    /-- Finds the flag in `c` with the corresponding `shortName`. -/
    def flagByShortName? (c : ExtendableCmd) (name : String) : Option Flag          := c.meta.flagByShortName? name
    /-- Finds the subcommand in `c` with the corresponding `name`. -/
    def subCmd?          (c : ExtendableCmd) (name : String) : Option ExtendableCmd := c.subCmds.find? (·.meta.name = name)

    /-- Finds the flag in `c` with the corresponding `shortName`. -/
    def flagByShortName! (c : ExtendableCmd) (name : String) : Flag          := c.meta.flagByShortName! name
    /-- Finds the subcommand in `c` with the corresponding `name`. -/
    def subCmd!          (c : ExtendableCmd) (name : String) : ExtendableCmd := c.subCmd? name |>.get!

    /-- Checks whether `c` has a flag with the corresponding `shortName`. -/
    def hasFlagByShortName (c : ExtendableCmd) (name : String) : Bool := c.meta.hasFlagByShortName name
    /-- Checks whether `c` contains a subcommand with the corresponding `name`. -/
    def hasSubCmd          (c : ExtendableCmd) (name : String) : Bool := c.subCmd? name |>.isSome
  end ExtendableCmd

  /--
  Allows user code to extend the library in two ways:
  - A command can be replaced or extended with new components.
  - The output of the parser can be postprocessed and validated.
  -/
  structure Extension where
    /--
    Priority that dictates how early an extension is applied.
    The lower the priority, the later it is applied.
    -/
    priority : Nat := 1024
    /--
    Extends a command to adjust the displayed help.
    The recursive subcommand structure may be mutated.
    -/
    extend : ExtendableCmd → ExtendableCmd := id
    /--
    Processes and validates the output of the parser for the given `ExtendableCmd`.
    Takes the `ExtendableCmd` that results from all extensions being applied.
    If postprocessing mutates the subcommand structure in `Parsed.cmd`, care must be taken to update
    `Parsed.parent?` accordingly as well.
    -/
    postprocess : ExtendableCmd → Parsed → Except String Parsed := fun _ => pure
    deriving Inhabited

  /--
  Composes both extensions so that the `Cmd`s are extended in succession
  and postprocessed in succession. Postprocessing errors if any of the two
  `postprocess` functions errors.
  -/
  def Extension.then (a : Extension) (b : Extension) : Extension := {
    extend  := b.extend ∘ a.extend
    postprocess := fun cmd parsed => do
      b.postprocess cmd <| ← a.postprocess cmd parsed
  }

  open Cmd in
  /--
  Represents a command, i.e. either the application root or some subcommand of the root.
  -/
  inductive Cmd
    | init
      («meta»     : Meta)
      (run        : Parsed → IO UInt32)
      (subCmds    : Array Cmd)
      (extension? : Option Extension)
    deriving Inhabited

  namespace Cmd
    /-- Non-recursive meta-data. -/
    def «meta»     : Cmd → Cmd.Meta             | init v _ _ _ => v
    /-- Handler to run when the command is called and flags/arguments have been successfully processed. -/
    def run        : Cmd → (Parsed → IO UInt32) | init _ v _ _ => v
    /-- Subcommands. -/
    def subCmds    : Cmd → Array Cmd            | init _ _ v _ => v
    /-- Extension of the Cli library. -/
    def extension? : Cmd → Option Extension     | init _ _ _ v => v

    private def update
      (c          : Cmd)
      («meta»     : Meta               := c.meta)
      (run        : Parsed → IO UInt32 := c.run)
      (subCmds    : Array Cmd          := c.subCmds)
      (extension? : Option Extension   := c.extension?)
      : Cmd :=
        .init «meta» run subCmds extension?

    /-- Recomputes all the parent names of subcommands in `c` with `c` as the root command. -/
    partial def updateParentNames (c : Cmd) : Cmd :=
      loop c #[]
    where
      loop (c : Cmd) (parentNames : Array String) : Cmd :=
        let subCmdParentNames := parentNames.push c.meta.name
        let subCmds := c.subCmds.map (loop · subCmdParentNames)
        .init { c.meta with parentNames := parentNames } c.run subCmds c.extension?

    /--
    Creates a new command. Adds a `-h, --help` and a `--version` flag if `«meta»` designates a version.
    Updates the `parentNames` of all subcommands.
    - `«meta»`:     Non-recursive meta-data.
    - `run`:        Handler to run when the command is called and flags/arguments have been successfully processed.
    - `subCmds`:    Subcommands.
    - `extension?`: Extension of the Cli library.
    -/
    partial def mk'
      («meta»     : Meta)
      (run        : Parsed → IO UInt32)
      (subCmds    : Array Cmd        := #[])
      (extension? : Option Extension := none)
      : Cmd :=
        let «meta» := meta.addHelpAndVersionFlags
        let c := .init «meta» run subCmds extension?
        updateParentNames c

    /--
    Creates a new command. Adds a `-h, --help` and a `--version` flag if a version is designated.
    Updates the `parentNames` of all subcommands.
    - `name`:                Name that is displayed in the help.
    - `version?`:            Version that is displayed in the help and when the version is queried.
    - `description`:         Description that is displayed in the help.
    - `furtherInformation?`: Information appended to the end of the help. Useful for command extensions.
    - `flags`:               Supported flags ("options" in standard terminology).
    - `positionalArgs`:      Supported positional arguments ("operands" in standard terminology).
    - `variableArg?`:        Variable argument at the end of the positional arguments.
    - `run`:                 Handler to run when the command is called and flags/arguments have been successfully processed.
    - `subCmds`:             Subcommands.
    - `extension?`:          Extension of the Cli library.
    -/
    def mk
      (name                : String)
      (version?            : Option String)
      (description         : String)
      (furtherInformation? : Option String := none)
      (flags               : Array Flag    := #[])
      (positionalArgs      : Array Arg     := #[])
      (variableArg?        : Option Arg    := none)
      (run                 : Parsed → IO UInt32)
      (subCmds             : Array Cmd        := #[])
      (extension?          : Option Extension := none)
      : Cmd :=
        mk'
          ⟨name, #[], version?, description, furtherInformation?, flags, positionalArgs, variableArg?⟩
          run subCmds extension?

    /-- Finds the subcommand in `c` with the corresponding `name`. -/
    def subCmd?    (c : Cmd) (name : String) : Option Cmd := c.subCmds.find? (·.meta.name = name)
    /-- Extension of the Cli library. -/
    def extension! (c : Cmd)                 : Extension  := c.extension?.get!

    /-- Finds the subcommand in `c` with the corresponding `name`. -/
    def subCmd! (c : Cmd) (name : String) : Cmd := c.subCmd? name |>.get!

    /-- Checks whether `c` contains a subcommand with the corresponding `name`. -/
    def hasSubCmd    (c : Cmd) (name : String) : Bool := c.subCmd? name |>.isSome
    /-- Checks whether `c` is being extended. -/
    def hasExtension (c : Cmd)                 : Bool := c.extension?.isSome
  end Cmd

  namespace Parsed
    namespace Cmd
      /-- Extracts `«meta»` and the recursive subcommand structure from `c` to create a `Parsed.Cmd`. -/
      partial def ofFullCmd (c : Cli.Cmd) : Cmd :=
        .init c.meta (c.subCmds.map ofFullCmd)

      /-- Embeds `c` into a `Cli.Cmd` that does nothing. -/
      partial def toFullCmd (c : Cmd) : Cli.Cmd :=
        let «meta»     := c.meta
        let run        := fun _ => pure 0
        let subCmds    := c.subCmds.map toFullCmd
        let extension? := { : Extension }
        .init «meta» run subCmds extension?
    end Cmd

    /-- Embeds `p.cmd` into a `Cli.Cmd` that does nothing. -/
    def toCmd (p : Parsed) : Cli.Cmd :=
      p.cmd.toFullCmd
  end Parsed

  namespace ExtendableCmd
    /-- Creates a view of `c` that can be extended by extensions. -/
    partial def ofFullCmd (c : Cli.Cmd) : ExtendableCmd :=
      .init c.meta c.run (c.subCmds.map ofFullCmd) c.meta.fullName

    /-- Converts `c` back into a `Cli.Cmd`, using the extensions denoted in `original`. -/
    partial def toFullCmd (c : ExtendableCmd) (original : Cli.Cmd) : Cli.Cmd := Id.run do
      let extensions := collectExtensions original
      let mut extensionIndex := Lean.mkRBMap String (Option Extension) compare
      for ⟨fullName, extension?⟩ in extensions do
        extensionIndex := extensionIndex.insert fullName extension?
      let rec loop (c : ExtendableCmd) : Cli.Cmd :=
        let extension? := do extensionIndex.find? (← c.originalFullName?) |> Option.join
        let subCmds := c.subCmds.map loop
        .init c.meta c.run subCmds extension?
      loop c |>.updateParentNames |> prependOriginalParentNames
    where
      collectExtensions (currentCmd : Cli.Cmd) : Array (String × Option Extension) := Id.run do
        let mut extensions := #[(currentCmd.meta.fullName, currentCmd.extension?)]
        for subCmd in currentCmd.subCmds do
          extensions := extensions ++ collectExtensions subCmd
        return extensions
      prependOriginalParentNames (currentCmd : Cli.Cmd) : Cli.Cmd := Id.run do
        let parentNames := original.meta.parentNames ++ currentCmd.meta.parentNames
        let «meta» := { currentCmd.meta with parentNames := parentNames }
        let subCmds := currentCmd.subCmds.map prependOriginalParentNames
        currentCmd.update («meta» := «meta») (subCmds := subCmds)

    /-- Converts `c` back into `Cli.Cmd` while retaining none of the extensions. -/
    partial def toFullCmdWithoutExtensions (c : ExtendableCmd) : Cli.Cmd :=
      Cmd.init c.meta c.run (c.subCmds.map toFullCmdWithoutExtensions) none

  end ExtendableCmd
end Configuration

section Macro
  open Lean

  syntax literalIdent := term

  syntax runFun := (" VIA " term) <|> " NOOP"

  syntax positionalArg := colGe literalIdent " : " term "; " term

  syntax variableArg := colGe "..." literalIdent " : " term "; " term

  syntax flag := colGe literalIdent ("," literalIdent)? (" : " term)? "; " term

  syntax "`[Cli|\n"
      literalIdent runFun "; " ("[" term "]")?
      term
      ("FLAGS:\n" withPosition((flag)*))?
      ("ARGS:\n" withPosition((positionalArg)* (variableArg)?))?
      ("SUBCOMMANDS: " sepBy(term, ";", "; "))?
      ("EXTENSIONS: " sepBy(term, ";", "; "))?
    "\n]" : term

  def expandIdentLiterally (t : Term) : Term :=
    match t with
    | `($i:ident) =>
      quote i.getId.toString
    | `($t:term) =>
      t

  def expandRunFun (runFun : TSyntax `Cli.runFun) : MacroM Term :=
    match runFun with
    | `(Cli.runFun| VIA $run) =>
      `($run)
    | `(Cli.runFun| NOOP) =>
      `(fun _ => pure 0)
    | _ => Macro.throwUnsupported

  def expandPositionalArg (positionalArg : TSyntax `Cli.positionalArg) : MacroM Term := do
    let `(Cli.positionalArg| $name:term : $type; $description) := positionalArg
      | Macro.throwUnsupported
    `(Arg.mk $(expandIdentLiterally name) $description $type)

  def expandVariableArg (variableArg : TSyntax `Cli.variableArg) : MacroM Term := do
    let `(Cli.variableArg| ...$name:term : $type; $description) := variableArg
      | Macro.throwUnsupported
    `(Arg.mk $(expandIdentLiterally name) $description $type)

  def expandFlag (flag : TSyntax `Cli.flag) : MacroM Term := do
    let `(Cli.flag| $flagName1:term $[, $flagName2:term]? $[ : $type]?; $description) := flag
      | Macro.throwUnsupported
    let mut shortName := quote (none : Option String)
    let mut longName := flagName1
    if let some flagName2 := flagName2 then
      shortName ← `(some $(expandIdentLiterally flagName1))
      longName := flagName2
    let unitType : Term ← `(Unit)
    let type :=
      match type with
      | none => unitType
      | some type => type
    `(Flag.mk $shortName $(expandIdentLiterally longName) $description $type)

  macro_rules
    | `(`[Cli|
        $name:term $run:runFun; $[[$version]]?
        $description
        $[FLAGS:
          $flags*
        ]?
        $[ARGS:
          $positionalArgs*
          $[$variableArg]?
        ]?
        $[SUBCOMMANDS: $subCommands;*]?
        $[EXTENSIONS: $extensions;*]?
      ]) => do
        `(Cmd.mk
          (name           := $(expandIdentLiterally name))
          (version?       := $(quote version))
          (description    := $description)
          (flags          := $(quote (← flags.getD #[] |>.mapM expandFlag)))
          (positionalArgs := $(quote (← positionalArgs.getD #[] |>.mapM expandPositionalArg)))
          (variableArg?   := $(quote (← (Option.join variableArg).mapM expandVariableArg)))
          (run            := $(← expandRunFun run))
          (subCmds        := $(quote (subCommands.getD ⟨#[]⟩).getElems))
          (extension?     := some <| Array.foldl Extension.then { : Extension } <| Array.qsort
            $(quote (extensions.getD ⟨#[]⟩).getElems) (·.priority > ·.priority)))
end Macro

section Info
  open Cli.String
  open Cli.Option

  /-- Maximum width within which all formatted text should fit. -/
  def maxWidth                  : Nat := 80
  /-- Amount of spaces with which section content is indented. -/
  def indentation               : Nat := 4
  /-- Maximum width within which all formatted text should fit, after indentation. -/
  def maxIndentedWidth          : Nat := maxWidth - indentation
  /-- Formats `xs` by `String.optJoin`ing the components with a single space. -/
  def line  (xs : Array String) : String := optJoin xs " "
  /-- Formats `xs` by `String.optJoin`ing the components with a newline `\n`. -/
  def lines (xs : Array String) : String := optJoin xs "\n"

  /--
  Renders a help section with the designated `title` and `content`.
  If `content = ""`, `emptyContentPlaceholder?` will be used instead.
  If `emptyContentPlaceholder? = none`, neither the title nor the content
  will be rendered.
  -/
  def renderSection
    (title                    : String)
    (content                  : String)
    (emptyContentPlaceholder? : Option String := none)
    : String :=
    let titleLine? : Option String := do
      if content = "" then
        return s!"{title}: {← emptyContentPlaceholder?}"
      else
        return s!"{title}:"
    lines #[
      optStr titleLine?,
      wrapWordsAt! content maxIndentedWidth |> indent (n := indentation)
    ]

  /--
  Renders a table using `Cli.Array.renderTable!` and then renders a section with
  the designated `title` and the rendered table as content.
  -/
  def renderTable
    (title                  : String)
    (columns                : Array (String × String))
    (emptyTablePlaceholder? : Option String := none)
    : String :=
    let table := Array.renderTable! columns (maxWidth := maxIndentedWidth)
    renderSection title table emptyTablePlaceholder?

  namespace Cmd
    private def metaDataInfo (c : Cmd) : String :=
      let version? : Option String := do return s!"[{← c.meta.version?}]"
      lines #[
        line #[c.meta.fullName, optStr version?] |> wrapWordsAt! (maxWidth := maxWidth),
        wrapWordsAt! c.meta.description maxWidth
      ]

    private def usageInfo (c : Cmd) : String :=
      let subCmdTitle? : Option String := if ¬c.subCmds.isEmpty then "[SUBCOMMAND]" else none
      let posArgNames  : String        := line <| c.meta.positionalArgs.map (s!"<{·.name}>")
      let varArgName?  : Option String := do return s!"<{(← c.meta.variableArg?).name}>..."
      let info := line #[c.meta.fullName, optStr subCmdTitle?, "[FLAGS]", posArgNames, optStr varArgName?]
      renderSection "USAGE" info

    private def flagInfo (c : Cmd) : String :=
      let columns : Array (String × String) := c.meta.flags.map fun flag =>
        let shortName?    : Option String := do return s!"-{← flag.shortName?}"
        let names         : String        := optJoin #[optStr shortName?, s!"--{flag.longName}"] ", "
        let type?         : Option String := if ¬ flag.isParamless then s!": {flag.type.name}" else none
        (line #[names, optStr type?], flag.description)
      renderTable "FLAGS" columns (emptyTablePlaceholder? := "None")

    private def positionalArgInfo (c : Cmd) : String :=
      let args :=
        if let some variableArg := c.meta.variableArg? then
          c.meta.positionalArgs ++ #[variableArg]
        else
          c.meta.positionalArgs
      args.map (fun arg => (line #[arg.name, s!": {arg.type.name}"], arg.description))
        |> renderTable "ARGS"

    private def subCommandInfo (c : Cmd) : String :=
      c.subCmds.map (fun subCmd => (subCmd.meta.name, subCmd.meta.description))
        |> renderTable "SUBCOMMANDS"

    /-- Renders the help for `c`. -/
    def help (c : Cmd) : String :=
      lines #[
        c.metaDataInfo,
        "\n" ++ c.usageInfo,
        "\n" ++ c.flagInfo,
        (if ¬c.meta.positionalArgs.isEmpty ∨ c.meta.hasVariableArg then "\n" else "") ++ c.positionalArgInfo,
        (if ¬c.subCmds.isEmpty then "\n" else "") ++ c.subCommandInfo,
        (if c.meta.hasFurtherInformation then "\n" else "") ++ optStr c.meta.furtherInformation?
      ]

    /-- Renders an error for `c` with the designated message `msg`. -/
    def error (c : Cmd) (msg : String) : String :=
      lines #[
        wrapWordsAt! msg maxWidth,
        wrapWordsAt! s!"Run `{c.meta.fullName} -h` for further information." maxWidth
      ]

    /-- Prints the help for `c`. -/
    def printHelp     (c : Cmd)                : IO Unit := IO.println c.help
    /-- Prints an error for `c` with the designated message `msg`. -/
    def printError    (c : Cmd) (msg : String) : IO Unit := IO.eprintln <| c.error msg
    /-- Prints the version of `c`. Panics if `c` has no version. -/
    def printVersion! (c : Cmd)                : IO Unit := IO.println c.meta.version!
  end Cmd

  namespace Parsed
      /-- Renders the help for `p.cmd`. -/
    def help (p : Parsed) : String := p.toCmd.help

    /-- Renders an error for `p.cmd` with the designated message `msg`. -/
    def error (p : Parsed) (msg : String) : String := p.toCmd.error msg

    /-- Prints the help for `p.cmd`. -/
    def printHelp     (p : Parsed)                : IO Unit := p.toCmd.printHelp
    /-- Prints an error for `p.cmd` with the designated message `msg`. -/
    def printError    (p : Parsed) (msg : String) : IO Unit := p.toCmd.printError msg
    /-- Prints the version of `p.cmd`. Panics if `p.cmd` has no version. -/
    def printVersion! (p : Parsed)                : IO Unit := p.toCmd.printVersion!
  end Parsed
end Info

section Parsing
  /-- Represents the exact representation of a flag as input by the user. -/
  structure InputFlag where
    /-- Flag name input by the user. -/
    name    : String
    /-- Whether the flag input by the user was a short one. -/
    isShort : Bool

  instance : ToString InputFlag where
    toString f :=
      let pre := if f.isShort then "-" else "--"
      s!"{pre}{f.name}"

  namespace ParseError
    /-- Represents the kind of error that occured during parsing. -/
    inductive Kind
    | unknownFlag
      (inputFlag : InputFlag)
      (msg       : String :=
        s!"Unknown flag `{inputFlag}`.")
    | missingFlagArg
      (flag      : Flag)
      (inputFlag : InputFlag)
      (msg       : String :=
        s!"Missing argument for flag `{inputFlag}`.")
    | duplicateFlag
      (flag      : Flag)
      (inputFlag : InputFlag)
      (msg       : String :=
        let complementaryName? : Option String := do
          if inputFlag.isShort then
            return s!" (`--{flag.longName}`)"
          else
            return s!" (`-{← flag.shortName?}`)"
        s!"Duplicate flag `{inputFlag}`{Option.optStr complementaryName?}.")
    | redundantFlagArg
      (flag       : Flag)
      (inputFlag  : InputFlag)
      (inputValue : String)
      (msg        : String :=
        s!"Redundant argument `{inputValue}` for flag `{inputFlag}` that takes no arguments.")
    | invalidFlagType
      (flag       : Flag)
      (inputFlag  : InputFlag)
      (inputValue : String)
      (msg        : String :=
        s!"Invalid type of argument `{inputValue}` for flag `{inputFlag} : {flag.type.name}`.")
    | missingPositionalArg
      (arg : Arg)
      (msg : String :=
        s!"Missing positional argument `<{arg.name}>.`")
    | invalidPositionalArgType
      (arg      : Arg)
      (inputArg : String)
      (msg      : String :=
        s!"Invalid type of argument `{inputArg}` for positional argument `<{arg.name} : {arg.type.name}>`.")
    | redundantPositionalArg
      (inputArg : String)
      (msg      : String :=
        s!"Redundant positional argument `{inputArg}`.")
    | invalidVariableArgType
      (arg      : Arg)
      (inputArg : String)
      (msg      : String :=
        s!"Invalid type of argument `{inputArg}` for variable argument `<{arg.name} : {arg.type.name}>...`.")

    /-- Associated message of the error. -/
    def Kind.msg : Kind → String
      | unknownFlag              _     msg
      | missingFlagArg           _ _   msg
      | duplicateFlag            _ _   msg
      | redundantFlagArg         _ _ _ msg
      | invalidFlagType          _ _ _ msg
      | missingPositionalArg     _     msg
      | invalidPositionalArgType _ _   msg
      | redundantPositionalArg   _     msg
      | invalidVariableArgType   _ _   msg => msg
  end ParseError

  open ParseError in
  /-- Error that occured during parsing. Contains the command that the error occured in and the kind of the error. -/
  structure ParseError where
    /-- Command that the error occured in. -/
    cmd         : Cmd
    /-- Kind of error that occured. -/
    kind        : Kind

  private structure ParseState where
    idx                  : Nat
    cmd                  : Cmd
    parent?              : Option Cmd
    parsedFlags          : Array Parsed.Flag
    parsedPositionalArgs : Array Parsed.Arg
    parsedVariableArgs   : Array Parsed.Arg

  private abbrev ParseM := ExceptT ParseError (ReaderT (Array String) (StateM ParseState))

  namespace ParseM
    open ParseError.Kind

    private def args                 : ParseM (Array String)      := read
    private def idx                  : ParseM Nat                 := do return (← get).idx
    private def cmd                  : ParseM Cmd                 := do return (← get).cmd
    private def parent?              : ParseM (Option Cmd)        := do return (← get).parent?
    private def parsedFlags          : ParseM (Array Parsed.Flag) := do return (← get).parsedFlags
    private def parsedPositionalArgs : ParseM (Array Parsed.Arg)  := do return (← get).parsedPositionalArgs
    private def parsedVariableArgs   : ParseM (Array Parsed.Arg)  := do return (← get).parsedVariableArgs
    private def peek?                : ParseM (Option String)     := do return (← args)[← idx]?
    private def peekNext?            : ParseM (Option String)     := do return (← args)[(← idx) + 1]?
    private def flag? (inputFlag : InputFlag) : ParseM (Option Flag) := do
      if inputFlag.isShort then
        return (← cmd).meta.flagByShortName? inputFlag.name
      else
        return (← cmd).meta.flag? inputFlag.name

    private def setIdx (idx : Nat) : ParseM Unit := do
      set { ← get with idx := idx }
    private def setCmd (c : Cmd) : ParseM Unit := do
      set { ← get with cmd := c }
    private def setParent (c? : Option Cmd) : ParseM Unit := do
      set { ← get with parent? := c? }
    private def pushParsedFlag (parsedFlag : Parsed.Flag) : ParseM Unit := do
      set { ← get with parsedFlags := (← parsedFlags).push parsedFlag }
    private def pushParsedPositionalArg (parsedPositionalArg : Parsed.Arg) : ParseM Unit := do
      set { ← get with parsedPositionalArgs := (← parsedPositionalArgs).push parsedPositionalArg }
    private def pushParsedVariableArg (parsedVariableArg : Parsed.Arg) : ParseM Unit := do
      set { ← get with parsedVariableArgs := (← parsedVariableArgs).push parsedVariableArg }
    private def skip : ParseM Unit := do
      setIdx <| (← idx) + 1

    private def parseError (kind : ParseError.Kind) : ParseM ParseError := do return ⟨← cmd, kind⟩

    private partial def parseSubCmds : ParseM Unit := do
      let mut parent? := none
      let mut lastSubCmd ← cmd
      repeat
        let some arg ← peek?
          | break
        let some subCmd := lastSubCmd.subCmd? arg
          | break
        skip
        parent? := lastSubCmd
        lastSubCmd := subCmd
      setCmd lastSubCmd
      setParent parent?

    private def parseEndOfFlags : ParseM Bool := do
      let some arg ← peek?
        | return false
      if arg = "--" then
        skip
        return true
      return false

    private def readFlagContent? : ParseM (Option (String × Bool)) := do
      let some arg ← peek?
        | return none
      if arg = "--" ∨ arg = "-" then
        return none
      if arg.take 2 = "--" then
        return (arg.drop 2, false)
      if arg.take 1 = "-" then
        return (arg.drop 1, true)
      return none

    private def ensureFlagUnique (flag : Flag) (inputFlag : InputFlag) : ParseM Unit := do
      if (← parsedFlags).find? (·.flag.longName = flag.longName) |>.isSome then
        throw <| ← parseError <| duplicateFlag flag inputFlag

    private def ensureFlagWellTyped (flag : Flag) (inputFlag : InputFlag) (value : String) : ParseM Unit := do
      if ¬ flag.type.isValid value then
        throw <| ← parseError <| invalidFlagType flag inputFlag value

    private partial def readMultiFlag? : ParseM (Option (Array Parsed.Flag)) := do
      let some (flagContent, true) ← readFlagContent?
        | return none
      let some (parsedFlags : Array (String × Parsed.Flag)) ← loop flagContent Lean.RBTree.empty
        | return none
      for (inputFlagName, parsedFlag) in parsedFlags do
        ensureFlagUnique parsedFlag.flag ⟨inputFlagName, true⟩
      skip
      return some <| parsedFlags.map (·.2)
    where
      loop (flagContent : String) (matched : Lean.RBTree String compare)
        : ParseM (Option (Array (String × Parsed.Flag))) := do
        -- this is not tail recursive, but that's fine: `loop` will only recurse further if the corresponding
        -- flag has not been matched yet, meaning that this can only overflow if the application has an
        -- astronomical amount of short flags.
        if flagContent = "" then
          return some #[]
        let parsedFlagsCandidates : Array (Array (String × Parsed.Flag)) ←
          (← cmd).meta.flags.filter (·.isParamless)
            |>.filter               (·.hasShortName)
            |>.filter               (·.shortName!.isPrefixOf flagContent)
            |>.filter               (¬ matched.contains ·.shortName!)
            |>.qsort                (·.shortName!.length > ·.shortName!.length)
            |>.filterMapM fun flag => do
              let inputFlagName := flagContent.take flag.shortName!.length
              let restContent   := flagContent.drop flag.shortName!.length
              let newMatched    := matched.insert flag.shortName!
              let some tail ← loop restContent newMatched
                | return none
              return some <| #[(inputFlagName, ⟨flag, ""⟩)] ++ tail
        return parsedFlagsCandidates[0]?

    private def readEqFlag? : ParseM (Option Parsed.Flag) := do
      let some (flagContent, isShort) ← readFlagContent?
        | return none
      match flagContent.splitOn "=" with
      | [] => panic! "Cli.readEqFlag?: String.splitOn returned empty list"
      | [_] => return none
      | (flagName :: flagArg :: rest) =>
        let flagValue := "=".intercalate <| flagArg :: rest
        let inputFlag : InputFlag := ⟨flagName, isShort⟩
        let some flag ← flag? inputFlag
          | throw <| ← parseError <| unknownFlag inputFlag
        if flag.isParamless then
          throw <| ← parseError <| redundantFlagArg flag inputFlag flagValue
        ensureFlagUnique flag inputFlag
        ensureFlagWellTyped flag inputFlag flagValue
        skip
        return some ⟨flag, flagValue⟩

    private def readWsFlag? : ParseM (Option Parsed.Flag) := do
      let some (flagName, isShort) ← readFlagContent?
        | return none
      let some flagValue ← peekNext?
        | return none
      let inputFlag : InputFlag := ⟨flagName, isShort⟩
      let some flag ← flag? inputFlag
        | return none
      if flag.isParamless then
        return none
      ensureFlagUnique flag inputFlag
      ensureFlagWellTyped flag inputFlag flagValue
      skip; skip
      return some ⟨flag, flagValue⟩

    private def readPrefixFlag? : ParseM (Option Parsed.Flag) := do
      let some (flagContent, true) ← readFlagContent?
        | return none
      let some flag :=
          ((← cmd).meta.flags.filter (¬ ·.isParamless)
            |>.filter               (·.hasShortName)
            |>.filter               (·.shortName!.isPrefixOf flagContent)
            |>.filter               (·.shortName!.length < flagContent.length)
            |>.qsort                (·.shortName!.length > ·.shortName!.length))[0]?
        | return none
      let flagName  := flag.shortName!
      let flagValue := flagContent.drop flagName.length
      let inputFlag : InputFlag := ⟨flagName, true⟩
      ensureFlagUnique flag inputFlag
      ensureFlagWellTyped flag inputFlag flagValue
      skip
      return some ⟨flag, flagValue⟩

    private def readParamlessFlag? : ParseM (Option Parsed.Flag) := do
      let some (flagName, isShort) ← readFlagContent?
        | return none
      let inputFlag : InputFlag := ⟨flagName, isShort⟩
      let some flag ← flag? inputFlag
        | throw <| ← parseError <| unknownFlag inputFlag
      if ¬ flag.isParamless then
        throw <| ← parseError <| missingFlagArg flag inputFlag
      ensureFlagUnique flag inputFlag
      skip
      return some ⟨flag, ""⟩

    private def parseFlag : ParseM Bool := do
      if let some parsedFlags ← readMultiFlag? then
        for parsedFlag in parsedFlags do
          pushParsedFlag parsedFlag
        return true
      let tryRead parse : OptionT ParseM Parsed.Flag := parse
      let some parsedFlag ←
          tryRead readEqFlag?     <|>
          tryRead readWsFlag?     <|>
          tryRead readPrefixFlag? <|>
          tryRead readParamlessFlag?
        | return false
      pushParsedFlag parsedFlag
      return true

    private def parsePositionalArg : ParseM Bool := do
      let some positionalArgValue ← peek?
        | return false
      let some positionalArg := (← cmd).meta.positionalArgs[(← parsedPositionalArgs).size]?
        | return false
      if ¬ positionalArg.type.isValid positionalArgValue then
        throw <| ← parseError <| invalidPositionalArgType positionalArg positionalArgValue
      skip
      pushParsedPositionalArg ⟨positionalArg, positionalArgValue⟩
      return true

    private def parseVariableArg : ParseM Bool := do
      let some variableArgValue ← peek?
        | return false
      let some variableArg := (← cmd).meta.variableArg?
        | throw <| ← parseError <| redundantPositionalArg variableArgValue
      if ¬ variableArg.type.isValid variableArgValue then
        throw <| ← parseError <| invalidVariableArgType variableArg variableArgValue
      skip
      pushParsedVariableArg ⟨variableArg, variableArgValue⟩
      return true

    private partial def parseArgs : ParseM Unit := do
      let mut parseEverythingAsArg := false
      let mut noEndOfInput := true
      while noEndOfInput do
        if ← (pure !parseEverythingAsArg) <&&> parseEndOfFlags then
          parseEverythingAsArg := true
        noEndOfInput := ← (pure !parseEverythingAsArg) <&&> parseFlag
                      <||> parsePositionalArg
                      <||> parseVariableArg

    private def parse (c : Cmd) (args : List String) : Except ParseError (Cmd × Parsed) :=
      parse' args.toArray |>.run' {
        idx                  := 0
        cmd                  := c
        parent?              := none
        parsedFlags          := #[]
        parsedPositionalArgs := #[]
        parsedVariableArgs   := #[]
      }
    where
      parse' : ParseM (Cmd × Parsed) := do
        parseSubCmds
        parseArgs
        let parsed : Parsed := {
          cmd            := .ofFullCmd (← cmd)
          parent?        := (← parent?).map .ofFullCmd
          flags          := ← parsedFlags
          positionalArgs := ← parsedPositionalArgs
          variableArgs   := ← parsedVariableArgs
        }
        if parsed.hasFlag "help" ∨ parsed.cmd.meta.hasVersion ∧ parsed.hasFlag "version" then
          return (← cmd, parsed)
        if (← parsedPositionalArgs).size < (← cmd).meta.positionalArgs.size then
          throw <| ← parseError <| missingPositionalArg <| (← cmd).meta.positionalArgs[(← parsedPositionalArgs).size]!
        return (← cmd, parsed)
  end ParseM

  namespace Cmd
    /--
    Parses `args` according to the specification provided in `c`, returning either a `ParseError` or the
    (sub)command that was called and the parsed content of the input.
    Note that `args` designates the list `<foo>` in `somebinary <foo>`.
    -/
    def parse (c : Cmd) (args : List String) : Except ParseError (Cmd × Parsed) :=
      ParseM.parse c args

    /-- Recursively applies extensions in all subcommands in `c` bottom-up and `c` itself. -/
    partial def applyExtensions (c : Cmd) : Cmd := Id.run do
      let subCmds := c.subCmds.map applyExtensions
      let c := c.update (subCmds := subCmds)
      let some extension := c.extension?
        | return c
      extension.extend (.ofFullCmd c) |>.toFullCmd c

    /--
    Processes `args` by applying all extensions in `c`, `Cmd.parse?`ing the input according to `c`
    and then applying the postprocessing extension of the respective (sub)command that was called.
    Note that `args` designates the list `<foo>` in `somebinary <foo>`.
    Returns either the (sub)command that an error occured in and the corresponding error message or
    the (sub)command that was called and the parsed input after postprocessing.
    -/
    def process (c : Cmd) (args : List String) : Except (Cmd × String) (Cmd × Parsed) := do
      let c := c.applyExtensions
      let result := c.parse args
      match result with
      | .ok (cmd, parsed) =>
        let some ext := cmd.extension?
          | return (cmd, parsed)
        match ext.postprocess (.ofFullCmd cmd) parsed with
        | .ok newParsed =>
          return (cmd, newParsed)
        | .error msg =>
          throw (cmd, msg)
      | .error err =>
        throw (err.cmd, err.kind.msg)
  end Cmd
end Parsing

section IO
  namespace Cmd
    /--
    Validates `args` by `Cmd.process?`ing the input according to `c`.
    Note that `args` designates the list `<foo>` in `somebinary <foo>`.
    Prints the help or the version of the called (sub)command if the respective flag was passed and
    returns `0` for the exit code.
    If neither of these flags were passed and processing was successful, the `run` handler of the
    called command is executed.
    In the case of a processing error, the error is printed to stderr and an exit code of `1` is returned.
    -/
    def validate (c : Cmd) (args : List String) : IO UInt32 := do
      let result := c.process args
      match result with
      | .ok (cmd, parsed) =>
        if parsed.hasFlag "help" then
          parsed.printHelp
          return 0
        if parsed.cmd.meta.hasVersion ∧ parsed.hasFlag "version" then
          parsed.printVersion!
          return 0
        cmd.run parsed
      | .error (cmd, err) =>
        cmd.printError err
        return 1
  end Cmd
end IO

end Cli



=== LEAN SOURCE: Example.lean ===
import Cli

open Cli

def runExampleCmd (p : Parsed) : IO UInt32 := do
  let input   : String       := p.positionalArg! "input" |>.as! String
  let outputs : Array String := p.variableArgsAs! String
  IO.println <| "Input: " ++ input
  IO.println <| "Outputs: " ++ toString outputs

  if p.hasFlag "verbose" then
    IO.println "Flag `--verbose` was set."
  if p.hasFlag "invert" then
    IO.println "Flag `--invert` was set."
  if p.hasFlag "optimize" then
    IO.println "Flag `--optimize` was set."

  let priority : Nat := p.flag! "priority" |>.as! Nat
  IO.println <| "Flag `--priority` always has at least a default value: " ++ toString priority

  if p.hasFlag "module" then
    let moduleName : ModuleName := p.flag! "module" |>.as! ModuleName
    IO.println <| s!"Flag `--module` was set to `{moduleName}`."

  if let some setPathsFlag := p.flag? "set-paths" then
    IO.println <| toString <| setPathsFlag.as! (Array String)
  return 0

def installCmd := `[Cli|
  installCmd NOOP;
  "installCmd provides an example for a subcommand without flags or arguments that does nothing. " ++
  "Versions can be omitted."
]

def testCmd := `[Cli|
  testCmd NOOP;
  "testCmd provides another example for a subcommand without flags or arguments that does nothing."
]

def exampleCmd : Cmd := `[Cli|
  exampleCmd VIA runExampleCmd; ["0.0.1"]
  "This string denotes the description of `exampleCmd`."

  FLAGS:
    verbose;                    "Declares a flag `--verbose`. This is the description of the flag."
    i, invert;                  "Declares a flag `--invert` with an associated short alias `-i`."
    o, optimize;                "Declares a flag `--optimize` with an associated short alias `-o`."
    p, priority : Nat;          "Declares a flag `--priority` with an associated short alias `-p` " ++
                                "that takes an argument of type `Nat`."
    module : ModuleName;        "Declares a flag `--module` that takes an argument of type `ModuleName` " ++
                                "which can be used to reference Lean modules like `Init.Data.Array` " ++
                                "or Lean files using a relative path like `Init/Data/Array.lean`."
    "set-paths" : Array String; "Declares a flag `--set-paths` " ++
                                "that takes an argument of type `Array Nat`. " ++
                                "Quotation marks allow the use of hyphens."

  ARGS:
    input : String;      "Declares a positional argument <input> " ++
                         "that takes an argument of type `String`."
    ...outputs : String; "Declares a variable argument <output>... " ++
                         "that takes an arbitrary amount of arguments of type `String`."

  SUBCOMMANDS:
    installCmd;
    testCmd

  -- The EXTENSIONS section denotes features that
  -- were added as an external extension to the library.
  -- `./Cli/Extensions.lean` provides some commonly useful examples.
  EXTENSIONS:
    author "mhuisi";
    defaultValues! #[("priority", "0")]
]

def main (args : List String) : IO UInt32 :=
  exampleCmd.validate args

#eval main <| "-i -o -p 1 --module=Lean.Compiler --set-paths=path1,path2,path3 input output1 output2".splitOn " "
/-
Yields:
  Input: input
  Outputs: #[output1, output2]
  Flag `--invert` was set.
  Flag `--optimize` was set.
  Flag `--priority` always has at least a default value: 1
  Flag `--module` was set to `Lean.Compiler`.
  #[path1, path2, path3]
-/

-- Short parameterless flags can be grouped,
-- short flags with parameters do not need to be separated from
-- the corresponding value.
#eval main <| "-io -p1 input".splitOn " "
/-
Yields:
  Input: input
  Outputs: #[]
  Flag `--invert` was set.
  Flag `--optimize` was set.
  Flag `--priority` always has at least a default value: 1
-/

#eval main <| "--version".splitOn " "
/-
Yields:
  0.0.1
-/


#eval main <| "-h".splitOn " "
/-
Yields:
  exampleCmd [0.0.1]
  mhuisi
  This string denotes the description of `exampleCmd`.

  USAGE:
      exampleCmd [SUBCOMMAND] [FLAGS] <input> <outputs>...

  FLAGS:
      -h, --help                  Prints this message.
      --version                   Prints the version.
      --verbose                   Declares a flag `--verbose`. This is the
                                  description of the flag.
      -i, --invert                Declares a flag `--invert` with an associated
                                  short alias `-i`.
      -o, --optimize              Declares a flag `--optimize` with an associated
                                  short alias `-o`.
      -p, --priority : Nat        Declares a flag `--priority` with an associated
                                  short alias `-p` that takes an argument of type
                                  `Nat`. [Default: `0`]
      --module : ModuleName       Declares a flag `--module` that takes an
                                  argument of type `ModuleName` which can be used
                                  to reference Lean modules like `Init.Data.Array`
                                  or Lean files using a relative path like
                                  `Init/Data/Array.lean`.
      --set-paths : Array String  Declares a flag `--set-paths` that takes an
                                  argument of type `Array Nat`. Quotation marks
                                  allow the use of hyphens.

  ARGS:
      input : String    Declares a positional argument <input> that takes an
                        argument of type `String`.
      outputs : String  Declares a variable argument <output>... that takes an
                        arbitrary amount of arguments of type `String`.

  SUBCOMMANDS:
      installCmd  installCmd provides an example for a subcommand without flags or
                  arguments that does nothing. Versions can be omitted.
      testCmd     testCmd provides another example for a subcommand without flags
                  or arguments that does nothing.
-/



=== LEAN SOURCE: Extensions.lean ===
import Cli.Basic

namespace Cli

section Utils
  namespace Array
    /--
    Appends those elements of `right` to `left` whose `key` is not already
    contained in `left`.
    -/
    def leftUnionBy [Ord α] (key : β → α) (left : Array β) (right : Array β)
      : Array β := Id.run do
      let leftMap := left.map (fun v => (key v, v)) |>.toList |> Lean.RBMap.ofList (cmp := compare)
      let mut result := left
      for v in right do
        if ¬ leftMap.contains (key v) then
          result := result.push v
      return result

    /--
    Prepends those elements of `left` to `right` whose `key` is not already
    contained in `right`.
    -/
    def rightUnionBy [Ord α] (key : β → α) (left : Array β) (right : Array β)
      : Array β := Id.run do
      let rightMap := right.map (fun v => (key v, v)) |>.toList |> Lean.RBMap.ofList (cmp := compare)
      let mut result := right
      for v in left.reverse do
        if ¬ rightMap.contains (key v) then
          result := #[v] ++ result
      return result

    /-- Deletes all elements from `left` whose `key` is in `right`. -/
    def diffBy [Ord α] (key : β → α) (left : Array β) (right : Array α)
      : Array β :=
      let rightMap := Lean.RBTree.ofList (cmp := compare) right.toList
      left.filter fun v => ¬ (rightMap.contains <| key v)
  end Array
end Utils

section Extensions
  /-- Prepends an author name to the description of the command. -/
  def author (author : String) : Extension := {
      extend := fun cmd => cmd.update (description := s!"{author}\n{cmd.description}")
    }

  /-- Appends a longer description to the end of the help. -/
  def longDescription (description : String) : Extension := {
      extend := fun cmd => cmd.update (furtherInformation? :=
        some <| Option.optStr cmd.furtherInformation? ++ lines #[
          Option.optStr cmd.furtherInformation?,
          (if cmd.hasFurtherInformation then "\n" else "") ++ renderSection "DESCRIPTION" description
        ]
      )
    }

  /-- Adds a `help` subcommand. -/
  def helpSubCommand : Extension := {
      priority := 0
      extend   := fun cmd =>
        let helpCmd := .mk
          (parent      := cmd)
          (name        := "help")
          (version?    := none)
          (description := "Prints this message.")
          (run         := fun _ => pure 0)
        -- adding it once without a command handler ensures that the help will include
        -- the help subcommand itself
        let cmd := cmd.update (subCmds := cmd.subCmds.push helpCmd)
        let helpCmd := helpCmd.update (run := fun _ => do
          cmd.toFullCmdWithoutExtensions.printHelp
          return 0)
        let subCmds := cmd.subCmds.set! (cmd.subCmds.size - 1) helpCmd
        cmd.update (subCmds := subCmds)
    }

  /-- Adds a `version` subcommand. -/
  def versionSubCommand! : Extension := {
    extend := fun cmd =>
      if cmd.version?.isNone then
        panic! "Cli.versionSubCommand!: Cannot add `version` subcommand to command without a version."
      else
        let helpCmd := .mk
          (parent      := cmd)
          (name        := "version")
          (version?    := none)
          (description := "Prints the version.")
          (run         := fun _ => do
            cmd.toFullCmdWithoutExtensions.printVersion!
            return 0)
        cmd.update (subCmds := cmd.subCmds.push helpCmd)
  }

  /--
  Sets default values for flags that were not set by the user according to
  `defaults := #[(long flag name, default value), ...]` and denotes the default value
  in the flag description of the help.
  Panics if one of the designated long flag names cannot be found in the command.
  -/
  def defaultValues! (defaults : Array (String × String)) : Extension :=
    let findDefaultFlags cmd := defaults.map <| fun (longName, defaultValue) =>
      ⟨cmd.flag! longName, defaultValue⟩
    {
      extend := fun cmd =>
        let defaultFlags := findDefaultFlags cmd
        let newMetaFlags := cmd.flags.map fun flag =>
          if let some defaultFlag := defaultFlags.find? (·.flag.longName = flag.longName) then
            { flag with description := flag.description ++ s!" [Default: `{defaultFlag.value}`]" }
          else
            flag
        cmd.update (flags := newMetaFlags)
      postprocess := fun cmd parsed =>
        let defaultFlags := findDefaultFlags cmd
        return { parsed with flags := Array.leftUnionBy (·.flag.longName) parsed.flags defaultFlags }
    }

  /--
  Errors if one of `requiredFlags := #[long flag name, ...]` were not passed by the user.
  Denotes that the flag is required in the flag description of the help.
  Panics if one of the designated long flag names cannot be found in the command.
  -/
  def require! (requiredFlags : Array String) : Extension :=
    let findRequiredFlags cmd := requiredFlags.map (cmd.flag! ·)
    {
      extend := fun cmd =>
        let requiredFlags := findRequiredFlags cmd
        let newMetaFlags := cmd.flags.map fun flag =>
          if requiredFlags.find? (·.longName = flag.longName) |>.isSome then
            { flag with description := "[Required] " ++ flag.description }
          else
            flag
        cmd.update (flags := newMetaFlags)
      postprocess := fun cmd parsed => do
        if parsed.hasFlag "help" ∨ parsed.hasFlag "version" then
          return parsed
        let requiredFlags := findRequiredFlags cmd
        let missingFlags := Array.diffBy (·.longName) requiredFlags <| parsed.flags.map (·.flag.longName)
        if let some missingFlag ← pure <| missingFlags[0]? then
          throw s!"Missing required flag `--{missingFlag.longName}`."
        return parsed
    }
end Extensions

end Cli



=== LEAN SOURCE: Tests.lean ===
import Cli.Basic
import Cli.Extensions

namespace Cli

section Utils
  instance [BEq α] [BEq β] : BEq (Except α β) where
    beq
    | Except.ok a,    Except.ok a'    => a == a'
    | Except.error b, Except.error b' => b == b'
    | _,              _               => false

  instance [Repr α] [Repr β] : Repr (Except α β) where
    reprPrec
    | Except.ok a,    _ => s!"Except.ok ({repr a})"
    | Except.error b, _ => s!"Except.error ({repr b})"

  def Cmd.processParsed (c : Cmd) (args : String) : String := Id.run do
    let mut args := args.splitOn
    if args = [""] then
      args := []
    match c.process args with
    | Except.ok (_, parsed) =>
      return toString parsed
    | Except.error (_, error) =>
      return error

  def Cmd.extendedHelp (c : Cmd) : String :=
    c.extension!.extend (.ofFullCmd c) |>.toFullCmd c |>.help

end Utils

def doNothing (_ : Parsed) : IO UInt32 := return 0

def testSubSubCmd : Cmd := `[Cli|
  testsubsubcommand VIA doNothing;
  "does this even do anything?"
]

def testSubCmd1 : Cmd := `[Cli|
  testsubcommand1 NOOP; ["0.0.1"]
  "a properly short description"

  FLAGS:
    "launch-the-nukes";  "please avoid passing this flag at all costs.\nif you like, you can have newlines in descriptions."

  ARGS:
    "city-location" : String;  "can also use hyphens"

  SUBCOMMANDS:
    testSubSubCmd

  EXTENSIONS:
    helpSubCommand;
    versionSubCommand!
]

def testSubCmd2 : Cmd := `[Cli|
  testsubcommand2 VIA doNothing; ["0.0.-1"]
  "does not do anything interesting"

  FLAGS:
    r, run; "really, this does not do anything. trust me."

  ARGS:
    "ominous-input" : Array String; "what could this be for?"
]

def testCmd : Cmd := `[Cli|
  testcommand VIA doNothing; ["0.0.0"]
  "some short description that happens to be much longer than necessary and hence needs to be wrapped to fit into an 80 character width limit"

  FLAGS:
    verbose;                     "a very verbose flag description that also needs to be wrapped to fit into an 80 character width limit"
    x, unknown1;                 "this flag has a short name"
    xn, unknown2;                "short names do not need to be prefix-free"
    ny, unknown3;                "-xny will parse as -x -ny and not fail to parse as -xn -y"
    t, typed1 : String;          "flags can have typed parameters"
    ty, typed2;                  "-ty parsed as --typed2, not -t=y"
    "p-n", "level-param" : Nat;  "hyphens work, too"

  ARGS:
    input1 : String;     "another very verbose description that also needs to be wrapped to fit into an 80 character width limit"
    input2 : Array Nat;  "arrays!"
    ...outputs : Nat;    "varargs!"

  SUBCOMMANDS: testSubCmd1; testSubCmd2

  EXTENSIONS:
    author "mhuisi";
    longDescription "this could be really long, but i'm too lazy to type it out.";
    defaultValues! #[⟨"level-param", "0"⟩];
    require! #["typed1"]
]

section ValidInputs
  #eval
    (testCmd.processParsed "foo 1 -ta")
    == "cmd: testcommand; flags: #[--typed1=a, --level-param=0]; positionalArgs: #[<input1=foo>, <input2=1>]; variableArgs: #[]"

  #eval
    (testCmd.processParsed "-h")
    == "cmd: testcommand; flags: #[--help, --level-param=0]; positionalArgs: #[]; variableArgs: #[]"

  #eval
    (testCmd.processParsed "--version")
    == "cmd: testcommand; flags: #[--version, --level-param=0]; positionalArgs: #[]; variableArgs: #[]"

  #eval
    (testCmd.processParsed "foo --verbose -p-n 2 1,2,3 1 -xnx 2 --typed1=foo 3")
    == "cmd: testcommand; flags: #[--verbose, --level-param=2, --unknown2, --unknown1, --typed1=foo]; positionalArgs: #[<input1=foo>, <input2=1,2,3>]; variableArgs: #[<outputs=1>, <outputs=2>, <outputs=3>]"

  #eval
    (testCmd.processParsed "foo -xny 1 -t 3")
    == "cmd: testcommand; flags: #[--unknown1, --unknown3, --typed1=3, --level-param=0]; positionalArgs: #[<input1=foo>, <input2=1>]; variableArgs: #[]"

  #eval
    (testCmd.processParsed "-t 3 -- --input 2")
    == "cmd: testcommand; flags: #[--typed1=3, --level-param=0]; positionalArgs: #[<input1=--input>, <input2=2>]; variableArgs: #[]"

  #eval
    (testCmd.processParsed "-t1 - 2")
    == "cmd: testcommand; flags: #[--typed1=1, --level-param=0]; positionalArgs: #[<input1=->, <input2=2>]; variableArgs: #[]"

  #eval
    (testCmd.processParsed "-ty -t1 foo 1,2")
    == "cmd: testcommand; flags: #[--typed2, --typed1=1, --level-param=0]; positionalArgs: #[<input1=foo>, <input2=1,2>]; variableArgs: #[]"

  #eval
    (testCmd.processParsed "testsubcommand1 -- testsubsubcommand")
    == "cmd: testcommand testsubcommand1; flags: #[]; positionalArgs: #[<city-location=testsubsubcommand>]; variableArgs: #[]"

  #eval
    (testCmd.processParsed "testsubcommand1 --launch-the-nukes x")
    == "cmd: testcommand testsubcommand1; flags: #[--launch-the-nukes]; positionalArgs: #[<city-location=x>]; variableArgs: #[]"

  #eval
    (testCmd.processParsed "testsubcommand1 -- --launch-the-nukes")
    == "cmd: testcommand testsubcommand1; flags: #[]; positionalArgs: #[<city-location=--launch-the-nukes>]; variableArgs: #[]"

  #eval
    (testCmd.processParsed "testsubcommand1 testsubsubcommand")
    == "cmd: testcommand testsubcommand1 testsubsubcommand; flags: #[]; positionalArgs: #[]; variableArgs: #[]"

  #eval 
    (testCmd.processParsed "testsubcommand2 --run asdf,geh")
    == "cmd: testcommand testsubcommand2; flags: #[--run]; positionalArgs: #[<ominous-input=asdf,geh>]; variableArgs: #[]"

  #eval 
    (testCmd.processParsed "testsubcommand1 help")
    == "cmd: testcommand testsubcommand1 help; flags: #[]; positionalArgs: #[]; variableArgs: #[]"

  #eval 
    (testCmd.processParsed "testsubcommand1 version")
    == "cmd: testcommand testsubcommand1 version; flags: #[]; positionalArgs: #[]; variableArgs: #[]"
end ValidInputs

section InvalidInputs
  #eval
    (testCmd.processParsed "")
    == "Missing positional argument `<input1>.`"

  #eval
    (testCmd.processParsed "foo")
    == "Missing positional argument `<input2>.`"

  #eval
    (testCmd.processParsed "foo asdf")
    == "Invalid type of argument `asdf` for positional argument `<input2 : Array Nat>`."

  #eval
    (testCmd.processParsed "foo 1,2,3")
    == "Missing required flag `--typed1`."

  #eval
    (testCmd.processParsed "foo 1,2,3 -t")
    == "Missing argument for flag `-t`."

  #eval
    (testCmd.processParsed "foo 1,2,3 -t1 --level-param=")
    == "Invalid type of argument `` for flag `--level-param : Nat`."

  #eval
    (testCmd.processParsed "foo 1,2,3 -t1 -p-n=")
    == "Invalid type of argument `` for flag `-p-n : Nat`."

  #eval
    (testCmd.processParsed "foo 1,2,3 -t1 --asdf")
    == "Unknown flag `--asdf`."

  #eval
    (testCmd.processParsed "foo 1,2,3 -t1 -t2")
    == "Duplicate flag `-t` (`--typed1`)."

  #eval
    (testCmd.processParsed "foo 1,2,3 -t1 --typed1=2")
    == "Duplicate flag `--typed1` (`-t`)."

  #eval
    (testCmd.processParsed "foo 1,2,3 --typed12")
    == "Unknown flag `--typed12`."

  #eval
    (testCmd.processParsed "foo 1,2,3 -t1 -x=1")
    == "Redundant argument `1` for flag `-x` that takes no arguments."

  #eval
    (testCmd.processParsed "foo 1,2,3 -t1 bar")
    == "Invalid type of argument `bar` for variable argument `<outputs : Nat>...`."

  #eval
    (testCmd.processParsed "foo 1,2,3 -t1 -xxn=1")
    == "Unknown flag `-xxn`."

  #eval
    (testCmd.processParsed "foo 1,2,3 --t=1")
    == "Unknown flag `--t`."

  #eval
    (testCmd.processParsed "testsubcommand1 asdf geh")
    == "Redundant positional argument `geh`."
end InvalidInputs

section Info
  /-
  testcommand [0.0.0]
  some short description that happens to be much longer than necessary and hence
  needs to be wrapped to fit into an 80 character width limit

  USAGE:
      testcommand [SUBCOMMAND] [FLAGS] <input1> <input2> <outputs>...

  FLAGS:
      -h, --help                 Prints this message.
      --version                  Prints the version.
      --verbose                  a very verbose flag description that also needs
                                 to be wrapped to fit into an 80 character width
                                 limit
      -x, --unknown1             this flag has a short name
      -xn, --unknown2            short names do not need to be prefix-free
      -ny, --unknown3            -xny will parse as -x -ny and not fail to parse
                                 as -xn -y
      -t, --typed1 : String      flags can have typed parameters
      -ty, --typed2              -ty parsed as --typed2, not -t=y
      -p-n, --level-param : Nat  hyphens work, too

  ARGS:
      input1 : String     another very verbose description that also needs to be
                          wrapped to fit into an 80 character width limit
      input2 : Array Nat  arrays!
      outputs : Nat       varargs!

  SUBCOMMANDS:
      testsubcommand1  a properly short description
      testsubcommand2  does not do anything interesting
  -/
  #eval
    testCmd.help
    == "testcommand [0.0.0]\nsome short description that happens to be much longer than necessary and hence\nneeds to be wrapped to fit into an 80 character width limit\n\nUSAGE:\n    testcommand [SUBCOMMAND] [FLAGS] <input1> <input2> <outputs>...\n\nFLAGS:\n    -h, --help                 Prints this message.\n    --version                  Prints the version.\n    --verbose                  a very verbose flag description that also needs\n                               to be wrapped to fit into an 80 character width\n                               limit\n    -x, --unknown1             this flag has a short name\n    -xn, --unknown2            short names do not need to be prefix-free\n    -ny, --unknown3            -xny will parse as -x -ny and not fail to parse\n                               as -xn -y\n    -t, --typed1 : String      flags can have typed parameters\n    -ty, --typed2              -ty parsed as --typed2, not -t=y\n    -p-n, --level-param : Nat  hyphens work, too\n\nARGS:\n    input1 : String     another very verbose description that also needs to be\n                        wrapped to fit into an 80 character width limit\n    input2 : Array Nat  arrays!\n    outputs : Nat       varargs!\n\nSUBCOMMANDS:\n    testsubcommand1  a properly short description\n    testsubcommand2  does not do anything interesting"

  #eval
    testCmd.meta.version!
    == "0.0.0"

  /-
  some exceedingly long error that needs to be wrapped to fit within an 80
  character width limit. none of our errors are really that long, but flag names
  might be.
  Run `testcommand -h` for further information.
  -/
  #eval
    (testCmd.error "some exceedingly long error that needs to be wrapped to fit within an 80 character width limit. none of our errors are really that long, but flag names might be.")
    == "some exceedingly long error that needs to be wrapped to fit within an 80\ncharacter width limit. none of our errors are really that long, but flag names\nmight be.\nRun `testcommand -h` for further information."

  /-
  testsubcommand2 [0.0.-1]
  does not do anything interesting

  USAGE:
      testsubcommand2 [FLAGS] <ominous-input>

  FLAGS:
      -h, --help  Prints this message.
      --version   Prints the version.
      -r, --run   really, this does not do anything. trust me.

  ARGS:
      ominous-input : Array String  what could this be for?
  -/
  #eval
    testSubCmd2.help
    == "testsubcommand2 [0.0.-1]\ndoes not do anything interesting\n\nUSAGE:\n    testsubcommand2 [FLAGS] <ominous-input>\n\nFLAGS:\n    -h, --help  Prints this message.\n    --version   Prints the version.\n    -r, --run   really, this does not do anything. trust me.\n\nARGS:\n    ominous-input : Array String  what could this be for?"

  /-
  testcommand testsubcommand2 [0.0.-1]
  does not do anything interesting

  USAGE:
      testcommand testsubcommand2 [FLAGS] <ominous-input>

  FLAGS:
      -h, --help  Prints this message.
      --version   Prints the version.
      -r, --run   really, this does not do anything. trust me.

  ARGS:
      ominous-input : Array String  what could this be for?
  -/
  #eval
    (testCmd.subCmd! "testsubcommand2").help
    == "testcommand testsubcommand2 [0.0.-1]\ndoes not do anything interesting\n\nUSAGE:\n    testcommand testsubcommand2 [FLAGS] <ominous-input>\n\nFLAGS:\n    -h, --help  Prints this message.\n    --version   Prints the version.\n    -r, --run   really, this does not do anything. trust me.\n\nARGS:\n    ominous-input : Array String  what could this be for?"

  /-
  testcommand testsubcommand1 testsubsubcommand
  does this even do anything?

  USAGE:
      testcommand testsubcommand1 testsubsubcommand [FLAGS]

  FLAGS:
      -h, --help  Prints this message.
  -/
  #eval
    (testCmd.subCmd! "testsubcommand1" |>.subCmd! "testsubsubcommand").help
    == "testcommand testsubcommand1 testsubsubcommand\ndoes this even do anything?\n\nUSAGE:\n    testcommand testsubcommand1 testsubsubcommand [FLAGS]\n\nFLAGS:\n    -h, --help  Prints this message."

  /-
  testcommand [0.0.0]
  mhuisi
  some short description that happens to be much longer than necessary and hence
  needs to be wrapped to fit into an 80 character width limit

  USAGE:
      testcommand [SUBCOMMAND] [FLAGS] <input1> <input2> <outputs>...

  FLAGS:
      -h, --help                 Prints this message.
      --version                  Prints the version.
      --verbose                  a very verbose flag description that also needs
                                 to be wrapped to fit into an 80 character width
                                 limit
      -x, --unknown1             this flag has a short name
      -xn, --unknown2            short names do not need to be prefix-free
      -ny, --unknown3            -xny will parse as -x -ny and not fail to parse
                                 as -xn -y
      -t, --typed1 : String      [Required] flags can have typed parameters
      -ty, --typed2              -ty parsed as --typed2, not -t=y
      -p-n, --level-param : Nat  hyphens work, too [Default: `0`]

  ARGS:
      input1 : String     another very verbose description that also needs to be
                          wrapped to fit into an 80 character width limit
      input2 : Array Nat  arrays!
      outputs : Nat       varargs!

  SUBCOMMANDS:
      testsubcommand1  a properly short description
      testsubcommand2  does not do anything interesting

  DESCRIPTION:
      this could be really long, but i'm too lazy to type it out.
  -/
  #eval testCmd.extendedHelp
    == "testcommand [0.0.0]\nmhuisi\nsome short description that happens to be much longer than necessary and hence\nneeds to be wrapped to fit into an 80 character width limit\n\nUSAGE:\n    testcommand [SUBCOMMAND] [FLAGS] <input1> <input2> <outputs>...\n\nFLAGS:\n    -h, --help                 Prints this message.\n    --version                  Prints the version.\n    --verbose                  a very verbose flag description that also needs\n                               to be wrapped to fit into an 80 character width\n                               limit\n    -x, --unknown1             this flag has a short name\n    -xn, --unknown2            short names do not need to be prefix-free\n    -ny, --unknown3            -xny will parse as -x -ny and not fail to parse\n                               as -xn -y\n    -t, --typed1 : String      [Required] flags can have typed parameters\n    -ty, --typed2              -ty parsed as --typed2, not -t=y\n    -p-n, --level-param : Nat  hyphens work, too [Default: `0`]\n\nARGS:\n    input1 : String     another very verbose description that also needs to be\n                        wrapped to fit into an 80 character width limit\n    input2 : Array Nat  arrays!\n    outputs : Nat       varargs!\n\nSUBCOMMANDS:\n    testsubcommand1  a properly short description\n    testsubcommand2  does not do anything interesting\n\nDESCRIPTION:\n    this could be really long, but i'm too lazy to type it out."

  /-
  testsubcommand1 [0.0.1]
  a properly short description

  USAGE:
      testsubcommand1 [SUBCOMMAND] [FLAGS] <city-location>

  FLAGS:
      -h, --help          Prints this message.
      --version           Prints the version.
      --launch-the-nukes  please avoid passing this flag at all costs.
                          if you like, you can have newlines in descriptions.

  ARGS:
      city-location : String  can also use hyphens

  SUBCOMMANDS:
      testsubsubcommand  does this even do anything?
      version            Prints the version.
      help               Prints this message.
  -/
  #eval testSubCmd1.extendedHelp
    == "testsubcommand1 [0.0.1]\na properly short description\n\nUSAGE:\n    testsubcommand1 [SUBCOMMAND] [FLAGS] <city-location>\n\nFLAGS:\n    -h, --help          Prints this message.\n    --version           Prints the version.\n    --launch-the-nukes  please avoid passing this flag at all costs.\n                        if you like, you can have newlines in descriptions.\n\nARGS:\n    city-location : String  can also use hyphens\n\nSUBCOMMANDS:\n    testsubsubcommand  does this even do anything?\n    version            Prints the version.\n    help               Prints this message."
end Info

section ModuleName
  def ModuleName.parse? : String → Option ModuleName := ParseableType.parse?

  section ValidInputs
    #eval ModuleName.parse? "Lean.Mathlib.Data" == some `Lean.Mathlib.Data
    #eval ModuleName.parse? "F00Bar.BarF00" == some `F00Bar.BarF00
    #eval ModuleName.parse? "foo_bar" == some `foo_bar
    #eval ModuleName.parse? "asdf.«foo bar»" == some `asdf.«foo bar»
    #eval ModuleName.parse? "«1».«2»" == some `«1».«2»
    #eval ModuleName.parse? "« »" == some `« »
    #eval ModuleName.parse? "Lean/Mathlib/Data/Afile.lean" == some `Lean.Mathlib.Data.Afile
    #eval ModuleName.parse? "Foo.lean" == some `Foo
    #eval ModuleName.parse? "..lean" == some `«.»
    #eval ModuleName.parse? " .lean" == some `« »
    #eval ModuleName.parse? " /Foo.lean" == some `« ».Foo
  end ValidInputs

  section InvalidInputs
    #eval ModuleName.parse? "" == none
    #eval ModuleName.parse? "." == none
    #eval ModuleName.parse? ".asdf" == none
    #eval ModuleName.parse? "asdf." == none
    #eval ModuleName.parse? "1.asdf" == none
    #eval ModuleName.parse? "asdf.1" == none
    #eval ModuleName.parse? "1asdf" == none
    #eval ModuleName.parse? "foo bar" == none
    #eval ModuleName.parse? "foo,bar" == none
    #eval ModuleName.parse? "«»" == none
    #eval ModuleName.parse? "x.«»" == none
    #eval ModuleName.parse? ".lean" == none
    #eval ModuleName.parse? "/foo.lean" == none
  end InvalidInputs
end ModuleName

end Cli



=== LEAN SOURCE: ImportGraph.lean ===
import ImportGraph.Cli
import ImportGraph.Imports
import ImportGraph.CurrentModule
import ImportGraph.Lean.Name
import ImportGraph.RequiredModules



=== LEAN SOURCE: ImportGraphTest.lean ===
import ImportGraphTest.Imports
import ImportGraphTest.Dot
import ImportGraphTest.Unused
import ImportGraphTest.Used



=== LEAN SOURCE: Main.lean ===
import ImportGraph.Cli

/-!
# `lake exe graph`

This is a replacement for Lean 3's `leanproject import-graph` tool.
-/

open Cli

/-- Setting up command line options and help text for `lake exe graph`. -/
def graph : Cmd := `[Cli|
  graph VIA importGraphCLI; ["0.0.3"]
  "Generate representations of a Lean import graph. \
   By default generates the import graph up to `Mathlib`. \
   If you are working in a downstream project, use `lake exe graph --to MyProject`."

  FLAGS:
    "show-transitive";         "Show transitively redundant edges."
    "to" : Array ModuleName;   "Only show the upstream imports of the specified modules."
    "from" : Array ModuleName; "Only show the downstream dependencies of the specified modules."
    "exclude-meta";            "Exclude any files starting with `Mathlib.[Tactic|Lean|Util|Mathport]`."
    "include-direct";          "Include directly imported files from other libraries"
    "include-deps";            "Include used files from other libraries (not including Lean itself and `std`)"
    "include-std";             "Include used files from the Lean standard library (implies `--include-deps`)"
    "include-lean";            "Include used files from Lean itself (implies `--include-deps` and `--include-std`)"
    "mark-package";            "Visually highlight the package containing the first `--to` target (used in combination with some `--include-XXX`)."

  ARGS:
    ...outputs : String;  "Filename(s) for the output. \
      If none are specified, generates `import_graph.dot`. \
      Automatically chooses the format based on the file extension. \
      Currently supported formats are `.dot`, `.gexf`, `.html`, \
      and if you have `graphviz` installed then any supported output format is allowed."
]


/-- `lake exe graph` -/
def main (args : List String) : IO UInt32 :=
  graph.validate args



=== LEAN SOURCE: Cli.lean ===
/-
Copyright (c) 2023 Kim Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Cli.Basic
import Batteries.Lean.IO.Process
import ImportGraph.CurrentModule
import ImportGraph.Imports
import ImportGraph.Lean.Name
import ImportGraph.Gexf

open Cli

open Lean
open ImportGraph

/--
Write an import graph, represented as a `NameMap (Array Name)` to the ".dot" graph format.
* Nodes in the `unused` set will be shaded light gray.
* If `markedPackage` is provided:
  * Nodes which start with the `markedPackage` will be highlighted in green and drawn closer together.
  * Edges from `directDeps` into the module are highlighted in green
  * Nodes in `directDeps` are marked with a green border and green text.
-/
def asDotGraph
    (graph : NameMap (Array Name))
    (unused : NameSet := {})
    (header := "import_graph")
    (markedPackage : Option Name := none)
    (directDeps : NameSet := {})
    (from_ to : NameSet := {}):
    String := Id.run do

  let mut lines := #[s!"digraph \"{header}\" " ++ "{"]
  for (n, is) in graph do
    let shape := if from_.contains n then "invhouse" else if to.contains n then "house" else "ellipse"
    if markedPackage.isSome ∧ directDeps.contains n then
      -- note: `fillcolor` defaults to `color` if not specified
      let fill := if unused.contains n then "#e0e0e0" else "white"
      lines := lines.push s!"  \"{n}\" [style=filled, fontcolor=\"#4b762d\", color=\"#71b144\", fillcolor=\"{fill}\", penwidth=2, shape={shape}];"
    else if unused.contains n then
      lines := lines.push s!"  \"{n}\" [style=filled, fillcolor=\"#e0e0e0\", shape={shape}];"
    else if isInModule markedPackage n then
      -- mark node
      lines := lines.push s!"  \"{n}\" [style=filled, fillcolor=\"#96ec5b\", shape={shape}];"
    else
      lines := lines.push s!"  \"{n}\" [shape={shape}];"
    -- Then add edges
    for i in is do
      if isInModule markedPackage n then
        if isInModule markedPackage i then
          -- draw the main project close together
          lines := lines.push s!"  \"{i}\" -> \"{n}\" [weight=100];"
        else
          -- mark edges into the main project
          lines := lines.push s!"  \"{i}\" -> \"{n}\" [penwidth=2, color=\"#71b144\"];"
      else
        lines := lines.push s!"  \"{i}\" -> \"{n}\";"
  lines := lines.push "}"
  return "\n".intercalate lines.toList

open Lean Core System

open IO.FS IO.Process Name in
/-- Implementation of the import graph command line program. -/
def importGraphCLI (args : Cli.Parsed) : IO UInt32 := do
  -- file extensions that should be created
  let extensions : Std.HashSet String := match args.variableArgsAs! String with
    | #[] => {"dot"}
    | outputs => outputs.foldl (fun acc (o : String) =>
      match FilePath.extension o with
       | none => acc.insert "dot"
       | some "gexf" => acc.insert "gexf"
       | some "html" => acc.insert "gexf"
       -- currently all other formats are handled by passing the `.dot` file to
       -- graphviz
       | some _ => acc.insert "dot" ) {}

  let to ← match args.flag? "to" with
  | some to => pure <| to.as! (Array ModuleName)
  | none => pure #[← getCurrentModule]
  let from? : Option (Array Name) := match args.flag? "from" with
  | some fr => some <| fr.as! (Array ModuleName)
  | none => none
  initSearchPath (← findSysroot)

  unsafe Lean.enableInitializersExecution
  let outFiles ← try unsafe withImportModules (to.map ({module := ·})) {} (trustLevel := 1024) fun env => do
    let toModule := ImportGraph.getModule to[0]!
    let mut graph := env.importGraph
    let unused ←
      match args.flag? "to"  with
      | some _ =>
        let ctx := { options := {}, fileName := "<input>", fileMap := default }
        let state := { env }
        let used ← Prod.fst <$> (CoreM.toIO (env.transitivelyRequiredModules' to.toList) ctx state)
        let used := used.fold (init := NameSet.empty) (fun s _ t => s ∪ t)
        pure <| graph.fold (fun acc n _ => if used.contains n then acc else acc.insert n) NameSet.empty
      | none => pure NameSet.empty
    if let Option.some f := from? then
      graph := graph.downstreamOf (NameSet.ofArray f)
    let includeLean := args.hasFlag "include-lean"
    let includeStd := args.hasFlag "include-std" || includeLean
    let includeDeps := args.hasFlag "include-deps" || includeStd
    -- Note: `includeDirect` does not imply `includeDeps`!
    -- e.g. if the package contains `import Lean`, the node `Lean` will be included with
    -- `--include-direct`, but not included with `--include-deps`.
    let includeDirect := args.hasFlag "include-direct"

    -- `directDeps` contains files which are not in the package
    -- but directly imported by a file in the package
    let directDeps : NameSet := graph.fold (init := .empty) (fun acc n deps =>
      if toModule.isPrefixOf n then
        deps.filter (!toModule.isPrefixOf ·) |>.foldl (init := acc) NameSet.insert
      else
        acc)

    let filter (n : Name) : Bool :=
      toModule.isPrefixOf n ||
      bif isPrefixOf `Std n then includeStd else
      bif isPrefixOf `Lean n || isPrefixOf `Init n then includeLean else
      includeDeps
    let filterDirect (n : Name) : Bool :=
      includeDirect ∧ directDeps.contains n

    graph := graph.filterMap (fun n i =>
      if filter n then
        -- include node regularly
        (i.filter (fun m => filterDirect m || filter m))
      else if filterDirect n then
        -- include node as direct dependency; drop any further deps.
        some #[]
      else
        -- not included
        none)
    if args.hasFlag "exclude-meta" then
      -- Mathlib-specific exclusion of tactics
      let filterMathlibMeta : Name → Bool := fun n => (
        isPrefixOf `Mathlib.Tactic n ∨
        isPrefixOf `Mathlib.Lean n ∨
        isPrefixOf `Mathlib.Mathport n ∨
        isPrefixOf `Mathlib.Util n)
      graph := graph.filterGraph filterMathlibMeta (replacement := `«Mathlib.Tactics»)
    if !args.hasFlag "show-transitive" then
      graph := graph.transitiveReduction

    let markedPackage : Option Name := if args.hasFlag "mark-package" then toModule else none

    -- Create all output files that are requested
    let mut outFiles : Std.HashMap String String := {}
    if extensions.contains "dot" then
      let dotFile := asDotGraph graph (unused := unused) (markedPackage := markedPackage) (directDeps := directDeps)
        (to := NameSet.ofArray to) (from_ := NameSet.ofArray (from?.getD #[]))
      outFiles := outFiles.insert "dot" dotFile
    if extensions.contains "gexf" then
      -- filter out the top node as it makes the graph less pretty
      let graph₂ := match args.flag? "to" with
        | none => graph.filter (fun n _ => !to.contains n)
        | some _ => graph
      let gexfFile := Graph.toGexf graph₂ toModule env
      outFiles := outFiles.insert "gexf" gexfFile
    return outFiles

  catch err =>
    -- TODO: try to build `to` first, so this doesn't happen
    throw <| IO.userError <| s!"{err}\nIf the error above says `object file ... does not exist`, " ++
      s!"try if `lake build {" ".intercalate (to.toList.map Name.toString)}` fixes the issue"
    throw err

  match args.variableArgsAs! String with
  | #[] => writeFile "import_graph.dot" (outFiles["dot"]!)
  | outputs => for o in outputs do
     let fp : FilePath := o
     match fp.extension with
     | none
     | "dot" => writeFile fp (outFiles["dot"]!)
     | "gexf" => IO.FS.writeFile fp (outFiles["gexf"]!)
     | "html" =>
        let gexfFile := (outFiles["gexf"]!)
        -- use `html-template/index.html` and insert any dependencies to make it
        -- a stand-alone HTML file.
        -- note: changes in `index.html` might need to be reflected here!
        let exeDir := (FilePath.parent (← IO.appPath) |>.get!) / ".." / ".." / ".."
        let mut html ← IO.FS.readFile <| ← IO.FS.realPath ( exeDir / "html-template" / "index.html")
        for dep in (#[
            "vendor" / "sigma.min.js",
            "vendor" / "graphology.min.js",
            "vendor" / "graphology-library.min.js" ] : Array FilePath) do
          let depContent ← IO.FS.readFile <| ← IO.FS.realPath (exeDir / "html-template" / dep)
          html := html.replace s!"<script src=\"{dep}\"></script>" s!"<script>{depContent}</script>"
        -- inline the graph data
        -- note: changes in `index.html` might need to be reflected here!
        let escapedFile := gexfFile.replace "\n" "" |>.replace "\"" "\\\""
        let toFormatted : String := ", ".intercalate <| (to.map toString).toList
        html := html
          |>.replace "fetch(\"imports.gexf\").then((res) => res.text()).then(render_gexf)" s!"render_gexf(\"{escapedFile}\")"
          |>.replace "<h1>Import Graph</h1>" s!"<h1>Import Graph for {toFormatted}</h1>"
          |>.replace "<title>import graph</title>" s!"<title>import graph for {toFormatted}</title>"
        IO.FS.writeFile fp html
     | some ext => try
        _ ← runCmdWithInput "dot" #["-T" ++ ext, "-o", o] (outFiles["dot"]!)
      catch ex =>
        IO.eprintln s!"Error occurred while writing out {fp}."
        IO.eprintln s!"Make sure you have `graphviz` installed and the file is writable."
        throw ex
  return 0



=== LEAN SOURCE: CurrentModule.lean ===
/-
Copyright (c) 2023 Jon Eugster. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jon Eugster
-/
import Lake.Load.Manifest

open Lean (Name)

namespace ImportGraph

/-- Read the name of the main module from the `lake-manifest`. -/
def getCurrentModule : IO Name := do

  match (← Lake.Manifest.load? ⟨"lake-manifest.json"⟩) with
  | none =>
    -- TODO: should this be caught?
    pure .anonymous
  | some manifest =>
    -- TODO: This assumes that the `package` and the default `lean_lib`
    -- have the same name up to capitalisation.
    -- Would be better to read the `.defaultTargets` from the
    -- `← getRootPackage` from `Lake`, but I can't make that work with the monads involved.
    return manifest.name.capitalize

/--
Helper which only returns `true` if the `module` is provided and the name `n` lies
inside it.
 -/
def isInModule (module : Option Name) (n : Name) := match module with
  | some m => m.isPrefixOf n
  | none => false



=== LEAN SOURCE: Gexf.lean ===
/-
Copyright (c) 2024 Jon Eugster. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jon Eugster
-/

import Lean.Data.Name
import Lean.AuxRecursor
import Lean.MonadEnv
import Lean.Meta.Match.MatcherInfo

open Lean

namespace ImportGraph

open Elab Meta in
/-- Filter Lean internal declarations -/
def isBlackListed (env : Environment) (declName : Name) : Bool :=
  declName == ``sorryAx
  || declName matches .str _ "inj"
  || declName matches .str _ "noConfusionType"
  || declName.isInternalDetail
  || isAuxRecursor env declName
  || isNoConfusion env declName
  || isRecCore env declName
  || isMatcherCore env declName

/-- Get number of non-blacklisted declarations per file. -/
def getNumberOfDeclsPerFile (env: Environment) : NameMap Nat :=
  env.const2ModIdx.fold (fun acc n (idx : ModuleIdx) =>
    let mod := env.allImportedModuleNames[idx]!
    if isBlackListed env n then acc else acc.insert mod ((acc.findD mod 0) + 1)
    ) {}

/-- Gexf template for a node in th graph. -/
def Gexf.nodeTemplate (n module : Name) (size : Nat) := s!"<node id=\"{n}\" label=\"{n}\"><attvalues><attvalue for=\"0\" value=\"{size}\" /><attvalue for=\"1\" value=\"{module.isPrefixOf n}\" /></attvalues></node>\n          "

/-- Gexf template for an edge in the graph -/
def Gexf.edgeTemplate (source target : Name) := s!"<edge source=\"{source}\" target=\"{target}\" id=\"{source}--{target}\" />\n          "

open Gexf in
/-- Creates a `.gexf` file of the graph, see https://gexf.net/

Metadata can be stored in forms of attributes, currently we record the following:
* `decl_count` (Nat): number of declarations in the file
* `in_module` (Bool): whether the file belongs to the main module
  (used to strip the first part of the name when displaying).
-/
def Graph.toGexf (graph : NameMap (Array Name)) (module : Name) (env : Environment) : String :=
  let sizes : NameMap Nat := getNumberOfDeclsPerFile env
  let nodes : String := graph.fold (fun acc n _ => acc ++ nodeTemplate n module (sizes.findD n 0)) ""
  let edges : String := graph.fold (fun acc n i => acc ++ (i.foldl (fun b j => b ++ edgeTemplate j n) "")) ""
  s!"<?xml version='1.0' encoding='utf-8'?>
    <gexf xmlns=\"http://www.gexf.net/1.2draft\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\" version=\"1.2\">
      <meta>
        <creator>Lean ImportGraph</creator>
      </meta>
      <graph defaultedgetype=\"directed\" mode=\"static\" name=\"\">
        <attributes mode=\"static\" class=\"node\">
          <attribute id=\"0\" title=\"decl_count\" type=\"long\" />
          <attribute id=\"1\" title=\"in_module\" type=\"boolean\" />
        </attributes>
        <nodes>
          {nodes.trim}
        </nodes>
        <edges>
          {edges.trim}
        </edges>
      </graph>
    </gexf>
    "



=== LEAN SOURCE: Imports.lean ===
/-
Copyright (c) 2023 Kim Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Lean.Elab.Command
import Lean.Util.SearchPath
import Lean.Server.GoTo
import Lean.Widget.UserWidget
import ImportGraph.RequiredModules

/-!
# Tools for analyzing imports.

Provides the commands

* `#redundant_imports` which lists any transitively redundant imports in the current module.
* `#min_imports` which attempts to construct a minimal set of imports for the declarations
  in the current file.
  (Must be run at the end of the file. Tactics and macros may result in incorrect output.)
* `#find_home decl` suggests files higher up the import hierarchy to which `decl` could be moved.
-/

open Lean

namespace Lean.Environment

/--
Find the imports of a given module.
-/
def importsOf (env : Environment) (n : Name) : Array Name :=
  if n = env.header.mainModule then
    env.header.imports.map Import.module
  else match env.getModuleIdx? n with
    | .some idx => env.header.moduleData[idx.toNat]!.imports.map Import.module |>.erase `Init
    | .none => #[]

/--
Construct the import graph of the current file.
-/
partial def importGraph (env : Environment) : NameMap (Array Name) :=
  let main := env.header.mainModule
  let imports := env.header.imports.map Import.module
  imports.foldl (fun m i => process env i m) (({} : NameMap _).insert main imports)
    |>.erase Name.anonymous
where
  process (env) (i) (m) : NameMap (Array Name) :=
    if m.contains i then
      m
    else
      let imports := env.importsOf i
      imports.foldr (fun i m => process env i m) (m.insert i imports)

/--
Return the redundant imports (i.e. those transitively implied by another import)
amongst a candidate list of imports.
-/
partial def findRedundantImports (env : Environment) (imports : Array Name) : NameSet :=
  let run := visit env.importGraph imports
  let (_, seen) := imports.foldl (fun ⟨v, s⟩ n => run v s n) ({}, {})
  seen
where
  visit (Γ) (targets) (visited) (seen) (n) : NameSet × NameSet :=
    if visited.contains n then
      (visited, seen)
    else
      let imports := (Γ.find? n).getD #[]
      let (visited', seen') := imports.foldl (fun ⟨v, s⟩ t => visit Γ targets v s t) (visited, seen)
      (visited'.insert n,
        imports.foldl (fun s t => if targets.contains t then s.insert t else s) seen')

end Lean.Environment

namespace Lean.NameMap

/--
Compute the transitive closure of an import graph.
-/
partial def transitiveClosure (m : NameMap (Array Name)) : NameMap NameSet :=
  m.fold (fun r n i => process r n i) {}
where
  process (r : NameMap NameSet) (n : Name) (i : Array Name) : NameMap NameSet :=
    if r.contains n then
      r
    else
      let r' := i.foldr (fun i r => process r i ((m.find? i).getD #[])) r
      let t := i.foldr
        (fun j s => ((r'.find? j).getD {}).fold NameSet.insert s)
        (RBTree.ofList i.toList)
      r'.insert n t

/--
Compute the transitive reduction of an import graph.

Typical usage is `transitiveReduction (← importGraph)`.
-/
def transitiveReduction (m : NameMap (Array Name)) : NameMap (Array Name) :=
  let c := transitiveClosure m
  m.fold (fun r n a =>
    r.insert n (a.foldr (fun i b => b.filter (fun j => ! ((c.find? i).getD {}).contains j)) a)) {}

/-- Restrict an import graph to only the downstream dependencies of some set of modules. -/
def downstreamOf (m : NameMap (Array Name)) (targets : NameSet) : NameMap (Array Name) :=
  let tc := transitiveClosure m
  let P (n : Name) := targets.contains n || ((tc.find? n).getD {}).any fun j => targets.contains j
  m.fold (init := {}) fun r n i =>
    if P n then
      r.insert n (i.filter P)
    else
      r

/-- Restrict an import graph to only the transitive imports of some set of modules. -/
def upstreamOf (m : NameMap (Array Name)) (targets : NameSet) : NameMap (Array Name) :=
  let tc := transitiveClosure m
  let P (n : Name) := targets.contains n || targets.any fun t => ((tc.find? t).getD {}).contains n
  m.fold (init := {}) fun r n i =>
    if P n then
      r.insert n (i.filter P)
    else
      r

/--
Filter the list of edges `… → node` inside `graph` by the function `filter`.

Any such upstream node `source` where `filter source` returns true will be replaced
by all its upstream nodes. This results in a list of all unfiltered nodes
in the `graph` that either had an edge to `node`
or had an indirect edge to `node` going through filtered nodes.

Will panic if the `node` is not in the `graph`.
-/
partial
def transitiveFilteredUpstream (node : Name) (graph : NameMap (Array Name))
    (filter : Name → Bool) (replacement : Option Name := none):
    List Name :=
  (graph.find! node).toList.flatMap fun source =>
    ( if filter source then
        -- Add the transitive edges going through the filtered node `source`.
        -- If there is a replacement node, add an additional edge `repl → node`.
        match replacement with
        | none => transitiveFilteredUpstream source graph filter
        | some repl => .cons repl <| transitiveFilteredUpstream source graph filter
      -- If the node is not filtered, we leave the edge `source → node` intact.
      else [source]).eraseDups

/--
Filters the `graph` removing all nodes where `filter n` returns false. Additionally,
replace edges from removed nodes by all the transitive edges.

This means there is a path between two nodes in the filtered graph iff there exists
such a path in the original graph.

If the optional `(replacement : Name)` is provided, a corresponding node will be
added together with edges to all nodes which had an incoming edge from any
filtered node.
-/
def filterGraph (graph : NameMap (Array Name)) (filter : Name → Bool)
    (replacement : Option Name := none) : NameMap (Array Name) :=
  -- Create a list of all files imported by any of the filtered files
  -- and remove all imports starting with `Mathlib` to avoid loops.
  let replImports := graph.toList.flatMap
    (fun ⟨n, i⟩ => if filter n then i.toList else [])
    |>.eraseDups |>.filter (¬ Name.isPrefixOf `Mathlib ·) |>.toArray
  let graph := graph.filterMap (fun node edges => if filter node then none else some <|
    -- If the node `node` is not filtered, modify the `edges` going into `node`.
    edges.toList.flatMap (fun source =>
      if filter source then
        transitiveFilteredUpstream source graph filter (replacement := replacement)
      else [source]) |>.eraseDups.toArray)
  -- Add a replacement node if provided.
  match replacement with
  | none => graph
  | some repl => graph.insert repl replImports

end Lean.NameMap

/--
Returns a `List (Name × List Name)` with a key for each module `n` in `amongst`,
whose corresponding value is the list of modules `m` in `amongst` which are transitively imported by `n`,
but no declaration in `n` makes use of a declaration in `m`.
-/
def unusedTransitiveImports (amongst : List Name) (verbose : Bool := false) : CoreM (List (Name × List Name)) := do
  let env ← getEnv
  let transitiveImports := env.importGraph.transitiveClosure
  let transitivelyRequired ← env.transitivelyRequiredModules' amongst verbose
  amongst.mapM fun n => do return (n,
    let unused := (transitiveImports.find? n).getD {} \ (transitivelyRequired.find? n |>.getD {})
    amongst.filter (fun m => unused.contains m))

def Core.withImportModules (modules : Array Name) {α} (f : CoreM α) : IO α := do
  initSearchPath (← findSysroot)
  unsafe Lean.withImportModules (modules.map (fun m => {module := m})) {} (trustLevel := 1024)
    fun env => Prod.fst <$> Core.CoreM.toIO
        (ctx := { fileName := "<CoreM>", fileMap := default }) (s := { env := env }) do f

/--
Return the redundant imports (i.e. those transitively implied by another import)
of a specified module (or the current module if `none` is specified).
-/
def redundantImports (n? : Option Name := none) : CoreM NameSet := do
  let env ← getEnv
  let imports := env.importsOf (n?.getD (env.header.mainModule))
  return env.findRedundantImports imports

/--
List the imports in this file which can be removed
because they are transitively implied by another import.
-/
elab "#redundant_imports" : command => do
  let redundant := (← Elab.Command.liftCoreM do redundantImports)
  if redundant.isEmpty then
    logInfo "No transitively redundant imports found."
  else
    logInfo <| "Found the following transitively redundant imports:\n" ++
      m!"{Format.joinSep redundant.toList "\n"}"

/--
Return the names of the modules in which constants used in the current file were defined,
with modules already transitively imported removed.

Note that this will *not* account for tactics and syntax used in the file,
so the results may not suffice as imports.
-/
def Lean.Environment.minimalRequiredModules (env : Environment) : Array Name :=
  let required := env.requiredModules.toArray.erase env.header.mainModule
  let redundant := findRedundantImports env required
  required.filter fun n => ¬ redundant.contains n

/--
Try to compute a minimal set of imports for this file,
by analyzing the declarations.

This must be run at the end of the file,
and is not aware of syntax and tactics,
so the results will likely need to be adjusted by hand.
-/
elab "#min_imports" : command => do
  let imports := (← getEnv).minimalRequiredModules.qsort (·.toString < ·.toString)
    |>.toList.map (fun n => "import " ++ n.toString)
  logInfo <| Format.joinSep imports "\n"

-- deprecated since 2024-07-06
elab "#minimize_imports" : command => do
  logWarning m!"'#minimize_imports' is deprecated: please use '#min_imports'"
  Elab.Command.elabCommand (← `(command| #min_imports))

/--
Find locations as high as possible in the import hierarchy
where the named declaration could live.
-/
def Lean.Name.findHome (n : Name) (env : Option Environment) : CoreM NameSet := do
  let current? := match env with | some env => env.header.mainModule | _ => default
  let required := (← n.requiredModules).toArray.erase current?
  let imports := (← getEnv).importGraph.transitiveClosure
  let mut candidates : NameSet := {}
  for (n, i) in imports do
    if required.all fun r => n == r || i.contains r then
      candidates := candidates.insert n
  for c in candidates do
    for i in candidates do
      if imports.find? i |>.getD {} |>.contains c then
        candidates := candidates.erase i
  return candidates

open Server in
/-- Tries to resolve the module `modName` to a source file URI.
This has to be done in the Lean server
since the `Environment` does not keep track of source URIs. -/
@[server_rpc_method]
def getModuleUri (modName : Name) : RequestM (RequestTask Lsp.DocumentUri) :=
  RequestM.asTask do
    let some uri ← documentUriFromModule? modName
      | throw $ RequestError.invalidParams s!"couldn't find URI for module '{modName}'"
    return uri

structure GoToModuleLinkProps where
  modName : Name
  deriving Server.RpcEncodable

/-- When clicked, this widget component jumps to the source of the module `modName`,
assuming a source URI can be found for the module. -/
@[widget_module]
def GoToModuleLink : Widget.Module where
  javascript := "
    import * as React from 'react'
    import { EditorContext, useRpcSession } from '@leanprover/infoview'

    export default function(props) {
      const ec = React.useContext(EditorContext)
      const rs = useRpcSession()
      return React.createElement('a',
        {
          className: 'link pointer dim',
          onClick: async () => {
            try {
              const uri = await rs.call('getModuleUri', props.modName)
              ec.revealPosition({ uri, line: 0, character: 0 })
            } catch {}
          }
        },
        props.modName)
    }
  "

open Elab Command in
/--
Find locations as high as possible in the import hierarchy
where the named declaration could live.
Using `#find_home!` will forcefully remove the current file.
Note that this works best if used in a file with `import Mathlib`.

The current file could still be the only suggestion, even using `#find_home! lemma`.
The reason is that `#find_home!` scans the import graph below the current file,
selects all the files containing declarations appearing in `lemma`, excluding
the current file itself and looks for all least upper bounds of such files.

For a simple example, if `lemma` is in a file importing only `A.lean` and `B.lean` and
uses one lemma from each, then `#find_home! lemma` returns the current file.
-/
elab "#find_home" bang:"!"? n:ident : command => do
  let stx ← getRef
  let mut homes : Array MessageData := #[]
  let n ← liftCoreM <| realizeGlobalConstNoOverloadWithInfo n
  let env? ← bang.mapM fun _ => getEnv
  for modName in (← Elab.Command.liftCoreM do n.findHome env?) do
    let p : GoToModuleLinkProps := { modName }
    homes := homes.push $ .ofWidget
      (← liftCoreM $ Widget.WidgetInstance.ofHash
        GoToModuleLink.javascriptHash $
        Server.RpcEncodable.rpcEncode p)
      (toString modName)
  logInfoAt stx[0] m!"{homes}"



=== LEAN SOURCE: RequiredModules.lean ===
/-
Copyright (c) 2023 Kim Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Lean.CoreM
import Lean.Data.NameMap
import Lean.Environment
import Lean.Util.FoldConsts
import Batteries.Data.NameSet

namespace Lean

/-- Return the name of the module in which a declaration was defined. -/
def Environment.getModuleFor? (env : Environment) (declName : Name) : Option Name :=
  match env.getModuleIdxFor? declName with
  | none =>
    if env.constants.map₂.contains declName then
      env.header.mainModule
    else
      none
  | some idx => env.header.moduleNames[idx.toNat]!

open Lean

/--
Return the names of the modules in which constants used in the specified declaration were defined.

Note that this will *not* account for tactics and syntax used in the declaration,
so the results may not suffice as imports.
-/
def Name.requiredModules (n : Name) : CoreM NameSet := do
  let env ← getEnv
  let mut requiredModules : NameSet := {}
  let ci ← getConstInfo n
  for n in ci.getUsedConstantsAsSet do
    match env.getModuleFor? n with
    | some m =>
      if ¬ (`Init).isPrefixOf m then
        requiredModules := requiredModules.insert m
    | none => pure ()
  return requiredModules

/--
Return the names of the constants used in the specified declarations,
and the constants they use transitively.
-/
def NameSet.transitivelyUsedConstants (s : NameSet) : CoreM NameSet := do
  let mut usedConstants : NameSet := {}
  let mut toProcess : NameSet := s
  while !toProcess.isEmpty do
    let current := toProcess.min.get!
    toProcess := toProcess.erase current
    usedConstants := usedConstants.insert current
    for m in (← getConstInfo current).getUsedConstantsAsSet do
      if !usedConstants.contains m then
        toProcess := toProcess.insert m
  return usedConstants

/--
Return the names of the constants used in the specified declaration,
and the constants they use transitively.
-/
def Name.transitivelyUsedConstants (n : Name) : CoreM NameSet :=
  NameSet.transitivelyUsedConstants {n}

/--
Return the names of the modules in which constants used transitively
in the specified declarations were defined.

Note that this will *not* account for tactics and syntax used in the declaration,
so the results may not suffice as imports.
-/
def NameSet.transitivelyRequiredModules (s : NameSet) (env : Environment) : CoreM NameSet := do
  let mut requiredModules : NameSet := {}
  for m in (← s.transitivelyUsedConstants) do
    if let some module := env.getModuleFor? m then
      requiredModules := requiredModules.insert module
  return requiredModules

/--
Return the names of the modules in which constants used transitively
in the specified declaration were defined.

Note that this will *not* account for tactics and syntax used in the declaration,
so the results may not suffice as imports.
-/
def Name.transitivelyRequiredModules (n : Name) (env : Environment) : CoreM NameSet :=
  NameSet.transitivelyRequiredModules {n} env

/--
Finds all constants defined in the specified module,
and identifies all modules containing constants which are transitively required by those constants.
-/
def Environment.transitivelyRequiredModules (env : Environment) (module : Name) : CoreM NameSet := do
  let constants := env.constants.map₁.values.map (·.name)
    |>.filter (! ·.isInternal)
    |>.filter (env.getModuleFor? · = some module)
  (NameSet.ofList constants).transitivelyRequiredModules env

/--
Computes all the modules transitively required by the specified modules.
Should be equivalent to calling `transitivelyRequiredModules` on each module, but shares more of the work.
-/
partial def Environment.transitivelyRequiredModules' (env : Environment) (modules : List Name) (verbose : Bool := false) :
    CoreM (NameMap NameSet) := do
  let N := env.header.moduleNames.size
  let mut c2m : NameMap (BitVec N) := {}
  let mut pushed : NameSet := {}
  let mut result : NameMap NameSet := {}
  for m in modules do
    if verbose then
      IO.println s!"Processing module {m}"
    let mut r : BitVec N := 0
    for n in env.header.moduleData[(env.header.moduleNames.idxOf? m).getD 0]!.constNames do
      if ! n.isInternal then
      -- This is messy: Mathlib is big enough that writing a recursive function causes a stack overflow.
      -- So we use an explicit stack instead. We visit each constant twice:
      -- once to record the constants transitively used by it,
      -- and again to record the modules which defined those constants.
      let mut stack : List (Name × Option NameSet) := [⟨n, none⟩]
      pushed := pushed.insert n
      while !stack.isEmpty do
        match stack with
        | [] => panic! "Stack is empty"
        | (c, used?) :: tail =>
          stack := tail
          match used? with
          | none =>
            if !c2m.contains c then
              let used := (← getConstInfo c).getUsedConstantsAsSet
              stack := ⟨c, some used⟩ :: stack
              for u in used do
                if !pushed.contains u then
                  stack := ⟨u, none⟩ :: stack
                  pushed := pushed.insert u
          | some used =>
            let usedModules : NameSet :=
              used.fold (init := {}) (fun s u => if let some m := env.getModuleFor? u then s.insert m else s)
            let transitivelyUsed : BitVec N :=
              used.fold (init := toBitVec usedModules) (fun s u => s ||| ((c2m.find? u).getD 0))
            c2m := c2m.insert c transitivelyUsed
      r := r ||| ((c2m.find? n).getD 0)
    result := result.insert m (toNameSet r)
  return result
where
  toBitVec {N : Nat} (s : NameSet) : BitVec N :=
    s.fold (init := 0) (fun b n => b ||| BitVec.twoPow _ ((env.header.moduleNames.idxOf? n).getD 0))
  toNameSet {N : Nat} (b : BitVec N) : NameSet :=
    env.header.moduleNames.zipIdx.foldl (init := {}) (fun s (n, i) => if b.getLsbD i then s.insert n else s)

/--
Return the names of the modules in which constants used in the current file were defined.

Note that this will *not* account for tactics and syntax used in the file,
so the results may not suffice as imports.
-/
def Environment.requiredModules (env : Environment) : NameSet := Id.run do
  let localConstantInfos := env.constants.map₂
  let mut requiredModules : NameSet := {}
  for (_, ci) in localConstantInfos do
    for n in ci.getUsedConstantsAsSet do
      match env.getModuleFor? n with
      | some m =>
        if ¬ (`Init).isPrefixOf m then
          requiredModules := requiredModules.insert m
      | none => pure ()
  return requiredModules

end Lean



=== LEAN SOURCE: UnusedTransitiveImports.lean ===
import ImportGraph.Imports

open Lean

/--
`lake exe unused_transitive_imports m1 m2 ...`

For each specified module `m`, prints those `n` from the argument list which are imported, but transitively unused by `m`.
-/
def main (args : List String) : IO UInt32 := do
  let (flags, args) := args.partition (fun s => s.startsWith "-")
  let mut modules := args.map (fun s => s.toName)
  Core.withImportModules modules.toArray do
    let r ← unusedTransitiveImports modules (verbose := flags.contains "-v" || flags.contains "--verbose")
    for (n, u) in r do
      IO.println s!"{n}: {u}"
    return 0



=== LEAN SOURCE: Name.lean ===
/-
Copyright (c) 2023 Jon Eugster. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jon Eugster
-/
import Lean.Data.Name
import Lean.CoreM
import Lean.Meta.Match.MatcherInfo
import Std.Data.HashMap

/-!
TODO: Some declarations in this file are duplicated from mathlib, but especially `isBlacklisted`
is deemed to specific for upstreaming to Batteries.
-/
namespace Lean.Name

open Lean Meta Elab

namespace ImportGraph

/-- Note: copied from `Mathlib.Lean.Name` -/
private def isBlackListed (declName : Name) : CoreM Bool := do
  if declName.toString.startsWith "Lean" then return true
  let env ← getEnv
  pure $ declName.isInternalDetail
   || isAuxRecursor env declName
   || isNoConfusion env declName
  <||> isRec declName <||> isMatcher declName

/--
Retrieve all names in the environment satisfying a predicate.

Note: copied from `Mathlib.Lean.Name`
-/
def allNames (p : Name → Bool) : CoreM (Array Name) := do
  (← getEnv).constants.foldM (init := #[]) fun names n _ => do
    if p n && !(← isBlackListed n) then
      return names.push n
    else
      return names

/--
Retrieve all names in the environment satisfying a predicate,
gathered together into a `HashMap` according to the module they are defined in.

Note: copied from `Mathlib.Lean.Name`
-/
def allNamesByModule (p : Name → Bool) : CoreM (Std.HashMap Name (Array Name)) := do
  (← getEnv).constants.foldM (init := ∅) fun names n _ => do
    if p n && !(← isBlackListed n) then
      let some m ← findModuleOf? n | return names
      -- TODO use `modify`/`alter` when available
      match names[m]? with
      | some others => return names.insert m (others.push n)
      | none => return names.insert m #[n]
    else
      return names

/-- Returns the very first part of a name: for `ImportGraph.Lean.NameMap` it
returns `ImportGraph`.
-/
def getModule (name : Name) (s := "") : Name :=
  match name with
    | .anonymous => .mkSimple s
    | .num _ _ => panic s!"panic in `getModule`: did not expect numerical name: {name}."
    | .str pre s => getModule pre s



=== LEAN SOURCE: Dot.lean ===
import ImportGraph.Cli

def readFile (path : System.FilePath) : IO String :=
  IO.FS.readFile path

def runGraphCommand : IO Unit := do
  let _ ← IO.Process.output {
    cmd := "lake"
    args := #["exe", "graph", "--to", "ImportGraphTest.Used", "ImportGraphTest/produced.dot"]
  }

def compareOutputs (expected : String) (actual : String) : IO Bool := do
  let expectedLines := expected.splitOn "\n" |>.filter (·.trim.length > 0) |>.map String.trim
  let actualLines := actual.splitOn "\n" |>.filter (·.trim.length > 0) |>.map String.trim
  pure (expectedLines == actualLines)

/-- info: Test passed: The graph command output matches the expected.dot file. -/
#guard_msgs in
#eval show IO Unit from do
  runGraphCommand
  let expectedOutput ← readFile "ImportGraphTest/expected.dot"
  let actualOutput ← readFile "ImportGraphTest/produced.dot"
  let isEqual ← compareOutputs expectedOutput actualOutput
  if isEqual then
    IO.println "Test passed: The graph command output matches the expected.dot file."
  else
    IO.println "Test failed: The graph command output does not match the expected.dot file."
    IO.println s!"Expected:\n{expectedOutput}"
    IO.println s!"Actual:\n{actualOutput}"



=== LEAN SOURCE: Imports.lean ===
import ImportGraph.Imports
import ImportGraph.RequiredModules
import ImportGraphTest.Used

open Lean

def importTest : CoreM Unit := do
  let x ← redundantImports
  logInfo s!"{x.toArray}"

/--
info: Found the following transitively redundant imports:
ImportGraph.RequiredModules
-/
#guard_msgs in
#redundant_imports

/-- info: import ImportGraph.Imports -/
#guard_msgs in
#min_imports

/-- info: [ImportGraph.Imports] -/
#guard_msgs in
#find_home importTest

open Elab Command


/--
Reports unused transitive imports amongst the specified modules.
-/
elab "#unused_transitive_imports" names:ident* : command => do
  let imports := (names.map Syntax.getId).toList
  let unused ← Elab.Command.liftCoreM (unusedTransitiveImports imports)
  for (n, u) in unused do
    if !u.isEmpty then
    logInfo <| s!"Transitively unused imports of {n}:\n{"\n".intercalate (u.map (fun i => s!"  {i}"))}"

/--
info: Transitively unused imports of Init.System.IO:
  Init.Control.StateRef
  Init.Control.Reader
-/
#guard_msgs in
#unused_transitive_imports Init.Control.StateRef Init.System.IO Init.Control.Reader Init.Control.Basic

/--
info: Transitively unused imports of ImportGraphTest.Used:
  ImportGraphTest.Unused
-/
#guard_msgs in
#unused_transitive_imports ImportGraphTest.Used ImportGraphTest.Unused Init.Control.Reader

elab "#transitivelyRequiredModules_test" : command => do
  let env ← getEnv
  let unused ← liftCoreM <| env.transitivelyRequiredModules `ImportGraph.RequiredModules
  logInfo s!"{unused.contains `Init.Data.Option.Lemmas}"

/-- info: true -/
#guard_msgs in
#transitivelyRequiredModules_test

elab "#my_test" : command => do
  -- functionality of `#redundant_imports`
  let expected := #[`ImportGraph.RequiredModules]
  let ri ← liftCoreM redundantImports
  if (ri.toArray != expected) then
    logError s!"Failed: `redundantImports` returned {ri.toArray} instead of {expected}"

  -- functionality of `#find_home`
  let expected := #[`ImportGraph.Imports]
  let mi ← liftCoreM <| Lean.Name.findHome `importTest none
  if (mi.toArray != expected) then
      logError s!"Failed: `findHome` returned {mi.toArray} instead of {expected}"

  -- functionality of `#find_home!`
  let expected := #[`ImportGraph.Imports]
  let mi! ← liftCoreM <| Lean.Name.findHome `importTest (← getEnv)
  if (mi!.toArray != expected) then
      logError s!"Failed: `findHome (!)` returned {mi!.toArray} instead of {expected}"

  logInfo s!"{mi.toArray}"
  pure ()

/-- info: #[ImportGraph.Imports] -/
#guard_msgs in
#my_test



=== LEAN SOURCE: Unused.lean ===
/-!
This is a dummy file to test that unused files are shaded in the import graph.
-/



=== LEAN SOURCE: Used.lean ===
import ImportGraphTest.Unused



=== LEAN SOURCE: LeanSearchClient.lean ===
-- This module serves as the root of the `LeanSearchClient` library.
-- Import modules here that should be built as part of the library.
import LeanSearchClient.Basic
import LeanSearchClient.Syntax
import LeanSearchClient.LoogleSyntax



=== LEAN SOURCE: LeanSearchClientTest.lean ===
import LeanSearchClientTest.Examples
import LeanSearchClientTest.MoogleExamples



=== LEAN SOURCE: Basic.lean ===
import Lean.Data.Options

register_option leansearch.queries : Nat :=
  { defValue := 6
    group := "leansearch"
    descr := "Number of results requested from leansearch (default 6)" }

register_option moogle.queries : Nat :=
  { defValue := 6
    group := "moogle"
    descr := "Number of results requested from moogle (default 6)" }

register_option loogle.queries : Nat :=
  { defValue := 6
    group := "loogle"
    descr := "Number of results requested from loogle (default 6)" }

register_option statesearch.queries : Nat :=
  { defValue := 6
    group := "statesearch"
    descr := "Number of results requested from statesearch (default 6)" }

register_option statesearch.revision : String :=
  { defValue := s!"v{Lean.versionString}"
    group := "statesearch"
    descr := "Revision of LeanStateSearch to use" }

register_option leansearchclient.useragent : String :=
  { defValue := "LeanSearchClient"
    group := "leansearchclient"
    descr := "Username for leansearchclient" }

register_option leansearchclient.backend : String :=
  { defValue := "leansearch"
    group := "leansearchclient"
    descr := "The backend to use by default, one of leansearch and moogle" }



=== LEAN SOURCE: LoogleSyntax.lean ===
/-
Copyright (c) 2024 Siddhartha Gadgil. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Siddhartha Gadgil
-/
import Lean.Elab.Tactic.Meta
import Lean.Parser.Basic
import Lean.Meta.Tactic.TryThis
import LeanSearchClient.Basic
import LeanSearchClient.Syntax

/-!
# LeanSearchClient

In this file, we provide syntax for search using the [leansearch API](https://leansearch.net/)
and the [Moogle API](https://www.moogle.ai/api/search).
from within Lean. It allows you to search for Lean tactics and theorems using natural language.

We provide syntax to make a query and generate `TryThis` options to click or
use a code action to use the results.

The queries are of three forms. For leansearch these are:

* `Command` syntax: `#leansearch "search query"` as a command.
* `Term` syntax: `#leansearch "search query"` as a term.
* `Tactic` syntax: `#leansearch "search query"` as a tactic.

The corresponding syntax for Moogle is:

* `Command` syntax: `#moogle "search query"` as a command.
* `Term` syntax: `#moogle "search query"` as a term.
* `Tactic` syntax: `#moogle "search query"` as a tactic.

In all cases results are displayed in the Lean Infoview and clicking these replaces the query text.
In the cases of a query for tactics only valid tactics are displayed.
-/

namespace LeanSearchClient

open Lean Meta Elab Tactic Parser Term

structure LoogleMatch where
  name : String
  type : String
  doc? : Option String
  deriving Inhabited, Repr

inductive LoogleResult where
  | empty : LoogleResult
  | success : Array SearchResult →  LoogleResult
  | failure (error : String) (suggestions: Option <| List String) : LoogleResult
  deriving Inhabited, Repr

initialize loogleCache :
  IO.Ref (Std.HashMap (String × Nat) LoogleResult) ← IO.mkRef {}

def getLoogleQueryJson (s : String) (num_results : Nat := 6) :
  CoreM <| LoogleResult:= do
  let s := s.splitOn "/-" |>.getD 0 s |>.trim
  let s := s.replace "\n" " "
  let cache ← loogleCache.get
  match cache.get? (s, num_results) with
  | some r => return r
  | none => do
    let apiUrl := (← IO.getEnv "LEANSEARCHCLIENT_LOOGLE_API_URL").getD "https://loogle.lean-lang.org/json"
    let s' := System.Uri.escapeUri s
    if s.trim == "" then
      return LoogleResult.empty
    let q := apiUrl ++ s!"?q={s'}"
    let out ← IO.Process.output {cmd := "curl", args := #["-X", "GET", "--user-agent", ← useragent,  q]}
    match Json.parse out.stdout with
    | Except.error _ =>
      IO.throwServerError s!"Could not contact Loogle server"
    | Except.ok js =>
    let result? := js.getObjValAs?  Json "hits" |>.toOption
    let result? := result?.filter fun js => js != Json.null
    match result? with
      | some result => do
          match result.getArr? with
          | Except.ok arr =>
            let arr :=  arr[0:num_results] |>.toArray
            let xs : Array SearchResult ←
              arr.mapM fun js => do
                let doc? := js.getObjValAs? String "doc" |>.toOption
                let name? := js.getObjValAs? String "name"
                let type? := js.getObjValAs? String "type"
                match name?, type? with
                | Except.ok name, Except.ok type =>
                  pure <| {name := name, type? := some type, docString? := doc?, doc_url? := none, kind? := none}
                | _, _ =>
                  IO.throwServerError s!"Could not obtain name and type from {js}"
            loogleCache.modify fun m => m.insert (s, num_results) (LoogleResult.success xs)
            return LoogleResult.success xs
          | Except.error e => IO.throwServerError s!"Could not obtain array from {js}; error: {e}, query :{s'}, hits: {result}"
      | _ =>
        let error? := js.getObjValAs? String "error"
        match error? with
          | Except.ok error =>
            let suggestions? :=
              js.getObjValAs? (List String) "suggestions" |>.toOption
            loogleCache.modify fun m => m.insert (s, num_results) (LoogleResult.failure error suggestions?)
            pure <| LoogleResult.failure error suggestions?
          | _ =>
            IO.throwServerError s!"Could not obtain hits or error from {js}"

-- #eval getLoogleQueryJson "List"

def loogleUsage : String :=
  "Loogle Usage

Loogle finds definitions and lemmas in various ways:

By constant:
🔍 Real.sin
finds all lemmas whose statement somehow mentions the sine function.

By lemma name substring:
🔍 \"differ\"
finds all lemmas that have \"differ\" somewhere in their lemma name.

By subexpression:
🔍 _ * (_ ^ _)
finds all lemmas whose statements somewhere include a product where the second argument is raised to some power.

The pattern can also be non-linear, as in
🔍 Real.sqrt ?a * Real.sqrt ?a

If the pattern has parameters, they are matched in any order. Both of these will find List.map:
🔍 (?a -> ?b) -> List ?a -> List ?b
🔍 List ?a -> (?a -> ?b) -> List ?b

By main conclusion:
🔍 |- tsum _ = _ * tsum _
finds all lemmas where the conclusion (the subexpression to the right of all → and ∀) has the given shape.

As before, if the pattern has parameters, they are matched against the hypotheses of the lemma in any order; for example,
🔍 |- _ < _ → tsum _ < tsum _
will find tsum_lt_tsum even though the hypothesis f i < g i is not the last.

If you pass more than one such search filter, separated by commas Loogle will return lemmas which match all of them. The search
🔍 Real.sin, \"two\", tsum, _ * _, _ ^ _, |- _ < _ → _
woould find all lemmas which mention the constants Real.sin and tsum, have \"two\" as a substring of the lemma name, include a product and a power somewhere in the type, and have a hypothesis of the form _ < _ (if there were any such lemmas). Metavariables (?a) are assigned independently in each filter."

open Lean.Parser
private def unicode_turnstile := nonReservedSymbol "⊢ "
private def ascii_turnstile := nonReservedSymbol "|- "

/-- The turnstyle uesd bin `#find`, unicode or ascii allowed -/
syntax turnstyle := patternIgnore(unicode_turnstile <|> ascii_turnstile)

/-- a single `#find` filter. The `term` can also be an ident or a strlit,
these are distinguished in `parseFindFilters` -/
syntax loogle_filter := (turnstyle term) <|> term

/-- The argument to `#find`, a list of filters -/
syntax loogle_filters := loogle_filter,*

open Command
/--
Search [Loogle](https://loogle.lean-lang.org/json) from within Lean. This can be used as a command, term or tactic as in the following examples. In the case of a tactic, only valid tactics are displayed.


```lean
#loogle List ?a → ?a

example := #loogle List ?a → ?a

example : 3 ≤ 5 := by
  #loogle Nat.succ_le_succ
  sorry

```

## Loogle Usage

Loogle finds definitions and lemmas in various ways:

By constant:
🔍 Real.sin
finds all lemmas whose statement somehow mentions the sine function.

By lemma name substring:
🔍 \"differ\"
finds all lemmas that have \"differ\" somewhere in their lemma name.

By subexpression:
🔍 _ * (_ ^ _)
finds all lemmas whose statements somewhere include a product where the second argument is raised to some power.

The pattern can also be non-linear, as in
🔍 Real.sqrt ?a * Real.sqrt ?a

If the pattern has parameters, they are matched in any order. Both of these will find List.map:
🔍 (?a -> ?b) -> List ?a -> List ?b
🔍 List ?a -> (?a -> ?b) -> List ?b

By main conclusion:
🔍 |- tsum _ = _ * tsum _
finds all lemmas where the conclusion (the subexpression to the right of all → and ∀) has the given shape.

As before, if the pattern has parameters, they are matched against the hypotheses of the lemma in any order; for example,
🔍 |- _ < _ → tsum _ < tsum _
will find tsum_lt_tsum even though the hypothesis f i < g i is not the last.

If you pass more than one such search filter, separated by commas Loogle will return lemmas which match all of them. The search
🔍 Real.sin, \"two\", tsum, _ * _, _ ^ _, |- _ < _ → _
woould find all lemmas which mention the constants Real.sin and tsum, have \"two\" as a substring of the lemma name, include a product and a power somewhere in the type, and have a hypothesis of the form _ < _ (if there were any such lemmas). Metavariables (?a) are assigned independently in each filter.

You can modify the Loogle server URL by setting the `LEANSEARCHCLIENT_LOOGLE_API_URL` environment variable.
-/
syntax (name := loogle_cmd) "#loogle" loogle_filters  : command
@[command_elab loogle_cmd] def loogleCmdImpl : CommandElab := fun stx =>
  Command.liftTermElabM do
  match stx with
  | `(command| #loogle $args:loogle_filters) =>
    let s := (← PrettyPrinter.ppCategory ``loogle_filters args).pretty
    let result ← getLoogleQueryJson s
    match result with
    | LoogleResult.empty =>
      logInfo loogleUsage
    | LoogleResult.success xs =>
      let suggestions := xs.map SearchResult.toCommandSuggestion
      if suggestions.isEmpty then
        logWarning "Loogle search returned no results"
        logInfo loogleUsage
      else
        TryThis.addSuggestions stx suggestions (header := s!"Loogle Search Results")
    | LoogleResult.failure error suggestions? =>
      logWarning s!"Loogle search failed with error: {error}"
      logInfo loogleUsage
      match suggestions? with
      | some suggestions =>
        let suggestions : List TryThis.Suggestion :=
          suggestions.map fun s =>
            {suggestion := .string s!"#loogle {s}"}
        unless suggestions.isEmpty do
          TryThis.addSuggestions stx suggestions.toArray (header := s!"Did you maybe mean")
      | none => pure ()
  | _ => throwUnsupportedSyntax

@[inherit_doc loogle_cmd]
syntax (name := just_loogle_cmd)(priority := low) "#loogle" loogle_filters  : command
@[command_elab just_loogle_cmd] def justLoogleCmdImpl : CommandElab := fun _ => return


@[inherit_doc loogle_cmd]
syntax (name := loogle_term) "#loogle" loogle_filters  : term
@[term_elab loogle_term] def loogleTermImpl : TermElab :=
    fun stx expectedType? => do
  match stx with
  | `(#loogle $args) =>
    let s := (← PrettyPrinter.ppCategory ``loogle_filters args).pretty
    let result ← getLoogleQueryJson s
    match result with
    | LoogleResult.empty =>
      logInfo loogleUsage
    | LoogleResult.success xs =>
      let suggestions := xs.map SearchResult.toTermSuggestion
      if suggestions.isEmpty then
        logWarning "Loogle search returned no results"
        logInfo loogleUsage
      else
        TryThis.addSuggestions stx suggestions (header := s!"Loogle Search Results")

    | LoogleResult.failure error suggestions? =>
      logWarning s!"Loogle search failed with error: {error}"
      logInfo loogleUsage
      match suggestions? with
      | some suggestions =>
        let suggestions : List TryThis.Suggestion :=
          suggestions.map fun s =>
            let s := s.replace "\"" "\\\""
            {suggestion := .string s!"#loogle \"{s}\""}
        unless suggestions.isEmpty do
          TryThis.addSuggestions stx suggestions.toArray (header := s!"Did you maybe mean")
      | none => pure ()
    defaultTerm expectedType?
  | _ => throwUnsupportedSyntax

@[inherit_doc loogle_cmd]
syntax (name := loogle_tactic)
  withPosition("#loogle" (ppSpace colGt (loogle_filters)))  : tactic
@[tactic loogle_tactic] def loogleTacticImpl : Tactic :=
    fun stx => do
  match stx with
  | `(tactic|#loogle $args) =>
    let s := (← PrettyPrinter.ppCategory ``loogle_filters args).pretty
    let result ← getLoogleQueryJson s
    match result with
    | LoogleResult.empty =>
      logInfo loogleUsage
    | LoogleResult.success xs => do
      let suggestionGroups := xs.map fun sr =>
         (sr.name, sr.toTacticSuggestions)
      for (name, sg) in suggestionGroups do
        let sg ←  sg.filterM fun s =>
          let sugTxt := s.suggestion
          match sugTxt with
          | .string s => do
            let stx? := runParserCategory (← getEnv) `tactic s
            match stx? with
            | Except.ok stx =>
              let n? ← checkTactic (← getMainTarget) stx
              return n?.isSome
            | Except.error _ =>
              pure false
          | _ => pure false
        unless sg.isEmpty do
          TryThis.addSuggestions stx sg (header := s!"From: {name}")
    | LoogleResult.failure error suggestions? =>
      logWarning s!"Loogle search failed with error: {error}"
      logInfo loogleUsage
      match suggestions? with
      | some suggestions =>
        let suggestions : List TryThis.Suggestion :=
          suggestions.map fun s =>
            {suggestion := .string s!"#loogle \"{s}\""}
        unless suggestions.isEmpty do
          TryThis.addSuggestions stx suggestions.toArray (header := s!"Did you maybe mean")
      | none => pure ()
  | _ => throwUnsupportedSyntax

syntax (name := just_loogle_tactic)(priority := low) "#loogle"  : tactic
@[tactic just_loogle_tactic] def justLoogleTacticImpl : Tactic :=
  fun _ => do
    logWarning loogleUsage

example : 3 ≤ 5 := by
  -- #loogle Nat.succ_le_succ
  decide

-- example := #loogle List ?a → ?b

end LeanSearchClient

-- #loogle "sin", Real → Real, |- Real



=== LEAN SOURCE: Syntax.lean ===
/-
Copyright (c) 2024 Siddhartha Gadgil. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Siddhartha Gadgil
-/
import Lean.Elab.Tactic.Meta
import Lean.Meta.Tactic.TryThis
import LeanSearchClient.Basic

/-!
# LeanSearchClient

In this file, we provide syntax for search using the [leansearch API](https://leansearch.net/)
and the [Moogle API](https://www.moogle.ai/api/search).
from within Lean. It allows you to search for Lean tactics and theorems using natural language.

We provide syntax to make a query and generate `TryThis` options to click or
use a code action to use the results.

The queries are of three forms. For leansearch these are:

* `Command` syntax: `#leansearch "search query"` as a command.
* `Term` syntax: `#leansearch "search query"` as a term.
* `Tactic` syntax: `#leansearch "search query"` as a tactic.

The corresponding syntax for Moogle is:

* `Command` syntax: `#moogle "search query"` as a command.
* `Term` syntax: `#moogle "search query"` as a term.
* `Tactic` syntax: `#moogle "search query"` as a tactic.

In all cases results are displayed in the Lean Infoview and clicking these replaces the query text.
In the cases of a query for tactics only valid tactics are displayed.
-/

namespace LeanSearchClient

open Lean Meta Elab Tactic Parser Term

def useragent : CoreM String :=
  return leansearchclient.useragent.get (← getOptions)

initialize leanSearchCache :
  IO.Ref (Std.HashMap (String × Nat) (Array Json)) ← IO.mkRef {}

initialize moogleCache :
  IO.Ref (Std.HashMap String (Array Json)) ← IO.mkRef {}

initialize stateSearchCache :
  IO.Ref (Std.HashMap (String × Nat × String) (Array Json)) ← IO.mkRef {}

def getLeanSearchQueryJson (s : String) (num_results : Nat := 6) : CoreM <| Array Json := do
  let cache ← leanSearchCache.get
  match cache.get? (s, num_results) with
  | some jsArr => return jsArr
  | none => do
    let apiUrl := (← IO.getEnv "LEANSEARCHCLIENT_LEANSEARCH_API_URL").getD "https://leansearch.net/search"
    -- let q := apiUrl ++ s!"?query={s'}&num_results={num_results}"
    let js := Json.mkObj [("query", Json.arr #[toJson s]), ("num_results", num_results)]
    let out ← IO.Process.output {cmd := "curl", args := #["-X", "POST", apiUrl, "--user-agent", ← useragent, "-H", "accept: application/json", "-H", "Content-Type: application/json", "--data", js.pretty]}
    let js ← match Json.parse out.stdout with
      | Except.ok js => pure js
      | Except.error e => IO.throwServerError s!"Could not parse response from LeanSearch server, error: {e}"
    match js.getArr? with
    | Except.ok jsArr => do
      match jsArr[0]!.getArr?  with
        | Except.ok jsArr =>
        leanSearchCache.modify fun m => m.insert (s, num_results) jsArr
        return jsArr
        | Except.error e => IO.throwServerError s!"Could not obtain inner array from {js}; error: {e}"
    | Except.error e =>
      IO.throwServerError s!"Could not obtain outer array from {js}; error: {e}"

def getMoogleQueryJson (s : String) (num_results : Nat := 6) : CoreM <| Array Json := do
  let cache ← moogleCache.get
  match cache.get? s with
  | some jsArr => return jsArr
  | none => do
  let apiUrl := (← IO.getEnv "LEANSEARCHCLIENT_MOOGLE_API_URL").getD "https://www.moogle.ai/api/search"
  let data := Json.arr
    #[Json.mkObj [("isFind", false), ("contents", s)]]
  let out ← IO.Process.output {cmd := "curl", args := #[apiUrl, "-H", "content-type: application/json",  "--user-agent", ← useragent, "--data", data.pretty]}
  match Json.parse out.stdout with
  | Except.error _ =>
    throwError m!"Could not contact Moogle server"
  | Except.ok js =>
  let result? := js.getObjValAs?  Json "data"
  match result? with
    | Except.ok result =>
        match result.getArr? with
        | Except.ok arr =>
            moogleCache.modify fun m => m.insert s arr
            return arr[0:num_results]
        | Except.error e => IO.throwServerError s!"Could not obtain array from {js}; error: {e}"
    | _ => IO.throwServerError s!"Could not obtain data from {js}"

def getStateSearchQueryJson (s : String) (num_results : Nat := 6) (rev : String) : CoreM <| Array Json := do
  let cache ← stateSearchCache.get
  match cache.get? (s, num_results, rev) with
  | .some jsArr => return jsArr
  | none => do
    let apiUrl := (← IO.getEnv "LEANSEARCHCLIENT_LEANSTATESEARCH_API_URL").getD "https://premise-search.com/api/search"
    let s' := System.Uri.escapeUri s
    let q := apiUrl ++ s!"?query={s'}&results={num_results}&rev={rev}"
    let out ← IO.Process.output {cmd := "curl", args := #["-X", "GET", "--user-agent", ← useragent, q]}
    let js ← match Json.parse out.stdout |>.toOption with
      | some js => pure js
      | none => IO.throwServerError s!"Could not contact LeanStateSearch server"
    match js.getArr? with
    | Except.ok jsArr => do
      stateSearchCache.modify fun m => m.insert (s, num_results, rev) jsArr
      return jsArr
    | Except.error e =>
      let .ok err := js.getObjVal? "error"
        | IO.throwServerError s!"{e}"
      let .ok schema := js.getObjVal? "schema"
        | IO.throwServerError s!"{e}"
      let .ok desc := schema.getObjVal? "description"
        | IO.throwServerError s!"{e}"
      IO.throwServerError s!"error: {err}\ndescription: {desc}"

structure SearchResult where
  name : String
  type? : Option String
  docString? : Option String
  doc_url? : Option String
  kind? : Option String
  deriving Repr

namespace SearchResult

def ofLeanSearchJson? (js : Json) : Option SearchResult :=
  match js.getObjVal? "result" with
  | Except.ok js =>
    match js.getObjValAs? (List String) "name" with
    | Except.ok nameList =>
        let name := nameList.foldl (init := "") fun acc s =>
          if acc == "" then s else acc ++ "." ++ s
        let type? := js.getObjValAs? String "type" |>.toOption
        let doc? := js.getObjValAs? String "docstring" |>.toOption
        let doc? := doc?.filter fun s => s != ""
        let docurl? := js.getObjValAs? String "doc_url" |>.toOption
        let kind? := js.getObjValAs? String "kind" |>.toOption
        some {name := name, type? := type?, docString? := doc?, doc_url? := docurl?, kind? := kind?}
    | _ =>
      none
  | _ =>
    none

def ofMoogleJson? (js : Json) : MetaM <| Option SearchResult :=
  match js.getObjValAs? String "declarationName" with
  | Except.ok name => do
      let type? ←
        try
          let info ←  getConstInfo name.toName
          let fmt ← PrettyPrinter.ppExpr info.type
          pure <| some fmt.pretty
        catch _ =>
          pure none
      let doc? := js.getObjValAs? String "declarationDocString" |>.toOption
      let doc? := doc?.filter fun s => s != ""
      let kind? := js.getObjValAs? String "declarationType" |>.toOption
      return some {name := name, type? := type?, docString? := doc?, doc_url? := none, kind? := kind?}
  | _ => return none

def ofLoogleJson? (js : Json) : Option SearchResult :=
  match js.getObjValAs? String "name" with
  | Except.ok name =>
      let type? := js.getObjValAs? String "type" |>.toOption
      let doc? := js.getObjValAs? String "doc" |>.toOption
      let doc? := doc?.filter fun s => s != ""
      some {name := name, type? := type?, docString? := doc?, doc_url? := none, kind? := none}
  | _ => none

def ofStateSearchJson? (js : Json) : Option SearchResult :=
  match js.getObjValAs? String "name" with
  | Except.ok name =>
      let type? := js.getObjValAs? String "formal_type" |>.toOption
      let doc? := js.getObjValAs? String "doc" |>.toOption
      let doc? := doc?.filter fun s => s != ""
      let kind? := js.getObjValAs? String "kind" |>.toOption
      some {name := name, type? := type?, docString? := doc?, doc_url? := none, kind? := kind?}
  | _ => none

def toCommandSuggestion (sr : SearchResult) : TryThis.Suggestion :=
  let data := match sr.docString? with
    | some doc => s!"{doc}\n"
    | none => ""
  {suggestion := s!"#check {sr.name}", postInfo? := sr.type?.map fun s => s!" -- {s}" ++ s!"\n{data}"}

def toTermSuggestion (sr : SearchResult) : TryThis.Suggestion :=
  match sr.type? with
  | some type => {suggestion := sr.name, postInfo? := some s!" (type: {type})"}
  | none => {suggestion := sr.name}

def toTacticSuggestions (sr : SearchResult) : Array TryThis.Suggestion :=
  match sr.type? with
  | some type => #[{suggestion := s!"apply {sr.name}"},
        {suggestion := s!"have : {type} := {sr.name}"},
        {suggestion := s!"rw [{sr.name}]"},
        {suggestion := s!"rw [← {sr.name}]" }]
  | none => #[]

end SearchResult


def queryLeanSearch (s : String) (num_results : Nat) :
    MetaM <| Array SearchResult := do
  let jsArr ← getLeanSearchQueryJson s num_results
  logInfo m!"LeanSearch: {jsArr}"
  return jsArr.filterMap SearchResult.ofLeanSearchJson?

def queryMoogle (s : String) (num_results : Nat) :
    MetaM <| Array SearchResult := do
  let jsArr ← getMoogleQueryJson s num_results
  let jsArr := jsArr.take num_results
  jsArr.filterMapM SearchResult.ofMoogleJson?

def queryStateSearch (s : String) (num_results : Nat) (rev : String):
    MetaM <| Array SearchResult := do
  let jsArr ← getStateSearchQueryJson s num_results rev
  return jsArr.filterMap SearchResult.ofStateSearchJson?

def defaultTerm (expectedType? : Option Expr) : MetaM Expr := do
  match expectedType? with
  | some type =>
    if !type.hasExprMVar then
      mkAppM ``sorryAx #[type, mkConst ``false]
    else
      return mkConst ``True.intro
  | none => return mkConst ``True.intro

def checkTactic (target : Expr) (tac : Syntax) :
    TermElabM (Option Nat) :=
  withoutModifyingState do
  try
    let goal ← mkFreshExprMVar target
    let (goals, _) ←
      withoutErrToSorry do
      Elab.runTactic goal.mvarId! tac
        (← read) (← get)
    return some goals.length
  catch _ =>
    return none

structure SearchServer where
  name : String
  url : String
  cmd: String
  query : String → Nat → MetaM  (Array SearchResult)
  queryNum : CoreM Nat

def leanSearchServer : SearchServer :=
  {name := "LeanSearch", cmd := "#leansearch", url := "https://leansearch.net/",
   query := queryLeanSearch, queryNum := return leansearch.queries.get (← getOptions)}

def moogleServer : SearchServer :=
  {name := "Moogle", cmd := "#moogle", url := "https://www.moogle.ai/api/search",
   query := queryMoogle, queryNum := return moogle.queries.get (← getOptions)}

instance : Inhabited SearchServer := ⟨leanSearchServer⟩

namespace SearchServer

def getCommandSuggestions (ss : SearchServer) (s : String) (num_results : Nat) :
    MetaM (Array TryThis.Suggestion) := do
  let suggestions ← ss.query s num_results
  return suggestions.map SearchResult.toCommandSuggestion

def getTermSuggestions (ss : SearchServer) (s : String) (num_results : Nat) :
    MetaM (Array TryThis.Suggestion) := do
  let suggestions ← ss.query s num_results
  return suggestions.map SearchResult.toTermSuggestion

def getTacticSuggestionGroups (ss : SearchServer) (s : String) (num_results : Nat) :
    MetaM (Array (String ×  Array TryThis.Suggestion)) := do
  let suggestions ← ss.query s num_results
  return suggestions.map fun sr =>
    let fullName := match sr.type? with
      | some type => s!"{sr.name} (type: {type})"
      | none => sr.name
    (fullName, sr.toTacticSuggestions)

def incompleteSearchQuery (ss : SearchServer) : String :=
  s!"{ss.cmd} query should be a string that ends with a `.` or `?`.\n\
   Note this command sends your query to an external service at {ss.url}."

open Command
def searchCommandSuggestions (ss: SearchServer) (stx: Syntax) (s: TSyntax `str) : CommandElabM Unit := Command.liftTermElabM do
    let s := s.getString
    if s.endsWith "." || s.endsWith "?" then
      let suggestions ← ss.getCommandSuggestions s (← ss.queryNum)
      TryThis.addSuggestions stx suggestions (header := s!"{ss.name} Search Results")
    else
      logWarning <| ss.incompleteSearchQuery

def searchTermSuggestions (ss: SearchServer) (stx: Syntax)
    (s: TSyntax `str)  : TermElabM Unit := do
    let s := s.getString
    if s.endsWith "." || s.endsWith "?" then
      let suggestions ← ss.getTermSuggestions s (← ss.queryNum)
      TryThis.addSuggestions stx suggestions (header := s!"{ss.name} Search Results")
    else
      logWarning <| ss.incompleteSearchQuery

def searchTacticSuggestions (ss: SearchServer) (stx: Syntax) (s: TSyntax `str) : TacticM Unit := do
    let s := s.getString
    if s.endsWith "." || s.endsWith "?" then
      let target ← getMainTarget
      let suggestionGroups ←
          ss.getTacticSuggestionGroups s (← ss.queryNum)
      for (name, sg) in suggestionGroups do
        let sg ←  sg.filterM fun s =>
          let sugTxt := s.suggestion
          match sugTxt with
          | .string s => do
            let stx? := runParserCategory (← getEnv) `tactic s
            match stx? with
            | Except.ok stx =>
              let n? ← checkTactic target stx
              return n?.isSome
            | Except.error _ =>
              pure false
          | _ => pure false
        unless sg.isEmpty do
          TryThis.addSuggestions stx sg (header := s!"From: {name}")
    else
      logWarning <| ss.incompleteSearchQuery

end SearchServer

open Command
/-- Search [LeanSearch](https://leansearch.net/) from within Lean.
Queries should be a string that ends with a `.` or `?`. This works as a command, as a term
and as a tactic as in the following examples. In tactic mode, only valid tactics are displayed.

```lean
#leansearch "If a natural number n is less than m, then the successor of n is less than the successor of m."

example := #leansearch "If a natural number n is less than m, then the successor of n is less than the successor of m."

example : 3 ≤ 5 := by
  #leansearch "If a natural number n is less than m, then the successor of n is less than the successor of m."
  sorry
```

You can modify the LeanSearch URL by setting the `LEANSEARCHCLIENT_LEANSEARCH_API_URL` environment variable.
 -/
syntax (name := leansearch_search_cmd) "#leansearch" (str)? : command

@[command_elab leansearch_search_cmd] def leanSearchCommandImpl : CommandElab :=
  fun stx =>
  match stx with
  | `(command| #leansearch $s) => do
    leanSearchServer.searchCommandSuggestions  stx s
  | `(command| #leansearch) => do
    logWarning leanSearchServer.incompleteSearchQuery
  | _ => throwUnsupportedSyntax

/-- Search [Moogle](https://www.moogle.ai/api/search) from within Lean.
Queries should be a string that ends with a `.` or `?`. This works as a command, as a term
and as a tactic as in the following examples. In tactic mode, only valid tactics are displayed.

```lean
#moogle "If a natural number n is less than m, then the successor of n is less than the successor of m."

example := #moogle "If a natural number n is less than m, then the successor of n is less than the successor of m."

example : 3 ≤ 5 := by
  #moogle "If a natural number n is less than m, then the successor of n is less than the successor of m."
  sorry
```

You can modify the Moogle URL by setting the `LEANSEARCHCLIENT_MOOGLE_API_URL` environment variable.
 -/
syntax (name := moogle_search_cmd) "#moogle" (str)? : command

@[command_elab moogle_search_cmd] def moogleCommandImpl : CommandElab :=
  fun stx =>
  match stx with
  | `(command| #moogle $s) => do
    moogleServer.searchCommandSuggestions  stx s
  | `(command| #moogle) => do
    logWarning moogleServer.incompleteSearchQuery
  | _ => throwUnsupportedSyntax

/-- Search either [Moogle](https://www.moogle.ai/api/search) or [LeanSearch]((https://leansearch.net/)) from within Lean, depending on the option `leansearchclient.backend`.
Queries should be a string that ends with a `.` or `?`. This works as a command, as a term
and as a tactic as in the following examples. In tactic mode, only valid tactics are displayed.

```lean
#search "If a natural number n is less than m, then the successor of n is less than the successor of m."

example := #search "If a natural number n is less than m, then the successor of n is less than the successor of m."

example : 3 ≤ 5 := by
  #search "If a natural number n is less than m, then the successor of n is less than the successor of m."
  sorry

In tactic mode, if the query string is not supplied, then [LeanStateSearch](https://premise-search.com) is queried based on the goal state.
```
 -/
syntax (name := search_cmd) "#search" (str)? : command
@[command_elab search_cmd] def searchCommandImpl : CommandElab :=
  fun stx => do
  let server ←  match leansearchclient.backend.get (← getOptions) with
  | "leansearch" => pure leanSearchServer
  | "moogle" => pure moogleServer
  | s => throwError s!"Invalid backend {s}, should be one of leansearch and moogle"
  match stx with
  | `(command| #search $s) => do
    server.searchCommandSuggestions  stx s
  | `(command| #search) => do
    logWarning server.incompleteSearchQuery
  | _ => throwUnsupportedSyntax


@[inherit_doc leansearch_search_cmd]
syntax (name := leansearch_search_term) "#leansearch" (str)? : term

@[term_elab leansearch_search_term] def leanSearchTermImpl : TermElab :=
  fun stx expectedType? => do
  match stx with
  | `(#leansearch $s) =>
    leanSearchServer.searchTermSuggestions stx s
    defaultTerm expectedType?
  | `(#leansearch) => do
    logWarning leanSearchServer.incompleteSearchQuery
    defaultTerm expectedType?
  | _ => throwUnsupportedSyntax

@[inherit_doc moogle_search_cmd]
syntax (name := moogle_search_term) "#moogle" (str)? : term

@[term_elab moogle_search_term] def moogleTermImpl : TermElab :=
  fun stx expectedType? => do
  match stx with
  | `(#moogle $s) =>
    moogleServer.searchTermSuggestions stx s
    defaultTerm expectedType?
  | `(#moogle) => do
    logWarning moogleServer.incompleteSearchQuery
    defaultTerm expectedType?
  | _ => throwUnsupportedSyntax

@[inherit_doc search_cmd]
syntax (name := search_term) "#search" (str)? : term

@[term_elab search_term] def searchTermImpl : TermElab :=
  fun stx expectedType? => do
  let server ←  match leansearchclient.backend.get (← getOptions) with
  | "leansearch" => pure leanSearchServer
  | "moogle" => pure moogleServer
  | s => throwError s!"Invalid backend {s}, should be one of leansearch and moogle"
  match stx with
  | `(#search $s) =>
    server.searchTermSuggestions stx s
    defaultTerm expectedType?
  | `(#search) => do
    logWarning server.incompleteSearchQuery
    defaultTerm expectedType?
  | _ => throwUnsupportedSyntax

@[inherit_doc leansearch_search_cmd]
syntax (name := leansearch_search_tactic)
  withPosition("#leansearch" (colGt str)?) : tactic

@[tactic leansearch_search_tactic] def leanSearchTacticImpl : Tactic :=
  fun stx => withMainContext do
  match stx with
  | `(tactic|#leansearch $s) =>
    leanSearchServer.searchTacticSuggestions stx s
  | `(tactic|#leansearch) => do
    logWarning leanSearchServer.incompleteSearchQuery
  | _ => throwUnsupportedSyntax

@[inherit_doc moogle_search_cmd]
syntax (name := moogle_search_tactic)
  withPosition("#moogle" (colGt str)?) : tactic

@[tactic moogle_search_tactic] def moogleTacticImpl : Tactic :=
  fun stx => withMainContext do
  match stx with
  | `(tactic|#moogle $s) =>
    moogleServer.searchTacticSuggestions stx s
  | `(tactic|#moogle) => do
    logWarning moogleServer.incompleteSearchQuery
  | _ => throwUnsupportedSyntax

/-- Search [LeanStateSearch](https://premise-search.com) from within Lean.
Your current main goal is sent as query. The revision to search can be set
using the `statesearch.revision` option. The number of results can be set
using the `statesearch.queries` option.

Hint: If you want to modify the query, you need to use the web interface.

```lean
set_option statesearch.queries 1
set_option statesearch.revision "v4.16.0"

example : 0 ≤ 1 := by
  #statesearch
  sorry
```

You can modify the LeanStateSearch URL by setting the `LEANSEARCHCLIENT_LEANSTATESEARCH_API_URL` environment variable.
-/
syntax (name := statesearch_search_tactic)
  withPosition("#statesearch") : tactic

@[tactic statesearch_search_tactic] def stateSearchTacticImpl : Tactic :=
  fun stx => withMainContext do
  let goal ← getMainGoal
  let target ← getMainTarget
  let state := (← Meta.ppGoal goal).pretty
  let num_results := (statesearch.queries.get (← getOptions))
  let rev := (statesearch.revision.get (← getOptions))
  match stx with
  | `(tactic|#statesearch) =>
    let results ← queryStateSearch state num_results rev
    let suggestionGroups := results.map fun sr =>
      let fullName := match sr.type? with
      | some type => s!"{sr.name} (type: {type})"
      | none => sr.name
    (fullName, sr.toTacticSuggestions)
    let mut foundValidTactic := false
    for (name, sg) in suggestionGroups do
        let sg ←  sg.filterM fun s =>
          let sugTxt := s.suggestion
          match sugTxt with
          | .string s => do
            let stx? := runParserCategory (← getEnv) `tactic s
            match stx? with
            | Except.ok stx =>
              let n? ← checkTactic target stx
              return n?.isSome
            | Except.error _ =>
              pure false
          | _ => pure false
        unless sg.isEmpty do
          foundValidTactic := true
          TryThis.addSuggestions stx sg (header := s!"From: {name}")
    unless foundValidTactic do
      TryThis.addSuggestions stx (results.map SearchResult.toCommandSuggestion)
  | _ => throwUnsupportedSyntax

@[inherit_doc search_cmd]
syntax (name := search_tactic) "#search" (str)? : tactic

@[tactic search_tactic] def searchTacticImpl : Tactic :=
  fun stx => withMainContext do
  match stx with
  | `(tactic|#search $s) =>
    let server ←  match leansearchclient.backend.get (← getOptions) with
    | "leansearch" => pure leanSearchServer
    | "moogle" => pure moogleServer
    | s => throwError s!"Invalid backend {s}, should be one of leansearch and moogle"
    server.searchTacticSuggestions stx s
  | `(tactic|#search) => do
    evalTactic (← `(tactic|#statesearch))
  | _ => throwUnsupportedSyntax

end LeanSearchClient



=== LEAN SOURCE: Examples.lean ===
import LeanSearchClient.Syntax

/-!
# Lean Search Examples

Examples of using the leansearch API. The search is triggered when the sentence ends with a full stop (period) or a question mark.
-/

/--
warning: #leansearch query should be a string that ends with a `.` or `?`.
Note this command sends your query to an external service at https://leansearch.net/.
-/
#guard_msgs in
#leansearch "If a natural number n is less than m, then the successor of n is less than the successor of m"

/--
warning: #leansearch query should be a string that ends with a `.` or `?`.
Note this command sends your query to an external service at https://leansearch.net/.
-/
#guard_msgs in
example := #leansearch "If a natural number n is less than m, then the successor of n is less than the successor of m"

set_option leansearch.queries 1

/--
info: LeanSearch: [{"result":
  {"value": ":=\n  ⟨succ_lt_succ l.h⟩",
   "type": "∀ (m n : ℕ) [l : Fin2.IsLT m n], Fin2.IsLT m.succ n.succ",
   "signature": " (m n) [l : IsLT m n] : IsLT (succ m) (succ n)",
   "name": ["Fin2", "IsLT", "succ"],
   "module_name": ["Mathlib", "Data", "Fin", "Fin2"],
   "kind": "instance",
   "informal_name": "Successor preserves the less-than relation for natural numbers",
   "informal_description":
   "For natural numbers $m$ and $n$, if $m < n$ holds, then $\\mathrm{succ}(m) < \\mathrm{succ}(n)$ also holds.",
   "docstring": null},
  "distance": 0.0862322449684143}]
---
warning: declaration uses 'sorry'
-/
#guard_msgs in
example : 3 ≤ 5 := by
  #leansearch "If a natural number n is less than m, then the successor of n is less than the successor of m."
  sorry


/--
warning: #leansearch query should be a string that ends with a `.` or `?`.
Note this command sends your query to an external service at https://leansearch.net/.
-/
#guard_msgs in
example : 3 ≤ 5 := by
  #leansearch
  decide

/-!
# Lean Search Examples using `#search`
-/
set_option leansearchclient.backend "leansearch"

/--
warning: #leansearch query should be a string that ends with a `.` or `?`.
Note this command sends your query to an external service at https://leansearch.net/.
-/
#guard_msgs in
#search "If a natural number n is less than m, then the successor of n is less than the successor of m"

/--
warning: #leansearch query should be a string that ends with a `.` or `?`.
Note this command sends your query to an external service at https://leansearch.net/.
-/
#guard_msgs in
example := #search "If a natural number n is less than m, then the successor of n is less than the successor of m"

set_option leansearch.queries 1

/--
info: LeanSearch: [{"result":
  {"value": ":=\n  ⟨succ_lt_succ l.h⟩",
   "type": "∀ (m n : ℕ) [l : Fin2.IsLT m n], Fin2.IsLT m.succ n.succ",
   "signature": " (m n) [l : IsLT m n] : IsLT (succ m) (succ n)",
   "name": ["Fin2", "IsLT", "succ"],
   "module_name": ["Mathlib", "Data", "Fin", "Fin2"],
   "kind": "instance",
   "informal_name": "Successor preserves the less-than relation for natural numbers",
   "informal_description":
   "For natural numbers $m$ and $n$, if $m < n$ holds, then $\\mathrm{succ}(m) < \\mathrm{succ}(n)$ also holds.",
   "docstring": null},
  "distance": 0.0862322449684143}]
---
warning: declaration uses 'sorry'
-/
#guard_msgs in
example : 3 ≤ 5 := by
  #search "If a natural number n is less than m, then the successor of n is less than the successor of m."
  sorry


/--
warning: #leansearch query should be a string that ends with a `.` or `?`.
Note this command sends your query to an external service at https://leansearch.net/.
---
warning: declaration uses 'sorry'
-/
#guard_msgs in
example : 3 ≤ 5 := #search

set_option leansearchclient.backend "magic"

/-- error: Invalid backend magic, should be one of leansearch and moogle -/
#guard_msgs in
#search "Every slice knot is ribbon."



=== LEAN SOURCE: LoogleExamples.lean ===
import LeanSearchClient.LoogleSyntax

/-!
# Loogle Examples

Examples of using the Loogle API. The search is triggered by the word at the end of the query.
-/

-- #loogle List ?a → ?a

-- example := #loogle List ?a → ?a


-- set_option loogle.queries 1

-- example : 3 ≤ 5 := by
--   #loogle Nat.succ_le_succ
--   sorry

example : 3 ≤ 5 := by
  #loogle
  decide

#loogle Dist.dist, edist
-- example : 3 ≤ 5 := by
--   #loogle
--   decide

/-!
More examples to test comments do not interfere with the search or caching.
-/

#loogle ?a * _ < ?a * _ ↔ _
#loogle ?a * _ < ?a * _ ↔ _ /- foo -/
#loogle ?a * _ < ?a * _ ↔ _


-- comment
#loogle ?a * _ < ?a * _ ↔ _

/--
info: Loogle Search Results
• #check Option.get!
-/
#guard_msgs in
  #loogle Option ?a → ?a, "get!"

/- hello -/



=== LEAN SOURCE: MoogleExamples.lean ===
import LeanSearchClient.Syntax

/-!
# Moogle Examples

Examples of using the Moogle API. The search is triggered when the sentence ends with a full stop (period) or a question mark.
-/

/--
warning: #moogle query should be a string that ends with a `.` or `?`.
Note this command sends your query to an external service at https://www.moogle.ai/api/search.
-/
#guard_msgs in
#moogle "If a natural number n is less than m, then the successor of n is less than the successor of m"

/--
warning: #moogle query should be a string that ends with a `.` or `?`.
Note this command sends your query to an external service at https://www.moogle.ai/api/search.
-/
#guard_msgs in
example := #moogle "If a natural number n is less than m, then the successor of n is less than the successor of m"

set_option moogle.queries 1 in
/--
info: From: Nat.lt (type: Nat → Nat → Prop)
• have : Nat → Nat → Prop := Nat.lt
---
warning: declaration uses 'sorry'
-/
#guard_msgs in
example : 3 ≤ 5 := by
  #moogle "If a natural number n is less than m, then the successor of n is less than the successor of m."
  sorry

/-!
## Moogle queries using `search`
-/

set_option leansearchclient.backend "moogle"
/--
warning: #moogle query should be a string that ends with a `.` or `?`.
Note this command sends your query to an external service at https://www.moogle.ai/api/search.
-/
#guard_msgs in
#search "If a natural number n is less than m, then the successor of n is less than the successor of m"

/--
warning: #moogle query should be a string that ends with a `.` or `?`.
Note this command sends your query to an external service at https://www.moogle.ai/api/search.
-/
#guard_msgs in
example := #search "If a natural number n is less than m, then the successor of n is less than the successor of m"

set_option moogle.queries 1

/--
info: From: Nat.lt (type: Nat → Nat → Prop)
• have : Nat → Nat → Prop := Nat.lt
---
warning: declaration uses 'sorry'
-/
#guard_msgs in
example : 3 ≤ 5 := by
  #search "If a natural number n is less than m, then the successor of n is less than the successor of m."
  sorry



=== LEAN SOURCE: StateSearchExamples.lean ===
import LeanSearchClient.Syntax

/-!
# LeanStateSearch Examples

Examples of using LeanStateSearch API. The search is triggered by the
tactic `#statesearch`.
-/

set_option statesearch.queries 1 -- set the number of results to 6
set_option statesearch.revision "v4.16.0" -- set the revision to v4.16.0


/-- info: Try these:
• #check Int.one_pos
---
warning: declaration uses 'sorry'
-/
#guard_msgs in
example : 0 < 1 := by
  #statesearch
  sorry

set_option statesearch.queries 6

/--
info: From: Nat.zero_lt_one (type: 0 < 1)
• apply Nat.zero_lt_one
• have : 0 < 1 := Nat.zero_lt_one
---
warning: declaration uses 'sorry'
-/
#guard_msgs in
example : 0 < 1 := by
  #statesearch
  sorry

set_option statesearch.revision "v4.15.0"

/-- error: error: "Invalid parameter value"
description: "Lean State Search does not support the specified revision"
-/
#guard_msgs in
example : 0 ≤ 1 := by
  #statesearch

/-!
Tests using `search` with `statesearch` as the backend.
-/
set_option statesearch.queries 1 -- set the number of results to 6
set_option statesearch.revision "v4.16.0" -- set the revision to v4.16.0


/-- info: Try these:
• #check Int.one_pos
---
warning: declaration uses 'sorry'
-/
#guard_msgs in
example : 0 < 1 := by
  #search
  sorry

set_option statesearch.queries 6

/--
info: From: Nat.zero_lt_one (type: 0 < 1)
• apply Nat.zero_lt_one
• have : 0 < 1 := Nat.zero_lt_one
---
warning: declaration uses 'sorry'
-/
#guard_msgs in
example : 0 < 1 := by
  #search
  sorry

set_option statesearch.revision "v4.15.0"

/-- error: error: "Invalid parameter value"
description: "Lean State Search does not support the specified revision"
-/
#guard_msgs in
example : 0 ≤ 1 := by
  #search



=== LEAN SOURCE: Archive.lean ===
import Archive.Arithcc
import Archive.Examples.Eisenstein
import Archive.Examples.IfNormalization.Result
import Archive.Examples.IfNormalization.Statement
import Archive.Examples.IfNormalization.WithoutAesop
import Archive.Examples.MersennePrimes
import Archive.Examples.PropEncodable
import Archive.Hairer
import Archive.Imo.Imo1959Q1
import Archive.Imo.Imo1959Q2
import Archive.Imo.Imo1960Q1
import Archive.Imo.Imo1960Q2
import Archive.Imo.Imo1961Q3
import Archive.Imo.Imo1962Q1
import Archive.Imo.Imo1962Q4
import Archive.Imo.Imo1963Q5
import Archive.Imo.Imo1964Q1
import Archive.Imo.Imo1969Q1
import Archive.Imo.Imo1972Q5
import Archive.Imo.Imo1975Q1
import Archive.Imo.Imo1977Q6
import Archive.Imo.Imo1981Q3
import Archive.Imo.Imo1982Q1
import Archive.Imo.Imo1982Q3
import Archive.Imo.Imo1985Q2
import Archive.Imo.Imo1986Q5
import Archive.Imo.Imo1987Q1
import Archive.Imo.Imo1988Q6
import Archive.Imo.Imo1994Q1
import Archive.Imo.Imo1998Q2
import Archive.Imo.Imo2001Q2
import Archive.Imo.Imo2001Q3
import Archive.Imo.Imo2001Q4
import Archive.Imo.Imo2001Q6
import Archive.Imo.Imo2005Q3
import Archive.Imo.Imo2005Q4
import Archive.Imo.Imo2006Q3
import Archive.Imo.Imo2006Q5
import Archive.Imo.Imo2008Q2
import Archive.Imo.Imo2008Q3
import Archive.Imo.Imo2008Q4
import Archive.Imo.Imo2011Q3
import Archive.Imo.Imo2011Q5
import Archive.Imo.Imo2013Q1
import Archive.Imo.Imo2013Q5
import Archive.Imo.Imo2015Q6
import Archive.Imo.Imo2019Q1
import Archive.Imo.Imo2019Q2
import Archive.Imo.Imo2019Q4
import Archive.Imo.Imo2020Q2
import Archive.Imo.Imo2021Q1
import Archive.Imo.Imo2024Q1
import Archive.Imo.Imo2024Q2
import Archive.Imo.Imo2024Q3
import Archive.Imo.Imo2024Q5
import Archive.Imo.Imo2024Q6
import Archive.MiuLanguage.Basic
import Archive.MiuLanguage.DecisionNec
import Archive.MiuLanguage.DecisionSuf
import Archive.OxfordInvariants.Summer2021.Week3P1
import Archive.Sensitivity
import Archive.Wiedijk100Theorems.AbelRuffini
import Archive.Wiedijk100Theorems.AreaOfACircle
import Archive.Wiedijk100Theorems.AscendingDescendingSequences
import Archive.Wiedijk100Theorems.BallotProblem
import Archive.Wiedijk100Theorems.BirthdayProblem
import Archive.Wiedijk100Theorems.BuffonsNeedle
import Archive.Wiedijk100Theorems.CubingACube
import Archive.Wiedijk100Theorems.FriendshipGraphs
import Archive.Wiedijk100Theorems.HeronsFormula
import Archive.Wiedijk100Theorems.InverseTriangleSum
import Archive.Wiedijk100Theorems.Konigsberg
import Archive.Wiedijk100Theorems.Partition
import Archive.Wiedijk100Theorems.PerfectNumbers
import Archive.Wiedijk100Theorems.SolutionOfCubicQuartic
import Archive.Wiedijk100Theorems.SumOfPrimeReciprocalsDiverges
import Archive.ZagierTwoSquares



=== LEAN SOURCE: Counterexamples.lean ===
import Counterexamples.AharoniKorman
import Counterexamples.CanonicallyOrderedCommSemiringTwoMul
import Counterexamples.CharPZeroNeCharZero
import Counterexamples.CliffordAlgebraNotInjective
import Counterexamples.Cyclotomic105
import Counterexamples.DirectSumIsInternal
import Counterexamples.DiscreteTopologyNonDiscreteUniformity
import Counterexamples.GameMultiplication
import Counterexamples.Girard
import Counterexamples.HomogeneousPrimeNotPrime
import Counterexamples.IrrationalPowerOfIrrational
import Counterexamples.LinearOrderWithPosMulPosEqZero
import Counterexamples.MapFloor
import Counterexamples.MonicNonRegular
import Counterexamples.OrderedCancelAddCommMonoidWithBounds
import Counterexamples.Phillips
import Counterexamples.Pseudoelement
import Counterexamples.QuadraticForm
import Counterexamples.SeminormLatticeNotDistrib
import Counterexamples.SorgenfreyLine
import Counterexamples.ZeroDivisorsInAddMonoidAlgebras



=== LEAN SOURCE: docs.lean ===
import docs.Conv.Guide
import docs.Conv.Introduction



=== LEAN SOURCE: lakefile.lean ===
import Lake

open Lake DSL

/-!
## Mathlib dependencies on upstream projects
-/

require "leanprover-community" / "batteries" @ git "main"
require "leanprover-community" / "Qq" @ git "master"
require "leanprover-community" / "aesop" @ git "master"
require "leanprover-community" / "proofwidgets" @ git "v0.0.67" -- ProofWidgets should always be pinned to a specific version
  with NameMap.empty.insert `errorOnBuild
    "ProofWidgets not up-to-date. \
    Please run `lake exe cache get` to fetch the latest ProofWidgets. \
    If this does not work, report your issue on the Lean Zulip."
require "leanprover-community" / "importGraph" @ git "main"
require "leanprover-community" / "LeanSearchClient" @ git "main"
require "leanprover-community" / "plausible" @ git "main"

/-!
## Options for building mathlib
-/

/-- These options are used as `leanOptions`, prefixed by `` `weak``, so that
`lake build` uses them, as well as `Archive` and `Counterexamples`. -/
abbrev mathlibOnlyLinters : Array LeanOption := #[
  ⟨`linter.mathlibStandardSet, true⟩,
  ⟨`linter.style.longFile, .ofNat 1500⟩,
  -- `latest_import.yml` uses this comment: if you edit it, make sure that the workflow still works
]

/-- These options are passed as `leanOptions` to building mathlib, as well as the
`Archive` and `Counterexamples`. (`tests` omits the first two options.) -/
abbrev mathlibLeanOptions := #[
    ⟨`pp.unicode.fun, true⟩, -- pretty-prints `fun a ↦ b`
    ⟨`autoImplicit, false⟩,
    ⟨`maxSynthPendingDepth, .ofNat 3⟩
  ] ++ -- options that are used in `lake build`
    mathlibOnlyLinters.map fun s ↦ { s with name := `weak ++ s.name }

package mathlib where
  testDriver := "MathlibTest"
  -- These are additional settings which do not affect the lake hash,
  -- so they can be enabled in CI and disabled locally or vice versa.
  -- Warning: Do not put any options here that actually change the olean files,
  -- or inconsistent behavior may result
  -- weakLeanArgs := #[]

/-!
## Mathlib libraries
-/

@[default_target]
lean_lib Mathlib where
  -- Enforce Mathlib's default linters and style options.
  leanOptions := mathlibLeanOptions

-- NB. When adding further libraries, check if they should be excluded from `getLeanLibs` in
-- `scripts/mk_all.lean`.
lean_lib Cache
lean_lib LongestPole

lean_lib MathlibTest where
  globs := #[.submodules `MathlibTest]

lean_lib Archive where
  leanOptions := mathlibLeanOptions

lean_lib Counterexamples where
  leanOptions := mathlibLeanOptions

/-- Additional documentation in the form of modules that only contain module docstrings. -/
lean_lib docs where
  roots := #[`docs]

/-!
## Executables provided by Mathlib
-/

/--
`lake exe autolabel 150100` adds a topic label to PR `150100` if there is a unique choice.
This requires GitHub CLI `gh` to be installed!

Calling `lake exe autolabel` without a PR number will print the result without applying
any labels online.
-/
lean_exe autolabel where
  srcDir := "scripts"

/-- `lake exe cache get` retrieves precompiled `.olean` files from a central server. -/
lean_exe cache where
  root := `Cache.Main

/-- `lake exe check-yaml` verifies that all declarations referred to in `docs/*.yaml` files exist. -/
lean_exe «check-yaml» where
  srcDir := "scripts"
  supportInterpreter := true

/-- `lake exe mk_all` constructs the files containing all imports for a project. -/
lean_exe mk_all where
  srcDir := "scripts"
  supportInterpreter := true
  -- Executables which import `Lake` must set `-lLake`.
  weakLinkArgs := #["-lLake"]

/-- `lake exe lint-style` runs text-based style linters. -/
lean_exe «lint-style» where
  srcDir := "scripts"
  supportInterpreter := true
  -- Executables which import `Lake` must set `-lLake`.
  weakLinkArgs := #["-lLake"]

/--
`lake exe pole` queries the Mathlib speedcenter for build times for the current commit,
and then calculates the longest pole
(i.e. the sequence of files you would be waiting for during a infinite parallelism build).
-/
lean_exe pole where
  root := `LongestPole.Main
  supportInterpreter := true
  -- Executables which import `Lake` must set `-lLake`.
  weakLinkArgs := #["-lLake"]

/--
`lake exe unused module_1 ... module_n` will analyze unused transitive imports in a given sequence.
The script expects the sequence to be in "reverse order", i.e. files imported later in `Mathlib` should
come earlier in the sequence.

Outputs a markdown file (called  `unused.md` by default) and a number of `lake exe graph` commands
highlighting particular ranges of transitively unused imports.

Typically this should be run via `scripts/unused_in_pole.sh`.
-/
lean_exe unused where
  root := `LongestPole.Unused
  supportInterpreter := true
  -- Executables which import `Lake` must set `-lLake`.
  weakLinkArgs := #["-lLake"]

lean_exe mathlib_test_executable where
  root := `MathlibTest.MathlibTestExecutable

/-!
## Other configuration
-/

/--
When a package depending on Mathlib updates its dependencies,
update its toolchain to match Mathlib's and fetch the new cache.
-/
post_update pkg do
  let rootPkg ← getRootPackage
  if rootPkg.name = pkg.name then
    return -- do not run in Mathlib itself
  if (← IO.getEnv "MATHLIB_NO_CACHE_ON_UPDATE") != some "1" then
    let exeFile ← runBuild cache.fetch
    -- Run the command in the root package directory,
    -- which is the one that holds the .lake folder and lean-toolchain file.
    let cwd ← IO.Process.getCurrentDir
    let exitCode ← try
      IO.Process.setCurrentDir rootPkg.dir
      env exeFile.toString #["get"]
    finally
      IO.Process.setCurrentDir cwd
    if exitCode ≠ 0 then
      error s!"{pkg.name}: failed to fetch cache"



=== LEAN SOURCE: Mathlib.lean ===
import Std
import Batteries
import Mathlib.Algebra.AddConstMap.Basic
import Mathlib.Algebra.AddConstMap.Equiv
import Mathlib.Algebra.AddTorsor.Basic
import Mathlib.Algebra.AddTorsor.Defs
import Mathlib.Algebra.Algebra.Basic
import Mathlib.Algebra.Algebra.Bilinear
import Mathlib.Algebra.Algebra.Defs
import Mathlib.Algebra.Algebra.Equiv
import Mathlib.Algebra.Algebra.Field
import Mathlib.Algebra.Algebra.Hom
import Mathlib.Algebra.Algebra.Hom.Rat
import Mathlib.Algebra.Algebra.NonUnitalHom
import Mathlib.Algebra.Algebra.NonUnitalSubalgebra
import Mathlib.Algebra.Algebra.Operations
import Mathlib.Algebra.Algebra.Opposite
import Mathlib.Algebra.Algebra.Pi
import Mathlib.Algebra.Algebra.Prod
import Mathlib.Algebra.Algebra.Rat
import Mathlib.Algebra.Algebra.RestrictScalars
import Mathlib.Algebra.Algebra.Shrink
import Mathlib.Algebra.Algebra.Spectrum.Basic
import Mathlib.Algebra.Algebra.Spectrum.Pi
import Mathlib.Algebra.Algebra.Spectrum.Quasispectrum
import Mathlib.Algebra.Algebra.Subalgebra.Basic
import Mathlib.Algebra.Algebra.Subalgebra.Centralizer
import Mathlib.Algebra.Algebra.Subalgebra.Directed
import Mathlib.Algebra.Algebra.Subalgebra.IsSimpleOrder
import Mathlib.Algebra.Algebra.Subalgebra.Lattice
import Mathlib.Algebra.Algebra.Subalgebra.Matrix
import Mathlib.Algebra.Algebra.Subalgebra.MulOpposite
import Mathlib.Algebra.Algebra.Subalgebra.Operations
import Mathlib.Algebra.Algebra.Subalgebra.Order
import Mathlib.Algebra.Algebra.Subalgebra.Pi
import Mathlib.Algebra.Algebra.Subalgebra.Pointwise
import Mathlib.Algebra.Algebra.Subalgebra.Prod
import Mathlib.Algebra.Algebra.Subalgebra.Rank
import Mathlib.Algebra.Algebra.Subalgebra.Tower
import Mathlib.Algebra.Algebra.Subalgebra.Unitization
import Mathlib.Algebra.Algebra.Tower
import Mathlib.Algebra.Algebra.TransferInstance
import Mathlib.Algebra.Algebra.Unitization
import Mathlib.Algebra.Algebra.ZMod
import Mathlib.Algebra.AlgebraicCard
import Mathlib.Algebra.Azumaya.Basic
import Mathlib.Algebra.Azumaya.Defs
import Mathlib.Algebra.Azumaya.Matrix
import Mathlib.Algebra.BigOperators.Associated
import Mathlib.Algebra.BigOperators.Balance
import Mathlib.Algebra.BigOperators.Expect
import Mathlib.Algebra.BigOperators.Field
import Mathlib.Algebra.BigOperators.Fin
import Mathlib.Algebra.BigOperators.Finprod
import Mathlib.Algebra.BigOperators.Finsupp.Basic
import Mathlib.Algebra.BigOperators.Finsupp.Fin
import Mathlib.Algebra.BigOperators.Group.Finset.Basic
import Mathlib.Algebra.BigOperators.Group.Finset.Defs
import Mathlib.Algebra.BigOperators.Group.Finset.Indicator
import Mathlib.Algebra.BigOperators.Group.Finset.Lemmas
import Mathlib.Algebra.BigOperators.Group.Finset.Pi
import Mathlib.Algebra.BigOperators.Group.Finset.Piecewise
import Mathlib.Algebra.BigOperators.Group.Finset.Powerset
import Mathlib.Algebra.BigOperators.Group.Finset.Preimage
import Mathlib.Algebra.BigOperators.Group.Finset.Sigma
import Mathlib.Algebra.BigOperators.Group.List.Basic
import Mathlib.Algebra.BigOperators.Group.List.Defs
import Mathlib.Algebra.BigOperators.Group.List.Lemmas
import Mathlib.Algebra.BigOperators.Group.Multiset.Basic
import Mathlib.Algebra.BigOperators.Group.Multiset.Defs
import Mathlib.Algebra.BigOperators.GroupWithZero.Action
import Mathlib.Algebra.BigOperators.GroupWithZero.Finset
import Mathlib.Algebra.BigOperators.Intervals
import Mathlib.Algebra.BigOperators.Module
import Mathlib.Algebra.BigOperators.NatAntidiagonal
import Mathlib.Algebra.BigOperators.Option
import Mathlib.Algebra.BigOperators.Pi
import Mathlib.Algebra.BigOperators.Ring.Finset
import Mathlib.Algebra.BigOperators.Ring.List
import Mathlib.Algebra.BigOperators.Ring.Multiset
import Mathlib.Algebra.BigOperators.Ring.Nat
import Mathlib.Algebra.BigOperators.RingEquiv
import Mathlib.Algebra.BigOperators.Sym
import Mathlib.Algebra.BigOperators.WithTop
import Mathlib.Algebra.BrauerGroup.Defs
import Mathlib.Algebra.Category.AlgCat.Basic
import Mathlib.Algebra.Category.AlgCat.Limits
import Mathlib.Algebra.Category.AlgCat.Monoidal
import Mathlib.Algebra.Category.AlgCat.Symmetric
import Mathlib.Algebra.Category.AlgebraCat.Symmetric
import Mathlib.Algebra.Category.BialgCat.Basic
import Mathlib.Algebra.Category.BialgCat.Monoidal
import Mathlib.Algebra.Category.BoolRing
import Mathlib.Algebra.Category.CoalgCat.Basic
import Mathlib.Algebra.Category.CoalgCat.ComonEquivalence
import Mathlib.Algebra.Category.CoalgCat.Monoidal
import Mathlib.Algebra.Category.CommAlgCat.Basic
import Mathlib.Algebra.Category.CommAlgCat.FiniteType
import Mathlib.Algebra.Category.CommAlgCat.Monoidal
import Mathlib.Algebra.Category.ContinuousCohomology.Basic
import Mathlib.Algebra.Category.FGModuleCat.Basic
import Mathlib.Algebra.Category.FGModuleCat.EssentiallySmall
import Mathlib.Algebra.Category.FGModuleCat.Limits
import Mathlib.Algebra.Category.Grp.AB
import Mathlib.Algebra.Category.Grp.Abelian
import Mathlib.Algebra.Category.Grp.Adjunctions
import Mathlib.Algebra.Category.Grp.Basic
import Mathlib.Algebra.Category.Grp.Biproducts
import Mathlib.Algebra.Category.Grp.CartesianMonoidal
import Mathlib.Algebra.Category.Grp.ChosenFiniteProducts
import Mathlib.Algebra.Category.Grp.Colimits
import Mathlib.Algebra.Category.Grp.EnoughInjectives
import Mathlib.Algebra.Category.Grp.EpiMono
import Mathlib.Algebra.Category.Grp.EquivalenceGroupAddGroup
import Mathlib.Algebra.Category.Grp.FilteredColimits
import Mathlib.Algebra.Category.Grp.FiniteGrp
import Mathlib.Algebra.Category.Grp.ForgetCorepresentable
import Mathlib.Algebra.Category.Grp.Images
import Mathlib.Algebra.Category.Grp.Injective
import Mathlib.Algebra.Category.Grp.IsFinite
import Mathlib.Algebra.Category.Grp.Kernels
import Mathlib.Algebra.Category.Grp.LargeColimits
import Mathlib.Algebra.Category.Grp.LeftExactFunctor
import Mathlib.Algebra.Category.Grp.Limits
import Mathlib.Algebra.Category.Grp.Preadditive
import Mathlib.Algebra.Category.Grp.Subobject
import Mathlib.Algebra.Category.Grp.Ulift
import Mathlib.Algebra.Category.Grp.Yoneda
import Mathlib.Algebra.Category.Grp.ZModuleEquivalence
import Mathlib.Algebra.Category.Grp.Zero
import Mathlib.Algebra.Category.GrpWithZero
import Mathlib.Algebra.Category.HopfAlgCat.Basic
import Mathlib.Algebra.Category.HopfAlgCat.Monoidal
import Mathlib.Algebra.Category.ModuleCat.AB
import Mathlib.Algebra.Category.ModuleCat.Abelian
import Mathlib.Algebra.Category.ModuleCat.Adjunctions
import Mathlib.Algebra.Category.ModuleCat.Algebra
import Mathlib.Algebra.Category.ModuleCat.Basic
import Mathlib.Algebra.Category.ModuleCat.Biproducts
import Mathlib.Algebra.Category.ModuleCat.ChangeOfRings
import Mathlib.Algebra.Category.ModuleCat.Colimits
import Mathlib.Algebra.Category.ModuleCat.Differentials.Basic
import Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf
import Mathlib.Algebra.Category.ModuleCat.EnoughInjectives
import Mathlib.Algebra.Category.ModuleCat.EpiMono
import Mathlib.Algebra.Category.ModuleCat.ExteriorPower
import Mathlib.Algebra.Category.ModuleCat.FilteredColimits
import Mathlib.Algebra.Category.ModuleCat.Free
import Mathlib.Algebra.Category.ModuleCat.Images
import Mathlib.Algebra.Category.ModuleCat.Injective
import Mathlib.Algebra.Category.ModuleCat.Kernels
import Mathlib.Algebra.Category.ModuleCat.Limits
import Mathlib.Algebra.Category.ModuleCat.Monoidal.Basic
import Mathlib.Algebra.Category.ModuleCat.Monoidal.Closed
import Mathlib.Algebra.Category.ModuleCat.Monoidal.Symmetric
import Mathlib.Algebra.Category.ModuleCat.Presheaf
import Mathlib.Algebra.Category.ModuleCat.Presheaf.Abelian
import Mathlib.Algebra.Category.ModuleCat.Presheaf.ChangeOfRings
import Mathlib.Algebra.Category.ModuleCat.Presheaf.Colimits
import Mathlib.Algebra.Category.ModuleCat.Presheaf.EpiMono
import Mathlib.Algebra.Category.ModuleCat.Presheaf.Free
import Mathlib.Algebra.Category.ModuleCat.Presheaf.Generator
import Mathlib.Algebra.Category.ModuleCat.Presheaf.Limits
import Mathlib.Algebra.Category.ModuleCat.Presheaf.Monoidal
import Mathlib.Algebra.Category.ModuleCat.Presheaf.Pullback
import Mathlib.Algebra.Category.ModuleCat.Presheaf.Pushforward
import Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafification
import Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafify
import Mathlib.Algebra.Category.ModuleCat.Products
import Mathlib.Algebra.Category.ModuleCat.Projective
import Mathlib.Algebra.Category.ModuleCat.Pseudofunctor
import Mathlib.Algebra.Category.ModuleCat.Sheaf
import Mathlib.Algebra.Category.ModuleCat.Sheaf.Abelian
import Mathlib.Algebra.Category.ModuleCat.Sheaf.ChangeOfRings
import Mathlib.Algebra.Category.ModuleCat.Sheaf.Colimits
import Mathlib.Algebra.Category.ModuleCat.Sheaf.Free
import Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators
import Mathlib.Algebra.Category.ModuleCat.Sheaf.Limits
import Mathlib.Algebra.Category.ModuleCat.Sheaf.PullbackContinuous
import Mathlib.Algebra.Category.ModuleCat.Sheaf.PushforwardContinuous
import Mathlib.Algebra.Category.ModuleCat.Sheaf.Quasicoherent
import Mathlib.Algebra.Category.ModuleCat.Simple
import Mathlib.Algebra.Category.ModuleCat.Subobject
import Mathlib.Algebra.Category.ModuleCat.Tannaka
import Mathlib.Algebra.Category.ModuleCat.Topology.Basic
import Mathlib.Algebra.Category.ModuleCat.Topology.Homology
import Mathlib.Algebra.Category.MonCat.Adjunctions
import Mathlib.Algebra.Category.MonCat.Basic
import Mathlib.Algebra.Category.MonCat.Colimits
import Mathlib.Algebra.Category.MonCat.FilteredColimits
import Mathlib.Algebra.Category.MonCat.ForgetCorepresentable
import Mathlib.Algebra.Category.MonCat.Limits
import Mathlib.Algebra.Category.MonCat.Yoneda
import Mathlib.Algebra.Category.Ring.Adjunctions
import Mathlib.Algebra.Category.Ring.Basic
import Mathlib.Algebra.Category.Ring.Colimits
import Mathlib.Algebra.Category.Ring.Constructions
import Mathlib.Algebra.Category.Ring.Epi
import Mathlib.Algebra.Category.Ring.FilteredColimits
import Mathlib.Algebra.Category.Ring.FinitePresentation
import Mathlib.Algebra.Category.Ring.Instances
import Mathlib.Algebra.Category.Ring.Limits
import Mathlib.Algebra.Category.Ring.LinearAlgebra
import Mathlib.Algebra.Category.Ring.Topology
import Mathlib.Algebra.Category.Ring.Under.Basic
import Mathlib.Algebra.Category.Ring.Under.Limits
import Mathlib.Algebra.Category.Semigrp.Basic
import Mathlib.Algebra.Central.Basic
import Mathlib.Algebra.Central.Defs
import Mathlib.Algebra.Central.Matrix
import Mathlib.Algebra.Central.TensorProduct
import Mathlib.Algebra.CharP.Algebra
import Mathlib.Algebra.CharP.Basic
import Mathlib.Algebra.CharP.CharAndCard
import Mathlib.Algebra.CharP.Defs
import Mathlib.Algebra.CharP.Frobenius
import Mathlib.Algebra.CharP.IntermediateField
import Mathlib.Algebra.CharP.Invertible
import Mathlib.Algebra.CharP.Lemmas
import Mathlib.Algebra.CharP.LinearMaps
import Mathlib.Algebra.CharP.LocalRing
import Mathlib.Algebra.CharP.MixedCharZero
import Mathlib.Algebra.CharP.Pi
import Mathlib.Algebra.CharP.Quotient
import Mathlib.Algebra.CharP.Reduced
import Mathlib.Algebra.CharP.Subring
import Mathlib.Algebra.CharP.Two
import Mathlib.Algebra.CharZero.Defs
import Mathlib.Algebra.CharZero.Infinite
import Mathlib.Algebra.CharZero.Quotient
import Mathlib.Algebra.Colimit.DirectLimit
import Mathlib.Algebra.Colimit.Finiteness
import Mathlib.Algebra.Colimit.Module
import Mathlib.Algebra.Colimit.Ring
import Mathlib.Algebra.Colimit.TensorProduct
import Mathlib.Algebra.ContinuedFractions.Basic
import Mathlib.Algebra.ContinuedFractions.Computation.ApproximationCorollaries
import Mathlib.Algebra.ContinuedFractions.Computation.Approximations
import Mathlib.Algebra.ContinuedFractions.Computation.Basic
import Mathlib.Algebra.ContinuedFractions.Computation.CorrectnessTerminating
import Mathlib.Algebra.ContinuedFractions.Computation.TerminatesIffRat
import Mathlib.Algebra.ContinuedFractions.Computation.Translations
import Mathlib.Algebra.ContinuedFractions.ContinuantsRecurrence
import Mathlib.Algebra.ContinuedFractions.ConvergentsEquiv
import Mathlib.Algebra.ContinuedFractions.Determinant
import Mathlib.Algebra.ContinuedFractions.TerminatedStable
import Mathlib.Algebra.ContinuedFractions.Translations
import Mathlib.Algebra.CubicDiscriminant
import Mathlib.Algebra.DirectSum.AddChar
import Mathlib.Algebra.DirectSum.Algebra
import Mathlib.Algebra.DirectSum.Basic
import Mathlib.Algebra.DirectSum.Decomposition
import Mathlib.Algebra.DirectSum.Finsupp
import Mathlib.Algebra.DirectSum.Idempotents
import Mathlib.Algebra.DirectSum.Internal
import Mathlib.Algebra.DirectSum.LinearMap
import Mathlib.Algebra.DirectSum.Module
import Mathlib.Algebra.DirectSum.Ring
import Mathlib.Algebra.Divisibility.Basic
import Mathlib.Algebra.Divisibility.Finite
import Mathlib.Algebra.Divisibility.Hom
import Mathlib.Algebra.Divisibility.Prod
import Mathlib.Algebra.Divisibility.Units
import Mathlib.Algebra.DualNumber
import Mathlib.Algebra.DualQuaternion
import Mathlib.Algebra.EuclideanDomain.Basic
import Mathlib.Algebra.EuclideanDomain.Defs
import Mathlib.Algebra.EuclideanDomain.Field
import Mathlib.Algebra.EuclideanDomain.Int
import Mathlib.Algebra.Exact
import Mathlib.Algebra.Expr
import Mathlib.Algebra.Field.Action.ConjAct
import Mathlib.Algebra.Field.Basic
import Mathlib.Algebra.Field.Defs
import Mathlib.Algebra.Field.Equiv
import Mathlib.Algebra.Field.IsField
import Mathlib.Algebra.Field.MinimalAxioms
import Mathlib.Algebra.Field.NegOnePow
import Mathlib.Algebra.Field.Opposite
import Mathlib.Algebra.Field.Periodic
import Mathlib.Algebra.Field.Power
import Mathlib.Algebra.Field.Rat
import Mathlib.Algebra.Field.Shrink
import Mathlib.Algebra.Field.Subfield.Basic
import Mathlib.Algebra.Field.Subfield.Defs
import Mathlib.Algebra.Field.TransferInstance
import Mathlib.Algebra.Field.ULift
import Mathlib.Algebra.Field.ZMod
import Mathlib.Algebra.FiveLemma
import Mathlib.Algebra.Free
import Mathlib.Algebra.FreeAbelianGroup.Finsupp
import Mathlib.Algebra.FreeAbelianGroup.UniqueSums
import Mathlib.Algebra.FreeAlgebra
import Mathlib.Algebra.FreeAlgebra.Cardinality
import Mathlib.Algebra.FreeMonoid.Basic
import Mathlib.Algebra.FreeMonoid.Count
import Mathlib.Algebra.FreeMonoid.Symbols
import Mathlib.Algebra.FreeMonoid.UniqueProds
import Mathlib.Algebra.FreeNonUnitalNonAssocAlgebra
import Mathlib.Algebra.GCDMonoid.Basic
import Mathlib.Algebra.GCDMonoid.Finset
import Mathlib.Algebra.GCDMonoid.IntegrallyClosed
import Mathlib.Algebra.GCDMonoid.Multiset
import Mathlib.Algebra.GCDMonoid.Nat
import Mathlib.Algebra.GCDMonoid.PUnit
import Mathlib.Algebra.GeomSum
import Mathlib.Algebra.GradedMonoid
import Mathlib.Algebra.GradedMulAction
import Mathlib.Algebra.Group.Action.Basic
import Mathlib.Algebra.Group.Action.Defs
import Mathlib.Algebra.Group.Action.End
import Mathlib.Algebra.Group.Action.Equidecomp
import Mathlib.Algebra.Group.Action.Faithful
import Mathlib.Algebra.Group.Action.Hom
import Mathlib.Algebra.Group.Action.Opposite
import Mathlib.Algebra.Group.Action.Option
import Mathlib.Algebra.Group.Action.Pi
import Mathlib.Algebra.Group.Action.Pointwise.Finset
import Mathlib.Algebra.Group.Action.Pointwise.Set.Basic
import Mathlib.Algebra.Group.Action.Pointwise.Set.Finite
import Mathlib.Algebra.Group.Action.Pretransitive
import Mathlib.Algebra.Group.Action.Prod
import Mathlib.Algebra.Group.Action.Sigma
import Mathlib.Algebra.Group.Action.Sum
import Mathlib.Algebra.Group.Action.TypeTags
import Mathlib.Algebra.Group.Action.Units
import Mathlib.Algebra.Group.AddChar
import Mathlib.Algebra.Group.Basic
import Mathlib.Algebra.Group.Center
import Mathlib.Algebra.Group.Commutator
import Mathlib.Algebra.Group.Commute.Basic
import Mathlib.Algebra.Group.Commute.Defs
import Mathlib.Algebra.Group.Commute.Hom
import Mathlib.Algebra.Group.Commute.Units
import Mathlib.Algebra.Group.Conj
import Mathlib.Algebra.Group.ConjFinite
import Mathlib.Algebra.Group.Defs
import Mathlib.Algebra.Group.Embedding
import Mathlib.Algebra.Group.End
import Mathlib.Algebra.Group.Equiv.Basic
import Mathlib.Algebra.Group.Equiv.Defs
import Mathlib.Algebra.Group.Equiv.Finite
import Mathlib.Algebra.Group.Equiv.Opposite
import Mathlib.Algebra.Group.Equiv.TypeTags
import Mathlib.Algebra.Group.Even
import Mathlib.Algebra.Group.EvenFunction
import Mathlib.Algebra.Group.Ext
import Mathlib.Algebra.Group.Fin.Basic
import Mathlib.Algebra.Group.Fin.Tuple
import Mathlib.Algebra.Group.FiniteSupport
import Mathlib.Algebra.Group.Finsupp
import Mathlib.Algebra.Group.ForwardDiff
import Mathlib.Algebra.Group.Graph
import Mathlib.Algebra.Group.Hom.Basic
import Mathlib.Algebra.Group.Hom.CompTypeclasses
import Mathlib.Algebra.Group.Hom.Defs
import Mathlib.Algebra.Group.Hom.End
import Mathlib.Algebra.Group.Hom.Instances
import Mathlib.Algebra.Group.Idempotent
import Mathlib.Algebra.Group.Indicator
import Mathlib.Algebra.Group.InjSurj
import Mathlib.Algebra.Group.Int.Defs
import Mathlib.Algebra.Group.Int.Even
import Mathlib.Algebra.Group.Int.TypeTags
import Mathlib.Algebra.Group.Int.Units
import Mathlib.Algebra.Group.Invertible.Basic
import Mathlib.Algebra.Group.Invertible.Defs
import Mathlib.Algebra.Group.Irreducible.Defs
import Mathlib.Algebra.Group.Irreducible.Lemmas
import Mathlib.Algebra.Group.MinimalAxioms
import Mathlib.Algebra.Group.Nat.Defs
import Mathlib.Algebra.Group.Nat.Even
import Mathlib.Algebra.Group.Nat.Hom
import Mathlib.Algebra.Group.Nat.Range
import Mathlib.Algebra.Group.Nat.TypeTags
import Mathlib.Algebra.Group.Nat.Units
import Mathlib.Algebra.Group.NatPowAssoc
import Mathlib.Algebra.Group.Opposite
import Mathlib.Algebra.Group.PNatPowAssoc
import Mathlib.Algebra.Group.PUnit
import Mathlib.Algebra.Group.Pi.Basic
import Mathlib.Algebra.Group.Pi.Lemmas
import Mathlib.Algebra.Group.Pi.Units
import Mathlib.Algebra.Group.Pointwise.Finset.Basic
import Mathlib.Algebra.Group.Pointwise.Finset.BigOperators
import Mathlib.Algebra.Group.Pointwise.Finset.Density
import Mathlib.Algebra.Group.Pointwise.Finset.Interval
import Mathlib.Algebra.Group.Pointwise.Finset.Scalar
import Mathlib.Algebra.Group.Pointwise.Set.Basic
import Mathlib.Algebra.Group.Pointwise.Set.BigOperators
import Mathlib.Algebra.Group.Pointwise.Set.Card
import Mathlib.Algebra.Group.Pointwise.Set.Finite
import Mathlib.Algebra.Group.Pointwise.Set.Lattice
import Mathlib.Algebra.Group.Pointwise.Set.ListOfFn
import Mathlib.Algebra.Group.Pointwise.Set.Scalar
import Mathlib.Algebra.Group.Prod
import Mathlib.Algebra.Group.Semiconj.Basic
import Mathlib.Algebra.Group.Semiconj.Defs
import Mathlib.Algebra.Group.Semiconj.Units
import Mathlib.Algebra.Group.Shrink
import Mathlib.Algebra.Group.Subgroup.Actions
import Mathlib.Algebra.Group.Subgroup.Basic
import Mathlib.Algebra.Group.Subgroup.Defs
import Mathlib.Algebra.Group.Subgroup.Even
import Mathlib.Algebra.Group.Subgroup.Finite
import Mathlib.Algebra.Group.Subgroup.Finsupp
import Mathlib.Algebra.Group.Subgroup.Ker
import Mathlib.Algebra.Group.Subgroup.Lattice
import Mathlib.Algebra.Group.Subgroup.Map
import Mathlib.Algebra.Group.Subgroup.MulOpposite
import Mathlib.Algebra.Group.Subgroup.MulOppositeLemmas
import Mathlib.Algebra.Group.Subgroup.Order
import Mathlib.Algebra.Group.Subgroup.Pointwise
import Mathlib.Algebra.Group.Subgroup.ZPowers.Basic
import Mathlib.Algebra.Group.Subgroup.ZPowers.Lemmas
import Mathlib.Algebra.Group.Submonoid.Basic
import Mathlib.Algebra.Group.Submonoid.BigOperators
import Mathlib.Algebra.Group.Submonoid.Defs
import Mathlib.Algebra.Group.Submonoid.DistribMulAction
import Mathlib.Algebra.Group.Submonoid.Finsupp
import Mathlib.Algebra.Group.Submonoid.Membership
import Mathlib.Algebra.Group.Submonoid.MulAction
import Mathlib.Algebra.Group.Submonoid.MulOpposite
import Mathlib.Algebra.Group.Submonoid.Operations
import Mathlib.Algebra.Group.Submonoid.Pointwise
import Mathlib.Algebra.Group.Submonoid.Units
import Mathlib.Algebra.Group.Subsemigroup.Basic
import Mathlib.Algebra.Group.Subsemigroup.Defs
import Mathlib.Algebra.Group.Subsemigroup.Membership
import Mathlib.Algebra.Group.Subsemigroup.Operations
import Mathlib.Algebra.Group.Support
import Mathlib.Algebra.Group.Torsion
import Mathlib.Algebra.Group.TransferInstance
import Mathlib.Algebra.Group.Translate
import Mathlib.Algebra.Group.TypeTags.Basic
import Mathlib.Algebra.Group.TypeTags.Finite
import Mathlib.Algebra.Group.TypeTags.Hom
import Mathlib.Algebra.Group.ULift
import Mathlib.Algebra.Group.UniqueProds.Basic
import Mathlib.Algebra.Group.UniqueProds.VectorSpace
import Mathlib.Algebra.Group.Units.Basic
import Mathlib.Algebra.Group.Units.Defs
import Mathlib.Algebra.Group.Units.Equiv
import Mathlib.Algebra.Group.Units.Hom
import Mathlib.Algebra.Group.Units.Opposite
import Mathlib.Algebra.Group.WithOne.Basic
import Mathlib.Algebra.Group.WithOne.Defs
import Mathlib.Algebra.GroupWithZero.Action.Basic
import Mathlib.Algebra.GroupWithZero.Action.Center
import Mathlib.Algebra.GroupWithZero.Action.ConjAct
import Mathlib.Algebra.GroupWithZero.Action.Defs
import Mathlib.Algebra.GroupWithZero.Action.End
import Mathlib.Algebra.GroupWithZero.Action.Faithful
import Mathlib.Algebra.GroupWithZero.Action.Hom
import Mathlib.Algebra.GroupWithZero.Action.Opposite
import Mathlib.Algebra.GroupWithZero.Action.Pi
import Mathlib.Algebra.GroupWithZero.Action.Pointwise.Finset
import Mathlib.Algebra.GroupWithZero.Action.Pointwise.Set
import Mathlib.Algebra.GroupWithZero.Action.Prod
import Mathlib.Algebra.GroupWithZero.Action.Units
import Mathlib.Algebra.GroupWithZero.Associated
import Mathlib.Algebra.GroupWithZero.Basic
import Mathlib.Algebra.GroupWithZero.Center
import Mathlib.Algebra.GroupWithZero.Commute
import Mathlib.Algebra.GroupWithZero.Conj
import Mathlib.Algebra.GroupWithZero.Defs
import Mathlib.Algebra.GroupWithZero.Divisibility
import Mathlib.Algebra.GroupWithZero.Equiv
import Mathlib.Algebra.GroupWithZero.Hom
import Mathlib.Algebra.GroupWithZero.Idempotent
import Mathlib.Algebra.GroupWithZero.Indicator
import Mathlib.Algebra.GroupWithZero.InjSurj
import Mathlib.Algebra.GroupWithZero.Int
import Mathlib.Algebra.GroupWithZero.Invertible
import Mathlib.Algebra.GroupWithZero.Nat
import Mathlib.Algebra.GroupWithZero.NeZero
import Mathlib.Algebra.GroupWithZero.NonZeroDivisors
import Mathlib.Algebra.GroupWithZero.Opposite
import Mathlib.Algebra.GroupWithZero.Pi
import Mathlib.Algebra.GroupWithZero.Pointwise.Finset
import Mathlib.Algebra.GroupWithZero.Pointwise.Set.Basic
import Mathlib.Algebra.GroupWithZero.Pointwise.Set.Card
import Mathlib.Algebra.GroupWithZero.Prod
import Mathlib.Algebra.GroupWithZero.ProdHom
import Mathlib.Algebra.GroupWithZero.Range
import Mathlib.Algebra.GroupWithZero.Regular
import Mathlib.Algebra.GroupWithZero.Semiconj
import Mathlib.Algebra.GroupWithZero.Shrink
import Mathlib.Algebra.GroupWithZero.Subgroup
import Mathlib.Algebra.GroupWithZero.Submonoid.Pointwise
import Mathlib.Algebra.GroupWithZero.Submonoid.Primal
import Mathlib.Algebra.GroupWithZero.TransferInstance
import Mathlib.Algebra.GroupWithZero.ULift
import Mathlib.Algebra.GroupWithZero.Units.Basic
import Mathlib.Algebra.GroupWithZero.Units.Equiv
import Mathlib.Algebra.GroupWithZero.Units.Lemmas
import Mathlib.Algebra.GroupWithZero.WithZero
import Mathlib.Algebra.HierarchyDesign
import Mathlib.Algebra.Homology.Additive
import Mathlib.Algebra.Homology.AlternatingConst
import Mathlib.Algebra.Homology.Augment
import Mathlib.Algebra.Homology.Bifunctor
import Mathlib.Algebra.Homology.BifunctorAssociator
import Mathlib.Algebra.Homology.BifunctorFlip
import Mathlib.Algebra.Homology.BifunctorHomotopy
import Mathlib.Algebra.Homology.BifunctorShift
import Mathlib.Algebra.Homology.CommSq
import Mathlib.Algebra.Homology.ComplexShape
import Mathlib.Algebra.Homology.ComplexShapeSigns
import Mathlib.Algebra.Homology.ConcreteCategory
import Mathlib.Algebra.Homology.DerivedCategory.Basic
import Mathlib.Algebra.Homology.DerivedCategory.ExactFunctor
import Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic
import Mathlib.Algebra.Homology.DerivedCategory.Ext.EnoughInjectives
import Mathlib.Algebra.Homology.DerivedCategory.Ext.EnoughProjectives
import Mathlib.Algebra.Homology.DerivedCategory.Ext.ExactSequences
import Mathlib.Algebra.Homology.DerivedCategory.Ext.ExtClass
import Mathlib.Algebra.Homology.DerivedCategory.Fractions
import Mathlib.Algebra.Homology.DerivedCategory.FullyFaithful
import Mathlib.Algebra.Homology.DerivedCategory.HomologySequence
import Mathlib.Algebra.Homology.DerivedCategory.ShortExact
import Mathlib.Algebra.Homology.DerivedCategory.SingleTriangle
import Mathlib.Algebra.Homology.DifferentialObject
import Mathlib.Algebra.Homology.Double
import Mathlib.Algebra.Homology.Embedding.Basic
import Mathlib.Algebra.Homology.Embedding.Boundary
import Mathlib.Algebra.Homology.Embedding.CochainComplex
import Mathlib.Algebra.Homology.Embedding.Connect
import Mathlib.Algebra.Homology.Embedding.Extend
import Mathlib.Algebra.Homology.Embedding.ExtendHomology
import Mathlib.Algebra.Homology.Embedding.HomEquiv
import Mathlib.Algebra.Homology.Embedding.IsSupported
import Mathlib.Algebra.Homology.Embedding.Restriction
import Mathlib.Algebra.Homology.Embedding.RestrictionHomology
import Mathlib.Algebra.Homology.Embedding.StupidTrunc
import Mathlib.Algebra.Homology.Embedding.TruncGE
import Mathlib.Algebra.Homology.Embedding.TruncGEHomology
import Mathlib.Algebra.Homology.Embedding.TruncLE
import Mathlib.Algebra.Homology.Embedding.TruncLEHomology
import Mathlib.Algebra.Homology.ExactSequence
import Mathlib.Algebra.Homology.Factorizations.Basic
import Mathlib.Algebra.Homology.Functor
import Mathlib.Algebra.Homology.GrothendieckAbelian
import Mathlib.Algebra.Homology.HasNoLoop
import Mathlib.Algebra.Homology.HomologicalBicomplex
import Mathlib.Algebra.Homology.HomologicalComplex
import Mathlib.Algebra.Homology.HomologicalComplexAbelian
import Mathlib.Algebra.Homology.HomologicalComplexBiprod
import Mathlib.Algebra.Homology.HomologicalComplexLimits
import Mathlib.Algebra.Homology.HomologySequence
import Mathlib.Algebra.Homology.HomologySequenceLemmas
import Mathlib.Algebra.Homology.Homotopy
import Mathlib.Algebra.Homology.HomotopyCategory
import Mathlib.Algebra.Homology.HomotopyCategory.DegreewiseSplit
import Mathlib.Algebra.Homology.HomotopyCategory.HomComplex
import Mathlib.Algebra.Homology.HomotopyCategory.HomComplexShift
import Mathlib.Algebra.Homology.HomotopyCategory.HomologicalFunctor
import Mathlib.Algebra.Homology.HomotopyCategory.MappingCone
import Mathlib.Algebra.Homology.HomotopyCategory.Pretriangulated
import Mathlib.Algebra.Homology.HomotopyCategory.Shift
import Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence
import Mathlib.Algebra.Homology.HomotopyCategory.ShortExact
import Mathlib.Algebra.Homology.HomotopyCategory.SingleFunctors
import Mathlib.Algebra.Homology.HomotopyCategory.Triangulated
import Mathlib.Algebra.Homology.HomotopyCofiber
import Mathlib.Algebra.Homology.ImageToKernel
import Mathlib.Algebra.Homology.Linear
import Mathlib.Algebra.Homology.LocalCohomology
import Mathlib.Algebra.Homology.Localization
import Mathlib.Algebra.Homology.Monoidal
import Mathlib.Algebra.Homology.Opposite
import Mathlib.Algebra.Homology.QuasiIso
import Mathlib.Algebra.Homology.Refinements
import Mathlib.Algebra.Homology.ShortComplex.Ab
import Mathlib.Algebra.Homology.ShortComplex.Abelian
import Mathlib.Algebra.Homology.ShortComplex.Basic
import Mathlib.Algebra.Homology.ShortComplex.ConcreteCategory
import Mathlib.Algebra.Homology.ShortComplex.Exact
import Mathlib.Algebra.Homology.ShortComplex.ExactFunctor
import Mathlib.Algebra.Homology.ShortComplex.FunctorEquivalence
import Mathlib.Algebra.Homology.ShortComplex.HomologicalComplex
import Mathlib.Algebra.Homology.ShortComplex.Homology
import Mathlib.Algebra.Homology.ShortComplex.LeftHomology
import Mathlib.Algebra.Homology.ShortComplex.Limits
import Mathlib.Algebra.Homology.ShortComplex.Linear
import Mathlib.Algebra.Homology.ShortComplex.ModuleCat
import Mathlib.Algebra.Homology.ShortComplex.Preadditive
import Mathlib.Algebra.Homology.ShortComplex.PreservesHomology
import Mathlib.Algebra.Homology.ShortComplex.QuasiIso
import Mathlib.Algebra.Homology.ShortComplex.Retract
import Mathlib.Algebra.Homology.ShortComplex.RightHomology
import Mathlib.Algebra.Homology.ShortComplex.ShortExact
import Mathlib.Algebra.Homology.ShortComplex.SnakeLemma
import Mathlib.Algebra.Homology.Single
import Mathlib.Algebra.Homology.SingleHomology
import Mathlib.Algebra.Homology.Square
import Mathlib.Algebra.Homology.TotalComplex
import Mathlib.Algebra.Homology.TotalComplexShift
import Mathlib.Algebra.Homology.TotalComplexSymmetry
import Mathlib.Algebra.IsPrimePow
import Mathlib.Algebra.Jordan.Basic
import Mathlib.Algebra.Lie.Abelian
import Mathlib.Algebra.Lie.BaseChange
import Mathlib.Algebra.Lie.Basic
import Mathlib.Algebra.Lie.CartanExists
import Mathlib.Algebra.Lie.CartanMatrix
import Mathlib.Algebra.Lie.CartanSubalgebra
import Mathlib.Algebra.Lie.Character
import Mathlib.Algebra.Lie.Classical
import Mathlib.Algebra.Lie.Derivation.AdjointAction
import Mathlib.Algebra.Lie.Derivation.Basic
import Mathlib.Algebra.Lie.Derivation.Killing
import Mathlib.Algebra.Lie.DirectSum
import Mathlib.Algebra.Lie.Engel
import Mathlib.Algebra.Lie.EngelSubalgebra
import Mathlib.Algebra.Lie.Extension
import Mathlib.Algebra.Lie.Free
import Mathlib.Algebra.Lie.Ideal
import Mathlib.Algebra.Lie.IdealOperations
import Mathlib.Algebra.Lie.InvariantForm
import Mathlib.Algebra.Lie.Killing
import Mathlib.Algebra.Lie.LieTheorem
import Mathlib.Algebra.Lie.Matrix
import Mathlib.Algebra.Lie.Nilpotent
import Mathlib.Algebra.Lie.NonUnitalNonAssocAlgebra
import Mathlib.Algebra.Lie.Normalizer
import Mathlib.Algebra.Lie.OfAssociative
import Mathlib.Algebra.Lie.Quotient
import Mathlib.Algebra.Lie.Rank
import Mathlib.Algebra.Lie.Semisimple.Basic
import Mathlib.Algebra.Lie.Semisimple.Defs
import Mathlib.Algebra.Lie.Semisimple.Lemmas
import Mathlib.Algebra.Lie.SkewAdjoint
import Mathlib.Algebra.Lie.Sl2
import Mathlib.Algebra.Lie.Solvable
import Mathlib.Algebra.Lie.Subalgebra
import Mathlib.Algebra.Lie.Submodule
import Mathlib.Algebra.Lie.TensorProduct
import Mathlib.Algebra.Lie.TraceForm
import Mathlib.Algebra.Lie.UniversalEnveloping
import Mathlib.Algebra.Lie.Weights.Basic
import Mathlib.Algebra.Lie.Weights.Cartan
import Mathlib.Algebra.Lie.Weights.Chain
import Mathlib.Algebra.Lie.Weights.Killing
import Mathlib.Algebra.Lie.Weights.Linear
import Mathlib.Algebra.Lie.Weights.RootSystem
import Mathlib.Algebra.LinearRecurrence
import Mathlib.Algebra.ModEq
import Mathlib.Algebra.Module.Basic
import Mathlib.Algebra.Module.BigOperators
import Mathlib.Algebra.Module.Bimodule
import Mathlib.Algebra.Module.Card
import Mathlib.Algebra.Module.CharacterModule
import Mathlib.Algebra.Module.DedekindDomain
import Mathlib.Algebra.Module.Defs
import Mathlib.Algebra.Module.End
import Mathlib.Algebra.Module.Equiv.Basic
import Mathlib.Algebra.Module.Equiv.Defs
import Mathlib.Algebra.Module.Equiv.Opposite
import Mathlib.Algebra.Module.FinitePresentation
import Mathlib.Algebra.Module.GradedModule
import Mathlib.Algebra.Module.Hom
import Mathlib.Algebra.Module.Injective
import Mathlib.Algebra.Module.Lattice
import Mathlib.Algebra.Module.LinearMap.Basic
import Mathlib.Algebra.Module.LinearMap.Defs
import Mathlib.Algebra.Module.LinearMap.End
import Mathlib.Algebra.Module.LinearMap.Polynomial
import Mathlib.Algebra.Module.LinearMap.Prod
import Mathlib.Algebra.Module.LinearMap.Rat
import Mathlib.Algebra.Module.LinearMap.Star
import Mathlib.Algebra.Module.LocalizedModule.AtPrime
import Mathlib.Algebra.Module.LocalizedModule.Away
import Mathlib.Algebra.Module.LocalizedModule.Basic
import Mathlib.Algebra.Module.LocalizedModule.Exact
import Mathlib.Algebra.Module.LocalizedModule.Int
import Mathlib.Algebra.Module.LocalizedModule.IsLocalization
import Mathlib.Algebra.Module.LocalizedModule.Submodule
import Mathlib.Algebra.Module.MinimalAxioms
import Mathlib.Algebra.Module.NatInt
import Mathlib.Algebra.Module.Opposite
import Mathlib.Algebra.Module.PID
import Mathlib.Algebra.Module.PUnit
import Mathlib.Algebra.Module.Pi
import Mathlib.Algebra.Module.PointwisePi
import Mathlib.Algebra.Module.Presentation.Basic
import Mathlib.Algebra.Module.Presentation.Cokernel
import Mathlib.Algebra.Module.Presentation.Differentials
import Mathlib.Algebra.Module.Presentation.DirectSum
import Mathlib.Algebra.Module.Presentation.Finite
import Mathlib.Algebra.Module.Presentation.Free
import Mathlib.Algebra.Module.Presentation.RestrictScalars
import Mathlib.Algebra.Module.Presentation.Tautological
import Mathlib.Algebra.Module.Presentation.Tensor
import Mathlib.Algebra.Module.Prod
import Mathlib.Algebra.Module.Projective
import Mathlib.Algebra.Module.Rat
import Mathlib.Algebra.Module.RingHom
import Mathlib.Algebra.Module.Shrink
import Mathlib.Algebra.Module.SnakeLemma
import Mathlib.Algebra.Module.SpanRank
import Mathlib.Algebra.Module.Submodule.Basic
import Mathlib.Algebra.Module.Submodule.Bilinear
import Mathlib.Algebra.Module.Submodule.Defs
import Mathlib.Algebra.Module.Submodule.EqLocus
import Mathlib.Algebra.Module.Submodule.Equiv
import Mathlib.Algebra.Module.Submodule.Invariant
import Mathlib.Algebra.Module.Submodule.IterateMapComap
import Mathlib.Algebra.Module.Submodule.Ker
import Mathlib.Algebra.Module.Submodule.Lattice
import Mathlib.Algebra.Module.Submodule.LinearMap
import Mathlib.Algebra.Module.Submodule.Map
import Mathlib.Algebra.Module.Submodule.Order
import Mathlib.Algebra.Module.Submodule.Pointwise
import Mathlib.Algebra.Module.Submodule.Range
import Mathlib.Algebra.Module.Submodule.RestrictScalars
import Mathlib.Algebra.Module.Submodule.Union
import Mathlib.Algebra.Module.Torsion
import Mathlib.Algebra.Module.TransferInstance
import Mathlib.Algebra.Module.ULift
import Mathlib.Algebra.Module.ZLattice.Basic
import Mathlib.Algebra.Module.ZLattice.Covolume
import Mathlib.Algebra.Module.ZMod
import Mathlib.Algebra.MonoidAlgebra.Basic
import Mathlib.Algebra.MonoidAlgebra.Defs
import Mathlib.Algebra.MonoidAlgebra.Degree
import Mathlib.Algebra.MonoidAlgebra.Division
import Mathlib.Algebra.MonoidAlgebra.Grading
import Mathlib.Algebra.MonoidAlgebra.Ideal
import Mathlib.Algebra.MonoidAlgebra.MapDomain
import Mathlib.Algebra.MonoidAlgebra.NoZeroDivisors
import Mathlib.Algebra.MonoidAlgebra.Support
import Mathlib.Algebra.MonoidAlgebra.ToDirectSum
import Mathlib.Algebra.MvPolynomial.Basic
import Mathlib.Algebra.MvPolynomial.Cardinal
import Mathlib.Algebra.MvPolynomial.Comap
import Mathlib.Algebra.MvPolynomial.CommRing
import Mathlib.Algebra.MvPolynomial.Counit
import Mathlib.Algebra.MvPolynomial.Degrees
import Mathlib.Algebra.MvPolynomial.Derivation
import Mathlib.Algebra.MvPolynomial.Division
import Mathlib.Algebra.MvPolynomial.Equiv
import Mathlib.Algebra.MvPolynomial.Eval
import Mathlib.Algebra.MvPolynomial.Expand
import Mathlib.Algebra.MvPolynomial.Funext
import Mathlib.Algebra.MvPolynomial.Invertible
import Mathlib.Algebra.MvPolynomial.Monad
import Mathlib.Algebra.MvPolynomial.Nilpotent
import Mathlib.Algebra.MvPolynomial.PDeriv
import Mathlib.Algebra.MvPolynomial.Polynomial
import Mathlib.Algebra.MvPolynomial.Rename
import Mathlib.Algebra.MvPolynomial.SchwartzZippel
import Mathlib.Algebra.MvPolynomial.Supported
import Mathlib.Algebra.MvPolynomial.Variables
import Mathlib.Algebra.NeZero
import Mathlib.Algebra.NoZeroSMulDivisors.Basic
import Mathlib.Algebra.NoZeroSMulDivisors.Defs
import Mathlib.Algebra.NoZeroSMulDivisors.Pi
import Mathlib.Algebra.NoZeroSMulDivisors.Prod
import Mathlib.Algebra.Notation
import Mathlib.Algebra.Notation.Defs
import Mathlib.Algebra.Notation.Lemmas
import Mathlib.Algebra.Notation.Pi.Basic
import Mathlib.Algebra.Notation.Pi.Defs
import Mathlib.Algebra.Notation.Prod
import Mathlib.Algebra.Opposites
import Mathlib.Algebra.Order.AbsoluteValue.Basic
import Mathlib.Algebra.Order.AbsoluteValue.Euclidean
import Mathlib.Algebra.Order.AddGroupWithTop
import Mathlib.Algebra.Order.AddTorsor
import Mathlib.Algebra.Order.Algebra
import Mathlib.Algebra.Order.Antidiag.Finsupp
import Mathlib.Algebra.Order.Antidiag.Nat
import Mathlib.Algebra.Order.Antidiag.Pi
import Mathlib.Algebra.Order.Antidiag.Prod
import Mathlib.Algebra.Order.Archimedean.Basic
import Mathlib.Algebra.Order.Archimedean.Class
import Mathlib.Algebra.Order.Archimedean.Hom
import Mathlib.Algebra.Order.Archimedean.IndicatorCard
import Mathlib.Algebra.Order.Archimedean.Submonoid
import Mathlib.Algebra.Order.BigOperators.Expect
import Mathlib.Algebra.Order.BigOperators.Group.Finset
import Mathlib.Algebra.Order.BigOperators.Group.List
import Mathlib.Algebra.Order.BigOperators.Group.LocallyFinite
import Mathlib.Algebra.Order.BigOperators.Group.Multiset
import Mathlib.Algebra.Order.BigOperators.GroupWithZero.List
import Mathlib.Algebra.Order.BigOperators.GroupWithZero.Multiset
import Mathlib.Algebra.Order.BigOperators.Ring.Finset
import Mathlib.Algebra.Order.BigOperators.Ring.List
import Mathlib.Algebra.Order.BigOperators.Ring.Multiset
import Mathlib.Algebra.Order.CauSeq.Basic
import Mathlib.Algebra.Order.CauSeq.BigOperators
import Mathlib.Algebra.Order.CauSeq.Completion
import Mathlib.Algebra.Order.Chebyshev
import Mathlib.Algebra.Order.CompleteField
import Mathlib.Algebra.Order.Disjointed
import Mathlib.Algebra.Order.Field.Basic
import Mathlib.Algebra.Order.Field.Canonical
import Mathlib.Algebra.Order.Field.Defs
import Mathlib.Algebra.Order.Field.InjSurj
import Mathlib.Algebra.Order.Field.Pi
import Mathlib.Algebra.Order.Field.Pointwise
import Mathlib.Algebra.Order.Field.Power
import Mathlib.Algebra.Order.Field.Rat
import Mathlib.Algebra.Order.Field.Subfield
import Mathlib.Algebra.Order.Floor
import Mathlib.Algebra.Order.Floor.Defs
import Mathlib.Algebra.Order.Floor.Div
import Mathlib.Algebra.Order.Floor.Ring
import Mathlib.Algebra.Order.Floor.Semiring
import Mathlib.Algebra.Order.Group.Abs
import Mathlib.Algebra.Order.Group.Action
import Mathlib.Algebra.Order.Group.Action.End
import Mathlib.Algebra.Order.Group.Action.Flag
import Mathlib.Algebra.Order.Group.Action.Synonym
import Mathlib.Algebra.Order.Group.Basic
import Mathlib.Algebra.Order.Group.Bounds
import Mathlib.Algebra.Order.Group.CompleteLattice
import Mathlib.Algebra.Order.Group.Cone
import Mathlib.Algebra.Order.Group.Cyclic
import Mathlib.Algebra.Order.Group.Defs
import Mathlib.Algebra.Order.Group.DenselyOrdered
import Mathlib.Algebra.Order.Group.End
import Mathlib.Algebra.Order.Group.Finset
import Mathlib.Algebra.Order.Group.Indicator
import Mathlib.Algebra.Order.Group.InjSurj
import Mathlib.Algebra.Order.Group.Instances
import Mathlib.Algebra.Order.Group.Int
import Mathlib.Algebra.Order.Group.Int.Sum
import Mathlib.Algebra.Order.Group.Lattice
import Mathlib.Algebra.Order.Group.MinMax
import Mathlib.Algebra.Order.Group.Multiset
import Mathlib.Algebra.Order.Group.Nat
import Mathlib.Algebra.Order.Group.Opposite
import Mathlib.Algebra.Order.Group.OrderIso
import Mathlib.Algebra.Order.Group.PiLex
import Mathlib.Algebra.Order.Group.Pointwise.Bounds
import Mathlib.Algebra.Order.Group.Pointwise.CompleteLattice
import Mathlib.Algebra.Order.Group.Pointwise.Interval
import Mathlib.Algebra.Order.Group.PosPart
import Mathlib.Algebra.Order.Group.Prod
import Mathlib.Algebra.Order.Group.Synonym
import Mathlib.Algebra.Order.Group.TypeTags
import Mathlib.Algebra.Order.Group.Unbundled.Abs
import Mathlib.Algebra.Order.Group.Unbundled.Basic
import Mathlib.Algebra.Order.Group.Unbundled.Int
import Mathlib.Algebra.Order.Group.Units
import Mathlib.Algebra.Order.GroupWithZero.Action.Synonym
import Mathlib.Algebra.Order.GroupWithZero.Bounds
import Mathlib.Algebra.Order.GroupWithZero.Canonical
import Mathlib.Algebra.Order.GroupWithZero.Finset
import Mathlib.Algebra.Order.GroupWithZero.Lex
import Mathlib.Algebra.Order.GroupWithZero.Submonoid
import Mathlib.Algebra.Order.GroupWithZero.Synonym
import Mathlib.Algebra.Order.GroupWithZero.Unbundled
import Mathlib.Algebra.Order.GroupWithZero.Unbundled.Basic
import Mathlib.Algebra.Order.GroupWithZero.Unbundled.Defs
import Mathlib.Algebra.Order.GroupWithZero.Unbundled.Lemmas
import Mathlib.Algebra.Order.GroupWithZero.Unbundled.OrderIso
import Mathlib.Algebra.Order.GroupWithZero.WithZero
import Mathlib.Algebra.Order.Hom.Basic
import Mathlib.Algebra.Order.Hom.Monoid
import Mathlib.Algebra.Order.Hom.MonoidWithZero
import Mathlib.Algebra.Order.Hom.Ring
import Mathlib.Algebra.Order.Hom.TypeTags
import Mathlib.Algebra.Order.Interval.Basic
import Mathlib.Algebra.Order.Interval.Finset.Basic
import Mathlib.Algebra.Order.Interval.Finset.SuccPred
import Mathlib.Algebra.Order.Interval.Multiset
import Mathlib.Algebra.Order.Interval.Set.Group
import Mathlib.Algebra.Order.Interval.Set.Instances
import Mathlib.Algebra.Order.Interval.Set.Monoid
import Mathlib.Algebra.Order.Interval.Set.SuccPred
import Mathlib.Algebra.Order.Invertible
import Mathlib.Algebra.Order.Kleene
import Mathlib.Algebra.Order.Module.Algebra
import Mathlib.Algebra.Order.Module.Basic
import Mathlib.Algebra.Order.Module.Defs
import Mathlib.Algebra.Order.Module.Field
import Mathlib.Algebra.Order.Module.OrderedSMul
import Mathlib.Algebra.Order.Module.Pointwise
import Mathlib.Algebra.Order.Module.PositiveLinearMap
import Mathlib.Algebra.Order.Module.Rat
import Mathlib.Algebra.Order.Module.Synonym
import Mathlib.Algebra.Order.Monoid.Associated
import Mathlib.Algebra.Order.Monoid.Basic
import Mathlib.Algebra.Order.Monoid.Canonical.Basic
import Mathlib.Algebra.Order.Monoid.Canonical.Defs
import Mathlib.Algebra.Order.Monoid.Defs
import Mathlib.Algebra.Order.Monoid.Lex
import Mathlib.Algebra.Order.Monoid.LocallyFiniteOrder
import Mathlib.Algebra.Order.Monoid.NatCast
import Mathlib.Algebra.Order.Monoid.OrderDual
import Mathlib.Algebra.Order.Monoid.Prod
import Mathlib.Algebra.Order.Monoid.Submonoid
import Mathlib.Algebra.Order.Monoid.ToMulBot
import Mathlib.Algebra.Order.Monoid.TypeTags
import Mathlib.Algebra.Order.Monoid.Unbundled.Basic
import Mathlib.Algebra.Order.Monoid.Unbundled.Defs
import Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE
import Mathlib.Algebra.Order.Monoid.Unbundled.MinMax
import Mathlib.Algebra.Order.Monoid.Unbundled.OrderDual
import Mathlib.Algebra.Order.Monoid.Unbundled.Pow
import Mathlib.Algebra.Order.Monoid.Unbundled.TypeTags
import Mathlib.Algebra.Order.Monoid.Unbundled.WithTop
import Mathlib.Algebra.Order.Monoid.Units
import Mathlib.Algebra.Order.Monoid.WithTop
import Mathlib.Algebra.Order.Monovary
import Mathlib.Algebra.Order.Nonneg.Basic
import Mathlib.Algebra.Order.Nonneg.Field
import Mathlib.Algebra.Order.Nonneg.Floor
import Mathlib.Algebra.Order.Nonneg.Lattice
import Mathlib.Algebra.Order.Nonneg.Module
import Mathlib.Algebra.Order.Nonneg.Ring
import Mathlib.Algebra.Order.PUnit
import Mathlib.Algebra.Order.PartialSups
import Mathlib.Algebra.Order.Pi
import Mathlib.Algebra.Order.Positive.Field
import Mathlib.Algebra.Order.Positive.Ring
import Mathlib.Algebra.Order.Quantale
import Mathlib.Algebra.Order.Rearrangement
import Mathlib.Algebra.Order.Ring.Abs
import Mathlib.Algebra.Order.Ring.Basic
import Mathlib.Algebra.Order.Ring.Canonical
import Mathlib.Algebra.Order.Ring.Cast
import Mathlib.Algebra.Order.Ring.Cone
import Mathlib.Algebra.Order.Ring.Defs
import Mathlib.Algebra.Order.Ring.Finset
import Mathlib.Algebra.Order.Ring.Idempotent
import Mathlib.Algebra.Order.Ring.InjSurj
import Mathlib.Algebra.Order.Ring.Int
import Mathlib.Algebra.Order.Ring.IsNonarchimedean
import Mathlib.Algebra.Order.Ring.Nat
import Mathlib.Algebra.Order.Ring.Opposite
import Mathlib.Algebra.Order.Ring.Pow
import Mathlib.Algebra.Order.Ring.Prod
import Mathlib.Algebra.Order.Ring.Rat
import Mathlib.Algebra.Order.Ring.Star
import Mathlib.Algebra.Order.Ring.Synonym
import Mathlib.Algebra.Order.Ring.Unbundled.Basic
import Mathlib.Algebra.Order.Ring.Unbundled.Rat
import Mathlib.Algebra.Order.Ring.WithTop
import Mathlib.Algebra.Order.Round
import Mathlib.Algebra.Order.Star.Basic
import Mathlib.Algebra.Order.Star.Conjneg
import Mathlib.Algebra.Order.Star.Prod
import Mathlib.Algebra.Order.Sub.Basic
import Mathlib.Algebra.Order.Sub.Defs
import Mathlib.Algebra.Order.Sub.Prod
import Mathlib.Algebra.Order.Sub.Unbundled.Basic
import Mathlib.Algebra.Order.Sub.Unbundled.Hom
import Mathlib.Algebra.Order.Sub.WithTop
import Mathlib.Algebra.Order.SuccPred
import Mathlib.Algebra.Order.SuccPred.TypeTags
import Mathlib.Algebra.Order.SuccPred.WithBot
import Mathlib.Algebra.Order.Sum
import Mathlib.Algebra.Order.ToIntervalMod
import Mathlib.Algebra.Order.UpperLower
import Mathlib.Algebra.Order.WithTop.Untop0
import Mathlib.Algebra.Order.ZeroLEOne
import Mathlib.Algebra.PEmptyInstances
import Mathlib.Algebra.Pointwise.Stabilizer
import Mathlib.Algebra.Polynomial.AlgebraMap
import Mathlib.Algebra.Polynomial.Basic
import Mathlib.Algebra.Polynomial.Basis
import Mathlib.Algebra.Polynomial.BigOperators
import Mathlib.Algebra.Polynomial.Bivariate
import Mathlib.Algebra.Polynomial.CancelLeads
import Mathlib.Algebra.Polynomial.Cardinal
import Mathlib.Algebra.Polynomial.Coeff
import Mathlib.Algebra.Polynomial.CoeffList
import Mathlib.Algebra.Polynomial.CoeffMem
import Mathlib.Algebra.Polynomial.Degree.CardPowDegree
import Mathlib.Algebra.Polynomial.Degree.Definitions
import Mathlib.Algebra.Polynomial.Degree.Domain
import Mathlib.Algebra.Polynomial.Degree.IsMonicOfDegree
import Mathlib.Algebra.Polynomial.Degree.Lemmas
import Mathlib.Algebra.Polynomial.Degree.Monomial
import Mathlib.Algebra.Polynomial.Degree.Operations
import Mathlib.Algebra.Polynomial.Degree.SmallDegree
import Mathlib.Algebra.Polynomial.Degree.Support
import Mathlib.Algebra.Polynomial.Degree.TrailingDegree
import Mathlib.Algebra.Polynomial.Degree.Units
import Mathlib.Algebra.Polynomial.DenomsClearable
import Mathlib.Algebra.Polynomial.Derivation
import Mathlib.Algebra.Polynomial.Derivative
import Mathlib.Algebra.Polynomial.Div
import Mathlib.Algebra.Polynomial.EraseLead
import Mathlib.Algebra.Polynomial.Eval.Algebra
import Mathlib.Algebra.Polynomial.Eval.Coeff
import Mathlib.Algebra.Polynomial.Eval.Defs
import Mathlib.Algebra.Polynomial.Eval.Degree
import Mathlib.Algebra.Polynomial.Eval.Irreducible
import Mathlib.Algebra.Polynomial.Eval.SMul
import Mathlib.Algebra.Polynomial.Eval.Subring
import Mathlib.Algebra.Polynomial.Expand
import Mathlib.Algebra.Polynomial.FieldDivision
import Mathlib.Algebra.Polynomial.GroupRingAction
import Mathlib.Algebra.Polynomial.HasseDeriv
import Mathlib.Algebra.Polynomial.Identities
import Mathlib.Algebra.Polynomial.Inductions
import Mathlib.Algebra.Polynomial.Laurent
import Mathlib.Algebra.Polynomial.Lifts
import Mathlib.Algebra.Polynomial.Mirror
import Mathlib.Algebra.Polynomial.Module.AEval
import Mathlib.Algebra.Polynomial.Module.Basic
import Mathlib.Algebra.Polynomial.Module.FiniteDimensional
import Mathlib.Algebra.Polynomial.Monic
import Mathlib.Algebra.Polynomial.Monomial
import Mathlib.Algebra.Polynomial.OfFn
import Mathlib.Algebra.Polynomial.PartialFractions
import Mathlib.Algebra.Polynomial.Reverse
import Mathlib.Algebra.Polynomial.RingDivision
import Mathlib.Algebra.Polynomial.Roots
import Mathlib.Algebra.Polynomial.Sequence
import Mathlib.Algebra.Polynomial.Smeval
import Mathlib.Algebra.Polynomial.SpecificDegree
import Mathlib.Algebra.Polynomial.Splits
import Mathlib.Algebra.Polynomial.SumIteratedDerivative
import Mathlib.Algebra.Polynomial.Taylor
import Mathlib.Algebra.Polynomial.UnitTrinomial
import Mathlib.Algebra.PresentedMonoid.Basic
import Mathlib.Algebra.Prime.Defs
import Mathlib.Algebra.Prime.Lemmas
import Mathlib.Algebra.QuadraticDiscriminant
import Mathlib.Algebra.Quandle
import Mathlib.Algebra.Quaternion
import Mathlib.Algebra.QuaternionBasis
import Mathlib.Algebra.Quotient
import Mathlib.Algebra.Regular.Basic
import Mathlib.Algebra.Regular.Defs
import Mathlib.Algebra.Regular.Opposite
import Mathlib.Algebra.Regular.Pi
import Mathlib.Algebra.Regular.Pow
import Mathlib.Algebra.Regular.Prod
import Mathlib.Algebra.Regular.SMul
import Mathlib.Algebra.Regular.ULift
import Mathlib.Algebra.Ring.Action.Basic
import Mathlib.Algebra.Ring.Action.ConjAct
import Mathlib.Algebra.Ring.Action.End
import Mathlib.Algebra.Ring.Action.Field
import Mathlib.Algebra.Ring.Action.Group
import Mathlib.Algebra.Ring.Action.Invariant
import Mathlib.Algebra.Ring.Action.Pointwise.Finset
import Mathlib.Algebra.Ring.Action.Pointwise.Set
import Mathlib.Algebra.Ring.Action.Rat
import Mathlib.Algebra.Ring.Action.Submonoid
import Mathlib.Algebra.Ring.Action.Subobjects
import Mathlib.Algebra.Ring.AddAut
import Mathlib.Algebra.Ring.Associated
import Mathlib.Algebra.Ring.Associator
import Mathlib.Algebra.Ring.Aut
import Mathlib.Algebra.Ring.Basic
import Mathlib.Algebra.Ring.BooleanRing
import Mathlib.Algebra.Ring.Center
import Mathlib.Algebra.Ring.Centralizer
import Mathlib.Algebra.Ring.CentroidHom
import Mathlib.Algebra.Ring.CharZero
import Mathlib.Algebra.Ring.Commute
import Mathlib.Algebra.Ring.CompTypeclasses
import Mathlib.Algebra.Ring.Defs
import Mathlib.Algebra.Ring.Divisibility.Basic
import Mathlib.Algebra.Ring.Divisibility.Lemmas
import Mathlib.Algebra.Ring.Equiv
import Mathlib.Algebra.Ring.Ext
import Mathlib.Algebra.Ring.Fin
import Mathlib.Algebra.Ring.GrindInstances
import Mathlib.Algebra.Ring.Hom.Basic
import Mathlib.Algebra.Ring.Hom.Defs
import Mathlib.Algebra.Ring.Hom.InjSurj
import Mathlib.Algebra.Ring.Idempotent
import Mathlib.Algebra.Ring.Identities
import Mathlib.Algebra.Ring.InjSurj
import Mathlib.Algebra.Ring.Int.Defs
import Mathlib.Algebra.Ring.Int.Parity
import Mathlib.Algebra.Ring.Int.Units
import Mathlib.Algebra.Ring.Invertible
import Mathlib.Algebra.Ring.MinimalAxioms
import Mathlib.Algebra.Ring.Nat
import Mathlib.Algebra.Ring.NegOnePow
import Mathlib.Algebra.Ring.NonZeroDivisors
import Mathlib.Algebra.Ring.Opposite
import Mathlib.Algebra.Ring.PUnit
import Mathlib.Algebra.Ring.Parity
import Mathlib.Algebra.Ring.Periodic
import Mathlib.Algebra.Ring.Pi
import Mathlib.Algebra.Ring.Pointwise.Finset
import Mathlib.Algebra.Ring.Pointwise.Set
import Mathlib.Algebra.Ring.Prod
import Mathlib.Algebra.Ring.Rat
import Mathlib.Algebra.Ring.Regular
import Mathlib.Algebra.Ring.Semiconj
import Mathlib.Algebra.Ring.Semireal.Defs
import Mathlib.Algebra.Ring.Shrink
import Mathlib.Algebra.Ring.Subgroup
import Mathlib.Algebra.Ring.Submonoid
import Mathlib.Algebra.Ring.Submonoid.Basic
import Mathlib.Algebra.Ring.Submonoid.Pointwise
import Mathlib.Algebra.Ring.Subring.Basic
import Mathlib.Algebra.Ring.Subring.Defs
import Mathlib.Algebra.Ring.Subring.IntPolynomial
import Mathlib.Algebra.Ring.Subring.MulOpposite
import Mathlib.Algebra.Ring.Subring.Order
import Mathlib.Algebra.Ring.Subring.Pointwise
import Mathlib.Algebra.Ring.Subring.Units
import Mathlib.Algebra.Ring.Subsemiring.Basic
import Mathlib.Algebra.Ring.Subsemiring.Defs
import Mathlib.Algebra.Ring.Subsemiring.MulOpposite
import Mathlib.Algebra.Ring.Subsemiring.Order
import Mathlib.Algebra.Ring.Subsemiring.Pointwise
import Mathlib.Algebra.Ring.SumsOfSquares
import Mathlib.Algebra.Ring.Torsion
import Mathlib.Algebra.Ring.TransferInstance
import Mathlib.Algebra.Ring.ULift
import Mathlib.Algebra.Ring.Units
import Mathlib.Algebra.Ring.WithZero
import Mathlib.Algebra.RingQuot
import Mathlib.Algebra.SkewMonoidAlgebra.Basic
import Mathlib.Algebra.Squarefree.Basic
import Mathlib.Algebra.Star.Basic
import Mathlib.Algebra.Star.BigOperators
import Mathlib.Algebra.Star.CHSH
import Mathlib.Algebra.Star.Center
import Mathlib.Algebra.Star.CentroidHom
import Mathlib.Algebra.Star.Conjneg
import Mathlib.Algebra.Star.Free
import Mathlib.Algebra.Star.Module
import Mathlib.Algebra.Star.MonoidHom
import Mathlib.Algebra.Star.NonUnitalSubalgebra
import Mathlib.Algebra.Star.NonUnitalSubsemiring
import Mathlib.Algebra.Star.Pi
import Mathlib.Algebra.Star.Pointwise
import Mathlib.Algebra.Star.Prod
import Mathlib.Algebra.Star.Rat
import Mathlib.Algebra.Star.RingQuot
import Mathlib.Algebra.Star.SelfAdjoint
import Mathlib.Algebra.Star.StarAlgHom
import Mathlib.Algebra.Star.StarProjection
import Mathlib.Algebra.Star.StarRingHom
import Mathlib.Algebra.Star.Subalgebra
import Mathlib.Algebra.Star.Subsemiring
import Mathlib.Algebra.Star.Unitary
import Mathlib.Algebra.Symmetrized
import Mathlib.Algebra.TrivSqZeroExt
import Mathlib.Algebra.Tropical.Basic
import Mathlib.Algebra.Tropical.BigOperators
import Mathlib.Algebra.Tropical.Lattice
import Mathlib.Algebra.Vertex.HVertexOperator
import Mathlib.Algebra.Vertex.VertexOperator
import Mathlib.AlgebraicGeometry.AffineScheme
import Mathlib.AlgebraicGeometry.AffineSpace
import Mathlib.AlgebraicGeometry.AffineTransitionLimit
import Mathlib.AlgebraicGeometry.Cover.MorphismProperty
import Mathlib.AlgebraicGeometry.Cover.Open
import Mathlib.AlgebraicGeometry.Cover.Over
import Mathlib.AlgebraicGeometry.Cover.Sigma
import Mathlib.AlgebraicGeometry.EllipticCurve.Affine
import Mathlib.AlgebraicGeometry.EllipticCurve.Affine.Basic
import Mathlib.AlgebraicGeometry.EllipticCurve.Affine.Formula
import Mathlib.AlgebraicGeometry.EllipticCurve.Affine.Point
import Mathlib.AlgebraicGeometry.EllipticCurve.DivisionPolynomial.Basic
import Mathlib.AlgebraicGeometry.EllipticCurve.DivisionPolynomial.Degree
import Mathlib.AlgebraicGeometry.EllipticCurve.Group
import Mathlib.AlgebraicGeometry.EllipticCurve.IsomOfJ
import Mathlib.AlgebraicGeometry.EllipticCurve.Jacobian.Basic
import Mathlib.AlgebraicGeometry.EllipticCurve.Jacobian.Formula
import Mathlib.AlgebraicGeometry.EllipticCurve.Jacobian.Point
import Mathlib.AlgebraicGeometry.EllipticCurve.ModelsWithJ
import Mathlib.AlgebraicGeometry.EllipticCurve.NormalForms
import Mathlib.AlgebraicGeometry.EllipticCurve.Projective.Basic
import Mathlib.AlgebraicGeometry.EllipticCurve.Projective.Formula
import Mathlib.AlgebraicGeometry.EllipticCurve.Projective.Point
import Mathlib.AlgebraicGeometry.EllipticCurve.VariableChange
import Mathlib.AlgebraicGeometry.EllipticCurve.Weierstrass
import Mathlib.AlgebraicGeometry.Fiber
import Mathlib.AlgebraicGeometry.FunctionField
import Mathlib.AlgebraicGeometry.GammaSpecAdjunction
import Mathlib.AlgebraicGeometry.Gluing
import Mathlib.AlgebraicGeometry.GluingOneHypercover
import Mathlib.AlgebraicGeometry.IdealSheaf
import Mathlib.AlgebraicGeometry.IdealSheaf.Basic
import Mathlib.AlgebraicGeometry.IdealSheaf.Functorial
import Mathlib.AlgebraicGeometry.IdealSheaf.Subscheme
import Mathlib.AlgebraicGeometry.Limits
import Mathlib.AlgebraicGeometry.Modules.Presheaf
import Mathlib.AlgebraicGeometry.Modules.Sheaf
import Mathlib.AlgebraicGeometry.Modules.Tilde
import Mathlib.AlgebraicGeometry.Morphisms.Affine
import Mathlib.AlgebraicGeometry.Morphisms.AffineAnd
import Mathlib.AlgebraicGeometry.Morphisms.Basic
import Mathlib.AlgebraicGeometry.Morphisms.ClosedImmersion
import Mathlib.AlgebraicGeometry.Morphisms.Constructors
import Mathlib.AlgebraicGeometry.Morphisms.Descent
import Mathlib.AlgebraicGeometry.Morphisms.Etale
import Mathlib.AlgebraicGeometry.Morphisms.Finite
import Mathlib.AlgebraicGeometry.Morphisms.FinitePresentation
import Mathlib.AlgebraicGeometry.Morphisms.FiniteType
import Mathlib.AlgebraicGeometry.Morphisms.Flat
import Mathlib.AlgebraicGeometry.Morphisms.FormallyUnramified
import Mathlib.AlgebraicGeometry.Morphisms.Immersion
import Mathlib.AlgebraicGeometry.Morphisms.Integral
import Mathlib.AlgebraicGeometry.Morphisms.IsIso
import Mathlib.AlgebraicGeometry.Morphisms.LocalClosure
import Mathlib.AlgebraicGeometry.Morphisms.LocalIso
import Mathlib.AlgebraicGeometry.Morphisms.OpenImmersion
import Mathlib.AlgebraicGeometry.Morphisms.Preimmersion
import Mathlib.AlgebraicGeometry.Morphisms.Proper
import Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact
import Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated
import Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties
import Mathlib.AlgebraicGeometry.Morphisms.Separated
import Mathlib.AlgebraicGeometry.Morphisms.Smooth
import Mathlib.AlgebraicGeometry.Morphisms.SurjectiveOnStalks
import Mathlib.AlgebraicGeometry.Morphisms.UnderlyingMap
import Mathlib.AlgebraicGeometry.Morphisms.UniversallyClosed
import Mathlib.AlgebraicGeometry.Morphisms.UniversallyInjective
import Mathlib.AlgebraicGeometry.Morphisms.UniversallyOpen
import Mathlib.AlgebraicGeometry.Noetherian
import Mathlib.AlgebraicGeometry.OpenImmersion
import Mathlib.AlgebraicGeometry.Over
import Mathlib.AlgebraicGeometry.PointsPi
import Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Basic
import Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Proper
import Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Scheme
import Mathlib.AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf
import Mathlib.AlgebraicGeometry.ProjectiveSpectrum.Topology
import Mathlib.AlgebraicGeometry.Properties
import Mathlib.AlgebraicGeometry.PullbackCarrier
import Mathlib.AlgebraicGeometry.Pullbacks
import Mathlib.AlgebraicGeometry.RationalMap
import Mathlib.AlgebraicGeometry.ResidueField
import Mathlib.AlgebraicGeometry.Restrict
import Mathlib.AlgebraicGeometry.Scheme
import Mathlib.AlgebraicGeometry.Sites.BigZariski
import Mathlib.AlgebraicGeometry.Sites.Etale
import Mathlib.AlgebraicGeometry.Sites.MorphismProperty
import Mathlib.AlgebraicGeometry.Sites.Representability
import Mathlib.AlgebraicGeometry.Sites.Small
import Mathlib.AlgebraicGeometry.Sites.SmallAffineZariski
import Mathlib.AlgebraicGeometry.Spec
import Mathlib.AlgebraicGeometry.SpreadingOut
import Mathlib.AlgebraicGeometry.Stalk
import Mathlib.AlgebraicGeometry.StructureSheaf
import Mathlib.AlgebraicGeometry.ValuativeCriterion
import Mathlib.AlgebraicTopology.AlternatingFaceMapComplex
import Mathlib.AlgebraicTopology.CechNerve
import Mathlib.AlgebraicTopology.DoldKan.Compatibility
import Mathlib.AlgebraicTopology.DoldKan.Decomposition
import Mathlib.AlgebraicTopology.DoldKan.Degeneracies
import Mathlib.AlgebraicTopology.DoldKan.Equivalence
import Mathlib.AlgebraicTopology.DoldKan.EquivalenceAdditive
import Mathlib.AlgebraicTopology.DoldKan.EquivalencePseudoabelian
import Mathlib.AlgebraicTopology.DoldKan.Faces
import Mathlib.AlgebraicTopology.DoldKan.FunctorGamma
import Mathlib.AlgebraicTopology.DoldKan.FunctorN
import Mathlib.AlgebraicTopology.DoldKan.GammaCompN
import Mathlib.AlgebraicTopology.DoldKan.Homotopies
import Mathlib.AlgebraicTopology.DoldKan.HomotopyEquivalence
import Mathlib.AlgebraicTopology.DoldKan.NCompGamma
import Mathlib.AlgebraicTopology.DoldKan.NReflectsIso
import Mathlib.AlgebraicTopology.DoldKan.Normalized
import Mathlib.AlgebraicTopology.DoldKan.Notations
import Mathlib.AlgebraicTopology.DoldKan.PInfty
import Mathlib.AlgebraicTopology.DoldKan.Projections
import Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject
import Mathlib.AlgebraicTopology.ExtraDegeneracy
import Mathlib.AlgebraicTopology.FundamentalGroupoid.Basic
import Mathlib.AlgebraicTopology.FundamentalGroupoid.FundamentalGroup
import Mathlib.AlgebraicTopology.FundamentalGroupoid.InducedMaps
import Mathlib.AlgebraicTopology.FundamentalGroupoid.PUnit
import Mathlib.AlgebraicTopology.FundamentalGroupoid.Product
import Mathlib.AlgebraicTopology.FundamentalGroupoid.SimplyConnected
import Mathlib.AlgebraicTopology.ModelCategory.Basic
import Mathlib.AlgebraicTopology.ModelCategory.CategoryWithCofibrations
import Mathlib.AlgebraicTopology.ModelCategory.Cylinder
import Mathlib.AlgebraicTopology.ModelCategory.Instances
import Mathlib.AlgebraicTopology.ModelCategory.IsCofibrant
import Mathlib.AlgebraicTopology.ModelCategory.JoyalTrick
import Mathlib.AlgebraicTopology.MooreComplex
import Mathlib.AlgebraicTopology.Quasicategory.Basic
import Mathlib.AlgebraicTopology.Quasicategory.Nerve
import Mathlib.AlgebraicTopology.Quasicategory.StrictSegal
import Mathlib.AlgebraicTopology.RelativeCellComplex.AttachCells
import Mathlib.AlgebraicTopology.RelativeCellComplex.Basic
import Mathlib.AlgebraicTopology.SimplexCategory.Augmented
import Mathlib.AlgebraicTopology.SimplexCategory.Basic
import Mathlib.AlgebraicTopology.SimplexCategory.Defs
import Mathlib.AlgebraicTopology.SimplexCategory.GeneratorsRelations.Basic
import Mathlib.AlgebraicTopology.SimplexCategory.GeneratorsRelations.EpiMono
import Mathlib.AlgebraicTopology.SimplexCategory.GeneratorsRelations.NormalForms
import Mathlib.AlgebraicTopology.SimplexCategory.MorphismProperty
import Mathlib.AlgebraicTopology.SimplexCategory.Truncated
import Mathlib.AlgebraicTopology.SimplicialCategory.Basic
import Mathlib.AlgebraicTopology.SimplicialCategory.SimplicialObject
import Mathlib.AlgebraicTopology.SimplicialNerve
import Mathlib.AlgebraicTopology.SimplicialObject.Basic
import Mathlib.AlgebraicTopology.SimplicialObject.Coskeletal
import Mathlib.AlgebraicTopology.SimplicialObject.Split
import Mathlib.AlgebraicTopology.SimplicialSet.Basic
import Mathlib.AlgebraicTopology.SimplicialSet.Boundary
import Mathlib.AlgebraicTopology.SimplicialSet.CategoryWithFibrations
import Mathlib.AlgebraicTopology.SimplicialSet.Coskeletal
import Mathlib.AlgebraicTopology.SimplicialSet.Degenerate
import Mathlib.AlgebraicTopology.SimplicialSet.HomotopyCat
import Mathlib.AlgebraicTopology.SimplicialSet.Horn
import Mathlib.AlgebraicTopology.SimplicialSet.KanComplex
import Mathlib.AlgebraicTopology.SimplicialSet.Monoidal
import Mathlib.AlgebraicTopology.SimplicialSet.Nerve
import Mathlib.AlgebraicTopology.SimplicialSet.NerveAdjunction
import Mathlib.AlgebraicTopology.SimplicialSet.Path
import Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex
import Mathlib.AlgebraicTopology.SimplicialSet.StrictSegal
import Mathlib.AlgebraicTopology.SimplicialSet.Subcomplex
import Mathlib.AlgebraicTopology.SingularHomology.Basic
import Mathlib.AlgebraicTopology.SingularSet
import Mathlib.AlgebraicTopology.TopologicalSimplex
import Mathlib.Analysis.AbsoluteValue.Equivalence
import Mathlib.Analysis.Analytic.Basic
import Mathlib.Analysis.Analytic.CPolynomial
import Mathlib.Analysis.Analytic.CPolynomialDef
import Mathlib.Analysis.Analytic.ChangeOrigin
import Mathlib.Analysis.Analytic.Composition
import Mathlib.Analysis.Analytic.Constructions
import Mathlib.Analysis.Analytic.Inverse
import Mathlib.Analysis.Analytic.IsolatedZeros
import Mathlib.Analysis.Analytic.IteratedFDeriv
import Mathlib.Analysis.Analytic.Linear
import Mathlib.Analysis.Analytic.OfScalars
import Mathlib.Analysis.Analytic.Order
import Mathlib.Analysis.Analytic.Polynomial
import Mathlib.Analysis.Analytic.RadiusLiminf
import Mathlib.Analysis.Analytic.Uniqueness
import Mathlib.Analysis.Analytic.Within
import Mathlib.Analysis.Asymptotics.AsymptoticEquivalent
import Mathlib.Analysis.Asymptotics.Completion
import Mathlib.Analysis.Asymptotics.Defs
import Mathlib.Analysis.Asymptotics.ExpGrowth
import Mathlib.Analysis.Asymptotics.Lemmas
import Mathlib.Analysis.Asymptotics.LinearGrowth
import Mathlib.Analysis.Asymptotics.SpecificAsymptotics
import Mathlib.Analysis.Asymptotics.SuperpolynomialDecay
import Mathlib.Analysis.Asymptotics.TVS
import Mathlib.Analysis.Asymptotics.Theta
import Mathlib.Analysis.BoundedVariation
import Mathlib.Analysis.BoxIntegral.Basic
import Mathlib.Analysis.BoxIntegral.Box.Basic
import Mathlib.Analysis.BoxIntegral.Box.SubboxInduction
import Mathlib.Analysis.BoxIntegral.DivergenceTheorem
import Mathlib.Analysis.BoxIntegral.Integrability
import Mathlib.Analysis.BoxIntegral.Partition.Additive
import Mathlib.Analysis.BoxIntegral.Partition.Basic
import Mathlib.Analysis.BoxIntegral.Partition.Filter
import Mathlib.Analysis.BoxIntegral.Partition.Measure
import Mathlib.Analysis.BoxIntegral.Partition.Split
import Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction
import Mathlib.Analysis.BoxIntegral.Partition.Tagged
import Mathlib.Analysis.BoxIntegral.UnitPartition
import Mathlib.Analysis.CStarAlgebra.ApproximateUnit
import Mathlib.Analysis.CStarAlgebra.Basic
import Mathlib.Analysis.CStarAlgebra.CStarMatrix
import Mathlib.Analysis.CStarAlgebra.Classes
import Mathlib.Analysis.CStarAlgebra.CompletelyPositiveMap
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Basic
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Continuity
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Instances
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Integral
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Isometric
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.NonUnital
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Note
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Pi
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Restrict
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unital
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unitary
import Mathlib.Analysis.CStarAlgebra.ContinuousLinearMap
import Mathlib.Analysis.CStarAlgebra.ContinuousMap
import Mathlib.Analysis.CStarAlgebra.Exponential
import Mathlib.Analysis.CStarAlgebra.GelfandDuality
import Mathlib.Analysis.CStarAlgebra.Hom
import Mathlib.Analysis.CStarAlgebra.Matrix
import Mathlib.Analysis.CStarAlgebra.Module.Constructions
import Mathlib.Analysis.CStarAlgebra.Module.Defs
import Mathlib.Analysis.CStarAlgebra.Module.Synonym
import Mathlib.Analysis.CStarAlgebra.Multiplier
import Mathlib.Analysis.CStarAlgebra.PositiveLinearMap
import Mathlib.Analysis.CStarAlgebra.Projection
import Mathlib.Analysis.CStarAlgebra.SpecialFunctions.PosPart
import Mathlib.Analysis.CStarAlgebra.Spectrum
import Mathlib.Analysis.CStarAlgebra.Unitization
import Mathlib.Analysis.CStarAlgebra.lpSpace
import Mathlib.Analysis.Calculus.AddTorsor.AffineMap
import Mathlib.Analysis.Calculus.AddTorsor.Coord
import Mathlib.Analysis.Calculus.BumpFunction.Basic
import Mathlib.Analysis.Calculus.BumpFunction.Convolution
import Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension
import Mathlib.Analysis.Calculus.BumpFunction.InnerProduct
import Mathlib.Analysis.Calculus.BumpFunction.Normed
import Mathlib.Analysis.Calculus.BumpFunction.SmoothApprox
import Mathlib.Analysis.Calculus.Conformal.InnerProduct
import Mathlib.Analysis.Calculus.Conformal.NormedSpace
import Mathlib.Analysis.Calculus.ContDiff.Basic
import Mathlib.Analysis.Calculus.ContDiff.Bounds
import Mathlib.Analysis.Calculus.ContDiff.CPolynomial
import Mathlib.Analysis.Calculus.ContDiff.Defs
import Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries
import Mathlib.Analysis.Calculus.ContDiff.FaaDiBruno
import Mathlib.Analysis.Calculus.ContDiff.FiniteDimension
import Mathlib.Analysis.Calculus.ContDiff.Operations
import Mathlib.Analysis.Calculus.ContDiff.RCLike
import Mathlib.Analysis.Calculus.ContDiff.RestrictScalars
import Mathlib.Analysis.Calculus.ContDiff.WithLp
import Mathlib.Analysis.Calculus.DSlope
import Mathlib.Analysis.Calculus.Darboux
import Mathlib.Analysis.Calculus.Deriv.Abs
import Mathlib.Analysis.Calculus.Deriv.Add
import Mathlib.Analysis.Calculus.Deriv.AffineMap
import Mathlib.Analysis.Calculus.Deriv.Basic
import Mathlib.Analysis.Calculus.Deriv.Comp
import Mathlib.Analysis.Calculus.Deriv.CompMul
import Mathlib.Analysis.Calculus.Deriv.Inv
import Mathlib.Analysis.Calculus.Deriv.Inverse
import Mathlib.Analysis.Calculus.Deriv.Linear
import Mathlib.Analysis.Calculus.Deriv.MeanValue
import Mathlib.Analysis.Calculus.Deriv.Mul
import Mathlib.Analysis.Calculus.Deriv.Pi
import Mathlib.Analysis.Calculus.Deriv.Polynomial
import Mathlib.Analysis.Calculus.Deriv.Pow
import Mathlib.Analysis.Calculus.Deriv.Prod
import Mathlib.Analysis.Calculus.Deriv.Shift
import Mathlib.Analysis.Calculus.Deriv.Slope
import Mathlib.Analysis.Calculus.Deriv.Star
import Mathlib.Analysis.Calculus.Deriv.Support
import Mathlib.Analysis.Calculus.Deriv.ZPow
import Mathlib.Analysis.Calculus.DerivativeTest
import Mathlib.Analysis.Calculus.DiffContOnCl
import Mathlib.Analysis.Calculus.FDeriv.Add
import Mathlib.Analysis.Calculus.FDeriv.Analytic
import Mathlib.Analysis.Calculus.FDeriv.Basic
import Mathlib.Analysis.Calculus.FDeriv.Bilinear
import Mathlib.Analysis.Calculus.FDeriv.Comp
import Mathlib.Analysis.Calculus.FDeriv.Congr
import Mathlib.Analysis.Calculus.FDeriv.Const
import Mathlib.Analysis.Calculus.FDeriv.Defs
import Mathlib.Analysis.Calculus.FDeriv.Equiv
import Mathlib.Analysis.Calculus.FDeriv.Extend
import Mathlib.Analysis.Calculus.FDeriv.Linear
import Mathlib.Analysis.Calculus.FDeriv.Measurable
import Mathlib.Analysis.Calculus.FDeriv.Mul
import Mathlib.Analysis.Calculus.FDeriv.Norm
import Mathlib.Analysis.Calculus.FDeriv.Pi
import Mathlib.Analysis.Calculus.FDeriv.Pow
import Mathlib.Analysis.Calculus.FDeriv.Prod
import Mathlib.Analysis.Calculus.FDeriv.RestrictScalars
import Mathlib.Analysis.Calculus.FDeriv.Star
import Mathlib.Analysis.Calculus.FDeriv.Symmetric
import Mathlib.Analysis.Calculus.FDeriv.WithLp
import Mathlib.Analysis.Calculus.FormalMultilinearSeries
import Mathlib.Analysis.Calculus.Gradient.Basic
import Mathlib.Analysis.Calculus.Implicit
import Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn
import Mathlib.Analysis.Calculus.InverseFunctionTheorem.ContDiff
import Mathlib.Analysis.Calculus.InverseFunctionTheorem.Deriv
import Mathlib.Analysis.Calculus.InverseFunctionTheorem.FDeriv
import Mathlib.Analysis.Calculus.InverseFunctionTheorem.FiniteDimensional
import Mathlib.Analysis.Calculus.IteratedDeriv.Defs
import Mathlib.Analysis.Calculus.IteratedDeriv.FaaDiBruno
import Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas
import Mathlib.Analysis.Calculus.IteratedDeriv.WithinZpow
import Mathlib.Analysis.Calculus.LHopital
import Mathlib.Analysis.Calculus.LagrangeMultipliers
import Mathlib.Analysis.Calculus.LineDeriv.Basic
import Mathlib.Analysis.Calculus.LineDeriv.IntegrationByParts
import Mathlib.Analysis.Calculus.LineDeriv.Measurable
import Mathlib.Analysis.Calculus.LineDeriv.QuadraticMap
import Mathlib.Analysis.Calculus.LocalExtr.Basic
import Mathlib.Analysis.Calculus.LocalExtr.LineDeriv
import Mathlib.Analysis.Calculus.LocalExtr.Polynomial
import Mathlib.Analysis.Calculus.LocalExtr.Rolle
import Mathlib.Analysis.Calculus.LogDeriv
import Mathlib.Analysis.Calculus.MeanValue
import Mathlib.Analysis.Calculus.Monotone
import Mathlib.Analysis.Calculus.ParametricIntegral
import Mathlib.Analysis.Calculus.ParametricIntervalIntegral
import Mathlib.Analysis.Calculus.Rademacher
import Mathlib.Analysis.Calculus.SmoothSeries
import Mathlib.Analysis.Calculus.TangentCone
import Mathlib.Analysis.Calculus.Taylor
import Mathlib.Analysis.Calculus.UniformLimitsDeriv
import Mathlib.Analysis.Calculus.VectorField
import Mathlib.Analysis.Complex.AbelLimit
import Mathlib.Analysis.Complex.AbsMax
import Mathlib.Analysis.Complex.Angle
import Mathlib.Analysis.Complex.Arg
import Mathlib.Analysis.Complex.Asymptotics
import Mathlib.Analysis.Complex.Basic
import Mathlib.Analysis.Complex.CauchyIntegral
import Mathlib.Analysis.Complex.Circle
import Mathlib.Analysis.Complex.Conformal
import Mathlib.Analysis.Complex.Convex
import Mathlib.Analysis.Complex.Hadamard
import Mathlib.Analysis.Complex.HalfPlane
import Mathlib.Analysis.Complex.IntegerCompl
import Mathlib.Analysis.Complex.IsIntegral
import Mathlib.Analysis.Complex.Isometry
import Mathlib.Analysis.Complex.Liouville
import Mathlib.Analysis.Complex.LocallyUniformLimit
import Mathlib.Analysis.Complex.MeanValue
import Mathlib.Analysis.Complex.OpenMapping
import Mathlib.Analysis.Complex.OperatorNorm
import Mathlib.Analysis.Complex.Periodic
import Mathlib.Analysis.Complex.PhragmenLindelof
import Mathlib.Analysis.Complex.Polynomial.Basic
import Mathlib.Analysis.Complex.Polynomial.UnitTrinomial
import Mathlib.Analysis.Complex.Positivity
import Mathlib.Analysis.Complex.ReImTopology
import Mathlib.Analysis.Complex.RealDeriv
import Mathlib.Analysis.Complex.RemovableSingularity
import Mathlib.Analysis.Complex.Schwarz
import Mathlib.Analysis.Complex.TaylorSeries
import Mathlib.Analysis.Complex.Tietze
import Mathlib.Analysis.Complex.UnitDisc.Basic
import Mathlib.Analysis.Complex.UpperHalfPlane.Basic
import Mathlib.Analysis.Complex.UpperHalfPlane.Exp
import Mathlib.Analysis.Complex.UpperHalfPlane.FunctionsBoundedAtInfty
import Mathlib.Analysis.Complex.UpperHalfPlane.Manifold
import Mathlib.Analysis.Complex.UpperHalfPlane.Metric
import Mathlib.Analysis.Complex.UpperHalfPlane.MoebiusAction
import Mathlib.Analysis.Complex.UpperHalfPlane.Topology
import Mathlib.Analysis.Complex.ValueDistribution.CharacteristicFunction
import Mathlib.Analysis.Complex.ValueDistribution.CountingFunction
import Mathlib.Analysis.Complex.ValueDistribution.FirstMainTheorem
import Mathlib.Analysis.Complex.ValueDistribution.ProximityFunction
import Mathlib.Analysis.ConstantSpeed
import Mathlib.Analysis.Convex.AmpleSet
import Mathlib.Analysis.Convex.Basic
import Mathlib.Analysis.Convex.Between
import Mathlib.Analysis.Convex.BetweenList
import Mathlib.Analysis.Convex.Birkhoff
import Mathlib.Analysis.Convex.Body
import Mathlib.Analysis.Convex.Caratheodory
import Mathlib.Analysis.Convex.Combination
import Mathlib.Analysis.Convex.Cone.Basic
import Mathlib.Analysis.Convex.Cone.Closure
import Mathlib.Analysis.Convex.Cone.Dual
import Mathlib.Analysis.Convex.Cone.Extension
import Mathlib.Analysis.Convex.Cone.InnerDual
import Mathlib.Analysis.Convex.Continuous
import Mathlib.Analysis.Convex.Contractible
import Mathlib.Analysis.Convex.Deriv
import Mathlib.Analysis.Convex.EGauge
import Mathlib.Analysis.Convex.Exposed
import Mathlib.Analysis.Convex.Extrema
import Mathlib.Analysis.Convex.Extreme
import Mathlib.Analysis.Convex.Function
import Mathlib.Analysis.Convex.Gauge
import Mathlib.Analysis.Convex.GaugeRescale
import Mathlib.Analysis.Convex.Hull
import Mathlib.Analysis.Convex.Independent
import Mathlib.Analysis.Convex.Integral
import Mathlib.Analysis.Convex.Intrinsic
import Mathlib.Analysis.Convex.Jensen
import Mathlib.Analysis.Convex.Join
import Mathlib.Analysis.Convex.KreinMilman
import Mathlib.Analysis.Convex.Measure
import Mathlib.Analysis.Convex.Mul
import Mathlib.Analysis.Convex.PartitionOfUnity
import Mathlib.Analysis.Convex.PathConnected
import Mathlib.Analysis.Convex.Piecewise
import Mathlib.Analysis.Convex.Quasiconvex
import Mathlib.Analysis.Convex.Radon
import Mathlib.Analysis.Convex.Segment
import Mathlib.Analysis.Convex.Side
import Mathlib.Analysis.Convex.SimplicialComplex.Basic
import Mathlib.Analysis.Convex.Slope
import Mathlib.Analysis.Convex.SpecificFunctions.Basic
import Mathlib.Analysis.Convex.SpecificFunctions.Deriv
import Mathlib.Analysis.Convex.SpecificFunctions.Pow
import Mathlib.Analysis.Convex.Star
import Mathlib.Analysis.Convex.StoneSeparation
import Mathlib.Analysis.Convex.Strict
import Mathlib.Analysis.Convex.StrictConvexBetween
import Mathlib.Analysis.Convex.StrictConvexSpace
import Mathlib.Analysis.Convex.Strong
import Mathlib.Analysis.Convex.Topology
import Mathlib.Analysis.Convex.TotallyBounded
import Mathlib.Analysis.Convex.Uniform
import Mathlib.Analysis.Convex.Visible
import Mathlib.Analysis.Convolution
import Mathlib.Analysis.Distribution.AEEqOfIntegralContDiff
import Mathlib.Analysis.Distribution.FourierSchwartz
import Mathlib.Analysis.Distribution.SchwartzSpace
import Mathlib.Analysis.Fourier.AddCircle
import Mathlib.Analysis.Fourier.AddCircleMulti
import Mathlib.Analysis.Fourier.BoundedContinuousFunctionChar
import Mathlib.Analysis.Fourier.FiniteAbelian.Orthogonality
import Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality
import Mathlib.Analysis.Fourier.FourierTransform
import Mathlib.Analysis.Fourier.FourierTransformDeriv
import Mathlib.Analysis.Fourier.Inversion
import Mathlib.Analysis.Fourier.PoissonSummation
import Mathlib.Analysis.Fourier.RiemannLebesgueLemma
import Mathlib.Analysis.Fourier.ZMod
import Mathlib.Analysis.FunctionalSpaces.SobolevInequality
import Mathlib.Analysis.Hofer
import Mathlib.Analysis.InnerProductSpace.Adjoint
import Mathlib.Analysis.InnerProductSpace.Affine
import Mathlib.Analysis.InnerProductSpace.Basic
import Mathlib.Analysis.InnerProductSpace.Calculus
import Mathlib.Analysis.InnerProductSpace.CanonicalTensor
import Mathlib.Analysis.InnerProductSpace.Completion
import Mathlib.Analysis.InnerProductSpace.ConformalLinearMap
import Mathlib.Analysis.InnerProductSpace.Continuous
import Mathlib.Analysis.InnerProductSpace.Convex
import Mathlib.Analysis.InnerProductSpace.Defs
import Mathlib.Analysis.InnerProductSpace.Dual
import Mathlib.Analysis.InnerProductSpace.EuclideanDist
import Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho
import Mathlib.Analysis.InnerProductSpace.Harmonic.Basic
import Mathlib.Analysis.InnerProductSpace.Harmonic.Constructions
import Mathlib.Analysis.InnerProductSpace.JointEigenspace
import Mathlib.Analysis.InnerProductSpace.Laplacian
import Mathlib.Analysis.InnerProductSpace.LaxMilgram
import Mathlib.Analysis.InnerProductSpace.LinearMap
import Mathlib.Analysis.InnerProductSpace.LinearPMap
import Mathlib.Analysis.InnerProductSpace.MeanErgodic
import Mathlib.Analysis.InnerProductSpace.NormPow
import Mathlib.Analysis.InnerProductSpace.OfNorm
import Mathlib.Analysis.InnerProductSpace.Orientation
import Mathlib.Analysis.InnerProductSpace.Orthogonal
import Mathlib.Analysis.InnerProductSpace.Orthonormal
import Mathlib.Analysis.InnerProductSpace.PiL2
import Mathlib.Analysis.InnerProductSpace.Positive
import Mathlib.Analysis.InnerProductSpace.ProdL2
import Mathlib.Analysis.InnerProductSpace.Projection
import Mathlib.Analysis.InnerProductSpace.Rayleigh
import Mathlib.Analysis.InnerProductSpace.Semisimple
import Mathlib.Analysis.InnerProductSpace.Spectrum
import Mathlib.Analysis.InnerProductSpace.StarOrder
import Mathlib.Analysis.InnerProductSpace.Subspace
import Mathlib.Analysis.InnerProductSpace.Symmetric
import Mathlib.Analysis.InnerProductSpace.Trace
import Mathlib.Analysis.InnerProductSpace.TwoDim
import Mathlib.Analysis.InnerProductSpace.WeakOperatorTopology
import Mathlib.Analysis.InnerProductSpace.l2Space
import Mathlib.Analysis.LConvolution
import Mathlib.Analysis.LocallyConvex.AbsConvex
import Mathlib.Analysis.LocallyConvex.AbsConvexOpen
import Mathlib.Analysis.LocallyConvex.BalancedCoreHull
import Mathlib.Analysis.LocallyConvex.Barrelled
import Mathlib.Analysis.LocallyConvex.Basic
import Mathlib.Analysis.LocallyConvex.Bounded
import Mathlib.Analysis.LocallyConvex.ContinuousOfBounded
import Mathlib.Analysis.LocallyConvex.Polar
import Mathlib.Analysis.LocallyConvex.StrongTopology
import Mathlib.Analysis.LocallyConvex.WeakDual
import Mathlib.Analysis.LocallyConvex.WeakOperatorTopology
import Mathlib.Analysis.LocallyConvex.WeakSpace
import Mathlib.Analysis.LocallyConvex.WithSeminorms
import Mathlib.Analysis.Matrix
import Mathlib.Analysis.MeanInequalities
import Mathlib.Analysis.MeanInequalitiesPow
import Mathlib.Analysis.MellinInversion
import Mathlib.Analysis.MellinTransform
import Mathlib.Analysis.Meromorphic.Basic
import Mathlib.Analysis.Meromorphic.Complex
import Mathlib.Analysis.Meromorphic.Divisor
import Mathlib.Analysis.Meromorphic.FactorizedRational
import Mathlib.Analysis.Meromorphic.IsolatedZeros
import Mathlib.Analysis.Meromorphic.NormalForm
import Mathlib.Analysis.Meromorphic.Order
import Mathlib.Analysis.Meromorphic.TrailingCoefficient
import Mathlib.Analysis.Normed.Affine.AddTorsor
import Mathlib.Analysis.Normed.Affine.AddTorsorBases
import Mathlib.Analysis.Normed.Affine.ContinuousAffineMap
import Mathlib.Analysis.Normed.Affine.Convex
import Mathlib.Analysis.Normed.Affine.Isometry
import Mathlib.Analysis.Normed.Affine.MazurUlam
import Mathlib.Analysis.Normed.Affine.Simplex
import Mathlib.Analysis.Normed.Algebra.Basic
import Mathlib.Analysis.Normed.Algebra.Exponential
import Mathlib.Analysis.Normed.Algebra.MatrixExponential
import Mathlib.Analysis.Normed.Algebra.QuaternionExponential
import Mathlib.Analysis.Normed.Algebra.Spectrum
import Mathlib.Analysis.Normed.Algebra.TrivSqZeroExt
import Mathlib.Analysis.Normed.Algebra.Ultra
import Mathlib.Analysis.Normed.Algebra.Unitization
import Mathlib.Analysis.Normed.Algebra.UnitizationL1
import Mathlib.Analysis.Normed.Field.Basic
import Mathlib.Analysis.Normed.Field.Instances
import Mathlib.Analysis.Normed.Field.Lemmas
import Mathlib.Analysis.Normed.Field.ProperSpace
import Mathlib.Analysis.Normed.Field.Ultra
import Mathlib.Analysis.Normed.Field.UnitBall
import Mathlib.Analysis.Normed.Field.WithAbs
import Mathlib.Analysis.Normed.Group.AddCircle
import Mathlib.Analysis.Normed.Group.AddTorsor
import Mathlib.Analysis.Normed.Group.BallSphere
import Mathlib.Analysis.Normed.Group.Basic
import Mathlib.Analysis.Normed.Group.Bounded
import Mathlib.Analysis.Normed.Group.CocompactMap
import Mathlib.Analysis.Normed.Group.Completeness
import Mathlib.Analysis.Normed.Group.Completion
import Mathlib.Analysis.Normed.Group.Constructions
import Mathlib.Analysis.Normed.Group.Continuity
import Mathlib.Analysis.Normed.Group.ControlledClosure
import Mathlib.Analysis.Normed.Group.Hom
import Mathlib.Analysis.Normed.Group.HomCompletion
import Mathlib.Analysis.Normed.Group.InfiniteSum
import Mathlib.Analysis.Normed.Group.Int
import Mathlib.Analysis.Normed.Group.Lemmas
import Mathlib.Analysis.Normed.Group.NullSubmodule
import Mathlib.Analysis.Normed.Group.Pointwise
import Mathlib.Analysis.Normed.Group.Quotient
import Mathlib.Analysis.Normed.Group.Rat
import Mathlib.Analysis.Normed.Group.SemiNormedGrp
import Mathlib.Analysis.Normed.Group.SemiNormedGrp.Completion
import Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels
import Mathlib.Analysis.Normed.Group.Seminorm
import Mathlib.Analysis.Normed.Group.SeparationQuotient
import Mathlib.Analysis.Normed.Group.Subgroup
import Mathlib.Analysis.Normed.Group.Submodule
import Mathlib.Analysis.Normed.Group.Tannery
import Mathlib.Analysis.Normed.Group.Ultra
import Mathlib.Analysis.Normed.Group.Uniform
import Mathlib.Analysis.Normed.Group.ZeroAtInfty
import Mathlib.Analysis.Normed.Lp.LpEquiv
import Mathlib.Analysis.Normed.Lp.MeasurableSpace
import Mathlib.Analysis.Normed.Lp.PiLp
import Mathlib.Analysis.Normed.Lp.ProdLp
import Mathlib.Analysis.Normed.Lp.WithLp
import Mathlib.Analysis.Normed.Lp.lpSpace
import Mathlib.Analysis.Normed.Module.Basic
import Mathlib.Analysis.Normed.Module.Complemented
import Mathlib.Analysis.Normed.Module.Completion
import Mathlib.Analysis.Normed.Module.Convex
import Mathlib.Analysis.Normed.Module.Dual
import Mathlib.Analysis.Normed.Module.FiniteDimension
import Mathlib.Analysis.Normed.Module.Ray
import Mathlib.Analysis.Normed.Module.Span
import Mathlib.Analysis.Normed.Module.WeakDual
import Mathlib.Analysis.Normed.MulAction
import Mathlib.Analysis.Normed.Operator.Banach
import Mathlib.Analysis.Normed.Operator.BanachSteinhaus
import Mathlib.Analysis.Normed.Operator.BoundedLinearMaps
import Mathlib.Analysis.Normed.Operator.Compact
import Mathlib.Analysis.Normed.Operator.ContinuousLinearMap
import Mathlib.Analysis.Normed.Operator.LinearIsometry
import Mathlib.Analysis.Normed.Order.Basic
import Mathlib.Analysis.Normed.Order.Hom.Basic
import Mathlib.Analysis.Normed.Order.Hom.Ultra
import Mathlib.Analysis.Normed.Order.Lattice
import Mathlib.Analysis.Normed.Order.UpperLower
import Mathlib.Analysis.Normed.Ring.Basic
import Mathlib.Analysis.Normed.Ring.InfiniteSum
import Mathlib.Analysis.Normed.Ring.Lemmas
import Mathlib.Analysis.Normed.Ring.Ultra
import Mathlib.Analysis.Normed.Ring.Units
import Mathlib.Analysis.Normed.Ring.WithAbs
import Mathlib.Analysis.Normed.Unbundled.AlgebraNorm
import Mathlib.Analysis.Normed.Unbundled.FiniteExtension
import Mathlib.Analysis.Normed.Unbundled.InvariantExtension
import Mathlib.Analysis.Normed.Unbundled.IsPowMulFaithful
import Mathlib.Analysis.Normed.Unbundled.RingSeminorm
import Mathlib.Analysis.Normed.Unbundled.SeminormFromBounded
import Mathlib.Analysis.Normed.Unbundled.SeminormFromConst
import Mathlib.Analysis.Normed.Unbundled.SmoothingSeminorm
import Mathlib.Analysis.Normed.Unbundled.SpectralNorm
import Mathlib.Analysis.NormedSpace.Alternating.Basic
import Mathlib.Analysis.NormedSpace.Alternating.Curry
import Mathlib.Analysis.NormedSpace.BallAction
import Mathlib.Analysis.NormedSpace.ConformalLinearMap
import Mathlib.Analysis.NormedSpace.Connected
import Mathlib.Analysis.NormedSpace.DualNumber
import Mathlib.Analysis.NormedSpace.ENormedSpace
import Mathlib.Analysis.NormedSpace.Extend
import Mathlib.Analysis.NormedSpace.Extr
import Mathlib.Analysis.NormedSpace.FunctionSeries
import Mathlib.Analysis.NormedSpace.HahnBanach.Extension
import Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual
import Mathlib.Analysis.NormedSpace.HahnBanach.Separation
import Mathlib.Analysis.NormedSpace.HomeomorphBall
import Mathlib.Analysis.NormedSpace.IndicatorFunction
import Mathlib.Analysis.NormedSpace.Int
import Mathlib.Analysis.NormedSpace.MStructure
import Mathlib.Analysis.NormedSpace.Multilinear.Basic
import Mathlib.Analysis.NormedSpace.Multilinear.Curry
import Mathlib.Analysis.NormedSpace.MultipliableUniformlyOn
import Mathlib.Analysis.NormedSpace.OperatorNorm.Asymptotics
import Mathlib.Analysis.NormedSpace.OperatorNorm.Basic
import Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear
import Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness
import Mathlib.Analysis.NormedSpace.OperatorNorm.Mul
import Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm
import Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace
import Mathlib.Analysis.NormedSpace.OperatorNorm.Prod
import Mathlib.Analysis.NormedSpace.PiTensorProduct.InjectiveSeminorm
import Mathlib.Analysis.NormedSpace.PiTensorProduct.ProjectiveSeminorm
import Mathlib.Analysis.NormedSpace.Pointwise
import Mathlib.Analysis.NormedSpace.RCLike
import Mathlib.Analysis.NormedSpace.Real
import Mathlib.Analysis.NormedSpace.RieszLemma
import Mathlib.Analysis.NormedSpace.SphereNormEquiv
import Mathlib.Analysis.ODE.Gronwall
import Mathlib.Analysis.ODE.PicardLindelof
import Mathlib.Analysis.Oscillation
import Mathlib.Analysis.PSeries
import Mathlib.Analysis.PSeriesComplex
import Mathlib.Analysis.Polynomial.Basic
import Mathlib.Analysis.Polynomial.CauchyBound
import Mathlib.Analysis.Quaternion
import Mathlib.Analysis.RCLike.Basic
import Mathlib.Analysis.RCLike.BoundedContinuous
import Mathlib.Analysis.RCLike.Inner
import Mathlib.Analysis.RCLike.Lemmas
import Mathlib.Analysis.RCLike.TangentCone
import Mathlib.Analysis.Seminorm
import Mathlib.Analysis.SpecialFunctions.Arsinh
import Mathlib.Analysis.SpecialFunctions.Bernstein
import Mathlib.Analysis.SpecialFunctions.BinaryEntropy
import Mathlib.Analysis.SpecialFunctions.Choose
import Mathlib.Analysis.SpecialFunctions.CompareExp
import Mathlib.Analysis.SpecialFunctions.Complex.Analytic
import Mathlib.Analysis.SpecialFunctions.Complex.Arctan
import Mathlib.Analysis.SpecialFunctions.Complex.Arg
import Mathlib.Analysis.SpecialFunctions.Complex.Circle
import Mathlib.Analysis.SpecialFunctions.Complex.CircleAddChar
import Mathlib.Analysis.SpecialFunctions.Complex.CircleMap
import Mathlib.Analysis.SpecialFunctions.Complex.Log
import Mathlib.Analysis.SpecialFunctions.Complex.LogBounds
import Mathlib.Analysis.SpecialFunctions.Complex.LogDeriv
import Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.ExpLog
import Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.PosPart.Basic
import Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.PosPart.Isometric
import Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.Rpow.Basic
import Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.Rpow.IntegralRepresentation
import Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.Rpow.Isometric
import Mathlib.Analysis.SpecialFunctions.Exp
import Mathlib.Analysis.SpecialFunctions.ExpDeriv
import Mathlib.Analysis.SpecialFunctions.Exponential
import Mathlib.Analysis.SpecialFunctions.Gamma.Basic
import Mathlib.Analysis.SpecialFunctions.Gamma.Beta
import Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup
import Mathlib.Analysis.SpecialFunctions.Gamma.Deligne
import Mathlib.Analysis.SpecialFunctions.Gamma.Deriv
import Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform
import Mathlib.Analysis.SpecialFunctions.Gaussian.GaussianIntegral
import Mathlib.Analysis.SpecialFunctions.Gaussian.PoissonSummation
import Mathlib.Analysis.SpecialFunctions.ImproperIntegrals
import Mathlib.Analysis.SpecialFunctions.Integrability.Basic
import Mathlib.Analysis.SpecialFunctions.Integrability.LogMeromorphic
import Mathlib.Analysis.SpecialFunctions.Integrals.Basic
import Mathlib.Analysis.SpecialFunctions.Integrals.LogTrigonometric
import Mathlib.Analysis.SpecialFunctions.Integrals.PosLogEqCircleAverage
import Mathlib.Analysis.SpecialFunctions.JapaneseBracket
import Mathlib.Analysis.SpecialFunctions.Log.Base
import Mathlib.Analysis.SpecialFunctions.Log.Basic
import Mathlib.Analysis.SpecialFunctions.Log.Deriv
import Mathlib.Analysis.SpecialFunctions.Log.ENNRealLog
import Mathlib.Analysis.SpecialFunctions.Log.ENNRealLogExp
import Mathlib.Analysis.SpecialFunctions.Log.ERealExp
import Mathlib.Analysis.SpecialFunctions.Log.Monotone
import Mathlib.Analysis.SpecialFunctions.Log.NegMulLog
import Mathlib.Analysis.SpecialFunctions.Log.PosLog
import Mathlib.Analysis.SpecialFunctions.Log.Summable
import Mathlib.Analysis.SpecialFunctions.MulExpNegMulSq
import Mathlib.Analysis.SpecialFunctions.MulExpNegMulSqIntegral
import Mathlib.Analysis.SpecialFunctions.NonIntegrable
import Mathlib.Analysis.SpecialFunctions.OrdinaryHypergeometric
import Mathlib.Analysis.SpecialFunctions.Pochhammer
import Mathlib.Analysis.SpecialFunctions.PolarCoord
import Mathlib.Analysis.SpecialFunctions.PolynomialExp
import Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics
import Mathlib.Analysis.SpecialFunctions.Pow.Complex
import Mathlib.Analysis.SpecialFunctions.Pow.Continuity
import Mathlib.Analysis.SpecialFunctions.Pow.Deriv
import Mathlib.Analysis.SpecialFunctions.Pow.Integral
import Mathlib.Analysis.SpecialFunctions.Pow.NNReal
import Mathlib.Analysis.SpecialFunctions.Pow.Real
import Mathlib.Analysis.SpecialFunctions.SmoothTransition
import Mathlib.Analysis.SpecialFunctions.Sqrt
import Mathlib.Analysis.SpecialFunctions.Stirling
import Mathlib.Analysis.SpecialFunctions.Trigonometric.Angle
import Mathlib.Analysis.SpecialFunctions.Trigonometric.Arctan
import Mathlib.Analysis.SpecialFunctions.Trigonometric.ArctanDeriv
import Mathlib.Analysis.SpecialFunctions.Trigonometric.Basic
import Mathlib.Analysis.SpecialFunctions.Trigonometric.Bounds
import Mathlib.Analysis.SpecialFunctions.Trigonometric.Chebyshev
import Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex
import Mathlib.Analysis.SpecialFunctions.Trigonometric.ComplexDeriv
import Mathlib.Analysis.SpecialFunctions.Trigonometric.Cotangent
import Mathlib.Analysis.SpecialFunctions.Trigonometric.Deriv
import Mathlib.Analysis.SpecialFunctions.Trigonometric.EulerSineProd
import Mathlib.Analysis.SpecialFunctions.Trigonometric.Inverse
import Mathlib.Analysis.SpecialFunctions.Trigonometric.InverseDeriv
import Mathlib.Analysis.SpecialFunctions.Trigonometric.Series
import Mathlib.Analysis.SpecialFunctions.Trigonometric.Sinc
import Mathlib.Analysis.SpecificLimits.Basic
import Mathlib.Analysis.SpecificLimits.FloorPow
import Mathlib.Analysis.SpecificLimits.Normed
import Mathlib.Analysis.SpecificLimits.RCLike
import Mathlib.Analysis.Subadditive
import Mathlib.Analysis.SumIntegralComparisons
import Mathlib.Analysis.SumOverResidueClass
import Mathlib.Analysis.VonNeumannAlgebra.Basic
import Mathlib.CategoryTheory.Abelian.Basic
import Mathlib.CategoryTheory.Abelian.CommSq
import Mathlib.CategoryTheory.Abelian.DiagramLemmas.Four
import Mathlib.CategoryTheory.Abelian.DiagramLemmas.KernelCokernelComp
import Mathlib.CategoryTheory.Abelian.EpiWithInjectiveKernel
import Mathlib.CategoryTheory.Abelian.Exact
import Mathlib.CategoryTheory.Abelian.Ext
import Mathlib.CategoryTheory.Abelian.FreydMitchell
import Mathlib.CategoryTheory.Abelian.FunctorCategory
import Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic
import Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Colim
import Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Connected
import Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.FunctorCategory
import Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Indization
import Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Sheaf
import Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Types
import Mathlib.CategoryTheory.Abelian.GrothendieckCategory.Basic
import Mathlib.CategoryTheory.Abelian.GrothendieckCategory.ColimCoyoneda
import Mathlib.CategoryTheory.Abelian.GrothendieckCategory.Coseparator
import Mathlib.CategoryTheory.Abelian.GrothendieckCategory.EnoughInjectives
import Mathlib.CategoryTheory.Abelian.GrothendieckCategory.ModuleEmbedding.GabrielPopescu
import Mathlib.CategoryTheory.Abelian.GrothendieckCategory.ModuleEmbedding.Opposite
import Mathlib.CategoryTheory.Abelian.GrothendieckCategory.Monomorphisms
import Mathlib.CategoryTheory.Abelian.GrothendieckCategory.Subobject
import Mathlib.CategoryTheory.Abelian.Images
import Mathlib.CategoryTheory.Abelian.Indization
import Mathlib.CategoryTheory.Abelian.Injective.Basic
import Mathlib.CategoryTheory.Abelian.Injective.Resolution
import Mathlib.CategoryTheory.Abelian.LeftDerived
import Mathlib.CategoryTheory.Abelian.Monomorphisms
import Mathlib.CategoryTheory.Abelian.NonPreadditive
import Mathlib.CategoryTheory.Abelian.Opposite
import Mathlib.CategoryTheory.Abelian.Projective.Basic
import Mathlib.CategoryTheory.Abelian.Projective.Dimension
import Mathlib.CategoryTheory.Abelian.Projective.Resolution
import Mathlib.CategoryTheory.Abelian.Pseudoelements
import Mathlib.CategoryTheory.Abelian.Refinements
import Mathlib.CategoryTheory.Abelian.RightDerived
import Mathlib.CategoryTheory.Abelian.SerreClass.Basic
import Mathlib.CategoryTheory.Abelian.SerreClass.Bousfield
import Mathlib.CategoryTheory.Abelian.SerreClass.MorphismProperty
import Mathlib.CategoryTheory.Abelian.Subobject
import Mathlib.CategoryTheory.Abelian.Transfer
import Mathlib.CategoryTheory.Abelian.Yoneda
import Mathlib.CategoryTheory.Action
import Mathlib.CategoryTheory.Action.Basic
import Mathlib.CategoryTheory.Action.Concrete
import Mathlib.CategoryTheory.Action.Continuous
import Mathlib.CategoryTheory.Action.Limits
import Mathlib.CategoryTheory.Action.Monoidal
import Mathlib.CategoryTheory.Adhesive
import Mathlib.CategoryTheory.Adjunction.Additive
import Mathlib.CategoryTheory.Adjunction.AdjointFunctorTheorems
import Mathlib.CategoryTheory.Adjunction.Basic
import Mathlib.CategoryTheory.Adjunction.Comma
import Mathlib.CategoryTheory.Adjunction.Evaluation
import Mathlib.CategoryTheory.Adjunction.FullyFaithful
import Mathlib.CategoryTheory.Adjunction.Lifting.Left
import Mathlib.CategoryTheory.Adjunction.Lifting.Right
import Mathlib.CategoryTheory.Adjunction.Limits
import Mathlib.CategoryTheory.Adjunction.Mates
import Mathlib.CategoryTheory.Adjunction.Opposites
import Mathlib.CategoryTheory.Adjunction.Parametrized
import Mathlib.CategoryTheory.Adjunction.PartialAdjoint
import Mathlib.CategoryTheory.Adjunction.Reflective
import Mathlib.CategoryTheory.Adjunction.Restrict
import Mathlib.CategoryTheory.Adjunction.Triple
import Mathlib.CategoryTheory.Adjunction.Unique
import Mathlib.CategoryTheory.Adjunction.Whiskering
import Mathlib.CategoryTheory.Balanced
import Mathlib.CategoryTheory.Bicategory.Adjunction.Adj
import Mathlib.CategoryTheory.Bicategory.Adjunction.Basic
import Mathlib.CategoryTheory.Bicategory.Adjunction.Mate
import Mathlib.CategoryTheory.Bicategory.Basic
import Mathlib.CategoryTheory.Bicategory.CatEnriched
import Mathlib.CategoryTheory.Bicategory.Coherence
import Mathlib.CategoryTheory.Bicategory.End
import Mathlib.CategoryTheory.Bicategory.Extension
import Mathlib.CategoryTheory.Bicategory.Free
import Mathlib.CategoryTheory.Bicategory.Functor.Lax
import Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete
import Mathlib.CategoryTheory.Bicategory.Functor.Oplax
import Mathlib.CategoryTheory.Bicategory.Functor.Prelax
import Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor
import Mathlib.CategoryTheory.Bicategory.Functor.Strict
import Mathlib.CategoryTheory.Bicategory.FunctorBicategory.Oplax
import Mathlib.CategoryTheory.Bicategory.Grothendieck
import Mathlib.CategoryTheory.Bicategory.Kan.Adjunction
import Mathlib.CategoryTheory.Bicategory.Kan.HasKan
import Mathlib.CategoryTheory.Bicategory.Kan.IsKan
import Mathlib.CategoryTheory.Bicategory.LocallyDiscrete
import Mathlib.CategoryTheory.Bicategory.Modification.Oplax
import Mathlib.CategoryTheory.Bicategory.Monad.Basic
import Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Oplax
import Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Pseudo
import Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong
import Mathlib.CategoryTheory.Bicategory.SingleObj
import Mathlib.CategoryTheory.Bicategory.Strict
import Mathlib.CategoryTheory.CatCommSq
import Mathlib.CategoryTheory.Category.Basic
import Mathlib.CategoryTheory.Category.Bipointed
import Mathlib.CategoryTheory.Category.Cat
import Mathlib.CategoryTheory.Category.Cat.Adjunction
import Mathlib.CategoryTheory.Category.Cat.AsSmall
import Mathlib.CategoryTheory.Category.Cat.CartesianClosed
import Mathlib.CategoryTheory.Category.Cat.Colimit
import Mathlib.CategoryTheory.Category.Cat.Limit
import Mathlib.CategoryTheory.Category.Cat.Op
import Mathlib.CategoryTheory.Category.Cat.Terminal
import Mathlib.CategoryTheory.Category.Factorisation
import Mathlib.CategoryTheory.Category.GaloisConnection
import Mathlib.CategoryTheory.Category.Grpd
import Mathlib.CategoryTheory.Category.Init
import Mathlib.CategoryTheory.Category.KleisliCat
import Mathlib.CategoryTheory.Category.Pairwise
import Mathlib.CategoryTheory.Category.PartialFun
import Mathlib.CategoryTheory.Category.Pointed
import Mathlib.CategoryTheory.Category.Preorder
import Mathlib.CategoryTheory.Category.Quiv
import Mathlib.CategoryTheory.Category.ReflQuiv
import Mathlib.CategoryTheory.Category.RelCat
import Mathlib.CategoryTheory.Category.TwoP
import Mathlib.CategoryTheory.Category.ULift
import Mathlib.CategoryTheory.Center.Basic
import Mathlib.CategoryTheory.Center.Linear
import Mathlib.CategoryTheory.Center.Localization
import Mathlib.CategoryTheory.ChosenFiniteProducts
import Mathlib.CategoryTheory.ChosenFiniteProducts.Cat
import Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory
import Mathlib.CategoryTheory.ChosenFiniteProducts.InfSemilattice
import Mathlib.CategoryTheory.ChosenFiniteProducts.Over
import Mathlib.CategoryTheory.Closed.Cartesian
import Mathlib.CategoryTheory.Closed.Enrichment
import Mathlib.CategoryTheory.Closed.Functor
import Mathlib.CategoryTheory.Closed.FunctorCategory.Basic
import Mathlib.CategoryTheory.Closed.FunctorCategory.Complete
import Mathlib.CategoryTheory.Closed.FunctorCategory.Groupoid
import Mathlib.CategoryTheory.Closed.FunctorToTypes
import Mathlib.CategoryTheory.Closed.Ideal
import Mathlib.CategoryTheory.Closed.Monoidal
import Mathlib.CategoryTheory.Closed.Types
import Mathlib.CategoryTheory.Closed.Zero
import Mathlib.CategoryTheory.CodiscreteCategory
import Mathlib.CategoryTheory.CofilteredSystem
import Mathlib.CategoryTheory.CommSq
import Mathlib.CategoryTheory.Comma.Arrow
import Mathlib.CategoryTheory.Comma.Basic
import Mathlib.CategoryTheory.Comma.CardinalArrow
import Mathlib.CategoryTheory.Comma.Final
import Mathlib.CategoryTheory.Comma.LocallySmall
import Mathlib.CategoryTheory.Comma.Over.Basic
import Mathlib.CategoryTheory.Comma.Over.OverClass
import Mathlib.CategoryTheory.Comma.Over.Pullback
import Mathlib.CategoryTheory.Comma.Presheaf.Basic
import Mathlib.CategoryTheory.Comma.Presheaf.Colimit
import Mathlib.CategoryTheory.Comma.StructuredArrow.Basic
import Mathlib.CategoryTheory.Comma.StructuredArrow.CommaMap
import Mathlib.CategoryTheory.Comma.StructuredArrow.Final
import Mathlib.CategoryTheory.Comma.StructuredArrow.Functor
import Mathlib.CategoryTheory.Comma.StructuredArrow.Small
import Mathlib.CategoryTheory.ComposableArrows
import Mathlib.CategoryTheory.ConcreteCategory.Basic
import Mathlib.CategoryTheory.ConcreteCategory.Bundled
import Mathlib.CategoryTheory.ConcreteCategory.BundledHom
import Mathlib.CategoryTheory.ConcreteCategory.Elementwise
import Mathlib.CategoryTheory.ConcreteCategory.EpiMono
import Mathlib.CategoryTheory.ConcreteCategory.ReflectsIso
import Mathlib.CategoryTheory.ConcreteCategory.UnbundledHom
import Mathlib.CategoryTheory.Conj
import Mathlib.CategoryTheory.ConnectedComponents
import Mathlib.CategoryTheory.Core
import Mathlib.CategoryTheory.Countable
import Mathlib.CategoryTheory.Dialectica.Basic
import Mathlib.CategoryTheory.Dialectica.Monoidal
import Mathlib.CategoryTheory.DifferentialObject
import Mathlib.CategoryTheory.DinatTrans
import Mathlib.CategoryTheory.Discrete.Basic
import Mathlib.CategoryTheory.Discrete.SumsProducts
import Mathlib.CategoryTheory.Distributive.Cartesian
import Mathlib.CategoryTheory.Distributive.Monoidal
import Mathlib.CategoryTheory.EffectiveEpi.Basic
import Mathlib.CategoryTheory.EffectiveEpi.Comp
import Mathlib.CategoryTheory.EffectiveEpi.Coproduct
import Mathlib.CategoryTheory.EffectiveEpi.Enough
import Mathlib.CategoryTheory.EffectiveEpi.Extensive
import Mathlib.CategoryTheory.EffectiveEpi.Preserves
import Mathlib.CategoryTheory.EffectiveEpi.RegularEpi
import Mathlib.CategoryTheory.Elements
import Mathlib.CategoryTheory.Elementwise
import Mathlib.CategoryTheory.Endofunctor.Algebra
import Mathlib.CategoryTheory.Endomorphism
import Mathlib.CategoryTheory.Enriched.Basic
import Mathlib.CategoryTheory.Enriched.FunctorCategory
import Mathlib.CategoryTheory.Enriched.HomCongr
import Mathlib.CategoryTheory.Enriched.Limits.HasConicalLimits
import Mathlib.CategoryTheory.Enriched.Limits.HasConicalProducts
import Mathlib.CategoryTheory.Enriched.Limits.HasConicalPullbacks
import Mathlib.CategoryTheory.Enriched.Limits.HasConicalTerminal
import Mathlib.CategoryTheory.Enriched.Opposite
import Mathlib.CategoryTheory.Enriched.Ordinary.Basic
import Mathlib.CategoryTheory.EpiMono
import Mathlib.CategoryTheory.EqToHom
import Mathlib.CategoryTheory.Equivalence
import Mathlib.CategoryTheory.Equivalence.Symmetry
import Mathlib.CategoryTheory.EssentialImage
import Mathlib.CategoryTheory.EssentiallySmall
import Mathlib.CategoryTheory.Extensive
import Mathlib.CategoryTheory.FiberedCategory.BasedCategory
import Mathlib.CategoryTheory.FiberedCategory.Cartesian
import Mathlib.CategoryTheory.FiberedCategory.Cocartesian
import Mathlib.CategoryTheory.FiberedCategory.Fiber
import Mathlib.CategoryTheory.FiberedCategory.Fibered
import Mathlib.CategoryTheory.FiberedCategory.Grothendieck
import Mathlib.CategoryTheory.FiberedCategory.HasFibers
import Mathlib.CategoryTheory.FiberedCategory.HomLift
import Mathlib.CategoryTheory.Filtered.Basic
import Mathlib.CategoryTheory.Filtered.Connected
import Mathlib.CategoryTheory.Filtered.CostructuredArrow
import Mathlib.CategoryTheory.Filtered.Final
import Mathlib.CategoryTheory.Filtered.Flat
import Mathlib.CategoryTheory.Filtered.Grothendieck
import Mathlib.CategoryTheory.Filtered.OfColimitCommutesFiniteLimit
import Mathlib.CategoryTheory.Filtered.Small
import Mathlib.CategoryTheory.FinCategory.AsType
import Mathlib.CategoryTheory.FinCategory.Basic
import Mathlib.CategoryTheory.FintypeCat
import Mathlib.CategoryTheory.FullSubcategory
import Mathlib.CategoryTheory.Functor.Basic
import Mathlib.CategoryTheory.Functor.Category
import Mathlib.CategoryTheory.Functor.Const
import Mathlib.CategoryTheory.Functor.Currying
import Mathlib.CategoryTheory.Functor.CurryingThree
import Mathlib.CategoryTheory.Functor.Derived.Adjunction
import Mathlib.CategoryTheory.Functor.Derived.LeftDerived
import Mathlib.CategoryTheory.Functor.Derived.RightDerived
import Mathlib.CategoryTheory.Functor.EpiMono
import Mathlib.CategoryTheory.Functor.Flat
import Mathlib.CategoryTheory.Functor.FullyFaithful
import Mathlib.CategoryTheory.Functor.FunctorHom
import Mathlib.CategoryTheory.Functor.Functorial
import Mathlib.CategoryTheory.Functor.Hom
import Mathlib.CategoryTheory.Functor.KanExtension.Adjunction
import Mathlib.CategoryTheory.Functor.KanExtension.Basic
import Mathlib.CategoryTheory.Functor.KanExtension.Pointwise
import Mathlib.CategoryTheory.Functor.KanExtension.Preserves
import Mathlib.CategoryTheory.Functor.OfSequence
import Mathlib.CategoryTheory.Functor.ReflectsIso.Balanced
import Mathlib.CategoryTheory.Functor.ReflectsIso.Basic
import Mathlib.CategoryTheory.Functor.Trifunctor
import Mathlib.CategoryTheory.Functor.TwoSquare
import Mathlib.CategoryTheory.Galois.Action
import Mathlib.CategoryTheory.Galois.Basic
import Mathlib.CategoryTheory.Galois.Decomposition
import Mathlib.CategoryTheory.Galois.Equivalence
import Mathlib.CategoryTheory.Galois.EssSurj
import Mathlib.CategoryTheory.Galois.Examples
import Mathlib.CategoryTheory.Galois.Full
import Mathlib.CategoryTheory.Galois.GaloisObjects
import Mathlib.CategoryTheory.Galois.IsFundamentalgroup
import Mathlib.CategoryTheory.Galois.Prorepresentability
import Mathlib.CategoryTheory.Galois.Topology
import Mathlib.CategoryTheory.Generator.Abelian
import Mathlib.CategoryTheory.Generator.Basic
import Mathlib.CategoryTheory.Generator.HomologicalComplex
import Mathlib.CategoryTheory.Generator.Indization
import Mathlib.CategoryTheory.Generator.Preadditive
import Mathlib.CategoryTheory.Generator.Presheaf
import Mathlib.CategoryTheory.Generator.Sheaf
import Mathlib.CategoryTheory.GlueData
import Mathlib.CategoryTheory.GradedObject
import Mathlib.CategoryTheory.GradedObject.Associator
import Mathlib.CategoryTheory.GradedObject.Bifunctor
import Mathlib.CategoryTheory.GradedObject.Braiding
import Mathlib.CategoryTheory.GradedObject.Monoidal
import Mathlib.CategoryTheory.GradedObject.Single
import Mathlib.CategoryTheory.GradedObject.Trifunctor
import Mathlib.CategoryTheory.GradedObject.Unitor
import Mathlib.CategoryTheory.Grothendieck
import Mathlib.CategoryTheory.Groupoid
import Mathlib.CategoryTheory.Groupoid.Basic
import Mathlib.CategoryTheory.Groupoid.Discrete
import Mathlib.CategoryTheory.Groupoid.FreeGroupoid
import Mathlib.CategoryTheory.Groupoid.Subgroupoid
import Mathlib.CategoryTheory.Groupoid.VertexGroup
import Mathlib.CategoryTheory.GuitartExact.Basic
import Mathlib.CategoryTheory.GuitartExact.Opposite
import Mathlib.CategoryTheory.GuitartExact.VerticalComposition
import Mathlib.CategoryTheory.HomCongr
import Mathlib.CategoryTheory.Idempotents.Basic
import Mathlib.CategoryTheory.Idempotents.Biproducts
import Mathlib.CategoryTheory.Idempotents.FunctorCategories
import Mathlib.CategoryTheory.Idempotents.FunctorExtension
import Mathlib.CategoryTheory.Idempotents.HomologicalComplex
import Mathlib.CategoryTheory.Idempotents.Karoubi
import Mathlib.CategoryTheory.Idempotents.KaroubiKaroubi
import Mathlib.CategoryTheory.Idempotents.SimplicialObject
import Mathlib.CategoryTheory.InducedCategory
import Mathlib.CategoryTheory.IsConnected
import Mathlib.CategoryTheory.Iso
import Mathlib.CategoryTheory.IsomorphismClasses
import Mathlib.CategoryTheory.Join.Basic
import Mathlib.CategoryTheory.Join.Final
import Mathlib.CategoryTheory.Join.Opposites
import Mathlib.CategoryTheory.Join.Pseudofunctor
import Mathlib.CategoryTheory.Join.Sum
import Mathlib.CategoryTheory.LiftingProperties.Adjunction
import Mathlib.CategoryTheory.LiftingProperties.Basic
import Mathlib.CategoryTheory.LiftingProperties.Limits
import Mathlib.CategoryTheory.LiftingProperties.ParametrizedAdjunction
import Mathlib.CategoryTheory.Limits.Bicones
import Mathlib.CategoryTheory.Limits.ColimitLimit
import Mathlib.CategoryTheory.Limits.Comma
import Mathlib.CategoryTheory.Limits.ConcreteCategory.Basic
import Mathlib.CategoryTheory.Limits.ConcreteCategory.WithAlgebraicStructures
import Mathlib.CategoryTheory.Limits.ConeCategory
import Mathlib.CategoryTheory.Limits.Cones
import Mathlib.CategoryTheory.Limits.Connected
import Mathlib.CategoryTheory.Limits.Constructions.BinaryProducts
import Mathlib.CategoryTheory.Limits.Constructions.EpiMono
import Mathlib.CategoryTheory.Limits.Constructions.Equalizers
import Mathlib.CategoryTheory.Limits.Constructions.EventuallyConstant
import Mathlib.CategoryTheory.Limits.Constructions.Filtered
import Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts
import Mathlib.CategoryTheory.Limits.Constructions.LimitsOfProductsAndEqualizers
import Mathlib.CategoryTheory.Limits.Constructions.Over.Basic
import Mathlib.CategoryTheory.Limits.Constructions.Over.Connected
import Mathlib.CategoryTheory.Limits.Constructions.Over.Products
import Mathlib.CategoryTheory.Limits.Constructions.Pullbacks
import Mathlib.CategoryTheory.Limits.Constructions.WeaklyInitial
import Mathlib.CategoryTheory.Limits.Constructions.ZeroObjects
import Mathlib.CategoryTheory.Limits.Creates
import Mathlib.CategoryTheory.Limits.Elements
import Mathlib.CategoryTheory.Limits.EpiMono
import Mathlib.CategoryTheory.Limits.EssentiallySmall
import Mathlib.CategoryTheory.Limits.ExactFunctor
import Mathlib.CategoryTheory.Limits.Filtered
import Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit
import Mathlib.CategoryTheory.Limits.FilteredColimitCommutesProduct
import Mathlib.CategoryTheory.Limits.Final
import Mathlib.CategoryTheory.Limits.Final.ParallelPair
import Mathlib.CategoryTheory.Limits.FinallySmall
import Mathlib.CategoryTheory.Limits.FintypeCat
import Mathlib.CategoryTheory.Limits.FormalCoproducts
import Mathlib.CategoryTheory.Limits.Fubini
import Mathlib.CategoryTheory.Limits.FullSubcategory
import Mathlib.CategoryTheory.Limits.FunctorCategory.Basic
import Mathlib.CategoryTheory.Limits.FunctorCategory.EpiMono
import Mathlib.CategoryTheory.Limits.FunctorCategory.Filtered
import Mathlib.CategoryTheory.Limits.FunctorCategory.Finite
import Mathlib.CategoryTheory.Limits.FunctorCategory.Shapes.Products
import Mathlib.CategoryTheory.Limits.FunctorCategory.Shapes.Pullbacks
import Mathlib.CategoryTheory.Limits.FunctorToTypes
import Mathlib.CategoryTheory.Limits.HasLimits
import Mathlib.CategoryTheory.Limits.IndYoneda
import Mathlib.CategoryTheory.Limits.Indization.Category
import Mathlib.CategoryTheory.Limits.Indization.Equalizers
import Mathlib.CategoryTheory.Limits.Indization.FilteredColimits
import Mathlib.CategoryTheory.Limits.Indization.IndObject
import Mathlib.CategoryTheory.Limits.Indization.LocallySmall
import Mathlib.CategoryTheory.Limits.Indization.ParallelPair
import Mathlib.CategoryTheory.Limits.Indization.Products
import Mathlib.CategoryTheory.Limits.IsConnected
import Mathlib.CategoryTheory.Limits.IsLimit
import Mathlib.CategoryTheory.Limits.Lattice
import Mathlib.CategoryTheory.Limits.MonoCoprod
import Mathlib.CategoryTheory.Limits.MorphismProperty
import Mathlib.CategoryTheory.Limits.Opposites
import Mathlib.CategoryTheory.Limits.Over
import Mathlib.CategoryTheory.Limits.Pi
import Mathlib.CategoryTheory.Limits.Preorder
import Mathlib.CategoryTheory.Limits.Preserves.Basic
import Mathlib.CategoryTheory.Limits.Preserves.Bifunctor
import Mathlib.CategoryTheory.Limits.Preserves.Creates.Finite
import Mathlib.CategoryTheory.Limits.Preserves.Filtered
import Mathlib.CategoryTheory.Limits.Preserves.Finite
import Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory
import Mathlib.CategoryTheory.Limits.Preserves.Grothendieck
import Mathlib.CategoryTheory.Limits.Preserves.Limits
import Mathlib.CategoryTheory.Limits.Preserves.Opposites
import Mathlib.CategoryTheory.Limits.Preserves.Over
import Mathlib.CategoryTheory.Limits.Preserves.Presheaf
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.BinaryProducts
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.Equalizers
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.Images
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.Multiequalizer
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.Preorder
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.Products
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.Square
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.Terminal
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero
import Mathlib.CategoryTheory.Limits.Preserves.Ulift
import Mathlib.CategoryTheory.Limits.Preserves.Yoneda
import Mathlib.CategoryTheory.Limits.Presheaf
import Mathlib.CategoryTheory.Limits.Set
import Mathlib.CategoryTheory.Limits.Shapes.BinaryBiproducts
import Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts
import Mathlib.CategoryTheory.Limits.Shapes.Biproducts
import Mathlib.CategoryTheory.Limits.Shapes.CombinedProducts
import Mathlib.CategoryTheory.Limits.Shapes.ConcreteCategory
import Mathlib.CategoryTheory.Limits.Shapes.Connected
import Mathlib.CategoryTheory.Limits.Shapes.Countable
import Mathlib.CategoryTheory.Limits.Shapes.Diagonal
import Mathlib.CategoryTheory.Limits.Shapes.DisjointCoproduct
import Mathlib.CategoryTheory.Limits.Shapes.End
import Mathlib.CategoryTheory.Limits.Shapes.Equalizers
import Mathlib.CategoryTheory.Limits.Shapes.Equivalence
import Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits
import Mathlib.CategoryTheory.Limits.Shapes.FiniteMultiequalizer
import Mathlib.CategoryTheory.Limits.Shapes.FiniteProducts
import Mathlib.CategoryTheory.Limits.Shapes.FunctorToTypes
import Mathlib.CategoryTheory.Limits.Shapes.Grothendieck
import Mathlib.CategoryTheory.Limits.Shapes.Images
import Mathlib.CategoryTheory.Limits.Shapes.IsTerminal
import Mathlib.CategoryTheory.Limits.Shapes.KernelPair
import Mathlib.CategoryTheory.Limits.Shapes.Kernels
import Mathlib.CategoryTheory.Limits.Shapes.Multiequalizer
import Mathlib.CategoryTheory.Limits.Shapes.MultiequalizerPullback
import Mathlib.CategoryTheory.Limits.Shapes.NormalMono.Basic
import Mathlib.CategoryTheory.Limits.Shapes.NormalMono.Equalizers
import Mathlib.CategoryTheory.Limits.Shapes.PiProd
import Mathlib.CategoryTheory.Limits.Shapes.Preorder.Basic
import Mathlib.CategoryTheory.Limits.Shapes.Preorder.Fin
import Mathlib.CategoryTheory.Limits.Shapes.Preorder.HasIterationOfShape
import Mathlib.CategoryTheory.Limits.Shapes.Preorder.PrincipalSeg
import Mathlib.CategoryTheory.Limits.Shapes.Preorder.TransfiniteCompositionOfShape
import Mathlib.CategoryTheory.Limits.Shapes.Preorder.WellOrderContinuous
import Mathlib.CategoryTheory.Limits.Shapes.Products
import Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc
import Mathlib.CategoryTheory.Limits.Shapes.Pullback.Categorical.Basic
import Mathlib.CategoryTheory.Limits.Shapes.Pullback.Categorical.CatCospanTransform
import Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq
import Mathlib.CategoryTheory.Limits.Shapes.Pullback.Cospan
import Mathlib.CategoryTheory.Limits.Shapes.Pullback.Equalizer
import Mathlib.CategoryTheory.Limits.Shapes.Pullback.HasPullback
import Mathlib.CategoryTheory.Limits.Shapes.Pullback.Iso
import Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono
import Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting
import Mathlib.CategoryTheory.Limits.Shapes.Pullback.PullbackCone
import Mathlib.CategoryTheory.Limits.Shapes.Pullback.Square
import Mathlib.CategoryTheory.Limits.Shapes.Reflexive
import Mathlib.CategoryTheory.Limits.Shapes.RegularMono
import Mathlib.CategoryTheory.Limits.Shapes.SequentialProduct
import Mathlib.CategoryTheory.Limits.Shapes.SingleObj
import Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer
import Mathlib.CategoryTheory.Limits.Shapes.SplitEqualizer
import Mathlib.CategoryTheory.Limits.Shapes.StrictInitial
import Mathlib.CategoryTheory.Limits.Shapes.StrongEpi
import Mathlib.CategoryTheory.Limits.Shapes.Terminal
import Mathlib.CategoryTheory.Limits.Shapes.WideEqualizers
import Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks
import Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms
import Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects
import Mathlib.CategoryTheory.Limits.Sifted
import Mathlib.CategoryTheory.Limits.SmallComplete
import Mathlib.CategoryTheory.Limits.Types.ColimitType
import Mathlib.CategoryTheory.Limits.Types.Colimits
import Mathlib.CategoryTheory.Limits.Types.Filtered
import Mathlib.CategoryTheory.Limits.Types.Images
import Mathlib.CategoryTheory.Limits.Types.Limits
import Mathlib.CategoryTheory.Limits.Types.Shapes
import Mathlib.CategoryTheory.Limits.Types.Yoneda
import Mathlib.CategoryTheory.Limits.Unit
import Mathlib.CategoryTheory.Limits.VanKampen
import Mathlib.CategoryTheory.Limits.Yoneda
import Mathlib.CategoryTheory.Linear.Basic
import Mathlib.CategoryTheory.Linear.FunctorCategory
import Mathlib.CategoryTheory.Linear.LinearFunctor
import Mathlib.CategoryTheory.Linear.Yoneda
import Mathlib.CategoryTheory.Localization.Adjunction
import Mathlib.CategoryTheory.Localization.Bifunctor
import Mathlib.CategoryTheory.Localization.Bousfield
import Mathlib.CategoryTheory.Localization.CalculusOfFractions
import Mathlib.CategoryTheory.Localization.CalculusOfFractions.ComposableArrows
import Mathlib.CategoryTheory.Localization.CalculusOfFractions.Fractions
import Mathlib.CategoryTheory.Localization.CalculusOfFractions.OfAdjunction
import Mathlib.CategoryTheory.Localization.CalculusOfFractions.Preadditive
import Mathlib.CategoryTheory.Localization.Composition
import Mathlib.CategoryTheory.Localization.Construction
import Mathlib.CategoryTheory.Localization.DerivabilityStructure.Basic
import Mathlib.CategoryTheory.Localization.DerivabilityStructure.Constructor
import Mathlib.CategoryTheory.Localization.DerivabilityStructure.OfFunctorialResolutions
import Mathlib.CategoryTheory.Localization.Equivalence
import Mathlib.CategoryTheory.Localization.FiniteProducts
import Mathlib.CategoryTheory.Localization.HasLocalization
import Mathlib.CategoryTheory.Localization.HomEquiv
import Mathlib.CategoryTheory.Localization.Linear
import Mathlib.CategoryTheory.Localization.LocalizerMorphism
import Mathlib.CategoryTheory.Localization.LocallySmall
import Mathlib.CategoryTheory.Localization.Monoidal
import Mathlib.CategoryTheory.Localization.Opposite
import Mathlib.CategoryTheory.Localization.Pi
import Mathlib.CategoryTheory.Localization.Preadditive
import Mathlib.CategoryTheory.Localization.Predicate
import Mathlib.CategoryTheory.Localization.Prod
import Mathlib.CategoryTheory.Localization.Quotient
import Mathlib.CategoryTheory.Localization.Resolution
import Mathlib.CategoryTheory.Localization.SmallHom
import Mathlib.CategoryTheory.Localization.SmallShiftedHom
import Mathlib.CategoryTheory.Localization.StructuredArrow
import Mathlib.CategoryTheory.Localization.Triangulated
import Mathlib.CategoryTheory.Localization.Trifunctor
import Mathlib.CategoryTheory.LocallyDirected
import Mathlib.CategoryTheory.Monad.Adjunction
import Mathlib.CategoryTheory.Monad.Algebra
import Mathlib.CategoryTheory.Monad.Basic
import Mathlib.CategoryTheory.Monad.Coequalizer
import Mathlib.CategoryTheory.Monad.Comonadicity
import Mathlib.CategoryTheory.Monad.Equalizer
import Mathlib.CategoryTheory.Monad.EquivMon
import Mathlib.CategoryTheory.Monad.Kleisli
import Mathlib.CategoryTheory.Monad.Limits
import Mathlib.CategoryTheory.Monad.Monadicity
import Mathlib.CategoryTheory.Monad.Products
import Mathlib.CategoryTheory.Monad.Types
import Mathlib.CategoryTheory.Monoidal.Action.Basic
import Mathlib.CategoryTheory.Monoidal.Action.LinearFunctor
import Mathlib.CategoryTheory.Monoidal.Action.Opposites
import Mathlib.CategoryTheory.Monoidal.Bimod
import Mathlib.CategoryTheory.Monoidal.Bimon_
import Mathlib.CategoryTheory.Monoidal.Braided.Basic
import Mathlib.CategoryTheory.Monoidal.Braided.Opposite
import Mathlib.CategoryTheory.Monoidal.Braided.Reflection
import Mathlib.CategoryTheory.Monoidal.Cartesian.Basic
import Mathlib.CategoryTheory.Monoidal.Cartesian.Cat
import Mathlib.CategoryTheory.Monoidal.Cartesian.CommGrp_
import Mathlib.CategoryTheory.Monoidal.Cartesian.CommMon_
import Mathlib.CategoryTheory.Monoidal.Cartesian.Comon_
import Mathlib.CategoryTheory.Monoidal.Cartesian.FunctorCategory
import Mathlib.CategoryTheory.Monoidal.Cartesian.Grp_
import Mathlib.CategoryTheory.Monoidal.Cartesian.InfSemilattice
import Mathlib.CategoryTheory.Monoidal.Cartesian.Mod_
import Mathlib.CategoryTheory.Monoidal.Cartesian.Mon_
import Mathlib.CategoryTheory.Monoidal.Cartesian.Over
import Mathlib.CategoryTheory.Monoidal.Category
import Mathlib.CategoryTheory.Monoidal.Center
import Mathlib.CategoryTheory.Monoidal.CoherenceLemmas
import Mathlib.CategoryTheory.Monoidal.CommGrp_
import Mathlib.CategoryTheory.Monoidal.CommMon_
import Mathlib.CategoryTheory.Monoidal.Comon_
import Mathlib.CategoryTheory.Monoidal.Conv
import Mathlib.CategoryTheory.Monoidal.DayConvolution
import Mathlib.CategoryTheory.Monoidal.DayConvolution.Braided
import Mathlib.CategoryTheory.Monoidal.DayConvolution.Closed
import Mathlib.CategoryTheory.Monoidal.Discrete
import Mathlib.CategoryTheory.Monoidal.End
import Mathlib.CategoryTheory.Monoidal.ExternalProduct
import Mathlib.CategoryTheory.Monoidal.ExternalProduct.Basic
import Mathlib.CategoryTheory.Monoidal.ExternalProduct.KanExtension
import Mathlib.CategoryTheory.Monoidal.Free.Basic
import Mathlib.CategoryTheory.Monoidal.Free.Coherence
import Mathlib.CategoryTheory.Monoidal.Functor
import Mathlib.CategoryTheory.Monoidal.FunctorCategory
import Mathlib.CategoryTheory.Monoidal.Grp_
import Mathlib.CategoryTheory.Monoidal.Hopf_
import Mathlib.CategoryTheory.Monoidal.Internal.FunctorCategory
import Mathlib.CategoryTheory.Monoidal.Internal.Limits
import Mathlib.CategoryTheory.Monoidal.Internal.Module
import Mathlib.CategoryTheory.Monoidal.Internal.Types.Basic
import Mathlib.CategoryTheory.Monoidal.Internal.Types.CommGrp_
import Mathlib.CategoryTheory.Monoidal.Internal.Types.Grp_
import Mathlib.CategoryTheory.Monoidal.Limits
import Mathlib.CategoryTheory.Monoidal.Linear
import Mathlib.CategoryTheory.Monoidal.Mod_
import Mathlib.CategoryTheory.Monoidal.Mon_
import Mathlib.CategoryTheory.Monoidal.NaturalTransformation
import Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Basic
import Mathlib.CategoryTheory.Monoidal.OfChosenFiniteProducts.Symmetric
import Mathlib.CategoryTheory.Monoidal.OfHasFiniteProducts
import Mathlib.CategoryTheory.Monoidal.Opposite
import Mathlib.CategoryTheory.Monoidal.Opposite.Mon_
import Mathlib.CategoryTheory.Monoidal.Preadditive
import Mathlib.CategoryTheory.Monoidal.Rigid.Basic
import Mathlib.CategoryTheory.Monoidal.Rigid.Braided
import Mathlib.CategoryTheory.Monoidal.Rigid.FunctorCategory
import Mathlib.CategoryTheory.Monoidal.Rigid.OfEquivalence
import Mathlib.CategoryTheory.Monoidal.Skeleton
import Mathlib.CategoryTheory.Monoidal.Subcategory
import Mathlib.CategoryTheory.Monoidal.Tor
import Mathlib.CategoryTheory.Monoidal.Transport
import Mathlib.CategoryTheory.Monoidal.Types.Basic
import Mathlib.CategoryTheory.Monoidal.Types.Coyoneda
import Mathlib.CategoryTheory.Monoidal.Yoneda
import Mathlib.CategoryTheory.MorphismProperty.Basic
import Mathlib.CategoryTheory.MorphismProperty.Comma
import Mathlib.CategoryTheory.MorphismProperty.Composition
import Mathlib.CategoryTheory.MorphismProperty.Concrete
import Mathlib.CategoryTheory.MorphismProperty.Descent
import Mathlib.CategoryTheory.MorphismProperty.Factorization
import Mathlib.CategoryTheory.MorphismProperty.FunctorCategory
import Mathlib.CategoryTheory.MorphismProperty.IsInvertedBy
import Mathlib.CategoryTheory.MorphismProperty.IsSmall
import Mathlib.CategoryTheory.MorphismProperty.LiftingProperty
import Mathlib.CategoryTheory.MorphismProperty.Limits
import Mathlib.CategoryTheory.MorphismProperty.OverAdjunction
import Mathlib.CategoryTheory.MorphismProperty.Representable
import Mathlib.CategoryTheory.MorphismProperty.Retract
import Mathlib.CategoryTheory.MorphismProperty.RetractArgument
import Mathlib.CategoryTheory.MorphismProperty.TransfiniteComposition
import Mathlib.CategoryTheory.MorphismProperty.WeakFactorizationSystem
import Mathlib.CategoryTheory.NatIso
import Mathlib.CategoryTheory.NatTrans
import Mathlib.CategoryTheory.Noetherian
import Mathlib.CategoryTheory.ObjectProperty.Basic
import Mathlib.CategoryTheory.ObjectProperty.ClosedUnderIsomorphisms
import Mathlib.CategoryTheory.ObjectProperty.ContainsZero
import Mathlib.CategoryTheory.ObjectProperty.EpiMono
import Mathlib.CategoryTheory.ObjectProperty.Extensions
import Mathlib.CategoryTheory.ObjectProperty.FullSubcategory
import Mathlib.CategoryTheory.ObjectProperty.Shift
import Mathlib.CategoryTheory.Opposites
import Mathlib.CategoryTheory.PEmpty
import Mathlib.CategoryTheory.PUnit
import Mathlib.CategoryTheory.PathCategory.Basic
import Mathlib.CategoryTheory.PathCategory.MorphismProperty
import Mathlib.CategoryTheory.Pi.Basic
import Mathlib.CategoryTheory.Preadditive.AdditiveFunctor
import Mathlib.CategoryTheory.Preadditive.Basic
import Mathlib.CategoryTheory.Preadditive.Biproducts
import Mathlib.CategoryTheory.Preadditive.CommGrp_
import Mathlib.CategoryTheory.Preadditive.EilenbergMoore
import Mathlib.CategoryTheory.Preadditive.EndoFunctor
import Mathlib.CategoryTheory.Preadditive.FunctorCategory
import Mathlib.CategoryTheory.Preadditive.HomOrthogonal
import Mathlib.CategoryTheory.Preadditive.Indization
import Mathlib.CategoryTheory.Preadditive.Injective.Basic
import Mathlib.CategoryTheory.Preadditive.Injective.LiftingProperties
import Mathlib.CategoryTheory.Preadditive.Injective.Preserves
import Mathlib.CategoryTheory.Preadditive.Injective.Resolution
import Mathlib.CategoryTheory.Preadditive.LeftExact
import Mathlib.CategoryTheory.Preadditive.LiftToFinset
import Mathlib.CategoryTheory.Preadditive.Mat
import Mathlib.CategoryTheory.Preadditive.OfBiproducts
import Mathlib.CategoryTheory.Preadditive.Opposite
import Mathlib.CategoryTheory.Preadditive.Projective.Basic
import Mathlib.CategoryTheory.Preadditive.Projective.LiftingProperties
import Mathlib.CategoryTheory.Preadditive.Projective.Preserves
import Mathlib.CategoryTheory.Preadditive.Projective.Resolution
import Mathlib.CategoryTheory.Preadditive.Schur
import Mathlib.CategoryTheory.Preadditive.SingleObj
import Mathlib.CategoryTheory.Preadditive.Transfer
import Mathlib.CategoryTheory.Preadditive.Yoneda.Basic
import Mathlib.CategoryTheory.Preadditive.Yoneda.Injective
import Mathlib.CategoryTheory.Preadditive.Yoneda.Limits
import Mathlib.CategoryTheory.Preadditive.Yoneda.Projective
import Mathlib.CategoryTheory.Presentable.Basic
import Mathlib.CategoryTheory.Presentable.Finite
import Mathlib.CategoryTheory.Presentable.IsCardinalFiltered
import Mathlib.CategoryTheory.Presentable.Limits
import Mathlib.CategoryTheory.Products.Associator
import Mathlib.CategoryTheory.Products.Basic
import Mathlib.CategoryTheory.Products.Bifunctor
import Mathlib.CategoryTheory.Products.Unitor
import Mathlib.CategoryTheory.Quotient
import Mathlib.CategoryTheory.Quotient.Linear
import Mathlib.CategoryTheory.Quotient.Preadditive
import Mathlib.CategoryTheory.Retract
import Mathlib.CategoryTheory.Shift.Adjunction
import Mathlib.CategoryTheory.Shift.Basic
import Mathlib.CategoryTheory.Shift.CommShift
import Mathlib.CategoryTheory.Shift.Induced
import Mathlib.CategoryTheory.Shift.InducedShiftSequence
import Mathlib.CategoryTheory.Shift.Linear
import Mathlib.CategoryTheory.Shift.Localization
import Mathlib.CategoryTheory.Shift.Opposite
import Mathlib.CategoryTheory.Shift.Pullback
import Mathlib.CategoryTheory.Shift.Quotient
import Mathlib.CategoryTheory.Shift.ShiftSequence
import Mathlib.CategoryTheory.Shift.ShiftedHom
import Mathlib.CategoryTheory.Shift.ShiftedHomOpposite
import Mathlib.CategoryTheory.Shift.SingleFunctors
import Mathlib.CategoryTheory.Sigma.Basic
import Mathlib.CategoryTheory.Simple
import Mathlib.CategoryTheory.SingleObj
import Mathlib.CategoryTheory.Sites.Abelian
import Mathlib.CategoryTheory.Sites.Adjunction
import Mathlib.CategoryTheory.Sites.Canonical
import Mathlib.CategoryTheory.Sites.CartesianClosed
import Mathlib.CategoryTheory.Sites.CartesianMonoidal
import Mathlib.CategoryTheory.Sites.ChosenFiniteProducts
import Mathlib.CategoryTheory.Sites.Closed
import Mathlib.CategoryTheory.Sites.Coherent.Basic
import Mathlib.CategoryTheory.Sites.Coherent.CoherentSheaves
import Mathlib.CategoryTheory.Sites.Coherent.CoherentTopology
import Mathlib.CategoryTheory.Sites.Coherent.Comparison
import Mathlib.CategoryTheory.Sites.Coherent.Equivalence
import Mathlib.CategoryTheory.Sites.Coherent.ExtensiveColimits
import Mathlib.CategoryTheory.Sites.Coherent.ExtensiveSheaves
import Mathlib.CategoryTheory.Sites.Coherent.ExtensiveTopology
import Mathlib.CategoryTheory.Sites.Coherent.LocallySurjective
import Mathlib.CategoryTheory.Sites.Coherent.ReflectsPrecoherent
import Mathlib.CategoryTheory.Sites.Coherent.ReflectsPreregular
import Mathlib.CategoryTheory.Sites.Coherent.RegularSheaves
import Mathlib.CategoryTheory.Sites.Coherent.RegularTopology
import Mathlib.CategoryTheory.Sites.Coherent.SequentialLimit
import Mathlib.CategoryTheory.Sites.Coherent.SheafComparison
import Mathlib.CategoryTheory.Sites.CompatiblePlus
import Mathlib.CategoryTheory.Sites.CompatibleSheafification
import Mathlib.CategoryTheory.Sites.ConcreteSheafification
import Mathlib.CategoryTheory.Sites.ConstantSheaf
import Mathlib.CategoryTheory.Sites.Continuous
import Mathlib.CategoryTheory.Sites.CoverLifting
import Mathlib.CategoryTheory.Sites.CoverPreserving
import Mathlib.CategoryTheory.Sites.Coverage
import Mathlib.CategoryTheory.Sites.CoversTop
import Mathlib.CategoryTheory.Sites.DenseSubsite.Basic
import Mathlib.CategoryTheory.Sites.DenseSubsite.InducedTopology
import Mathlib.CategoryTheory.Sites.DenseSubsite.SheafEquiv
import Mathlib.CategoryTheory.Sites.EffectiveEpimorphic
import Mathlib.CategoryTheory.Sites.EpiMono
import Mathlib.CategoryTheory.Sites.EqualizerSheafCondition
import Mathlib.CategoryTheory.Sites.Equivalence
import Mathlib.CategoryTheory.Sites.GlobalSections
import Mathlib.CategoryTheory.Sites.Grothendieck
import Mathlib.CategoryTheory.Sites.IsSheafFor
import Mathlib.CategoryTheory.Sites.IsSheafOneHypercover
import Mathlib.CategoryTheory.Sites.LeftExact
import Mathlib.CategoryTheory.Sites.Limits
import Mathlib.CategoryTheory.Sites.Localization
import Mathlib.CategoryTheory.Sites.LocallyBijective
import Mathlib.CategoryTheory.Sites.LocallyFullyFaithful
import Mathlib.CategoryTheory.Sites.LocallyInjective
import Mathlib.CategoryTheory.Sites.LocallySurjective
import Mathlib.CategoryTheory.Sites.MayerVietorisSquare
import Mathlib.CategoryTheory.Sites.Monoidal
import Mathlib.CategoryTheory.Sites.MorphismProperty
import Mathlib.CategoryTheory.Sites.NonabelianCohomology.H1
import Mathlib.CategoryTheory.Sites.OneHypercover
import Mathlib.CategoryTheory.Sites.Over
import Mathlib.CategoryTheory.Sites.Plus
import Mathlib.CategoryTheory.Sites.Preserves
import Mathlib.CategoryTheory.Sites.PreservesLocallyBijective
import Mathlib.CategoryTheory.Sites.PreservesSheafification
import Mathlib.CategoryTheory.Sites.Pretopology
import Mathlib.CategoryTheory.Sites.Pullback
import Mathlib.CategoryTheory.Sites.Sheaf
import Mathlib.CategoryTheory.Sites.SheafCohomology.Basic
import Mathlib.CategoryTheory.Sites.SheafHom
import Mathlib.CategoryTheory.Sites.SheafOfTypes
import Mathlib.CategoryTheory.Sites.Sheafification
import Mathlib.CategoryTheory.Sites.Sieves
import Mathlib.CategoryTheory.Sites.Spaces
import Mathlib.CategoryTheory.Sites.Subcanonical
import Mathlib.CategoryTheory.Sites.Subsheaf
import Mathlib.CategoryTheory.Sites.Types
import Mathlib.CategoryTheory.Sites.Whiskering
import Mathlib.CategoryTheory.Sites.ZeroHypercover
import Mathlib.CategoryTheory.Skeletal
import Mathlib.CategoryTheory.SmallObject.Basic
import Mathlib.CategoryTheory.SmallObject.Construction
import Mathlib.CategoryTheory.SmallObject.IsCardinalForSmallObjectArgument
import Mathlib.CategoryTheory.SmallObject.Iteration.Basic
import Mathlib.CategoryTheory.SmallObject.Iteration.ExtendToSucc
import Mathlib.CategoryTheory.SmallObject.Iteration.FunctorOfCocone
import Mathlib.CategoryTheory.SmallObject.Iteration.Nonempty
import Mathlib.CategoryTheory.SmallObject.TransfiniteCompositionLifting
import Mathlib.CategoryTheory.SmallObject.TransfiniteIteration
import Mathlib.CategoryTheory.SmallObject.WellOrderInductionData
import Mathlib.CategoryTheory.Square
import Mathlib.CategoryTheory.Subobject.ArtinianObject
import Mathlib.CategoryTheory.Subobject.Basic
import Mathlib.CategoryTheory.Subobject.Comma
import Mathlib.CategoryTheory.Subobject.FactorThru
import Mathlib.CategoryTheory.Subobject.HasCardinalLT
import Mathlib.CategoryTheory.Subobject.Lattice
import Mathlib.CategoryTheory.Subobject.Limits
import Mathlib.CategoryTheory.Subobject.MonoOver
import Mathlib.CategoryTheory.Subobject.NoetherianObject
import Mathlib.CategoryTheory.Subobject.Presheaf
import Mathlib.CategoryTheory.Subobject.Types
import Mathlib.CategoryTheory.Subobject.WellPowered
import Mathlib.CategoryTheory.Subpresheaf.Basic
import Mathlib.CategoryTheory.Subpresheaf.Equalizer
import Mathlib.CategoryTheory.Subpresheaf.Finite
import Mathlib.CategoryTheory.Subpresheaf.Image
import Mathlib.CategoryTheory.Subpresheaf.OfSection
import Mathlib.CategoryTheory.Subpresheaf.Sieves
import Mathlib.CategoryTheory.Subpresheaf.Subobject
import Mathlib.CategoryTheory.Subterminal
import Mathlib.CategoryTheory.Sums.Associator
import Mathlib.CategoryTheory.Sums.Basic
import Mathlib.CategoryTheory.Sums.Products
import Mathlib.CategoryTheory.Thin
import Mathlib.CategoryTheory.Topos.Classifier
import Mathlib.CategoryTheory.Triangulated.Adjunction
import Mathlib.CategoryTheory.Triangulated.Basic
import Mathlib.CategoryTheory.Triangulated.Functor
import Mathlib.CategoryTheory.Triangulated.HomologicalFunctor
import Mathlib.CategoryTheory.Triangulated.Opposite.Basic
import Mathlib.CategoryTheory.Triangulated.Opposite.Functor
import Mathlib.CategoryTheory.Triangulated.Opposite.Pretriangulated
import Mathlib.CategoryTheory.Triangulated.Opposite.Triangle
import Mathlib.CategoryTheory.Triangulated.Pretriangulated
import Mathlib.CategoryTheory.Triangulated.Rotate
import Mathlib.CategoryTheory.Triangulated.Subcategory
import Mathlib.CategoryTheory.Triangulated.TStructure.Basic
import Mathlib.CategoryTheory.Triangulated.TriangleShift
import Mathlib.CategoryTheory.Triangulated.Triangulated
import Mathlib.CategoryTheory.Triangulated.Yoneda
import Mathlib.CategoryTheory.Types
import Mathlib.CategoryTheory.UnivLE
import Mathlib.CategoryTheory.Whiskering
import Mathlib.CategoryTheory.Widesubcategory
import Mathlib.CategoryTheory.WithTerminal
import Mathlib.CategoryTheory.WithTerminal.Basic
import Mathlib.CategoryTheory.WithTerminal.Cone
import Mathlib.CategoryTheory.WithTerminal.FinCategory
import Mathlib.CategoryTheory.Yoneda
import Mathlib.Combinatorics.Additive.AP.Three.Behrend
import Mathlib.Combinatorics.Additive.AP.Three.Defs
import Mathlib.Combinatorics.Additive.ApproximateSubgroup
import Mathlib.Combinatorics.Additive.CauchyDavenport
import Mathlib.Combinatorics.Additive.Corner.Defs
import Mathlib.Combinatorics.Additive.Corner.Roth
import Mathlib.Combinatorics.Additive.CovBySMul
import Mathlib.Combinatorics.Additive.Dissociation
import Mathlib.Combinatorics.Additive.DoublingConst
import Mathlib.Combinatorics.Additive.ETransform
import Mathlib.Combinatorics.Additive.Energy
import Mathlib.Combinatorics.Additive.ErdosGinzburgZiv
import Mathlib.Combinatorics.Additive.FreimanHom
import Mathlib.Combinatorics.Additive.PluenneckeRuzsa
import Mathlib.Combinatorics.Additive.Randomisation
import Mathlib.Combinatorics.Additive.RuzsaCovering
import Mathlib.Combinatorics.Additive.SmallTripling
import Mathlib.Combinatorics.Additive.VerySmallDoubling
import Mathlib.Combinatorics.Colex
import Mathlib.Combinatorics.Configuration
import Mathlib.Combinatorics.Derangements.Basic
import Mathlib.Combinatorics.Derangements.Exponential
import Mathlib.Combinatorics.Derangements.Finite
import Mathlib.Combinatorics.Digraph.Basic
import Mathlib.Combinatorics.Digraph.Orientation
import Mathlib.Combinatorics.Enumerative.Bell
import Mathlib.Combinatorics.Enumerative.Catalan
import Mathlib.Combinatorics.Enumerative.Composition
import Mathlib.Combinatorics.Enumerative.DoubleCounting
import Mathlib.Combinatorics.Enumerative.DyckWord
import Mathlib.Combinatorics.Enumerative.IncidenceAlgebra
import Mathlib.Combinatorics.Enumerative.InclusionExclusion
import Mathlib.Combinatorics.Enumerative.Partition
import Mathlib.Combinatorics.Extremal.RuzsaSzemeredi
import Mathlib.Combinatorics.Graph.Basic
import Mathlib.Combinatorics.HalesJewett
import Mathlib.Combinatorics.Hall.Basic
import Mathlib.Combinatorics.Hall.Finite
import Mathlib.Combinatorics.Hindman
import Mathlib.Combinatorics.Nullstellensatz
import Mathlib.Combinatorics.Optimization.ValuedCSP
import Mathlib.Combinatorics.Pigeonhole
import Mathlib.Combinatorics.Quiver.Arborescence
import Mathlib.Combinatorics.Quiver.Basic
import Mathlib.Combinatorics.Quiver.Cast
import Mathlib.Combinatorics.Quiver.ConnectedComponent
import Mathlib.Combinatorics.Quiver.Covering
import Mathlib.Combinatorics.Quiver.Path
import Mathlib.Combinatorics.Quiver.Path.Decomposition
import Mathlib.Combinatorics.Quiver.Path.Weight
import Mathlib.Combinatorics.Quiver.Prefunctor
import Mathlib.Combinatorics.Quiver.Push
import Mathlib.Combinatorics.Quiver.ReflQuiver
import Mathlib.Combinatorics.Quiver.SingleObj
import Mathlib.Combinatorics.Quiver.Subquiver
import Mathlib.Combinatorics.Quiver.Symmetric
import Mathlib.Combinatorics.Schnirelmann
import Mathlib.Combinatorics.SetFamily.AhlswedeZhang
import Mathlib.Combinatorics.SetFamily.Compression.Down
import Mathlib.Combinatorics.SetFamily.Compression.UV
import Mathlib.Combinatorics.SetFamily.FourFunctions
import Mathlib.Combinatorics.SetFamily.HarrisKleitman
import Mathlib.Combinatorics.SetFamily.Intersecting
import Mathlib.Combinatorics.SetFamily.Kleitman
import Mathlib.Combinatorics.SetFamily.KruskalKatona
import Mathlib.Combinatorics.SetFamily.LYM
import Mathlib.Combinatorics.SetFamily.Shadow
import Mathlib.Combinatorics.SetFamily.Shatter
import Mathlib.Combinatorics.SimpleGraph.Acyclic
import Mathlib.Combinatorics.SimpleGraph.AdjMatrix
import Mathlib.Combinatorics.SimpleGraph.Basic
import Mathlib.Combinatorics.SimpleGraph.Bipartite
import Mathlib.Combinatorics.SimpleGraph.Circulant
import Mathlib.Combinatorics.SimpleGraph.Clique
import Mathlib.Combinatorics.SimpleGraph.Coloring
import Mathlib.Combinatorics.SimpleGraph.CompleteMultipartite
import Mathlib.Combinatorics.SimpleGraph.ConcreteColorings
import Mathlib.Combinatorics.SimpleGraph.Connectivity.Connected
import Mathlib.Combinatorics.SimpleGraph.Connectivity.Represents
import Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph
import Mathlib.Combinatorics.SimpleGraph.Connectivity.WalkCounting
import Mathlib.Combinatorics.SimpleGraph.Connectivity.WalkDecomp
import Mathlib.Combinatorics.SimpleGraph.Copy
import Mathlib.Combinatorics.SimpleGraph.Dart
import Mathlib.Combinatorics.SimpleGraph.DegreeSum
import Mathlib.Combinatorics.SimpleGraph.DeleteEdges
import Mathlib.Combinatorics.SimpleGraph.Density
import Mathlib.Combinatorics.SimpleGraph.Diam
import Mathlib.Combinatorics.SimpleGraph.Ends.Defs
import Mathlib.Combinatorics.SimpleGraph.Ends.Properties
import Mathlib.Combinatorics.SimpleGraph.Extremal.Basic
import Mathlib.Combinatorics.SimpleGraph.Finite
import Mathlib.Combinatorics.SimpleGraph.Finsubgraph
import Mathlib.Combinatorics.SimpleGraph.FiveWheelLike
import Mathlib.Combinatorics.SimpleGraph.Girth
import Mathlib.Combinatorics.SimpleGraph.Hamiltonian
import Mathlib.Combinatorics.SimpleGraph.Hasse
import Mathlib.Combinatorics.SimpleGraph.IncMatrix
import Mathlib.Combinatorics.SimpleGraph.Init
import Mathlib.Combinatorics.SimpleGraph.LapMatrix
import Mathlib.Combinatorics.SimpleGraph.LineGraph
import Mathlib.Combinatorics.SimpleGraph.Maps
import Mathlib.Combinatorics.SimpleGraph.Matching
import Mathlib.Combinatorics.SimpleGraph.Metric
import Mathlib.Combinatorics.SimpleGraph.Operations
import Mathlib.Combinatorics.SimpleGraph.Partition
import Mathlib.Combinatorics.SimpleGraph.Path
import Mathlib.Combinatorics.SimpleGraph.Paths
import Mathlib.Combinatorics.SimpleGraph.Prod
import Mathlib.Combinatorics.SimpleGraph.Regularity.Bound
import Mathlib.Combinatorics.SimpleGraph.Regularity.Chunk
import Mathlib.Combinatorics.SimpleGraph.Regularity.Energy
import Mathlib.Combinatorics.SimpleGraph.Regularity.Equitabilise
import Mathlib.Combinatorics.SimpleGraph.Regularity.Increment
import Mathlib.Combinatorics.SimpleGraph.Regularity.Lemma
import Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform
import Mathlib.Combinatorics.SimpleGraph.StronglyRegular
import Mathlib.Combinatorics.SimpleGraph.Subgraph
import Mathlib.Combinatorics.SimpleGraph.Sum
import Mathlib.Combinatorics.SimpleGraph.Trails
import Mathlib.Combinatorics.SimpleGraph.Triangle.Basic
import Mathlib.Combinatorics.SimpleGraph.Triangle.Counting
import Mathlib.Combinatorics.SimpleGraph.Triangle.Removal
import Mathlib.Combinatorics.SimpleGraph.Triangle.Tripartite
import Mathlib.Combinatorics.SimpleGraph.Turan
import Mathlib.Combinatorics.SimpleGraph.Tutte
import Mathlib.Combinatorics.SimpleGraph.UniversalVerts
import Mathlib.Combinatorics.SimpleGraph.Walk
import Mathlib.Combinatorics.Young.SemistandardTableau
import Mathlib.Combinatorics.Young.YoungDiagram
import Mathlib.Computability.Ackermann
import Mathlib.Computability.AkraBazzi.AkraBazzi
import Mathlib.Computability.AkraBazzi.GrowsPolynomially
import Mathlib.Computability.AkraBazzi.SumTransform
import Mathlib.Computability.ContextFreeGrammar
import Mathlib.Computability.DFA
import Mathlib.Computability.Encoding
import Mathlib.Computability.EpsilonNFA
import Mathlib.Computability.Halting
import Mathlib.Computability.Language
import Mathlib.Computability.MyhillNerode
import Mathlib.Computability.NFA
import Mathlib.Computability.Partrec
import Mathlib.Computability.PartrecCode
import Mathlib.Computability.PostTuringMachine
import Mathlib.Computability.Primrec
import Mathlib.Computability.Reduce
import Mathlib.Computability.RegularExpressions
import Mathlib.Computability.TMComputable
import Mathlib.Computability.TMConfig
import Mathlib.Computability.TMToPartrec
import Mathlib.Computability.Tape
import Mathlib.Computability.TuringDegree
import Mathlib.Computability.TuringMachine
import Mathlib.Condensed.AB
import Mathlib.Condensed.Basic
import Mathlib.Condensed.CartesianClosed
import Mathlib.Condensed.Discrete.Basic
import Mathlib.Condensed.Discrete.Characterization
import Mathlib.Condensed.Discrete.Colimit
import Mathlib.Condensed.Discrete.LocallyConstant
import Mathlib.Condensed.Discrete.Module
import Mathlib.Condensed.Epi
import Mathlib.Condensed.Equivalence
import Mathlib.Condensed.Explicit
import Mathlib.Condensed.Functors
import Mathlib.Condensed.Light.AB
import Mathlib.Condensed.Light.Basic
import Mathlib.Condensed.Light.CartesianClosed
import Mathlib.Condensed.Light.Epi
import Mathlib.Condensed.Light.Explicit
import Mathlib.Condensed.Light.Functors
import Mathlib.Condensed.Light.Limits
import Mathlib.Condensed.Light.Module
import Mathlib.Condensed.Light.TopCatAdjunction
import Mathlib.Condensed.Light.TopComparison
import Mathlib.Condensed.Limits
import Mathlib.Condensed.Module
import Mathlib.Condensed.Solid
import Mathlib.Condensed.TopCatAdjunction
import Mathlib.Condensed.TopComparison
import Mathlib.Control.Applicative
import Mathlib.Control.Basic
import Mathlib.Control.Bifunctor
import Mathlib.Control.Bitraversable.Basic
import Mathlib.Control.Bitraversable.Instances
import Mathlib.Control.Bitraversable.Lemmas
import Mathlib.Control.Combinators
import Mathlib.Control.EquivFunctor
import Mathlib.Control.EquivFunctor.Instances
import Mathlib.Control.Fix
import Mathlib.Control.Fold
import Mathlib.Control.Functor
import Mathlib.Control.Functor.Multivariate
import Mathlib.Control.Lawful
import Mathlib.Control.LawfulFix
import Mathlib.Control.Monad.Basic
import Mathlib.Control.Monad.Cont
import Mathlib.Control.Monad.Writer
import Mathlib.Control.Random
import Mathlib.Control.Traversable.Basic
import Mathlib.Control.Traversable.Equiv
import Mathlib.Control.Traversable.Instances
import Mathlib.Control.Traversable.Lemmas
import Mathlib.Control.ULift
import Mathlib.Control.ULiftable
import Mathlib.Data.Analysis.Filter
import Mathlib.Data.Analysis.Topology
import Mathlib.Data.Array.Defs
import Mathlib.Data.Array.Extract
import Mathlib.Data.BitVec
import Mathlib.Data.Bool.AllAny
import Mathlib.Data.Bool.Basic
import Mathlib.Data.Bool.Count
import Mathlib.Data.Bool.Set
import Mathlib.Data.Bracket
import Mathlib.Data.Bundle
import Mathlib.Data.Char
import Mathlib.Data.Complex.Basic
import Mathlib.Data.Complex.BigOperators
import Mathlib.Data.Complex.Cardinality
import Mathlib.Data.Complex.Determinant
import Mathlib.Data.Complex.Exponential
import Mathlib.Data.Complex.ExponentialBounds
import Mathlib.Data.Complex.FiniteDimensional
import Mathlib.Data.Complex.Module
import Mathlib.Data.Complex.Norm
import Mathlib.Data.Complex.Order
import Mathlib.Data.Complex.Orientation
import Mathlib.Data.Complex.Trigonometric
import Mathlib.Data.Countable.Basic
import Mathlib.Data.Countable.Defs
import Mathlib.Data.Countable.Small
import Mathlib.Data.DFinsupp.BigOperators
import Mathlib.Data.DFinsupp.Defs
import Mathlib.Data.DFinsupp.Encodable
import Mathlib.Data.DFinsupp.Ext
import Mathlib.Data.DFinsupp.FiniteInfinite
import Mathlib.Data.DFinsupp.Interval
import Mathlib.Data.DFinsupp.Lex
import Mathlib.Data.DFinsupp.Module
import Mathlib.Data.DFinsupp.Multiset
import Mathlib.Data.DFinsupp.NeLocus
import Mathlib.Data.DFinsupp.Notation
import Mathlib.Data.DFinsupp.Order
import Mathlib.Data.DFinsupp.Sigma
import Mathlib.Data.DFinsupp.Small
import Mathlib.Data.DFinsupp.Submonoid
import Mathlib.Data.DFinsupp.WellFounded
import Mathlib.Data.DList.Instances
import Mathlib.Data.ENNReal.Action
import Mathlib.Data.ENNReal.Basic
import Mathlib.Data.ENNReal.BigOperators
import Mathlib.Data.ENNReal.Holder
import Mathlib.Data.ENNReal.Inv
import Mathlib.Data.ENNReal.Lemmas
import Mathlib.Data.ENNReal.Operations
import Mathlib.Data.ENNReal.Order
import Mathlib.Data.ENNReal.Real
import Mathlib.Data.ENat.Basic
import Mathlib.Data.ENat.BigOperators
import Mathlib.Data.ENat.Defs
import Mathlib.Data.ENat.Lattice
import Mathlib.Data.EReal.Basic
import Mathlib.Data.EReal.Inv
import Mathlib.Data.EReal.Operations
import Mathlib.Data.Erased
import Mathlib.Data.FP.Basic
import Mathlib.Data.Fin.Basic
import Mathlib.Data.Fin.Embedding
import Mathlib.Data.Fin.Fin2
import Mathlib.Data.Fin.FlagRange
import Mathlib.Data.Fin.Parity
import Mathlib.Data.Fin.Pigeonhole
import Mathlib.Data.Fin.Rev
import Mathlib.Data.Fin.SuccPred
import Mathlib.Data.Fin.Tuple.Basic
import Mathlib.Data.Fin.Tuple.BubbleSortInduction
import Mathlib.Data.Fin.Tuple.Curry
import Mathlib.Data.Fin.Tuple.Embedding
import Mathlib.Data.Fin.Tuple.Finset
import Mathlib.Data.Fin.Tuple.NatAntidiagonal
import Mathlib.Data.Fin.Tuple.Reflection
import Mathlib.Data.Fin.Tuple.Sort
import Mathlib.Data.Fin.Tuple.Take
import Mathlib.Data.Fin.VecNotation
import Mathlib.Data.FinEnum
import Mathlib.Data.FinEnum.Option
import Mathlib.Data.Finite.Card
import Mathlib.Data.Finite.Defs
import Mathlib.Data.Finite.Perm
import Mathlib.Data.Finite.Prod
import Mathlib.Data.Finite.Set
import Mathlib.Data.Finite.Sigma
import Mathlib.Data.Finite.Sum
import Mathlib.Data.Finite.Vector
import Mathlib.Data.Finmap
import Mathlib.Data.Finset.Attach
import Mathlib.Data.Finset.Attr
import Mathlib.Data.Finset.Basic
import Mathlib.Data.Finset.BooleanAlgebra
import Mathlib.Data.Finset.Card
import Mathlib.Data.Finset.CastCard
import Mathlib.Data.Finset.Dedup
import Mathlib.Data.Finset.Defs
import Mathlib.Data.Finset.Density
import Mathlib.Data.Finset.Disjoint
import Mathlib.Data.Finset.Empty
import Mathlib.Data.Finset.Erase
import Mathlib.Data.Finset.Filter
import Mathlib.Data.Finset.Fin
import Mathlib.Data.Finset.Finsupp
import Mathlib.Data.Finset.Fold
import Mathlib.Data.Finset.Functor
import Mathlib.Data.Finset.Grade
import Mathlib.Data.Finset.Image
import Mathlib.Data.Finset.Insert
import Mathlib.Data.Finset.Interval
import Mathlib.Data.Finset.Lattice.Basic
import Mathlib.Data.Finset.Lattice.Fold
import Mathlib.Data.Finset.Lattice.Lemmas
import Mathlib.Data.Finset.Lattice.Pi
import Mathlib.Data.Finset.Lattice.Prod
import Mathlib.Data.Finset.Lattice.Union
import Mathlib.Data.Finset.Max
import Mathlib.Data.Finset.MulAntidiagonal
import Mathlib.Data.Finset.NAry
import Mathlib.Data.Finset.NatAntidiagonal
import Mathlib.Data.Finset.NatDivisors
import Mathlib.Data.Finset.NoncommProd
import Mathlib.Data.Finset.Option
import Mathlib.Data.Finset.Order
import Mathlib.Data.Finset.PImage
import Mathlib.Data.Finset.Pairwise
import Mathlib.Data.Finset.Pi
import Mathlib.Data.Finset.PiInduction
import Mathlib.Data.Finset.Piecewise
import Mathlib.Data.Finset.Powerset
import Mathlib.Data.Finset.Preimage
import Mathlib.Data.Finset.Prod
import Mathlib.Data.Finset.Range
import Mathlib.Data.Finset.SDiff
import Mathlib.Data.Finset.SMulAntidiagonal
import Mathlib.Data.Finset.Sigma
import Mathlib.Data.Finset.Slice
import Mathlib.Data.Finset.Sort
import Mathlib.Data.Finset.Sum
import Mathlib.Data.Finset.Sups
import Mathlib.Data.Finset.Sym
import Mathlib.Data.Finset.SymmDiff
import Mathlib.Data.Finset.Union
import Mathlib.Data.Finset.Update
import Mathlib.Data.Finsupp.AList
import Mathlib.Data.Finsupp.Antidiagonal
import Mathlib.Data.Finsupp.Basic
import Mathlib.Data.Finsupp.BigOperators
import Mathlib.Data.Finsupp.Defs
import Mathlib.Data.Finsupp.Encodable
import Mathlib.Data.Finsupp.Ext
import Mathlib.Data.Finsupp.Fin
import Mathlib.Data.Finsupp.Fintype
import Mathlib.Data.Finsupp.Indicator
import Mathlib.Data.Finsupp.Interval
import Mathlib.Data.Finsupp.Lex
import Mathlib.Data.Finsupp.MonomialOrder
import Mathlib.Data.Finsupp.MonomialOrder.DegLex
import Mathlib.Data.Finsupp.Multiset
import Mathlib.Data.Finsupp.NeLocus
import Mathlib.Data.Finsupp.Notation
import Mathlib.Data.Finsupp.Option
import Mathlib.Data.Finsupp.Order
import Mathlib.Data.Finsupp.PWO
import Mathlib.Data.Finsupp.Pointwise
import Mathlib.Data.Finsupp.SMul
import Mathlib.Data.Finsupp.SMulWithZero
import Mathlib.Data.Finsupp.Single
import Mathlib.Data.Finsupp.ToDFinsupp
import Mathlib.Data.Finsupp.Weight
import Mathlib.Data.Finsupp.WellFounded
import Mathlib.Data.Fintype.Basic
import Mathlib.Data.Fintype.BigOperators
import Mathlib.Data.Fintype.Card
import Mathlib.Data.Fintype.CardEmbedding
import Mathlib.Data.Fintype.Defs
import Mathlib.Data.Fintype.EquivFin
import Mathlib.Data.Fintype.Fin
import Mathlib.Data.Fintype.Inv
import Mathlib.Data.Fintype.Lattice
import Mathlib.Data.Fintype.List
import Mathlib.Data.Fintype.OfMap
import Mathlib.Data.Fintype.Option
import Mathlib.Data.Fintype.Order
import Mathlib.Data.Fintype.Parity
import Mathlib.Data.Fintype.Perm
import Mathlib.Data.Fintype.Pi
import Mathlib.Data.Fintype.Pigeonhole
import Mathlib.Data.Fintype.Powerset
import Mathlib.Data.Fintype.Prod
import Mathlib.Data.Fintype.Quotient
import Mathlib.Data.Fintype.Sets
import Mathlib.Data.Fintype.Shrink
import Mathlib.Data.Fintype.Sigma
import Mathlib.Data.Fintype.Sort
import Mathlib.Data.Fintype.Sum
import Mathlib.Data.Fintype.Units
import Mathlib.Data.Fintype.Vector
import Mathlib.Data.FunLike.Basic
import Mathlib.Data.FunLike.Embedding
import Mathlib.Data.FunLike.Equiv
import Mathlib.Data.FunLike.Fintype
import Mathlib.Data.Holor
import Mathlib.Data.Ineq
import Mathlib.Data.Int.AbsoluteValue
import Mathlib.Data.Int.Associated
import Mathlib.Data.Int.Basic
import Mathlib.Data.Int.Bitwise
import Mathlib.Data.Int.CardIntervalMod
import Mathlib.Data.Int.Cast.Basic
import Mathlib.Data.Int.Cast.Defs
import Mathlib.Data.Int.Cast.Field
import Mathlib.Data.Int.Cast.Lemmas
import Mathlib.Data.Int.Cast.Pi
import Mathlib.Data.Int.Cast.Prod
import Mathlib.Data.Int.CharZero
import Mathlib.Data.Int.ConditionallyCompleteOrder
import Mathlib.Data.Int.DivMod
import Mathlib.Data.Int.GCD
import Mathlib.Data.Int.Init
import Mathlib.Data.Int.Interval
import Mathlib.Data.Int.LeastGreatest
import Mathlib.Data.Int.Lemmas
import Mathlib.Data.Int.Log
import Mathlib.Data.Int.ModEq
import Mathlib.Data.Int.NatAbs
import Mathlib.Data.Int.NatPrime
import Mathlib.Data.Int.Notation
import Mathlib.Data.Int.Order.Basic
import Mathlib.Data.Int.Order.Lemmas
import Mathlib.Data.Int.Order.Units
import Mathlib.Data.Int.Range
import Mathlib.Data.Int.Sqrt
import Mathlib.Data.Int.Star
import Mathlib.Data.Int.SuccPred
import Mathlib.Data.Int.WithZero
import Mathlib.Data.List.AList
import Mathlib.Data.List.Basic
import Mathlib.Data.List.Chain
import Mathlib.Data.List.ChainOfFn
import Mathlib.Data.List.Count
import Mathlib.Data.List.Cycle
import Mathlib.Data.List.Dedup
import Mathlib.Data.List.Defs
import Mathlib.Data.List.Destutter
import Mathlib.Data.List.DropRight
import Mathlib.Data.List.Duplicate
import Mathlib.Data.List.EditDistance.Bounds
import Mathlib.Data.List.EditDistance.Defs
import Mathlib.Data.List.EditDistance.Estimator
import Mathlib.Data.List.Enum
import Mathlib.Data.List.FinRange
import Mathlib.Data.List.Flatten
import Mathlib.Data.List.Forall2
import Mathlib.Data.List.GetD
import Mathlib.Data.List.Indexes
import Mathlib.Data.List.Induction
import Mathlib.Data.List.Infix
import Mathlib.Data.List.InsertIdx
import Mathlib.Data.List.InsertNth
import Mathlib.Data.List.Intervals
import Mathlib.Data.List.Iterate
import Mathlib.Data.List.Lattice
import Mathlib.Data.List.Lemmas
import Mathlib.Data.List.Lex
import Mathlib.Data.List.Lookmap
import Mathlib.Data.List.Map2
import Mathlib.Data.List.MinMax
import Mathlib.Data.List.ModifyLast
import Mathlib.Data.List.Monad
import Mathlib.Data.List.NatAntidiagonal
import Mathlib.Data.List.Nodup
import Mathlib.Data.List.NodupEquivFin
import Mathlib.Data.List.OfFn
import Mathlib.Data.List.Pairwise
import Mathlib.Data.List.Palindrome
import Mathlib.Data.List.Perm.Basic
import Mathlib.Data.List.Perm.Lattice
import Mathlib.Data.List.Perm.Subperm
import Mathlib.Data.List.Permutation
import Mathlib.Data.List.Pi
import Mathlib.Data.List.Prime
import Mathlib.Data.List.ProdSigma
import Mathlib.Data.List.Range
import Mathlib.Data.List.ReduceOption
import Mathlib.Data.List.Rotate
import Mathlib.Data.List.Scan
import Mathlib.Data.List.Sections
import Mathlib.Data.List.Shortlex
import Mathlib.Data.List.Sigma
import Mathlib.Data.List.Sort
import Mathlib.Data.List.SplitBy
import Mathlib.Data.List.SplitLengths
import Mathlib.Data.List.SplitOn
import Mathlib.Data.List.Sublists
import Mathlib.Data.List.Sym
import Mathlib.Data.List.TFAE
import Mathlib.Data.List.TakeDrop
import Mathlib.Data.List.TakeWhile
import Mathlib.Data.List.ToFinsupp
import Mathlib.Data.List.Triplewise
import Mathlib.Data.List.Zip
import Mathlib.Data.MLList.BestFirst
import Mathlib.Data.Matrix.Auto
import Mathlib.Data.Matrix.Basic
import Mathlib.Data.Matrix.Basis
import Mathlib.Data.Matrix.Bilinear
import Mathlib.Data.Matrix.Block
import Mathlib.Data.Matrix.CharP
import Mathlib.Data.Matrix.ColumnRowPartitioned
import Mathlib.Data.Matrix.Composition
import Mathlib.Data.Matrix.ConjTranspose
import Mathlib.Data.Matrix.DMatrix
import Mathlib.Data.Matrix.Defs
import Mathlib.Data.Matrix.Diagonal
import Mathlib.Data.Matrix.DoublyStochastic
import Mathlib.Data.Matrix.DualNumber
import Mathlib.Data.Matrix.Hadamard
import Mathlib.Data.Matrix.Invertible
import Mathlib.Data.Matrix.Kronecker
import Mathlib.Data.Matrix.Mul
import Mathlib.Data.Matrix.Notation
import Mathlib.Data.Matrix.PEquiv
import Mathlib.Data.Matrix.Rank
import Mathlib.Data.Matrix.Reflection
import Mathlib.Data.Matrix.RowCol
import Mathlib.Data.Matrix.Vec
import Mathlib.Data.Matroid.Basic
import Mathlib.Data.Matroid.Circuit
import Mathlib.Data.Matroid.Closure
import Mathlib.Data.Matroid.Constructions
import Mathlib.Data.Matroid.Dual
import Mathlib.Data.Matroid.IndepAxioms
import Mathlib.Data.Matroid.Init
import Mathlib.Data.Matroid.Loop
import Mathlib.Data.Matroid.Map
import Mathlib.Data.Matroid.Minor.Contract
import Mathlib.Data.Matroid.Minor.Delete
import Mathlib.Data.Matroid.Minor.Order
import Mathlib.Data.Matroid.Minor.Restrict
import Mathlib.Data.Matroid.Rank.Cardinal
import Mathlib.Data.Matroid.Rank.ENat
import Mathlib.Data.Matroid.Rank.Finite
import Mathlib.Data.Matroid.Sum
import Mathlib.Data.Multiset.AddSub
import Mathlib.Data.Multiset.Antidiagonal
import Mathlib.Data.Multiset.Basic
import Mathlib.Data.Multiset.Bind
import Mathlib.Data.Multiset.Count
import Mathlib.Data.Multiset.Dedup
import Mathlib.Data.Multiset.Defs
import Mathlib.Data.Multiset.DershowitzManna
import Mathlib.Data.Multiset.Filter
import Mathlib.Data.Multiset.FinsetOps
import Mathlib.Data.Multiset.Fintype
import Mathlib.Data.Multiset.Fold
import Mathlib.Data.Multiset.Functor
import Mathlib.Data.Multiset.Interval
import Mathlib.Data.Multiset.Lattice
import Mathlib.Data.Multiset.MapFold
import Mathlib.Data.Multiset.NatAntidiagonal
import Mathlib.Data.Multiset.OrderedMonoid
import Mathlib.Data.Multiset.Pairwise
import Mathlib.Data.Multiset.Pi
import Mathlib.Data.Multiset.Powerset
import Mathlib.Data.Multiset.Range
import Mathlib.Data.Multiset.Replicate
import Mathlib.Data.Multiset.Sections
import Mathlib.Data.Multiset.Sort
import Mathlib.Data.Multiset.Sum
import Mathlib.Data.Multiset.Sym
import Mathlib.Data.Multiset.UnionInter
import Mathlib.Data.Multiset.ZeroCons
import Mathlib.Data.NNRat.BigOperators
import Mathlib.Data.NNRat.Defs
import Mathlib.Data.NNRat.Floor
import Mathlib.Data.NNRat.Lemmas
import Mathlib.Data.NNRat.Order
import Mathlib.Data.NNReal.Basic
import Mathlib.Data.NNReal.Defs
import Mathlib.Data.NNReal.Star
import Mathlib.Data.Nat.Basic
import Mathlib.Data.Nat.BinaryRec
import Mathlib.Data.Nat.BitIndices
import Mathlib.Data.Nat.Bits
import Mathlib.Data.Nat.Bitwise
import Mathlib.Data.Nat.Cast.Basic
import Mathlib.Data.Nat.Cast.Commute
import Mathlib.Data.Nat.Cast.Defs
import Mathlib.Data.Nat.Cast.Field
import Mathlib.Data.Nat.Cast.NeZero
import Mathlib.Data.Nat.Cast.Order.Basic
import Mathlib.Data.Nat.Cast.Order.Field
import Mathlib.Data.Nat.Cast.Order.Ring
import Mathlib.Data.Nat.Cast.Prod
import Mathlib.Data.Nat.Cast.SetInterval
import Mathlib.Data.Nat.Cast.Synonym
import Mathlib.Data.Nat.Cast.WithTop
import Mathlib.Data.Nat.ChineseRemainder
import Mathlib.Data.Nat.Choose.Basic
import Mathlib.Data.Nat.Choose.Bounds
import Mathlib.Data.Nat.Choose.Cast
import Mathlib.Data.Nat.Choose.Central
import Mathlib.Data.Nat.Choose.Dvd
import Mathlib.Data.Nat.Choose.Factorization
import Mathlib.Data.Nat.Choose.Lucas
import Mathlib.Data.Nat.Choose.Mul
import Mathlib.Data.Nat.Choose.Multinomial
import Mathlib.Data.Nat.Choose.Sum
import Mathlib.Data.Nat.Choose.Vandermonde
import Mathlib.Data.Nat.Count
import Mathlib.Data.Nat.Digits.Defs
import Mathlib.Data.Nat.Digits.Div
import Mathlib.Data.Nat.Digits.Lemmas
import Mathlib.Data.Nat.Dist
import Mathlib.Data.Nat.EvenOddRec
import Mathlib.Data.Nat.Factorial.Basic
import Mathlib.Data.Nat.Factorial.BigOperators
import Mathlib.Data.Nat.Factorial.Cast
import Mathlib.Data.Nat.Factorial.DoubleFactorial
import Mathlib.Data.Nat.Factorial.NatCast
import Mathlib.Data.Nat.Factorial.SuperFactorial
import Mathlib.Data.Nat.Factorization.Basic
import Mathlib.Data.Nat.Factorization.Defs
import Mathlib.Data.Nat.Factorization.Induction
import Mathlib.Data.Nat.Factorization.LCM
import Mathlib.Data.Nat.Factorization.PrimePow
import Mathlib.Data.Nat.Factorization.Root
import Mathlib.Data.Nat.Factors
import Mathlib.Data.Nat.Fib.Basic
import Mathlib.Data.Nat.Fib.Zeckendorf
import Mathlib.Data.Nat.Find
import Mathlib.Data.Nat.GCD.Basic
import Mathlib.Data.Nat.GCD.BigOperators
import Mathlib.Data.Nat.Hyperoperation
import Mathlib.Data.Nat.Init
import Mathlib.Data.Nat.Lattice
import Mathlib.Data.Nat.Log
import Mathlib.Data.Nat.MaxPowDiv
import Mathlib.Data.Nat.ModEq
import Mathlib.Data.Nat.Multiplicity
import Mathlib.Data.Nat.Notation
import Mathlib.Data.Nat.Nth
import Mathlib.Data.Nat.Order.Lemmas
import Mathlib.Data.Nat.PSub
import Mathlib.Data.Nat.Pairing
import Mathlib.Data.Nat.PartENat
import Mathlib.Data.Nat.Periodic
import Mathlib.Data.Nat.PowModTotient
import Mathlib.Data.Nat.Prime.Basic
import Mathlib.Data.Nat.Prime.Defs
import Mathlib.Data.Nat.Prime.Factorial
import Mathlib.Data.Nat.Prime.Infinite
import Mathlib.Data.Nat.Prime.Int
import Mathlib.Data.Nat.Prime.Nth
import Mathlib.Data.Nat.Prime.Pow
import Mathlib.Data.Nat.PrimeFin
import Mathlib.Data.Nat.Set
import Mathlib.Data.Nat.Size
import Mathlib.Data.Nat.Sqrt
import Mathlib.Data.Nat.Squarefree
import Mathlib.Data.Nat.SuccPred
import Mathlib.Data.Nat.Totient
import Mathlib.Data.Nat.Upto
import Mathlib.Data.Nat.WithBot
import Mathlib.Data.Num.Basic
import Mathlib.Data.Num.Bitwise
import Mathlib.Data.Num.Lemmas
import Mathlib.Data.Num.Prime
import Mathlib.Data.Num.ZNum
import Mathlib.Data.Opposite
import Mathlib.Data.Option.Basic
import Mathlib.Data.Option.Defs
import Mathlib.Data.Option.NAry
import Mathlib.Data.Ordering.Basic
import Mathlib.Data.Ordering.Lemmas
import Mathlib.Data.Ordmap.Invariants
import Mathlib.Data.Ordmap.Ordnode
import Mathlib.Data.Ordmap.Ordset
import Mathlib.Data.PEquiv
import Mathlib.Data.PFun
import Mathlib.Data.PFunctor.Multivariate.Basic
import Mathlib.Data.PFunctor.Multivariate.M
import Mathlib.Data.PFunctor.Multivariate.W
import Mathlib.Data.PFunctor.Univariate.Basic
import Mathlib.Data.PFunctor.Univariate.M
import Mathlib.Data.PNat.Basic
import Mathlib.Data.PNat.Defs
import Mathlib.Data.PNat.Equiv
import Mathlib.Data.PNat.Factors
import Mathlib.Data.PNat.Find
import Mathlib.Data.PNat.Interval
import Mathlib.Data.PNat.Notation
import Mathlib.Data.PNat.Prime
import Mathlib.Data.PNat.Xgcd
import Mathlib.Data.PSigma.Order
import Mathlib.Data.Part
import Mathlib.Data.Pi.Interval
import Mathlib.Data.Prod.Basic
import Mathlib.Data.Prod.Lex
import Mathlib.Data.Prod.PProd
import Mathlib.Data.Prod.TProd
import Mathlib.Data.QPF.Multivariate.Basic
import Mathlib.Data.QPF.Multivariate.Constructions.Cofix
import Mathlib.Data.QPF.Multivariate.Constructions.Comp
import Mathlib.Data.QPF.Multivariate.Constructions.Const
import Mathlib.Data.QPF.Multivariate.Constructions.Fix
import Mathlib.Data.QPF.Multivariate.Constructions.Prj
import Mathlib.Data.QPF.Multivariate.Constructions.Quot
import Mathlib.Data.QPF.Multivariate.Constructions.Sigma
import Mathlib.Data.QPF.Univariate.Basic
import Mathlib.Data.Quot
import Mathlib.Data.Rat.BigOperators
import Mathlib.Data.Rat.Cardinal
import Mathlib.Data.Rat.Cast.CharZero
import Mathlib.Data.Rat.Cast.Defs
import Mathlib.Data.Rat.Cast.Lemmas
import Mathlib.Data.Rat.Cast.Order
import Mathlib.Data.Rat.Defs
import Mathlib.Data.Rat.Denumerable
import Mathlib.Data.Rat.Encodable
import Mathlib.Data.Rat.Floor
import Mathlib.Data.Rat.Init
import Mathlib.Data.Rat.Lemmas
import Mathlib.Data.Rat.Sqrt
import Mathlib.Data.Rat.Star
import Mathlib.Data.Real.Archimedean
import Mathlib.Data.Real.Basic
import Mathlib.Data.Real.Cardinality
import Mathlib.Data.Real.CompleteField
import Mathlib.Data.Real.ConjExponents
import Mathlib.Data.Real.ENatENNReal
import Mathlib.Data.Real.EReal
import Mathlib.Data.Real.Embedding
import Mathlib.Data.Real.GoldenRatio
import Mathlib.Data.Real.Hyperreal
import Mathlib.Data.Real.Irrational
import Mathlib.Data.Real.Pi.Bounds
import Mathlib.Data.Real.Pi.Irrational
import Mathlib.Data.Real.Pi.Leibniz
import Mathlib.Data.Real.Pi.Wallis
import Mathlib.Data.Real.Pointwise
import Mathlib.Data.Real.Sign
import Mathlib.Data.Real.Sqrt
import Mathlib.Data.Real.Star
import Mathlib.Data.Real.StarOrdered
import Mathlib.Data.Rel
import Mathlib.Data.SProd
import Mathlib.Data.Semiquot
import Mathlib.Data.Seq.Computation
import Mathlib.Data.Seq.Parallel
import Mathlib.Data.Seq.Seq
import Mathlib.Data.Seq.WSeq
import Mathlib.Data.Set.Accumulate
import Mathlib.Data.Set.Basic
import Mathlib.Data.Set.BoolIndicator
import Mathlib.Data.Set.BooleanAlgebra
import Mathlib.Data.Set.Card
import Mathlib.Data.Set.Card.Arithmetic
import Mathlib.Data.Set.CoeSort
import Mathlib.Data.Set.Constructions
import Mathlib.Data.Set.Countable
import Mathlib.Data.Set.Defs
import Mathlib.Data.Set.Disjoint
import Mathlib.Data.Set.Enumerate
import Mathlib.Data.Set.Equitable
import Mathlib.Data.Set.Finite.Basic
import Mathlib.Data.Set.Finite.Lattice
import Mathlib.Data.Set.Finite.Lemmas
import Mathlib.Data.Set.Finite.List
import Mathlib.Data.Set.Finite.Monad
import Mathlib.Data.Set.Finite.Powerset
import Mathlib.Data.Set.Finite.Range
import Mathlib.Data.Set.Function
import Mathlib.Data.Set.Functor
import Mathlib.Data.Set.FunctorToTypes
import Mathlib.Data.Set.Image
import Mathlib.Data.Set.Inclusion
import Mathlib.Data.Set.Insert
import Mathlib.Data.Set.Lattice
import Mathlib.Data.Set.Lattice.Image
import Mathlib.Data.Set.List
import Mathlib.Data.Set.MemPartition
import Mathlib.Data.Set.Monotone
import Mathlib.Data.Set.MulAntidiagonal
import Mathlib.Data.Set.NAry
import Mathlib.Data.Set.Notation
import Mathlib.Data.Set.Operations
import Mathlib.Data.Set.Opposite
import Mathlib.Data.Set.Order
import Mathlib.Data.Set.Pairwise.Basic
import Mathlib.Data.Set.Pairwise.Lattice
import Mathlib.Data.Set.Pairwise.List
import Mathlib.Data.Set.Piecewise
import Mathlib.Data.Set.Pointwise.Support
import Mathlib.Data.Set.Prod
import Mathlib.Data.Set.Restrict
import Mathlib.Data.Set.SMulAntidiagonal
import Mathlib.Data.Set.Semiring
import Mathlib.Data.Set.Sigma
import Mathlib.Data.Set.Subset
import Mathlib.Data.Set.Subsingleton
import Mathlib.Data.Set.Sups
import Mathlib.Data.Set.SymmDiff
import Mathlib.Data.Set.UnionLift
import Mathlib.Data.SetLike.Basic
import Mathlib.Data.SetLike.Fintype
import Mathlib.Data.Setoid.Basic
import Mathlib.Data.Setoid.Partition
import Mathlib.Data.Setoid.Partition.Card
import Mathlib.Data.Sigma.Basic
import Mathlib.Data.Sigma.Interval
import Mathlib.Data.Sigma.Lex
import Mathlib.Data.Sigma.Order
import Mathlib.Data.Sign
import Mathlib.Data.Sign.Basic
import Mathlib.Data.Sign.Defs
import Mathlib.Data.Stream.Defs
import Mathlib.Data.Stream.Init
import Mathlib.Data.String.Basic
import Mathlib.Data.String.Defs
import Mathlib.Data.String.Lemmas
import Mathlib.Data.Subtype
import Mathlib.Data.Sum.Basic
import Mathlib.Data.Sum.Interval
import Mathlib.Data.Sum.Lattice
import Mathlib.Data.Sum.Order
import Mathlib.Data.Sym.Basic
import Mathlib.Data.Sym.Card
import Mathlib.Data.Sym.Sym2
import Mathlib.Data.Sym.Sym2.Finsupp
import Mathlib.Data.Sym.Sym2.Init
import Mathlib.Data.Sym.Sym2.Order
import Mathlib.Data.Tree.Basic
import Mathlib.Data.Tree.Get
import Mathlib.Data.Tree.RBMap
import Mathlib.Data.Tree.Traversable
import Mathlib.Data.TwoPointing
import Mathlib.Data.TypeVec
import Mathlib.Data.UInt
import Mathlib.Data.ULift
import Mathlib.Data.Vector.Basic
import Mathlib.Data.Vector.Defs
import Mathlib.Data.Vector.MapLemmas
import Mathlib.Data.Vector.Mem
import Mathlib.Data.Vector.Snoc
import Mathlib.Data.Vector.Zip
import Mathlib.Data.Vector3
import Mathlib.Data.W.Basic
import Mathlib.Data.W.Cardinal
import Mathlib.Data.W.Constructions
import Mathlib.Data.WSeq.Basic
import Mathlib.Data.WSeq.Defs
import Mathlib.Data.WSeq.Productive
import Mathlib.Data.WSeq.Relation
import Mathlib.Data.ZMod.Aut
import Mathlib.Data.ZMod.Basic
import Mathlib.Data.ZMod.Coprime
import Mathlib.Data.ZMod.Defs
import Mathlib.Data.ZMod.Factorial
import Mathlib.Data.ZMod.IntUnitsPower
import Mathlib.Data.ZMod.QuotientGroup
import Mathlib.Data.ZMod.QuotientRing
import Mathlib.Data.ZMod.Units
import Mathlib.Data.ZMod.ValMinAbs
import Mathlib.Deprecated.Aliases
import Mathlib.Deprecated.AnalyticManifold
import Mathlib.Deprecated.Order
import Mathlib.Deprecated.RingHom
import Mathlib.Dynamics.BirkhoffSum.Average
import Mathlib.Dynamics.BirkhoffSum.Basic
import Mathlib.Dynamics.BirkhoffSum.NormedSpace
import Mathlib.Dynamics.Circle.RotationNumber.TranslationNumber
import Mathlib.Dynamics.Ergodic.Action.Basic
import Mathlib.Dynamics.Ergodic.Action.OfMinimal
import Mathlib.Dynamics.Ergodic.Action.Regular
import Mathlib.Dynamics.Ergodic.AddCircle
import Mathlib.Dynamics.Ergodic.AddCircleAdd
import Mathlib.Dynamics.Ergodic.Conservative
import Mathlib.Dynamics.Ergodic.Ergodic
import Mathlib.Dynamics.Ergodic.Extreme
import Mathlib.Dynamics.Ergodic.Function
import Mathlib.Dynamics.Ergodic.MeasurePreserving
import Mathlib.Dynamics.Ergodic.RadonNikodym
import Mathlib.Dynamics.FixedPoints.Basic
import Mathlib.Dynamics.FixedPoints.Prufer
import Mathlib.Dynamics.FixedPoints.Topology
import Mathlib.Dynamics.Flow
import Mathlib.Dynamics.Minimal
import Mathlib.Dynamics.Newton
import Mathlib.Dynamics.OmegaLimit
import Mathlib.Dynamics.PeriodicPts.Defs
import Mathlib.Dynamics.PeriodicPts.Lemmas
import Mathlib.Dynamics.TopologicalEntropy.CoverEntropy
import Mathlib.Dynamics.TopologicalEntropy.DynamicalEntourage
import Mathlib.Dynamics.TopologicalEntropy.NetEntropy
import Mathlib.Dynamics.TopologicalEntropy.Semiconj
import Mathlib.Dynamics.TopologicalEntropy.Subset
import Mathlib.FieldTheory.AbelRuffini
import Mathlib.FieldTheory.AbsoluteGaloisGroup
import Mathlib.FieldTheory.AlgebraicClosure
import Mathlib.FieldTheory.AxGrothendieck
import Mathlib.FieldTheory.CardinalEmb
import Mathlib.FieldTheory.Cardinality
import Mathlib.FieldTheory.ChevalleyWarning
import Mathlib.FieldTheory.Differential.Basic
import Mathlib.FieldTheory.Differential.Liouville
import Mathlib.FieldTheory.Extension
import Mathlib.FieldTheory.Finite.Basic
import Mathlib.FieldTheory.Finite.GaloisField
import Mathlib.FieldTheory.Finite.Polynomial
import Mathlib.FieldTheory.Finite.Trace
import Mathlib.FieldTheory.Finiteness
import Mathlib.FieldTheory.Fixed
import Mathlib.FieldTheory.Galois.Basic
import Mathlib.FieldTheory.Galois.GaloisClosure
import Mathlib.FieldTheory.Galois.Infinite
import Mathlib.FieldTheory.Galois.IsGaloisGroup
import Mathlib.FieldTheory.Galois.Profinite
import Mathlib.FieldTheory.IntermediateField.Adjoin.Algebra
import Mathlib.FieldTheory.IntermediateField.Adjoin.Basic
import Mathlib.FieldTheory.IntermediateField.Adjoin.Defs
import Mathlib.FieldTheory.IntermediateField.Algebraic
import Mathlib.FieldTheory.IntermediateField.Basic
import Mathlib.FieldTheory.IsAlgClosed.AlgebraicClosure
import Mathlib.FieldTheory.IsAlgClosed.Basic
import Mathlib.FieldTheory.IsAlgClosed.Classification
import Mathlib.FieldTheory.IsAlgClosed.Spectrum
import Mathlib.FieldTheory.IsPerfectClosure
import Mathlib.FieldTheory.IsSepClosed
import Mathlib.FieldTheory.Isaacs
import Mathlib.FieldTheory.JacobsonNoether
import Mathlib.FieldTheory.KrullTopology
import Mathlib.FieldTheory.KummerExtension
import Mathlib.FieldTheory.KummerPolynomial
import Mathlib.FieldTheory.Laurent
import Mathlib.FieldTheory.LinearDisjoint
import Mathlib.FieldTheory.Minpoly.Basic
import Mathlib.FieldTheory.Minpoly.Field
import Mathlib.FieldTheory.Minpoly.IsConjRoot
import Mathlib.FieldTheory.Minpoly.IsIntegrallyClosed
import Mathlib.FieldTheory.Minpoly.MinpolyDiv
import Mathlib.FieldTheory.MvRatFunc.Rank
import Mathlib.FieldTheory.Normal.Basic
import Mathlib.FieldTheory.Normal.Closure
import Mathlib.FieldTheory.Normal.Defs
import Mathlib.FieldTheory.NormalizedTrace
import Mathlib.FieldTheory.Perfect
import Mathlib.FieldTheory.PerfectClosure
import Mathlib.FieldTheory.PolynomialGaloisGroup
import Mathlib.FieldTheory.PrimitiveElement
import Mathlib.FieldTheory.PurelyInseparable.Basic
import Mathlib.FieldTheory.PurelyInseparable.Exponent
import Mathlib.FieldTheory.PurelyInseparable.PerfectClosure
import Mathlib.FieldTheory.PurelyInseparable.Tower
import Mathlib.FieldTheory.RatFunc.AsPolynomial
import Mathlib.FieldTheory.RatFunc.Basic
import Mathlib.FieldTheory.RatFunc.Defs
import Mathlib.FieldTheory.RatFunc.Degree
import Mathlib.FieldTheory.Relrank
import Mathlib.FieldTheory.Separable
import Mathlib.FieldTheory.SeparableClosure
import Mathlib.FieldTheory.SeparableDegree
import Mathlib.FieldTheory.SplittingField.Construction
import Mathlib.FieldTheory.SplittingField.IsSplittingField
import Mathlib.FieldTheory.Tower
import Mathlib.Geometry.Convex.Cone.Basic
import Mathlib.Geometry.Convex.Cone.Dual
import Mathlib.Geometry.Convex.Cone.Pointed
import Mathlib.Geometry.Euclidean.Altitude
import Mathlib.Geometry.Euclidean.Angle.Oriented.Affine
import Mathlib.Geometry.Euclidean.Angle.Oriented.Basic
import Mathlib.Geometry.Euclidean.Angle.Oriented.RightAngle
import Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation
import Mathlib.Geometry.Euclidean.Angle.Sphere
import Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine
import Mathlib.Geometry.Euclidean.Angle.Unoriented.Basic
import Mathlib.Geometry.Euclidean.Angle.Unoriented.Conformal
import Mathlib.Geometry.Euclidean.Angle.Unoriented.CrossProduct
import Mathlib.Geometry.Euclidean.Angle.Unoriented.RightAngle
import Mathlib.Geometry.Euclidean.Basic
import Mathlib.Geometry.Euclidean.Circumcenter
import Mathlib.Geometry.Euclidean.Congruence
import Mathlib.Geometry.Euclidean.Incenter
import Mathlib.Geometry.Euclidean.Inversion.Basic
import Mathlib.Geometry.Euclidean.Inversion.Calculus
import Mathlib.Geometry.Euclidean.Inversion.ImageHyperplane
import Mathlib.Geometry.Euclidean.MongePoint
import Mathlib.Geometry.Euclidean.PerpBisector
import Mathlib.Geometry.Euclidean.Projection
import Mathlib.Geometry.Euclidean.SignedDist
import Mathlib.Geometry.Euclidean.Simplex
import Mathlib.Geometry.Euclidean.Sphere.Basic
import Mathlib.Geometry.Euclidean.Sphere.Power
import Mathlib.Geometry.Euclidean.Sphere.Ptolemy
import Mathlib.Geometry.Euclidean.Sphere.SecondInter
import Mathlib.Geometry.Euclidean.Sphere.Tangent
import Mathlib.Geometry.Euclidean.Triangle
import Mathlib.Geometry.Group.Growth.LinearLowerBound
import Mathlib.Geometry.Group.Growth.QuotientInter
import Mathlib.Geometry.Manifold.Algebra.LeftInvariantDerivation
import Mathlib.Geometry.Manifold.Algebra.LieGroup
import Mathlib.Geometry.Manifold.Algebra.Monoid
import Mathlib.Geometry.Manifold.Algebra.SmoothFunctions
import Mathlib.Geometry.Manifold.Algebra.Structures
import Mathlib.Geometry.Manifold.AnalyticManifold
import Mathlib.Geometry.Manifold.Bordism
import Mathlib.Geometry.Manifold.BumpFunction
import Mathlib.Geometry.Manifold.ChartedSpace
import Mathlib.Geometry.Manifold.Complex
import Mathlib.Geometry.Manifold.ConformalGroupoid
import Mathlib.Geometry.Manifold.ContMDiff.Atlas
import Mathlib.Geometry.Manifold.ContMDiff.Basic
import Mathlib.Geometry.Manifold.ContMDiff.Constructions
import Mathlib.Geometry.Manifold.ContMDiff.Defs
import Mathlib.Geometry.Manifold.ContMDiff.NormedSpace
import Mathlib.Geometry.Manifold.ContMDiffMFDeriv
import Mathlib.Geometry.Manifold.ContMDiffMap
import Mathlib.Geometry.Manifold.DerivationBundle
import Mathlib.Geometry.Manifold.Diffeomorph
import Mathlib.Geometry.Manifold.GroupLieAlgebra
import Mathlib.Geometry.Manifold.Instances.Icc
import Mathlib.Geometry.Manifold.Instances.Real
import Mathlib.Geometry.Manifold.Instances.Sphere
import Mathlib.Geometry.Manifold.Instances.UnitsOfNormedAlgebra
import Mathlib.Geometry.Manifold.IntegralCurve.Basic
import Mathlib.Geometry.Manifold.IntegralCurve.ExistUnique
import Mathlib.Geometry.Manifold.IntegralCurve.Transform
import Mathlib.Geometry.Manifold.IntegralCurve.UniformTime
import Mathlib.Geometry.Manifold.IsManifold.Basic
import Mathlib.Geometry.Manifold.IsManifold.ExtChartAt
import Mathlib.Geometry.Manifold.IsManifold.InteriorBoundary
import Mathlib.Geometry.Manifold.LocalDiffeomorph
import Mathlib.Geometry.Manifold.LocalInvariantProperties
import Mathlib.Geometry.Manifold.MFDeriv.Atlas
import Mathlib.Geometry.Manifold.MFDeriv.Basic
import Mathlib.Geometry.Manifold.MFDeriv.Defs
import Mathlib.Geometry.Manifold.MFDeriv.FDeriv
import Mathlib.Geometry.Manifold.MFDeriv.NormedSpace
import Mathlib.Geometry.Manifold.MFDeriv.SpecificFunctions
import Mathlib.Geometry.Manifold.MFDeriv.Tangent
import Mathlib.Geometry.Manifold.MFDeriv.UniqueDifferential
import Mathlib.Geometry.Manifold.Metrizable
import Mathlib.Geometry.Manifold.PartitionOfUnity
import Mathlib.Geometry.Manifold.PoincareConjecture
import Mathlib.Geometry.Manifold.Riemannian.Basic
import Mathlib.Geometry.Manifold.Riemannian.PathELength
import Mathlib.Geometry.Manifold.Sheaf.Basic
import Mathlib.Geometry.Manifold.Sheaf.LocallyRingedSpace
import Mathlib.Geometry.Manifold.Sheaf.Smooth
import Mathlib.Geometry.Manifold.VectorBundle.Basic
import Mathlib.Geometry.Manifold.VectorBundle.FiberwiseLinear
import Mathlib.Geometry.Manifold.VectorBundle.Hom
import Mathlib.Geometry.Manifold.VectorBundle.MDifferentiable
import Mathlib.Geometry.Manifold.VectorBundle.Pullback
import Mathlib.Geometry.Manifold.VectorBundle.Riemannian
import Mathlib.Geometry.Manifold.VectorBundle.SmoothSection
import Mathlib.Geometry.Manifold.VectorBundle.Tangent
import Mathlib.Geometry.Manifold.VectorField.LieBracket
import Mathlib.Geometry.Manifold.VectorField.Pullback
import Mathlib.Geometry.Manifold.WhitneyEmbedding
import Mathlib.Geometry.RingedSpace.Basic
import Mathlib.Geometry.RingedSpace.LocallyRingedSpace
import Mathlib.Geometry.RingedSpace.LocallyRingedSpace.HasColimits
import Mathlib.Geometry.RingedSpace.LocallyRingedSpace.ResidueField
import Mathlib.Geometry.RingedSpace.OpenImmersion
import Mathlib.Geometry.RingedSpace.PresheafedSpace
import Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing
import Mathlib.Geometry.RingedSpace.PresheafedSpace.HasColimits
import Mathlib.Geometry.RingedSpace.SheafedSpace
import Mathlib.Geometry.RingedSpace.Stalks
import Mathlib.GroupTheory.Abelianization.Defs
import Mathlib.GroupTheory.Abelianization.Finite
import Mathlib.GroupTheory.Archimedean
import Mathlib.GroupTheory.ArchimedeanDensely
import Mathlib.GroupTheory.ClassEquation
import Mathlib.GroupTheory.Commensurable
import Mathlib.GroupTheory.Commutator.Basic
import Mathlib.GroupTheory.Commutator.Finite
import Mathlib.GroupTheory.CommutingProbability
import Mathlib.GroupTheory.Complement
import Mathlib.GroupTheory.Congruence.Basic
import Mathlib.GroupTheory.Congruence.BigOperators
import Mathlib.GroupTheory.Congruence.Defs
import Mathlib.GroupTheory.Congruence.Hom
import Mathlib.GroupTheory.Congruence.Opposite
import Mathlib.GroupTheory.Coprod.Basic
import Mathlib.GroupTheory.CoprodI
import Mathlib.GroupTheory.Coset.Basic
import Mathlib.GroupTheory.Coset.Card
import Mathlib.GroupTheory.Coset.Defs
import Mathlib.GroupTheory.CosetCover
import Mathlib.GroupTheory.Coxeter.Basic
import Mathlib.GroupTheory.Coxeter.Inversion
import Mathlib.GroupTheory.Coxeter.Length
import Mathlib.GroupTheory.Coxeter.Matrix
import Mathlib.GroupTheory.Divisible
import Mathlib.GroupTheory.DoubleCoset
import Mathlib.GroupTheory.EckmannHilton
import Mathlib.GroupTheory.Exponent
import Mathlib.GroupTheory.FiniteAbelian.Basic
import Mathlib.GroupTheory.FiniteAbelian.Duality
import Mathlib.GroupTheory.Finiteness
import Mathlib.GroupTheory.FixedPointFree
import Mathlib.GroupTheory.Frattini
import Mathlib.GroupTheory.FreeAbelianGroup
import Mathlib.GroupTheory.FreeGroup.Basic
import Mathlib.GroupTheory.FreeGroup.GeneratorEquiv
import Mathlib.GroupTheory.FreeGroup.IsFreeGroup
import Mathlib.GroupTheory.FreeGroup.NielsenSchreier
import Mathlib.GroupTheory.FreeGroup.Reduce
import Mathlib.GroupTheory.Goursat
import Mathlib.GroupTheory.GroupAction.Basic
import Mathlib.GroupTheory.GroupAction.Blocks
import Mathlib.GroupTheory.GroupAction.CardCommute
import Mathlib.GroupTheory.GroupAction.ConjAct
import Mathlib.GroupTheory.GroupAction.Defs
import Mathlib.GroupTheory.GroupAction.DomAct.ActionHom
import Mathlib.GroupTheory.GroupAction.DomAct.Basic
import Mathlib.GroupTheory.GroupAction.Embedding
import Mathlib.GroupTheory.GroupAction.FixedPoints
import Mathlib.GroupTheory.GroupAction.FixingSubgroup
import Mathlib.GroupTheory.GroupAction.Hom
import Mathlib.GroupTheory.GroupAction.IterateAct
import Mathlib.GroupTheory.GroupAction.Iwasawa
import Mathlib.GroupTheory.GroupAction.MultiplePrimitivity
import Mathlib.GroupTheory.GroupAction.MultipleTransitivity
import Mathlib.GroupTheory.GroupAction.Period
import Mathlib.GroupTheory.GroupAction.Pointwise
import Mathlib.GroupTheory.GroupAction.Primitive
import Mathlib.GroupTheory.GroupAction.Quotient
import Mathlib.GroupTheory.GroupAction.Ring
import Mathlib.GroupTheory.GroupAction.SubMulAction
import Mathlib.GroupTheory.GroupAction.SubMulAction.OfFixingSubgroup
import Mathlib.GroupTheory.GroupAction.SubMulAction.OfStabilizer
import Mathlib.GroupTheory.GroupAction.SubMulAction.Pointwise
import Mathlib.GroupTheory.GroupAction.Support
import Mathlib.GroupTheory.GroupAction.Transitive
import Mathlib.GroupTheory.GroupExtension.Basic
import Mathlib.GroupTheory.GroupExtension.Defs
import Mathlib.GroupTheory.HNNExtension
import Mathlib.GroupTheory.Index
import Mathlib.GroupTheory.IndexNormal
import Mathlib.GroupTheory.MonoidLocalization.Away
import Mathlib.GroupTheory.MonoidLocalization.Basic
import Mathlib.GroupTheory.MonoidLocalization.Cardinality
import Mathlib.GroupTheory.MonoidLocalization.DivPairs
import Mathlib.GroupTheory.MonoidLocalization.Finite
import Mathlib.GroupTheory.MonoidLocalization.GrothendieckGroup
import Mathlib.GroupTheory.MonoidLocalization.MonoidWithZero
import Mathlib.GroupTheory.MonoidLocalization.Order
import Mathlib.GroupTheory.Nilpotent
import Mathlib.GroupTheory.NoncommCoprod
import Mathlib.GroupTheory.NoncommPiCoprod
import Mathlib.GroupTheory.Order.Min
import Mathlib.GroupTheory.OrderOfElement
import Mathlib.GroupTheory.OreLocalization.Basic
import Mathlib.GroupTheory.OreLocalization.Cardinality
import Mathlib.GroupTheory.OreLocalization.OreSet
import Mathlib.GroupTheory.PGroup
import Mathlib.GroupTheory.Perm.Basic
import Mathlib.GroupTheory.Perm.Centralizer
import Mathlib.GroupTheory.Perm.Closure
import Mathlib.GroupTheory.Perm.ClosureSwap
import Mathlib.GroupTheory.Perm.ConjAct
import Mathlib.GroupTheory.Perm.Cycle.Basic
import Mathlib.GroupTheory.Perm.Cycle.Concrete
import Mathlib.GroupTheory.Perm.Cycle.Factors
import Mathlib.GroupTheory.Perm.Cycle.PossibleTypes
import Mathlib.GroupTheory.Perm.Cycle.Type
import Mathlib.GroupTheory.Perm.DomMulAct
import Mathlib.GroupTheory.Perm.Fin
import Mathlib.GroupTheory.Perm.Finite
import Mathlib.GroupTheory.Perm.List
import Mathlib.GroupTheory.Perm.Option
import Mathlib.GroupTheory.Perm.Sign
import Mathlib.GroupTheory.Perm.Subgroup
import Mathlib.GroupTheory.Perm.Support
import Mathlib.GroupTheory.Perm.ViaEmbedding
import Mathlib.GroupTheory.PresentedGroup
import Mathlib.GroupTheory.PushoutI
import Mathlib.GroupTheory.QuotientGroup.Basic
import Mathlib.GroupTheory.QuotientGroup.Defs
import Mathlib.GroupTheory.QuotientGroup.Finite
import Mathlib.GroupTheory.Rank
import Mathlib.GroupTheory.RegularWreathProduct
import Mathlib.GroupTheory.Schreier
import Mathlib.GroupTheory.SchurZassenhaus
import Mathlib.GroupTheory.SemidirectProduct
import Mathlib.GroupTheory.Solvable
import Mathlib.GroupTheory.SpecificGroups.Alternating
import Mathlib.GroupTheory.SpecificGroups.Alternating.Centralizer
import Mathlib.GroupTheory.SpecificGroups.Alternating.KleinFour
import Mathlib.GroupTheory.SpecificGroups.Cyclic
import Mathlib.GroupTheory.SpecificGroups.Dihedral
import Mathlib.GroupTheory.SpecificGroups.KleinFour
import Mathlib.GroupTheory.SpecificGroups.Quaternion
import Mathlib.GroupTheory.SpecificGroups.ZGroup
import Mathlib.GroupTheory.Subgroup.Center
import Mathlib.GroupTheory.Subgroup.Centralizer
import Mathlib.GroupTheory.Subgroup.Saturated
import Mathlib.GroupTheory.Subgroup.Simple
import Mathlib.GroupTheory.Submonoid.Center
import Mathlib.GroupTheory.Submonoid.Centralizer
import Mathlib.GroupTheory.Submonoid.Inverses
import Mathlib.GroupTheory.Subsemigroup.Center
import Mathlib.GroupTheory.Subsemigroup.Centralizer
import Mathlib.GroupTheory.Sylow
import Mathlib.GroupTheory.Torsion
import Mathlib.GroupTheory.Transfer
import Mathlib.InformationTheory.Hamming
import Mathlib.InformationTheory.KullbackLeibler.Basic
import Mathlib.InformationTheory.KullbackLeibler.KLFun
import Mathlib.Init
import Mathlib.Lean.CoreM
import Mathlib.Lean.Elab.Tactic.Basic
import Mathlib.Lean.Elab.Term
import Mathlib.Lean.EnvExtension
import Mathlib.Lean.Exception
import Mathlib.Lean.Expr
import Mathlib.Lean.Expr.Basic
import Mathlib.Lean.Expr.ExtraRecognizers
import Mathlib.Lean.Expr.Rat
import Mathlib.Lean.Expr.ReplaceRec
import Mathlib.Lean.GoalsLocation
import Mathlib.Lean.Json
import Mathlib.Lean.LocalContext
import Mathlib.Lean.Message
import Mathlib.Lean.Meta
import Mathlib.Lean.Meta.Basic
import Mathlib.Lean.Meta.CongrTheorems
import Mathlib.Lean.Meta.DiscrTree
import Mathlib.Lean.Meta.KAbstractPositions
import Mathlib.Lean.Meta.RefinedDiscrTree
import Mathlib.Lean.Meta.RefinedDiscrTree.Basic
import Mathlib.Lean.Meta.RefinedDiscrTree.Encode
import Mathlib.Lean.Meta.RefinedDiscrTree.Initialize
import Mathlib.Lean.Meta.RefinedDiscrTree.Lookup
import Mathlib.Lean.Meta.Simp
import Mathlib.Lean.Name
import Mathlib.Lean.PrettyPrinter.Delaborator
import Mathlib.Lean.Thunk
import Mathlib.LinearAlgebra.AffineSpace.AffineEquiv
import Mathlib.LinearAlgebra.AffineSpace.AffineMap
import Mathlib.LinearAlgebra.AffineSpace.AffineSubspace.Basic
import Mathlib.LinearAlgebra.AffineSpace.AffineSubspace.Defs
import Mathlib.LinearAlgebra.AffineSpace.Basis
import Mathlib.LinearAlgebra.AffineSpace.Combination
import Mathlib.LinearAlgebra.AffineSpace.ContinuousAffineEquiv
import Mathlib.LinearAlgebra.AffineSpace.Defs
import Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional
import Mathlib.LinearAlgebra.AffineSpace.Independent
import Mathlib.LinearAlgebra.AffineSpace.Matrix
import Mathlib.LinearAlgebra.AffineSpace.Midpoint
import Mathlib.LinearAlgebra.AffineSpace.MidpointZero
import Mathlib.LinearAlgebra.AffineSpace.Ordered
import Mathlib.LinearAlgebra.AffineSpace.Pointwise
import Mathlib.LinearAlgebra.AffineSpace.Restrict
import Mathlib.LinearAlgebra.AffineSpace.Slope
import Mathlib.LinearAlgebra.Alternating.Basic
import Mathlib.LinearAlgebra.Alternating.Curry
import Mathlib.LinearAlgebra.Alternating.DomCoprod
import Mathlib.LinearAlgebra.Alternating.Uncurry.Fin
import Mathlib.LinearAlgebra.AnnihilatingPolynomial
import Mathlib.LinearAlgebra.Basis.Basic
import Mathlib.LinearAlgebra.Basis.Bilinear
import Mathlib.LinearAlgebra.Basis.Cardinality
import Mathlib.LinearAlgebra.Basis.Defs
import Mathlib.LinearAlgebra.Basis.Exact
import Mathlib.LinearAlgebra.Basis.Fin
import Mathlib.LinearAlgebra.Basis.Flag
import Mathlib.LinearAlgebra.Basis.MulOpposite
import Mathlib.LinearAlgebra.Basis.Prod
import Mathlib.LinearAlgebra.Basis.SMul
import Mathlib.LinearAlgebra.Basis.Submodule
import Mathlib.LinearAlgebra.Basis.VectorSpace
import Mathlib.LinearAlgebra.BilinearForm.Basic
import Mathlib.LinearAlgebra.BilinearForm.DualLattice
import Mathlib.LinearAlgebra.BilinearForm.Hom
import Mathlib.LinearAlgebra.BilinearForm.Orthogonal
import Mathlib.LinearAlgebra.BilinearForm.Properties
import Mathlib.LinearAlgebra.BilinearForm.TensorProduct
import Mathlib.LinearAlgebra.BilinearMap
import Mathlib.LinearAlgebra.Charpoly.BaseChange
import Mathlib.LinearAlgebra.Charpoly.Basic
import Mathlib.LinearAlgebra.Charpoly.ToMatrix
import Mathlib.LinearAlgebra.CliffordAlgebra.BaseChange
import Mathlib.LinearAlgebra.CliffordAlgebra.Basic
import Mathlib.LinearAlgebra.CliffordAlgebra.CategoryTheory
import Mathlib.LinearAlgebra.CliffordAlgebra.Conjugation
import Mathlib.LinearAlgebra.CliffordAlgebra.Contraction
import Mathlib.LinearAlgebra.CliffordAlgebra.Equivs
import Mathlib.LinearAlgebra.CliffordAlgebra.Even
import Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv
import Mathlib.LinearAlgebra.CliffordAlgebra.Fold
import Mathlib.LinearAlgebra.CliffordAlgebra.Grading
import Mathlib.LinearAlgebra.CliffordAlgebra.Inversion
import Mathlib.LinearAlgebra.CliffordAlgebra.Prod
import Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup
import Mathlib.LinearAlgebra.CliffordAlgebra.Star
import Mathlib.LinearAlgebra.Coevaluation
import Mathlib.LinearAlgebra.Contraction
import Mathlib.LinearAlgebra.Countable
import Mathlib.LinearAlgebra.CrossProduct
import Mathlib.LinearAlgebra.DFinsupp
import Mathlib.LinearAlgebra.Determinant
import Mathlib.LinearAlgebra.Dimension.Basic
import Mathlib.LinearAlgebra.Dimension.Constructions
import Mathlib.LinearAlgebra.Dimension.DivisionRing
import Mathlib.LinearAlgebra.Dimension.ErdosKaplansky
import Mathlib.LinearAlgebra.Dimension.Finite
import Mathlib.LinearAlgebra.Dimension.Finrank
import Mathlib.LinearAlgebra.Dimension.Free
import Mathlib.LinearAlgebra.Dimension.FreeAndStrongRankCondition
import Mathlib.LinearAlgebra.Dimension.LinearMap
import Mathlib.LinearAlgebra.Dimension.Localization
import Mathlib.LinearAlgebra.Dimension.RankNullity
import Mathlib.LinearAlgebra.Dimension.StrongRankCondition
import Mathlib.LinearAlgebra.Dimension.Subsingleton
import Mathlib.LinearAlgebra.Dimension.Torsion.Basic
import Mathlib.LinearAlgebra.Dimension.Torsion.Finite
import Mathlib.LinearAlgebra.DirectSum.Basis
import Mathlib.LinearAlgebra.DirectSum.Finite
import Mathlib.LinearAlgebra.DirectSum.Finsupp
import Mathlib.LinearAlgebra.DirectSum.TensorProduct
import Mathlib.LinearAlgebra.Dual.Basis
import Mathlib.LinearAlgebra.Dual.Defs
import Mathlib.LinearAlgebra.Dual.Lemmas
import Mathlib.LinearAlgebra.Eigenspace.Basic
import Mathlib.LinearAlgebra.Eigenspace.Matrix
import Mathlib.LinearAlgebra.Eigenspace.Minpoly
import Mathlib.LinearAlgebra.Eigenspace.Pi
import Mathlib.LinearAlgebra.Eigenspace.Semisimple
import Mathlib.LinearAlgebra.Eigenspace.Triangularizable
import Mathlib.LinearAlgebra.Eigenspace.Zero
import Mathlib.LinearAlgebra.ExteriorAlgebra.Basic
import Mathlib.LinearAlgebra.ExteriorAlgebra.Grading
import Mathlib.LinearAlgebra.ExteriorAlgebra.OfAlternating
import Mathlib.LinearAlgebra.ExteriorPower.Basic
import Mathlib.LinearAlgebra.ExteriorPower.Pairing
import Mathlib.LinearAlgebra.FiniteDimensional.Basic
import Mathlib.LinearAlgebra.FiniteDimensional.Defs
import Mathlib.LinearAlgebra.FiniteDimensional.Lemmas
import Mathlib.LinearAlgebra.FiniteSpan
import Mathlib.LinearAlgebra.Finsupp.Defs
import Mathlib.LinearAlgebra.Finsupp.LSum
import Mathlib.LinearAlgebra.Finsupp.LinearCombination
import Mathlib.LinearAlgebra.Finsupp.Pi
import Mathlib.LinearAlgebra.Finsupp.Span
import Mathlib.LinearAlgebra.Finsupp.SumProd
import Mathlib.LinearAlgebra.Finsupp.Supported
import Mathlib.LinearAlgebra.Finsupp.VectorSpace
import Mathlib.LinearAlgebra.FreeAlgebra
import Mathlib.LinearAlgebra.FreeModule.Basic
import Mathlib.LinearAlgebra.FreeModule.Determinant
import Mathlib.LinearAlgebra.FreeModule.Finite.Basic
import Mathlib.LinearAlgebra.FreeModule.Finite.CardQuotient
import Mathlib.LinearAlgebra.FreeModule.Finite.Matrix
import Mathlib.LinearAlgebra.FreeModule.Finite.Quotient
import Mathlib.LinearAlgebra.FreeModule.IdealQuotient
import Mathlib.LinearAlgebra.FreeModule.Int
import Mathlib.LinearAlgebra.FreeModule.ModN
import Mathlib.LinearAlgebra.FreeModule.Norm
import Mathlib.LinearAlgebra.FreeModule.PID
import Mathlib.LinearAlgebra.FreeModule.StrongRankCondition
import Mathlib.LinearAlgebra.FreeProduct.Basic
import Mathlib.LinearAlgebra.GeneralLinearGroup
import Mathlib.LinearAlgebra.Goursat
import Mathlib.LinearAlgebra.InvariantBasisNumber
import Mathlib.LinearAlgebra.Isomorphisms
import Mathlib.LinearAlgebra.JordanChevalley
import Mathlib.LinearAlgebra.Lagrange
import Mathlib.LinearAlgebra.LinearDisjoint
import Mathlib.LinearAlgebra.LinearIndependent.Basic
import Mathlib.LinearAlgebra.LinearIndependent.Defs
import Mathlib.LinearAlgebra.LinearIndependent.Lemmas
import Mathlib.LinearAlgebra.LinearPMap
import Mathlib.LinearAlgebra.Matrix.AbsoluteValue
import Mathlib.LinearAlgebra.Matrix.Adjugate
import Mathlib.LinearAlgebra.Matrix.BaseChange
import Mathlib.LinearAlgebra.Matrix.Basis
import Mathlib.LinearAlgebra.Matrix.BilinearForm
import Mathlib.LinearAlgebra.Matrix.Block
import Mathlib.LinearAlgebra.Matrix.Charpoly.Basic
import Mathlib.LinearAlgebra.Matrix.Charpoly.Coeff
import Mathlib.LinearAlgebra.Matrix.Charpoly.Eigs
import Mathlib.LinearAlgebra.Matrix.Charpoly.FiniteField
import Mathlib.LinearAlgebra.Matrix.Charpoly.LinearMap
import Mathlib.LinearAlgebra.Matrix.Charpoly.Minpoly
import Mathlib.LinearAlgebra.Matrix.Charpoly.Univ
import Mathlib.LinearAlgebra.Matrix.Circulant
import Mathlib.LinearAlgebra.Matrix.Determinant.Basic
import Mathlib.LinearAlgebra.Matrix.Determinant.Misc
import Mathlib.LinearAlgebra.Matrix.Determinant.TotallyUnimodular
import Mathlib.LinearAlgebra.Matrix.Diagonal
import Mathlib.LinearAlgebra.Matrix.DotProduct
import Mathlib.LinearAlgebra.Matrix.Dual
import Mathlib.LinearAlgebra.Matrix.FiniteDimensional
import Mathlib.LinearAlgebra.Matrix.FixedDetMatrices
import Mathlib.LinearAlgebra.Matrix.GeneralLinearGroup.Basic
import Mathlib.LinearAlgebra.Matrix.GeneralLinearGroup.Card
import Mathlib.LinearAlgebra.Matrix.GeneralLinearGroup.Defs
import Mathlib.LinearAlgebra.Matrix.Gershgorin
import Mathlib.LinearAlgebra.Matrix.Hermitian
import Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus
import Mathlib.LinearAlgebra.Matrix.Ideal
import Mathlib.LinearAlgebra.Matrix.Integer
import Mathlib.LinearAlgebra.Matrix.InvariantBasisNumber
import Mathlib.LinearAlgebra.Matrix.IsDiag
import Mathlib.LinearAlgebra.Matrix.LDL
import Mathlib.LinearAlgebra.Matrix.MvPolynomial
import Mathlib.LinearAlgebra.Matrix.Nondegenerate
import Mathlib.LinearAlgebra.Matrix.NonsingularInverse
import Mathlib.LinearAlgebra.Matrix.Orthogonal
import Mathlib.LinearAlgebra.Matrix.Permanent
import Mathlib.LinearAlgebra.Matrix.Permutation
import Mathlib.LinearAlgebra.Matrix.Polynomial
import Mathlib.LinearAlgebra.Matrix.PosDef
import Mathlib.LinearAlgebra.Matrix.ProjectiveSpecialLinearGroup
import Mathlib.LinearAlgebra.Matrix.Reindex
import Mathlib.LinearAlgebra.Matrix.SchurComplement
import Mathlib.LinearAlgebra.Matrix.SemiringInverse
import Mathlib.LinearAlgebra.Matrix.SesquilinearForm
import Mathlib.LinearAlgebra.Matrix.SpecialLinearGroup
import Mathlib.LinearAlgebra.Matrix.Spectrum
import Mathlib.LinearAlgebra.Matrix.StdBasis
import Mathlib.LinearAlgebra.Matrix.Swap
import Mathlib.LinearAlgebra.Matrix.Symmetric
import Mathlib.LinearAlgebra.Matrix.ToLin
import Mathlib.LinearAlgebra.Matrix.ToLinearEquiv
import Mathlib.LinearAlgebra.Matrix.Trace
import Mathlib.LinearAlgebra.Matrix.Transvection
import Mathlib.LinearAlgebra.Matrix.Unique
import Mathlib.LinearAlgebra.Matrix.ZPow
import Mathlib.LinearAlgebra.Multilinear.Basic
import Mathlib.LinearAlgebra.Multilinear.Basis
import Mathlib.LinearAlgebra.Multilinear.Curry
import Mathlib.LinearAlgebra.Multilinear.DFinsupp
import Mathlib.LinearAlgebra.Multilinear.FiniteDimensional
import Mathlib.LinearAlgebra.Multilinear.Pi
import Mathlib.LinearAlgebra.Multilinear.TensorProduct
import Mathlib.LinearAlgebra.Orientation
import Mathlib.LinearAlgebra.PID
import Mathlib.LinearAlgebra.PerfectPairing.Basic
import Mathlib.LinearAlgebra.PerfectPairing.Matrix
import Mathlib.LinearAlgebra.PerfectPairing.Restrict
import Mathlib.LinearAlgebra.Pi
import Mathlib.LinearAlgebra.PiTensorProduct
import Mathlib.LinearAlgebra.Prod
import Mathlib.LinearAlgebra.Projection
import Mathlib.LinearAlgebra.Projectivization.Basic
import Mathlib.LinearAlgebra.Projectivization.Cardinality
import Mathlib.LinearAlgebra.Projectivization.Constructions
import Mathlib.LinearAlgebra.Projectivization.Independence
import Mathlib.LinearAlgebra.Projectivization.Subspace
import Mathlib.LinearAlgebra.QuadraticForm.Basic
import Mathlib.LinearAlgebra.QuadraticForm.Basis
import Mathlib.LinearAlgebra.QuadraticForm.Complex
import Mathlib.LinearAlgebra.QuadraticForm.Dual
import Mathlib.LinearAlgebra.QuadraticForm.Isometry
import Mathlib.LinearAlgebra.QuadraticForm.IsometryEquiv
import Mathlib.LinearAlgebra.QuadraticForm.Prod
import Mathlib.LinearAlgebra.QuadraticForm.QuadraticModuleCat
import Mathlib.LinearAlgebra.QuadraticForm.QuadraticModuleCat.Monoidal
import Mathlib.LinearAlgebra.QuadraticForm.QuadraticModuleCat.Symmetric
import Mathlib.LinearAlgebra.QuadraticForm.Real
import Mathlib.LinearAlgebra.QuadraticForm.TensorProduct
import Mathlib.LinearAlgebra.QuadraticForm.TensorProduct.Isometries
import Mathlib.LinearAlgebra.Quotient.Basic
import Mathlib.LinearAlgebra.Quotient.Defs
import Mathlib.LinearAlgebra.Quotient.Pi
import Mathlib.LinearAlgebra.Ray
import Mathlib.LinearAlgebra.Reflection
import Mathlib.LinearAlgebra.RootSystem.Base
import Mathlib.LinearAlgebra.RootSystem.BaseChange
import Mathlib.LinearAlgebra.RootSystem.Basic
import Mathlib.LinearAlgebra.RootSystem.CartanMatrix
import Mathlib.LinearAlgebra.RootSystem.Chain
import Mathlib.LinearAlgebra.RootSystem.Defs
import Mathlib.LinearAlgebra.RootSystem.Finite.CanonicalBilinear
import Mathlib.LinearAlgebra.RootSystem.Finite.G2
import Mathlib.LinearAlgebra.RootSystem.Finite.Lemmas
import Mathlib.LinearAlgebra.RootSystem.Finite.Nondegenerate
import Mathlib.LinearAlgebra.RootSystem.GeckConstruction.Basic
import Mathlib.LinearAlgebra.RootSystem.GeckConstruction.Lemmas
import Mathlib.LinearAlgebra.RootSystem.Hom
import Mathlib.LinearAlgebra.RootSystem.Irreducible
import Mathlib.LinearAlgebra.RootSystem.IsValuedIn
import Mathlib.LinearAlgebra.RootSystem.OfBilinear
import Mathlib.LinearAlgebra.RootSystem.Reduced
import Mathlib.LinearAlgebra.RootSystem.RootPairingCat
import Mathlib.LinearAlgebra.RootSystem.RootPositive
import Mathlib.LinearAlgebra.RootSystem.WeylGroup
import Mathlib.LinearAlgebra.SModEq
import Mathlib.LinearAlgebra.Semisimple
import Mathlib.LinearAlgebra.SesquilinearForm
import Mathlib.LinearAlgebra.Span.Basic
import Mathlib.LinearAlgebra.Span.Defs
import Mathlib.LinearAlgebra.StdBasis
import Mathlib.LinearAlgebra.SymmetricAlgebra.Basic
import Mathlib.LinearAlgebra.SymmetricAlgebra.Basis
import Mathlib.LinearAlgebra.SymplecticGroup
import Mathlib.LinearAlgebra.TensorAlgebra.Basic
import Mathlib.LinearAlgebra.TensorAlgebra.Basis
import Mathlib.LinearAlgebra.TensorAlgebra.Grading
import Mathlib.LinearAlgebra.TensorAlgebra.ToTensorPower
import Mathlib.LinearAlgebra.TensorPower.Basic
import Mathlib.LinearAlgebra.TensorPower.Pairing
import Mathlib.LinearAlgebra.TensorProduct.Associator
import Mathlib.LinearAlgebra.TensorProduct.Basic
import Mathlib.LinearAlgebra.TensorProduct.Basis
import Mathlib.LinearAlgebra.TensorProduct.DirectLimit
import Mathlib.LinearAlgebra.TensorProduct.Finiteness
import Mathlib.LinearAlgebra.TensorProduct.Graded.External
import Mathlib.LinearAlgebra.TensorProduct.Graded.Internal
import Mathlib.LinearAlgebra.TensorProduct.Matrix
import Mathlib.LinearAlgebra.TensorProduct.Opposite
import Mathlib.LinearAlgebra.TensorProduct.Pi
import Mathlib.LinearAlgebra.TensorProduct.Prod
import Mathlib.LinearAlgebra.TensorProduct.Quotient
import Mathlib.LinearAlgebra.TensorProduct.RightExactness
import Mathlib.LinearAlgebra.TensorProduct.Subalgebra
import Mathlib.LinearAlgebra.TensorProduct.Submodule
import Mathlib.LinearAlgebra.TensorProduct.Tower
import Mathlib.LinearAlgebra.TensorProduct.Vanishing
import Mathlib.LinearAlgebra.Trace
import Mathlib.LinearAlgebra.UnitaryGroup
import Mathlib.LinearAlgebra.Vandermonde
import Mathlib.Logic.Basic
import Mathlib.Logic.Denumerable
import Mathlib.Logic.Embedding.Basic
import Mathlib.Logic.Embedding.Set
import Mathlib.Logic.Encodable.Basic
import Mathlib.Logic.Encodable.Lattice
import Mathlib.Logic.Encodable.Pi
import Mathlib.Logic.Equiv.Array
import Mathlib.Logic.Equiv.Basic
import Mathlib.Logic.Equiv.Defs
import Mathlib.Logic.Equiv.Embedding
import Mathlib.Logic.Equiv.Fin.Basic
import Mathlib.Logic.Equiv.Fin.Rotate
import Mathlib.Logic.Equiv.Finset
import Mathlib.Logic.Equiv.Fintype
import Mathlib.Logic.Equiv.Functor
import Mathlib.Logic.Equiv.List
import Mathlib.Logic.Equiv.Multiset
import Mathlib.Logic.Equiv.Nat
import Mathlib.Logic.Equiv.Option
import Mathlib.Logic.Equiv.Pairwise
import Mathlib.Logic.Equiv.PartialEquiv
import Mathlib.Logic.Equiv.Prod
import Mathlib.Logic.Equiv.Set
import Mathlib.Logic.Equiv.Sum
import Mathlib.Logic.ExistsUnique
import Mathlib.Logic.Function.Basic
import Mathlib.Logic.Function.Coequalizer
import Mathlib.Logic.Function.CompTypeclasses
import Mathlib.Logic.Function.Conjugate
import Mathlib.Logic.Function.Defs
import Mathlib.Logic.Function.DependsOn
import Mathlib.Logic.Function.FiberPartition
import Mathlib.Logic.Function.FromTypes
import Mathlib.Logic.Function.Iterate
import Mathlib.Logic.Function.OfArity
import Mathlib.Logic.Function.ULift
import Mathlib.Logic.Godel.GodelBetaFunction
import Mathlib.Logic.Hydra
import Mathlib.Logic.IsEmpty
import Mathlib.Logic.Lemmas
import Mathlib.Logic.Nonempty
import Mathlib.Logic.Nontrivial.Basic
import Mathlib.Logic.Nontrivial.Defs
import Mathlib.Logic.OpClass
import Mathlib.Logic.Pairwise
import Mathlib.Logic.Relation
import Mathlib.Logic.Relator
import Mathlib.Logic.Small.Basic
import Mathlib.Logic.Small.Defs
import Mathlib.Logic.Small.List
import Mathlib.Logic.Small.Set
import Mathlib.Logic.Unique
import Mathlib.Logic.UnivLE
import Mathlib.MeasureTheory.Category.MeasCat
import Mathlib.MeasureTheory.Constructions.AddChar
import Mathlib.MeasureTheory.Constructions.BorelSpace.Basic
import Mathlib.MeasureTheory.Constructions.BorelSpace.Complex
import Mathlib.MeasureTheory.Constructions.BorelSpace.ContinuousLinearMap
import Mathlib.MeasureTheory.Constructions.BorelSpace.Metric
import Mathlib.MeasureTheory.Constructions.BorelSpace.Metrizable
import Mathlib.MeasureTheory.Constructions.BorelSpace.Order
import Mathlib.MeasureTheory.Constructions.BorelSpace.Real
import Mathlib.MeasureTheory.Constructions.ClosedCompactCylinders
import Mathlib.MeasureTheory.Constructions.Cylinders
import Mathlib.MeasureTheory.Constructions.HaarToSphere
import Mathlib.MeasureTheory.Constructions.Pi
import Mathlib.MeasureTheory.Constructions.Polish.Basic
import Mathlib.MeasureTheory.Constructions.Polish.EmbeddingReal
import Mathlib.MeasureTheory.Constructions.Polish.StronglyMeasurable
import Mathlib.MeasureTheory.Constructions.Projective
import Mathlib.MeasureTheory.Constructions.ProjectiveFamilyContent
import Mathlib.MeasureTheory.Constructions.SubmoduleQuotient
import Mathlib.MeasureTheory.Constructions.UnitInterval
import Mathlib.MeasureTheory.Covering.Besicovitch
import Mathlib.MeasureTheory.Covering.BesicovitchVectorSpace
import Mathlib.MeasureTheory.Covering.DensityTheorem
import Mathlib.MeasureTheory.Covering.Differentiation
import Mathlib.MeasureTheory.Covering.LiminfLimsup
import Mathlib.MeasureTheory.Covering.OneDim
import Mathlib.MeasureTheory.Covering.Vitali
import Mathlib.MeasureTheory.Covering.VitaliFamily
import Mathlib.MeasureTheory.Function.AEEqFun
import Mathlib.MeasureTheory.Function.AEEqFun.DomAct
import Mathlib.MeasureTheory.Function.AEEqOfIntegral
import Mathlib.MeasureTheory.Function.AEEqOfLIntegral
import Mathlib.MeasureTheory.Function.AEMeasurableOrder
import Mathlib.MeasureTheory.Function.AEMeasurableSequence
import Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable
import Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic
import Mathlib.MeasureTheory.Function.ConditionalExpectation.CondexpL1
import Mathlib.MeasureTheory.Function.ConditionalExpectation.CondexpL2
import Mathlib.MeasureTheory.Function.ConditionalExpectation.Indicator
import Mathlib.MeasureTheory.Function.ConditionalExpectation.Real
import Mathlib.MeasureTheory.Function.ConditionalExpectation.Unique
import Mathlib.MeasureTheory.Function.ContinuousMapDense
import Mathlib.MeasureTheory.Function.ConvergenceInMeasure
import Mathlib.MeasureTheory.Function.Egorov
import Mathlib.MeasureTheory.Function.EssSup
import Mathlib.MeasureTheory.Function.FactorsThrough
import Mathlib.MeasureTheory.Function.Floor
import Mathlib.MeasureTheory.Function.Holder
import Mathlib.MeasureTheory.Function.Intersectivity
import Mathlib.MeasureTheory.Function.Jacobian
import Mathlib.MeasureTheory.Function.JacobianOneDim
import Mathlib.MeasureTheory.Function.L1Space.AEEqFun
import Mathlib.MeasureTheory.Function.L1Space.HasFiniteIntegral
import Mathlib.MeasureTheory.Function.L1Space.Integrable
import Mathlib.MeasureTheory.Function.L2Space
import Mathlib.MeasureTheory.Function.LocallyIntegrable
import Mathlib.MeasureTheory.Function.LpOrder
import Mathlib.MeasureTheory.Function.LpSeminorm.Basic
import Mathlib.MeasureTheory.Function.LpSeminorm.ChebyshevMarkov
import Mathlib.MeasureTheory.Function.LpSeminorm.CompareExp
import Mathlib.MeasureTheory.Function.LpSeminorm.Defs
import Mathlib.MeasureTheory.Function.LpSeminorm.Prod
import Mathlib.MeasureTheory.Function.LpSeminorm.TriangleInequality
import Mathlib.MeasureTheory.Function.LpSeminorm.Trim
import Mathlib.MeasureTheory.Function.LpSpace.Basic
import Mathlib.MeasureTheory.Function.LpSpace.Complete
import Mathlib.MeasureTheory.Function.LpSpace.ContinuousCompMeasurePreserving
import Mathlib.MeasureTheory.Function.LpSpace.ContinuousFunctions
import Mathlib.MeasureTheory.Function.LpSpace.DomAct.Basic
import Mathlib.MeasureTheory.Function.LpSpace.DomAct.Continuous
import Mathlib.MeasureTheory.Function.LpSpace.Indicator
import Mathlib.MeasureTheory.Function.SimpleFunc
import Mathlib.MeasureTheory.Function.SimpleFuncDense
import Mathlib.MeasureTheory.Function.SimpleFuncDenseLp
import Mathlib.MeasureTheory.Function.SpecialFunctions.Arctan
import Mathlib.MeasureTheory.Function.SpecialFunctions.Basic
import Mathlib.MeasureTheory.Function.SpecialFunctions.Inner
import Mathlib.MeasureTheory.Function.SpecialFunctions.RCLike
import Mathlib.MeasureTheory.Function.SpecialFunctions.Sinc
import Mathlib.MeasureTheory.Function.StronglyMeasurable.AEStronglyMeasurable
import Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic
import Mathlib.MeasureTheory.Function.StronglyMeasurable.ENNReal
import Mathlib.MeasureTheory.Function.StronglyMeasurable.Inner
import Mathlib.MeasureTheory.Function.StronglyMeasurable.Lemmas
import Mathlib.MeasureTheory.Function.StronglyMeasurable.Lp
import Mathlib.MeasureTheory.Function.UnifTight
import Mathlib.MeasureTheory.Function.UniformIntegrable
import Mathlib.MeasureTheory.Group.AEStabilizer
import Mathlib.MeasureTheory.Group.Action
import Mathlib.MeasureTheory.Group.AddCircle
import Mathlib.MeasureTheory.Group.Arithmetic
import Mathlib.MeasureTheory.Group.Convolution
import Mathlib.MeasureTheory.Group.Defs
import Mathlib.MeasureTheory.Group.FundamentalDomain
import Mathlib.MeasureTheory.Group.GeometryOfNumbers
import Mathlib.MeasureTheory.Group.Integral
import Mathlib.MeasureTheory.Group.IntegralConvolution
import Mathlib.MeasureTheory.Group.LIntegral
import Mathlib.MeasureTheory.Group.MeasurableEquiv
import Mathlib.MeasureTheory.Group.Measure
import Mathlib.MeasureTheory.Group.ModularCharacter
import Mathlib.MeasureTheory.Group.Pointwise
import Mathlib.MeasureTheory.Group.Prod
import Mathlib.MeasureTheory.Integral.Asymptotics
import Mathlib.MeasureTheory.Integral.Average
import Mathlib.MeasureTheory.Integral.Bochner
import Mathlib.MeasureTheory.Integral.Bochner.Basic
import Mathlib.MeasureTheory.Integral.Bochner.ContinuousLinearMap
import Mathlib.MeasureTheory.Integral.Bochner.FundThmCalculus
import Mathlib.MeasureTheory.Integral.Bochner.L1
import Mathlib.MeasureTheory.Integral.Bochner.Set
import Mathlib.MeasureTheory.Integral.Bochner.VitaliCaratheodory
import Mathlib.MeasureTheory.Integral.BochnerL1
import Mathlib.MeasureTheory.Integral.BoundedContinuousFunction
import Mathlib.MeasureTheory.Integral.CircleAverage
import Mathlib.MeasureTheory.Integral.CircleIntegral
import Mathlib.MeasureTheory.Integral.CircleTransform
import Mathlib.MeasureTheory.Integral.DivergenceTheorem
import Mathlib.MeasureTheory.Integral.DominatedConvergence
import Mathlib.MeasureTheory.Integral.ExpDecay
import Mathlib.MeasureTheory.Integral.FinMeasAdditive
import Mathlib.MeasureTheory.Integral.FundThmCalculus
import Mathlib.MeasureTheory.Integral.Gamma
import Mathlib.MeasureTheory.Integral.Indicator
import Mathlib.MeasureTheory.Integral.IntegrableOn
import Mathlib.MeasureTheory.Integral.IntegralEqImproper
import Mathlib.MeasureTheory.Integral.IntegrationByParts
import Mathlib.MeasureTheory.Integral.IntervalAverage
import Mathlib.MeasureTheory.Integral.IntervalIntegral
import Mathlib.MeasureTheory.Integral.IntervalIntegral.Basic
import Mathlib.MeasureTheory.Integral.IntervalIntegral.ContDiff
import Mathlib.MeasureTheory.Integral.IntervalIntegral.FundThmCalculus
import Mathlib.MeasureTheory.Integral.IntervalIntegral.IntegrationByParts
import Mathlib.MeasureTheory.Integral.IntervalIntegral.Periodic
import Mathlib.MeasureTheory.Integral.Layercake
import Mathlib.MeasureTheory.Integral.Lebesgue
import Mathlib.MeasureTheory.Integral.Lebesgue.Add
import Mathlib.MeasureTheory.Integral.Lebesgue.Basic
import Mathlib.MeasureTheory.Integral.Lebesgue.Countable
import Mathlib.MeasureTheory.Integral.Lebesgue.DominatedConvergence
import Mathlib.MeasureTheory.Integral.Lebesgue.Map
import Mathlib.MeasureTheory.Integral.Lebesgue.Markov
import Mathlib.MeasureTheory.Integral.Lebesgue.MeasurePreserving
import Mathlib.MeasureTheory.Integral.Lebesgue.Norm
import Mathlib.MeasureTheory.Integral.Lebesgue.Sub
import Mathlib.MeasureTheory.Integral.LebesgueNormedSpace
import Mathlib.MeasureTheory.Integral.Marginal
import Mathlib.MeasureTheory.Integral.MeanInequalities
import Mathlib.MeasureTheory.Integral.PeakFunction
import Mathlib.MeasureTheory.Integral.Periodic
import Mathlib.MeasureTheory.Integral.Pi
import Mathlib.MeasureTheory.Integral.Prod
import Mathlib.MeasureTheory.Integral.RieszMarkovKakutani.Basic
import Mathlib.MeasureTheory.Integral.RieszMarkovKakutani.NNReal
import Mathlib.MeasureTheory.Integral.RieszMarkovKakutani.Real
import Mathlib.MeasureTheory.Integral.SetIntegral
import Mathlib.MeasureTheory.Integral.SetToL1
import Mathlib.MeasureTheory.Integral.TorusIntegral
import Mathlib.MeasureTheory.Integral.VitaliCaratheodory
import Mathlib.MeasureTheory.MeasurableSpace.Basic
import Mathlib.MeasureTheory.MeasurableSpace.Card
import Mathlib.MeasureTheory.MeasurableSpace.Constructions
import Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated
import Mathlib.MeasureTheory.MeasurableSpace.Defs
import Mathlib.MeasureTheory.MeasurableSpace.Embedding
import Mathlib.MeasureTheory.MeasurableSpace.EventuallyMeasurable
import Mathlib.MeasureTheory.MeasurableSpace.Instances
import Mathlib.MeasureTheory.MeasurableSpace.Invariants
import Mathlib.MeasureTheory.MeasurableSpace.MeasurablyGenerated
import Mathlib.MeasureTheory.MeasurableSpace.NCard
import Mathlib.MeasureTheory.MeasurableSpace.Pi
import Mathlib.MeasureTheory.MeasurableSpace.PreorderRestrict
import Mathlib.MeasureTheory.MeasurableSpace.Prod
import Mathlib.MeasureTheory.Measure.AEDisjoint
import Mathlib.MeasureTheory.Measure.AEMeasurable
import Mathlib.MeasureTheory.Measure.AbsolutelyContinuous
import Mathlib.MeasureTheory.Measure.AddContent
import Mathlib.MeasureTheory.Measure.CharacteristicFunction
import Mathlib.MeasureTheory.Measure.Comap
import Mathlib.MeasureTheory.Measure.Complex
import Mathlib.MeasureTheory.Measure.Content
import Mathlib.MeasureTheory.Measure.ContinuousPreimage
import Mathlib.MeasureTheory.Measure.Count
import Mathlib.MeasureTheory.Measure.Decomposition.Exhaustion
import Mathlib.MeasureTheory.Measure.Decomposition.Hahn
import Mathlib.MeasureTheory.Measure.Decomposition.IntegralRNDeriv
import Mathlib.MeasureTheory.Measure.Decomposition.Lebesgue
import Mathlib.MeasureTheory.Measure.Decomposition.RadonNikodym
import Mathlib.MeasureTheory.Measure.Dirac
import Mathlib.MeasureTheory.Measure.DiracProba
import Mathlib.MeasureTheory.Measure.Doubling
import Mathlib.MeasureTheory.Measure.EverywherePos
import Mathlib.MeasureTheory.Measure.FiniteMeasure
import Mathlib.MeasureTheory.Measure.FiniteMeasureExt
import Mathlib.MeasureTheory.Measure.FiniteMeasureProd
import Mathlib.MeasureTheory.Measure.GiryMonad
import Mathlib.MeasureTheory.Measure.Haar.Basic
import Mathlib.MeasureTheory.Measure.Haar.Disintegration
import Mathlib.MeasureTheory.Measure.Haar.DistribChar
import Mathlib.MeasureTheory.Measure.Haar.InnerProductSpace
import Mathlib.MeasureTheory.Measure.Haar.MulEquivHaarChar
import Mathlib.MeasureTheory.Measure.Haar.NormedSpace
import Mathlib.MeasureTheory.Measure.Haar.OfBasis
import Mathlib.MeasureTheory.Measure.Haar.Quotient
import Mathlib.MeasureTheory.Measure.Haar.Unique
import Mathlib.MeasureTheory.Measure.HasOuterApproxClosed
import Mathlib.MeasureTheory.Measure.Hausdorff
import Mathlib.MeasureTheory.Measure.IntegralCharFun
import Mathlib.MeasureTheory.Measure.Lebesgue.Basic
import Mathlib.MeasureTheory.Measure.Lebesgue.Complex
import Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar
import Mathlib.MeasureTheory.Measure.Lebesgue.Integral
import Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls
import Mathlib.MeasureTheory.Measure.LevyProkhorovMetric
import Mathlib.MeasureTheory.Measure.LogLikelihoodRatio
import Mathlib.MeasureTheory.Measure.Map
import Mathlib.MeasureTheory.Measure.MeasureSpace
import Mathlib.MeasureTheory.Measure.MeasureSpaceDef
import Mathlib.MeasureTheory.Measure.MutuallySingular
import Mathlib.MeasureTheory.Measure.NullMeasurable
import Mathlib.MeasureTheory.Measure.OpenPos
import Mathlib.MeasureTheory.Measure.Portmanteau
import Mathlib.MeasureTheory.Measure.ProbabilityMeasure
import Mathlib.MeasureTheory.Measure.Prod
import Mathlib.MeasureTheory.Measure.QuasiMeasurePreserving
import Mathlib.MeasureTheory.Measure.Real
import Mathlib.MeasureTheory.Measure.Regular
import Mathlib.MeasureTheory.Measure.RegularityCompacts
import Mathlib.MeasureTheory.Measure.Restrict
import Mathlib.MeasureTheory.Measure.SeparableMeasure
import Mathlib.MeasureTheory.Measure.Stieltjes
import Mathlib.MeasureTheory.Measure.Sub
import Mathlib.MeasureTheory.Measure.Tight
import Mathlib.MeasureTheory.Measure.TightNormed
import Mathlib.MeasureTheory.Measure.Tilted
import Mathlib.MeasureTheory.Measure.Trim
import Mathlib.MeasureTheory.Measure.Typeclasses
import Mathlib.MeasureTheory.Measure.Typeclasses.Finite
import Mathlib.MeasureTheory.Measure.Typeclasses.NoAtoms
import Mathlib.MeasureTheory.Measure.Typeclasses.Probability
import Mathlib.MeasureTheory.Measure.Typeclasses.SFinite
import Mathlib.MeasureTheory.Measure.WithDensity
import Mathlib.MeasureTheory.Measure.WithDensityFinite
import Mathlib.MeasureTheory.Order.Group.Lattice
import Mathlib.MeasureTheory.Order.Lattice
import Mathlib.MeasureTheory.Order.UpperLower
import Mathlib.MeasureTheory.OuterMeasure.AE
import Mathlib.MeasureTheory.OuterMeasure.Basic
import Mathlib.MeasureTheory.OuterMeasure.BorelCantelli
import Mathlib.MeasureTheory.OuterMeasure.Caratheodory
import Mathlib.MeasureTheory.OuterMeasure.Defs
import Mathlib.MeasureTheory.OuterMeasure.Induced
import Mathlib.MeasureTheory.OuterMeasure.OfAddContent
import Mathlib.MeasureTheory.OuterMeasure.OfFunction
import Mathlib.MeasureTheory.OuterMeasure.Operations
import Mathlib.MeasureTheory.PiSystem
import Mathlib.MeasureTheory.SetAlgebra
import Mathlib.MeasureTheory.SetSemiring
import Mathlib.MeasureTheory.SpecificCodomains.ContinuousMap
import Mathlib.MeasureTheory.SpecificCodomains.ContinuousMapZero
import Mathlib.MeasureTheory.Topology
import Mathlib.MeasureTheory.VectorMeasure.Basic
import Mathlib.MeasureTheory.VectorMeasure.Decomposition.Hahn
import Mathlib.MeasureTheory.VectorMeasure.Decomposition.Jordan
import Mathlib.MeasureTheory.VectorMeasure.Decomposition.JordanSub
import Mathlib.MeasureTheory.VectorMeasure.Decomposition.Lebesgue
import Mathlib.MeasureTheory.VectorMeasure.Decomposition.RadonNikodym
import Mathlib.MeasureTheory.VectorMeasure.WithDensity
import Mathlib.ModelTheory.Algebra.Field.Basic
import Mathlib.ModelTheory.Algebra.Field.CharP
import Mathlib.ModelTheory.Algebra.Field.IsAlgClosed
import Mathlib.ModelTheory.Algebra.Ring.Basic
import Mathlib.ModelTheory.Algebra.Ring.Definability
import Mathlib.ModelTheory.Algebra.Ring.FreeCommRing
import Mathlib.ModelTheory.Arithmetic.Presburger.Basic
import Mathlib.ModelTheory.Basic
import Mathlib.ModelTheory.Bundled
import Mathlib.ModelTheory.Complexity
import Mathlib.ModelTheory.Definability
import Mathlib.ModelTheory.DirectLimit
import Mathlib.ModelTheory.ElementaryMaps
import Mathlib.ModelTheory.ElementarySubstructures
import Mathlib.ModelTheory.Encoding
import Mathlib.ModelTheory.Equivalence
import Mathlib.ModelTheory.FinitelyGenerated
import Mathlib.ModelTheory.Fraisse
import Mathlib.ModelTheory.Graph
import Mathlib.ModelTheory.LanguageMap
import Mathlib.ModelTheory.Order
import Mathlib.ModelTheory.PartialEquiv
import Mathlib.ModelTheory.Quotients
import Mathlib.ModelTheory.Satisfiability
import Mathlib.ModelTheory.Semantics
import Mathlib.ModelTheory.Skolem
import Mathlib.ModelTheory.Substructures
import Mathlib.ModelTheory.Syntax
import Mathlib.ModelTheory.Types
import Mathlib.ModelTheory.Ultraproducts
import Mathlib.NumberTheory.ADEInequality
import Mathlib.NumberTheory.AbelSummation
import Mathlib.NumberTheory.ArithmeticFunction
import Mathlib.NumberTheory.Basic
import Mathlib.NumberTheory.Bernoulli
import Mathlib.NumberTheory.BernoulliPolynomials
import Mathlib.NumberTheory.Bertrand
import Mathlib.NumberTheory.ClassNumber.AdmissibleAbs
import Mathlib.NumberTheory.ClassNumber.AdmissibleAbsoluteValue
import Mathlib.NumberTheory.ClassNumber.AdmissibleCardPowDegree
import Mathlib.NumberTheory.ClassNumber.Finite
import Mathlib.NumberTheory.ClassNumber.FunctionField
import Mathlib.NumberTheory.Cyclotomic.Basic
import Mathlib.NumberTheory.Cyclotomic.CyclotomicCharacter
import Mathlib.NumberTheory.Cyclotomic.Discriminant
import Mathlib.NumberTheory.Cyclotomic.Embeddings
import Mathlib.NumberTheory.Cyclotomic.Gal
import Mathlib.NumberTheory.Cyclotomic.PID
import Mathlib.NumberTheory.Cyclotomic.PrimitiveRoots
import Mathlib.NumberTheory.Cyclotomic.Rat
import Mathlib.NumberTheory.Cyclotomic.Three
import Mathlib.NumberTheory.Dioph
import Mathlib.NumberTheory.DiophantineApproximation.Basic
import Mathlib.NumberTheory.DiophantineApproximation.ContinuedFractions
import Mathlib.NumberTheory.DirichletCharacter.Basic
import Mathlib.NumberTheory.DirichletCharacter.Bounds
import Mathlib.NumberTheory.DirichletCharacter.GaussSum
import Mathlib.NumberTheory.DirichletCharacter.Orthogonality
import Mathlib.NumberTheory.Divisors
import Mathlib.NumberTheory.EllipticDivisibilitySequence
import Mathlib.NumberTheory.EulerProduct.Basic
import Mathlib.NumberTheory.EulerProduct.DirichletLSeries
import Mathlib.NumberTheory.EulerProduct.ExpLog
import Mathlib.NumberTheory.FLT.Basic
import Mathlib.NumberTheory.FLT.Four
import Mathlib.NumberTheory.FLT.MasonStothers
import Mathlib.NumberTheory.FLT.Polynomial
import Mathlib.NumberTheory.FLT.Three
import Mathlib.NumberTheory.FactorisationProperties
import Mathlib.NumberTheory.Fermat
import Mathlib.NumberTheory.FermatPsp
import Mathlib.NumberTheory.FrobeniusNumber
import Mathlib.NumberTheory.FunctionField
import Mathlib.NumberTheory.GaussSum
import Mathlib.NumberTheory.Harmonic.Bounds
import Mathlib.NumberTheory.Harmonic.Defs
import Mathlib.NumberTheory.Harmonic.EulerMascheroni
import Mathlib.NumberTheory.Harmonic.GammaDeriv
import Mathlib.NumberTheory.Harmonic.Int
import Mathlib.NumberTheory.Harmonic.ZetaAsymp
import Mathlib.NumberTheory.JacobiSum.Basic
import Mathlib.NumberTheory.KummerDedekind
import Mathlib.NumberTheory.LSeries.AbstractFuncEq
import Mathlib.NumberTheory.LSeries.Basic
import Mathlib.NumberTheory.LSeries.Convergence
import Mathlib.NumberTheory.LSeries.Convolution
import Mathlib.NumberTheory.LSeries.Deriv
import Mathlib.NumberTheory.LSeries.Dirichlet
import Mathlib.NumberTheory.LSeries.DirichletContinuation
import Mathlib.NumberTheory.LSeries.HurwitzZeta
import Mathlib.NumberTheory.LSeries.HurwitzZetaEven
import Mathlib.NumberTheory.LSeries.HurwitzZetaOdd
import Mathlib.NumberTheory.LSeries.HurwitzZetaValues
import Mathlib.NumberTheory.LSeries.Injectivity
import Mathlib.NumberTheory.LSeries.Linearity
import Mathlib.NumberTheory.LSeries.MellinEqDirichlet
import Mathlib.NumberTheory.LSeries.Nonvanishing
import Mathlib.NumberTheory.LSeries.Positivity
import Mathlib.NumberTheory.LSeries.PrimesInAP
import Mathlib.NumberTheory.LSeries.RiemannZeta
import Mathlib.NumberTheory.LSeries.SumCoeff
import Mathlib.NumberTheory.LSeries.ZMod
import Mathlib.NumberTheory.LegendreSymbol.AddCharacter
import Mathlib.NumberTheory.LegendreSymbol.Basic
import Mathlib.NumberTheory.LegendreSymbol.GaussEisensteinLemmas
import Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol
import Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic
import Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.GaussSum
import Mathlib.NumberTheory.LegendreSymbol.QuadraticReciprocity
import Mathlib.NumberTheory.LegendreSymbol.ZModChar
import Mathlib.NumberTheory.LucasLehmer
import Mathlib.NumberTheory.LucasPrimality
import Mathlib.NumberTheory.MaricaSchoenheim
import Mathlib.NumberTheory.Modular
import Mathlib.NumberTheory.ModularForms.Basic
import Mathlib.NumberTheory.ModularForms.CongruenceSubgroups
import Mathlib.NumberTheory.ModularForms.EisensteinSeries.Basic
import Mathlib.NumberTheory.ModularForms.EisensteinSeries.Defs
import Mathlib.NumberTheory.ModularForms.EisensteinSeries.IsBoundedAtImInfty
import Mathlib.NumberTheory.ModularForms.EisensteinSeries.MDifferentiable
import Mathlib.NumberTheory.ModularForms.EisensteinSeries.Summable
import Mathlib.NumberTheory.ModularForms.EisensteinSeries.UniformConvergence
import Mathlib.NumberTheory.ModularForms.Identities
import Mathlib.NumberTheory.ModularForms.JacobiTheta.Bounds
import Mathlib.NumberTheory.ModularForms.JacobiTheta.Manifold
import Mathlib.NumberTheory.ModularForms.JacobiTheta.OneVariable
import Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable
import Mathlib.NumberTheory.ModularForms.LevelOne
import Mathlib.NumberTheory.ModularForms.QExpansion
import Mathlib.NumberTheory.ModularForms.SlashActions
import Mathlib.NumberTheory.ModularForms.SlashInvariantForms
import Mathlib.NumberTheory.MulChar.Basic
import Mathlib.NumberTheory.MulChar.Duality
import Mathlib.NumberTheory.MulChar.Lemmas
import Mathlib.NumberTheory.Multiplicity
import Mathlib.NumberTheory.NumberField.AdeleRing
import Mathlib.NumberTheory.NumberField.Basic
import Mathlib.NumberTheory.NumberField.CMField
import Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic
import Mathlib.NumberTheory.NumberField.CanonicalEmbedding.ConvexBody
import Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone
import Mathlib.NumberTheory.NumberField.CanonicalEmbedding.NormLeOne
import Mathlib.NumberTheory.NumberField.CanonicalEmbedding.PolarCoord
import Mathlib.NumberTheory.NumberField.ClassNumber
import Mathlib.NumberTheory.NumberField.Completion
import Mathlib.NumberTheory.NumberField.DedekindZeta
import Mathlib.NumberTheory.NumberField.Discriminant.Basic
import Mathlib.NumberTheory.NumberField.Discriminant.Defs
import Mathlib.NumberTheory.NumberField.Discriminant.Different
import Mathlib.NumberTheory.NumberField.Embeddings
import Mathlib.NumberTheory.NumberField.EquivReindex
import Mathlib.NumberTheory.NumberField.FinitePlaces
import Mathlib.NumberTheory.NumberField.FractionalIdeal
import Mathlib.NumberTheory.NumberField.House
import Mathlib.NumberTheory.NumberField.Ideal
import Mathlib.NumberTheory.NumberField.Ideal.Asymptotics
import Mathlib.NumberTheory.NumberField.Ideal.Basic
import Mathlib.NumberTheory.NumberField.Ideal.KummerDedekind
import Mathlib.NumberTheory.NumberField.InfinitePlace.Basic
import Mathlib.NumberTheory.NumberField.InfinitePlace.Embeddings
import Mathlib.NumberTheory.NumberField.InfinitePlace.Ramification
import Mathlib.NumberTheory.NumberField.InfinitePlace.TotallyRealComplex
import Mathlib.NumberTheory.NumberField.Norm
import Mathlib.NumberTheory.NumberField.ProductFormula
import Mathlib.NumberTheory.NumberField.Units.Basic
import Mathlib.NumberTheory.NumberField.Units.DirichletTheorem
import Mathlib.NumberTheory.NumberField.Units.Regulator
import Mathlib.NumberTheory.Ostrowski
import Mathlib.NumberTheory.Padics.AddChar
import Mathlib.NumberTheory.Padics.Complex
import Mathlib.NumberTheory.Padics.Hensel
import Mathlib.NumberTheory.Padics.MahlerBasis
import Mathlib.NumberTheory.Padics.PadicIntegers
import Mathlib.NumberTheory.Padics.PadicNorm
import Mathlib.NumberTheory.Padics.PadicNumbers
import Mathlib.NumberTheory.Padics.PadicVal.Basic
import Mathlib.NumberTheory.Padics.PadicVal.Defs
import Mathlib.NumberTheory.Padics.ProperSpace
import Mathlib.NumberTheory.Padics.RingHoms
import Mathlib.NumberTheory.Padics.ValuativeRel
import Mathlib.NumberTheory.Pell
import Mathlib.NumberTheory.PellMatiyasevic
import Mathlib.NumberTheory.PrimeCounting
import Mathlib.NumberTheory.PrimesCongruentOne
import Mathlib.NumberTheory.Primorial
import Mathlib.NumberTheory.PythagoreanTriples
import Mathlib.NumberTheory.RamificationInertia.Basic
import Mathlib.NumberTheory.RamificationInertia.Galois
import Mathlib.NumberTheory.RamificationInertia.Unramified
import Mathlib.NumberTheory.Rayleigh
import Mathlib.NumberTheory.SelbergSieve
import Mathlib.NumberTheory.SiegelsLemma
import Mathlib.NumberTheory.SmoothNumbers
import Mathlib.NumberTheory.SumFourSquares
import Mathlib.NumberTheory.SumPrimeReciprocals
import Mathlib.NumberTheory.SumTwoSquares
import Mathlib.NumberTheory.Transcendental.Lindemann.AnalyticalPart
import Mathlib.NumberTheory.Transcendental.Liouville.Basic
import Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleNumber
import Mathlib.NumberTheory.Transcendental.Liouville.LiouvilleWith
import Mathlib.NumberTheory.Transcendental.Liouville.Measure
import Mathlib.NumberTheory.Transcendental.Liouville.Residual
import Mathlib.NumberTheory.VonMangoldt
import Mathlib.NumberTheory.WellApproximable
import Mathlib.NumberTheory.Wilson
import Mathlib.NumberTheory.ZetaValues
import Mathlib.NumberTheory.Zsqrtd.Basic
import Mathlib.NumberTheory.Zsqrtd.GaussianInt
import Mathlib.NumberTheory.Zsqrtd.QuadraticReciprocity
import Mathlib.NumberTheory.Zsqrtd.ToReal
import Mathlib.Order.Antichain
import Mathlib.Order.Antisymmetrization
import Mathlib.Order.Atoms
import Mathlib.Order.Atoms.Finite
import Mathlib.Order.Basic
import Mathlib.Order.Birkhoff
import Mathlib.Order.BooleanAlgebra
import Mathlib.Order.BooleanAlgebra.Basic
import Mathlib.Order.BooleanAlgebra.Defs
import Mathlib.Order.BooleanAlgebra.Set
import Mathlib.Order.BooleanGenerators
import Mathlib.Order.BooleanSubalgebra
import Mathlib.Order.Booleanisation
import Mathlib.Order.Bounded
import Mathlib.Order.BoundedOrder.Basic
import Mathlib.Order.BoundedOrder.Lattice
import Mathlib.Order.BoundedOrder.Monotone
import Mathlib.Order.Bounds.Basic
import Mathlib.Order.Bounds.Defs
import Mathlib.Order.Bounds.Image
import Mathlib.Order.Bounds.Lattice
import Mathlib.Order.Bounds.OrderIso
import Mathlib.Order.Category.BddDistLat
import Mathlib.Order.Category.BddLat
import Mathlib.Order.Category.BddOrd
import Mathlib.Order.Category.BoolAlg
import Mathlib.Order.Category.CompleteLat
import Mathlib.Order.Category.DistLat
import Mathlib.Order.Category.FinBddDistLat
import Mathlib.Order.Category.FinBoolAlg
import Mathlib.Order.Category.FinPartOrd
import Mathlib.Order.Category.Frm
import Mathlib.Order.Category.HeytAlg
import Mathlib.Order.Category.Lat
import Mathlib.Order.Category.LinOrd
import Mathlib.Order.Category.NonemptyFinLinOrd
import Mathlib.Order.Category.OmegaCompletePartialOrder
import Mathlib.Order.Category.PartOrd
import Mathlib.Order.Category.Preord
import Mathlib.Order.Category.Semilat
import Mathlib.Order.Chain
import Mathlib.Order.Circular
import Mathlib.Order.Circular.ZMod
import Mathlib.Order.Closure
import Mathlib.Order.Cofinal
import Mathlib.Order.CompactlyGenerated.Basic
import Mathlib.Order.CompactlyGenerated.Intervals
import Mathlib.Order.Comparable
import Mathlib.Order.Compare
import Mathlib.Order.CompleteBooleanAlgebra
import Mathlib.Order.CompleteLattice.Basic
import Mathlib.Order.CompleteLattice.Chain
import Mathlib.Order.CompleteLattice.Defs
import Mathlib.Order.CompleteLattice.Finset
import Mathlib.Order.CompleteLattice.Group
import Mathlib.Order.CompleteLattice.Lemmas
import Mathlib.Order.CompleteLattice.MulticoequalizerDiagram
import Mathlib.Order.CompleteLattice.SetLike
import Mathlib.Order.CompleteLatticeIntervals
import Mathlib.Order.CompletePartialOrder
import Mathlib.Order.CompleteSublattice
import Mathlib.Order.Concept
import Mathlib.Order.ConditionallyCompleteLattice.Basic
import Mathlib.Order.ConditionallyCompleteLattice.Defs
import Mathlib.Order.ConditionallyCompleteLattice.Finset
import Mathlib.Order.ConditionallyCompleteLattice.Group
import Mathlib.Order.ConditionallyCompleteLattice.Indexed
import Mathlib.Order.Copy
import Mathlib.Order.CountableDenseLinearOrder
import Mathlib.Order.Cover
import Mathlib.Order.Defs.LinearOrder
import Mathlib.Order.Defs.PartialOrder
import Mathlib.Order.Defs.Unbundled
import Mathlib.Order.Directed
import Mathlib.Order.DirectedInverseSystem
import Mathlib.Order.Disjoint
import Mathlib.Order.Disjointed
import Mathlib.Order.Estimator
import Mathlib.Order.Extension.Linear
import Mathlib.Order.Extension.Well
import Mathlib.Order.Filter.AtTopBot.Archimedean
import Mathlib.Order.Filter.AtTopBot.Basic
import Mathlib.Order.Filter.AtTopBot.BigOperators
import Mathlib.Order.Filter.AtTopBot.CompleteLattice
import Mathlib.Order.Filter.AtTopBot.CountablyGenerated
import Mathlib.Order.Filter.AtTopBot.Defs
import Mathlib.Order.Filter.AtTopBot.Disjoint
import Mathlib.Order.Filter.AtTopBot.Field
import Mathlib.Order.Filter.AtTopBot.Finite
import Mathlib.Order.Filter.AtTopBot.Finset
import Mathlib.Order.Filter.AtTopBot.Floor
import Mathlib.Order.Filter.AtTopBot.Group
import Mathlib.Order.Filter.AtTopBot.Map
import Mathlib.Order.Filter.AtTopBot.ModEq
import Mathlib.Order.Filter.AtTopBot.Monoid
import Mathlib.Order.Filter.AtTopBot.Prod
import Mathlib.Order.Filter.AtTopBot.Ring
import Mathlib.Order.Filter.AtTopBot.Tendsto
import Mathlib.Order.Filter.Bases.Basic
import Mathlib.Order.Filter.Bases.Finite
import Mathlib.Order.Filter.Basic
import Mathlib.Order.Filter.CardinalInter
import Mathlib.Order.Filter.Cocardinal
import Mathlib.Order.Filter.Cofinite
import Mathlib.Order.Filter.CountableInter
import Mathlib.Order.Filter.CountableSeparatingOn
import Mathlib.Order.Filter.CountablyGenerated
import Mathlib.Order.Filter.Curry
import Mathlib.Order.Filter.Defs
import Mathlib.Order.Filter.ENNReal
import Mathlib.Order.Filter.EventuallyConst
import Mathlib.Order.Filter.Extr
import Mathlib.Order.Filter.FilterProduct
import Mathlib.Order.Filter.Finite
import Mathlib.Order.Filter.Germ.Basic
import Mathlib.Order.Filter.Germ.OrderedMonoid
import Mathlib.Order.Filter.IndicatorFunction
import Mathlib.Order.Filter.Interval
import Mathlib.Order.Filter.IsBounded
import Mathlib.Order.Filter.Ker
import Mathlib.Order.Filter.Lift
import Mathlib.Order.Filter.ListTraverse
import Mathlib.Order.Filter.Map
import Mathlib.Order.Filter.NAry
import Mathlib.Order.Filter.Partial
import Mathlib.Order.Filter.Pi
import Mathlib.Order.Filter.Pointwise
import Mathlib.Order.Filter.Prod
import Mathlib.Order.Filter.Ring
import Mathlib.Order.Filter.SmallSets
import Mathlib.Order.Filter.Subsingleton
import Mathlib.Order.Filter.Tendsto
import Mathlib.Order.Filter.Ultrafilter.Basic
import Mathlib.Order.Filter.Ultrafilter.Defs
import Mathlib.Order.Filter.ZeroAndBoundedAtFilter
import Mathlib.Order.Fin.Basic
import Mathlib.Order.Fin.Finset
import Mathlib.Order.Fin.SuccAboveOrderIso
import Mathlib.Order.Fin.Tuple
import Mathlib.Order.FixedPoints
import Mathlib.Order.GaloisConnection.Basic
import Mathlib.Order.GaloisConnection.Defs
import Mathlib.Order.GameAdd
import Mathlib.Order.Grade
import Mathlib.Order.Height
import Mathlib.Order.Heyting.Basic
import Mathlib.Order.Heyting.Boundary
import Mathlib.Order.Heyting.Hom
import Mathlib.Order.Heyting.Regular
import Mathlib.Order.Hom.Basic
import Mathlib.Order.Hom.Bounded
import Mathlib.Order.Hom.BoundedLattice
import Mathlib.Order.Hom.CompleteLattice
import Mathlib.Order.Hom.Lattice
import Mathlib.Order.Hom.Lex
import Mathlib.Order.Hom.Order
import Mathlib.Order.Hom.Set
import Mathlib.Order.Hom.WithTopBot
import Mathlib.Order.Ideal
import Mathlib.Order.InitialSeg
import Mathlib.Order.Interval.Basic
import Mathlib.Order.Interval.Finset.Basic
import Mathlib.Order.Interval.Finset.Box
import Mathlib.Order.Interval.Finset.Defs
import Mathlib.Order.Interval.Finset.DenselyOrdered
import Mathlib.Order.Interval.Finset.Fin
import Mathlib.Order.Interval.Finset.Nat
import Mathlib.Order.Interval.Finset.SuccPred
import Mathlib.Order.Interval.Lex
import Mathlib.Order.Interval.Multiset
import Mathlib.Order.Interval.Set.Basic
import Mathlib.Order.Interval.Set.Defs
import Mathlib.Order.Interval.Set.Disjoint
import Mathlib.Order.Interval.Set.Fin
import Mathlib.Order.Interval.Set.Final
import Mathlib.Order.Interval.Set.Image
import Mathlib.Order.Interval.Set.Infinite
import Mathlib.Order.Interval.Set.InitialSeg
import Mathlib.Order.Interval.Set.IsoIoo
import Mathlib.Order.Interval.Set.Limit
import Mathlib.Order.Interval.Set.LinearOrder
import Mathlib.Order.Interval.Set.Monotone
import Mathlib.Order.Interval.Set.OrdConnected
import Mathlib.Order.Interval.Set.OrdConnectedComponent
import Mathlib.Order.Interval.Set.OrdConnectedLinear
import Mathlib.Order.Interval.Set.OrderEmbedding
import Mathlib.Order.Interval.Set.OrderIso
import Mathlib.Order.Interval.Set.Pi
import Mathlib.Order.Interval.Set.ProjIcc
import Mathlib.Order.Interval.Set.SuccOrder
import Mathlib.Order.Interval.Set.SuccPred
import Mathlib.Order.Interval.Set.SurjOn
import Mathlib.Order.Interval.Set.Union
import Mathlib.Order.Interval.Set.UnorderedInterval
import Mathlib.Order.Interval.Set.WithBotTop
import Mathlib.Order.Irreducible
import Mathlib.Order.IsNormal
import Mathlib.Order.Iterate
import Mathlib.Order.JordanHolder
import Mathlib.Order.KonigLemma
import Mathlib.Order.KrullDimension
import Mathlib.Order.Lattice
import Mathlib.Order.LatticeIntervals
import Mathlib.Order.LiminfLimsup
import Mathlib.Order.Max
import Mathlib.Order.MinMax
import Mathlib.Order.Minimal
import Mathlib.Order.ModularLattice
import Mathlib.Order.Monotone.Basic
import Mathlib.Order.Monotone.Defs
import Mathlib.Order.Monotone.Extension
import Mathlib.Order.Monotone.Monovary
import Mathlib.Order.Monotone.MonovaryOrder
import Mathlib.Order.Monotone.Odd
import Mathlib.Order.Monotone.Union
import Mathlib.Order.Nat
import Mathlib.Order.Notation
import Mathlib.Order.Nucleus
import Mathlib.Order.OmegaCompletePartialOrder
import Mathlib.Order.OrdContinuous
import Mathlib.Order.OrderIsoNat
import Mathlib.Order.PFilter
import Mathlib.Order.Part
import Mathlib.Order.PartialSups
import Mathlib.Order.Partition.Basic
import Mathlib.Order.Partition.Equipartition
import Mathlib.Order.Partition.Finpartition
import Mathlib.Order.PiLex
import Mathlib.Order.Preorder.Chain
import Mathlib.Order.Preorder.Finite
import Mathlib.Order.PrimeIdeal
import Mathlib.Order.PrimeSeparator
import Mathlib.Order.Prod.Lex.Hom
import Mathlib.Order.PropInstances
import Mathlib.Order.Radical
import Mathlib.Order.Rel.GaloisConnection
import Mathlib.Order.RelClasses
import Mathlib.Order.RelIso.Basic
import Mathlib.Order.RelIso.Set
import Mathlib.Order.RelSeries
import Mathlib.Order.Restriction
import Mathlib.Order.ScottContinuity
import Mathlib.Order.SemiconjSup
import Mathlib.Order.Set
import Mathlib.Order.SetIsMax
import Mathlib.Order.SetNotation
import Mathlib.Order.Shrink
import Mathlib.Order.Sublattice
import Mathlib.Order.SuccPred.Archimedean
import Mathlib.Order.SuccPred.Basic
import Mathlib.Order.SuccPred.CompleteLinearOrder
import Mathlib.Order.SuccPred.InitialSeg
import Mathlib.Order.SuccPred.IntervalSucc
import Mathlib.Order.SuccPred.Limit
import Mathlib.Order.SuccPred.LinearLocallyFinite
import Mathlib.Order.SuccPred.Relation
import Mathlib.Order.SuccPred.Tree
import Mathlib.Order.SuccPred.WithBot
import Mathlib.Order.SupClosed
import Mathlib.Order.SupIndep
import Mathlib.Order.SymmDiff
import Mathlib.Order.Synonym
import Mathlib.Order.TransfiniteIteration
import Mathlib.Order.TypeTags
import Mathlib.Order.ULift
import Mathlib.Order.UpperLower.Basic
import Mathlib.Order.UpperLower.Closure
import Mathlib.Order.UpperLower.CompleteLattice
import Mathlib.Order.UpperLower.Fibration
import Mathlib.Order.UpperLower.Hom
import Mathlib.Order.UpperLower.LocallyFinite
import Mathlib.Order.UpperLower.Principal
import Mathlib.Order.UpperLower.Prod
import Mathlib.Order.UpperLower.Relative
import Mathlib.Order.WellFounded
import Mathlib.Order.WellFoundedSet
import Mathlib.Order.WellQuasiOrder
import Mathlib.Order.WithBot
import Mathlib.Order.Zorn
import Mathlib.Order.ZornAtoms
import Mathlib.Probability.BorelCantelli
import Mathlib.Probability.CDF
import Mathlib.Probability.CondVar
import Mathlib.Probability.ConditionalExpectation
import Mathlib.Probability.ConditionalProbability
import Mathlib.Probability.Density
import Mathlib.Probability.Distributions.Exponential
import Mathlib.Probability.Distributions.Gamma
import Mathlib.Probability.Distributions.Gaussian
import Mathlib.Probability.Distributions.Gaussian.Basic
import Mathlib.Probability.Distributions.Gaussian.Real
import Mathlib.Probability.Distributions.Geometric
import Mathlib.Probability.Distributions.Pareto
import Mathlib.Probability.Distributions.Poisson
import Mathlib.Probability.Distributions.Uniform
import Mathlib.Probability.IdentDistrib
import Mathlib.Probability.Independence.Basic
import Mathlib.Probability.Independence.Conditional
import Mathlib.Probability.Independence.InfinitePi
import Mathlib.Probability.Independence.Integrable
import Mathlib.Probability.Independence.Integration
import Mathlib.Probability.Independence.Kernel
import Mathlib.Probability.Independence.ZeroOne
import Mathlib.Probability.Integration
import Mathlib.Probability.Kernel.Basic
import Mathlib.Probability.Kernel.CompProdEqIff
import Mathlib.Probability.Kernel.Composition.AbsolutelyContinuous
import Mathlib.Probability.Kernel.Composition.Comp
import Mathlib.Probability.Kernel.Composition.CompMap
import Mathlib.Probability.Kernel.Composition.CompNotation
import Mathlib.Probability.Kernel.Composition.CompProd
import Mathlib.Probability.Kernel.Composition.IntegralCompProd
import Mathlib.Probability.Kernel.Composition.Lemmas
import Mathlib.Probability.Kernel.Composition.MapComap
import Mathlib.Probability.Kernel.Composition.MeasureComp
import Mathlib.Probability.Kernel.Composition.MeasureCompProd
import Mathlib.Probability.Kernel.Composition.ParallelComp
import Mathlib.Probability.Kernel.Composition.Prod
import Mathlib.Probability.Kernel.CondDistrib
import Mathlib.Probability.Kernel.Condexp
import Mathlib.Probability.Kernel.Defs
import Mathlib.Probability.Kernel.Disintegration.Basic
import Mathlib.Probability.Kernel.Disintegration.CDFToKernel
import Mathlib.Probability.Kernel.Disintegration.CondCDF
import Mathlib.Probability.Kernel.Disintegration.Density
import Mathlib.Probability.Kernel.Disintegration.Integral
import Mathlib.Probability.Kernel.Disintegration.MeasurableStieltjes
import Mathlib.Probability.Kernel.Disintegration.StandardBorel
import Mathlib.Probability.Kernel.Disintegration.Unique
import Mathlib.Probability.Kernel.Integral
import Mathlib.Probability.Kernel.Invariance
import Mathlib.Probability.Kernel.IonescuTulcea.Maps
import Mathlib.Probability.Kernel.IonescuTulcea.PartialTraj
import Mathlib.Probability.Kernel.IonescuTulcea.Traj
import Mathlib.Probability.Kernel.MeasurableIntegral
import Mathlib.Probability.Kernel.MeasurableLIntegral
import Mathlib.Probability.Kernel.Posterior
import Mathlib.Probability.Kernel.Proper
import Mathlib.Probability.Kernel.RadonNikodym
import Mathlib.Probability.Kernel.SetIntegral
import Mathlib.Probability.Kernel.WithDensity
import Mathlib.Probability.Martingale.Basic
import Mathlib.Probability.Martingale.BorelCantelli
import Mathlib.Probability.Martingale.Centering
import Mathlib.Probability.Martingale.Convergence
import Mathlib.Probability.Martingale.OptionalSampling
import Mathlib.Probability.Martingale.OptionalStopping
import Mathlib.Probability.Martingale.Upcrossing
import Mathlib.Probability.Moments.Basic
import Mathlib.Probability.Moments.ComplexMGF
import Mathlib.Probability.Moments.Covariance
import Mathlib.Probability.Moments.CovarianceBilin
import Mathlib.Probability.Moments.IntegrableExpMul
import Mathlib.Probability.Moments.MGFAnalytic
import Mathlib.Probability.Moments.SubGaussian
import Mathlib.Probability.Moments.Tilted
import Mathlib.Probability.Moments.Variance
import Mathlib.Probability.Notation
import Mathlib.Probability.ProbabilityMassFunction.Basic
import Mathlib.Probability.ProbabilityMassFunction.Binomial
import Mathlib.Probability.ProbabilityMassFunction.Constructions
import Mathlib.Probability.ProbabilityMassFunction.Integrals
import Mathlib.Probability.ProbabilityMassFunction.Monad
import Mathlib.Probability.Process.Adapted
import Mathlib.Probability.Process.Filtration
import Mathlib.Probability.Process.FiniteDimensionalLaws
import Mathlib.Probability.Process.HittingTime
import Mathlib.Probability.Process.Kolmogorov
import Mathlib.Probability.Process.PartitionFiltration
import Mathlib.Probability.Process.Stopping
import Mathlib.Probability.ProductMeasure
import Mathlib.Probability.StrongLaw
import Mathlib.Probability.UniformOn
import Mathlib.Probability.Variance
import Mathlib.RepresentationTheory.Basic
import Mathlib.RepresentationTheory.Character
import Mathlib.RepresentationTheory.Coinduced
import Mathlib.RepresentationTheory.Coinvariants
import Mathlib.RepresentationTheory.FDRep
import Mathlib.RepresentationTheory.FiniteIndex
import Mathlib.RepresentationTheory.GroupCohomology.Basic
import Mathlib.RepresentationTheory.GroupCohomology.Functoriality
import Mathlib.RepresentationTheory.GroupCohomology.Hilbert90
import Mathlib.RepresentationTheory.GroupCohomology.LowDegree
import Mathlib.RepresentationTheory.GroupCohomology.Resolution
import Mathlib.RepresentationTheory.Homological.GroupCohomology.Basic
import Mathlib.RepresentationTheory.Homological.GroupCohomology.Functoriality
import Mathlib.RepresentationTheory.Homological.GroupCohomology.Hilbert90
import Mathlib.RepresentationTheory.Homological.GroupCohomology.LongExactSequence
import Mathlib.RepresentationTheory.Homological.GroupCohomology.LowDegree
import Mathlib.RepresentationTheory.Homological.GroupCohomology.Shapiro
import Mathlib.RepresentationTheory.Homological.GroupHomology.Basic
import Mathlib.RepresentationTheory.Homological.GroupHomology.Functoriality
import Mathlib.RepresentationTheory.Homological.GroupHomology.LongExactSequence
import Mathlib.RepresentationTheory.Homological.GroupHomology.LowDegree
import Mathlib.RepresentationTheory.Homological.GroupHomology.Shapiro
import Mathlib.RepresentationTheory.Homological.Resolution
import Mathlib.RepresentationTheory.Induced
import Mathlib.RepresentationTheory.Invariants
import Mathlib.RepresentationTheory.Maschke
import Mathlib.RepresentationTheory.Rep
import Mathlib.RepresentationTheory.Submodule
import Mathlib.RepresentationTheory.Tannaka
import Mathlib.RingTheory.AdicCompletion.Algebra
import Mathlib.RingTheory.AdicCompletion.AsTensorProduct
import Mathlib.RingTheory.AdicCompletion.Basic
import Mathlib.RingTheory.AdicCompletion.Exactness
import Mathlib.RingTheory.AdicCompletion.Functoriality
import Mathlib.RingTheory.AdicCompletion.LocalRing
import Mathlib.RingTheory.AdicCompletion.Noetherian
import Mathlib.RingTheory.Adjoin.Basic
import Mathlib.RingTheory.Adjoin.Dimension
import Mathlib.RingTheory.Adjoin.FG
import Mathlib.RingTheory.Adjoin.Field
import Mathlib.RingTheory.Adjoin.Polynomial
import Mathlib.RingTheory.Adjoin.PowerBasis
import Mathlib.RingTheory.Adjoin.Tower
import Mathlib.RingTheory.AdjoinRoot
import Mathlib.RingTheory.AlgebraTower
import Mathlib.RingTheory.Algebraic.Basic
import Mathlib.RingTheory.Algebraic.Cardinality
import Mathlib.RingTheory.Algebraic.Defs
import Mathlib.RingTheory.Algebraic.Integral
import Mathlib.RingTheory.Algebraic.LinearIndependent
import Mathlib.RingTheory.Algebraic.MvPolynomial
import Mathlib.RingTheory.Algebraic.Pi
import Mathlib.RingTheory.AlgebraicIndependent.Adjoin
import Mathlib.RingTheory.AlgebraicIndependent.AlgebraicClosure
import Mathlib.RingTheory.AlgebraicIndependent.Basic
import Mathlib.RingTheory.AlgebraicIndependent.Defs
import Mathlib.RingTheory.AlgebraicIndependent.RankAndCardinality
import Mathlib.RingTheory.AlgebraicIndependent.TranscendenceBasis
import Mathlib.RingTheory.AlgebraicIndependent.Transcendental
import Mathlib.RingTheory.Artinian.Algebra
import Mathlib.RingTheory.Artinian.Instances
import Mathlib.RingTheory.Artinian.Module
import Mathlib.RingTheory.Artinian.Ring
import Mathlib.RingTheory.Bezout
import Mathlib.RingTheory.Bialgebra.Basic
import Mathlib.RingTheory.Bialgebra.Equiv
import Mathlib.RingTheory.Bialgebra.Hom
import Mathlib.RingTheory.Bialgebra.MonoidAlgebra
import Mathlib.RingTheory.Bialgebra.TensorProduct
import Mathlib.RingTheory.Binomial
import Mathlib.RingTheory.ChainOfDivisors
import Mathlib.RingTheory.ClassGroup
import Mathlib.RingTheory.Coalgebra.Basic
import Mathlib.RingTheory.Coalgebra.Equiv
import Mathlib.RingTheory.Coalgebra.Hom
import Mathlib.RingTheory.Coalgebra.MonoidAlgebra
import Mathlib.RingTheory.Coalgebra.TensorProduct
import Mathlib.RingTheory.Complex
import Mathlib.RingTheory.Congruence.Basic
import Mathlib.RingTheory.Congruence.BigOperators
import Mathlib.RingTheory.Congruence.Defs
import Mathlib.RingTheory.Congruence.Opposite
import Mathlib.RingTheory.Coprime.Basic
import Mathlib.RingTheory.Coprime.Ideal
import Mathlib.RingTheory.Coprime.Lemmas
import Mathlib.RingTheory.CotangentLocalizationAway
import Mathlib.RingTheory.DedekindDomain.AdicValuation
import Mathlib.RingTheory.DedekindDomain.Basic
import Mathlib.RingTheory.DedekindDomain.Different
import Mathlib.RingTheory.DedekindDomain.Dvr
import Mathlib.RingTheory.DedekindDomain.Factorization
import Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing
import Mathlib.RingTheory.DedekindDomain.Ideal.Basic
import Mathlib.RingTheory.DedekindDomain.Ideal.Lemmas
import Mathlib.RingTheory.DedekindDomain.Instances
import Mathlib.RingTheory.DedekindDomain.IntegralClosure
import Mathlib.RingTheory.DedekindDomain.PID
import Mathlib.RingTheory.DedekindDomain.SInteger
import Mathlib.RingTheory.DedekindDomain.SelmerGroup
import Mathlib.RingTheory.Derivation.Basic
import Mathlib.RingTheory.Derivation.DifferentialRing
import Mathlib.RingTheory.Derivation.Lie
import Mathlib.RingTheory.Derivation.MapCoeffs
import Mathlib.RingTheory.Derivation.ToSquareZero
import Mathlib.RingTheory.DiscreteValuationRing.Basic
import Mathlib.RingTheory.DiscreteValuationRing.TFAE
import Mathlib.RingTheory.Discriminant
import Mathlib.RingTheory.DividedPowers.Basic
import Mathlib.RingTheory.DividedPowers.DPMorphism
import Mathlib.RingTheory.DividedPowers.SubDPIdeal
import Mathlib.RingTheory.DualNumber
import Mathlib.RingTheory.EisensteinCriterion
import Mathlib.RingTheory.EssentialFiniteness
import Mathlib.RingTheory.Etale.Basic
import Mathlib.RingTheory.Etale.Field
import Mathlib.RingTheory.Etale.Kaehler
import Mathlib.RingTheory.Etale.Pi
import Mathlib.RingTheory.EuclideanDomain
import Mathlib.RingTheory.Extension
import Mathlib.RingTheory.Extension.Basic
import Mathlib.RingTheory.Extension.Cotangent.Basic
import Mathlib.RingTheory.Extension.Cotangent.LocalizationAway
import Mathlib.RingTheory.Extension.Generators
import Mathlib.RingTheory.Extension.Presentation.Basic
import Mathlib.RingTheory.FilteredAlgebra.Basic
import Mathlib.RingTheory.Filtration
import Mathlib.RingTheory.FiniteLength
import Mathlib.RingTheory.FinitePresentation
import Mathlib.RingTheory.FiniteStability
import Mathlib.RingTheory.FiniteType
import Mathlib.RingTheory.Finiteness.Basic
import Mathlib.RingTheory.Finiteness.Bilinear
import Mathlib.RingTheory.Finiteness.Cardinality
import Mathlib.RingTheory.Finiteness.Defs
import Mathlib.RingTheory.Finiteness.Finsupp
import Mathlib.RingTheory.Finiteness.Ideal
import Mathlib.RingTheory.Finiteness.Lattice
import Mathlib.RingTheory.Finiteness.Nakayama
import Mathlib.RingTheory.Finiteness.Nilpotent
import Mathlib.RingTheory.Finiteness.Prod
import Mathlib.RingTheory.Finiteness.Projective
import Mathlib.RingTheory.Finiteness.Quotient
import Mathlib.RingTheory.Finiteness.Small
import Mathlib.RingTheory.Finiteness.Subalgebra
import Mathlib.RingTheory.Fintype
import Mathlib.RingTheory.Flat.Basic
import Mathlib.RingTheory.Flat.CategoryTheory
import Mathlib.RingTheory.Flat.Domain
import Mathlib.RingTheory.Flat.Equalizer
import Mathlib.RingTheory.Flat.EquationalCriterion
import Mathlib.RingTheory.Flat.FaithfullyFlat.Algebra
import Mathlib.RingTheory.Flat.FaithfullyFlat.Basic
import Mathlib.RingTheory.Flat.Localization
import Mathlib.RingTheory.Flat.Stability
import Mathlib.RingTheory.FractionalIdeal.Basic
import Mathlib.RingTheory.FractionalIdeal.Extended
import Mathlib.RingTheory.FractionalIdeal.Inverse
import Mathlib.RingTheory.FractionalIdeal.Norm
import Mathlib.RingTheory.FractionalIdeal.Operations
import Mathlib.RingTheory.FreeCommRing
import Mathlib.RingTheory.FreeRing
import Mathlib.RingTheory.Frobenius
import Mathlib.RingTheory.Generators
import Mathlib.RingTheory.GradedAlgebra.Basic
import Mathlib.RingTheory.GradedAlgebra.FiniteType
import Mathlib.RingTheory.GradedAlgebra.Homogeneous.Ideal
import Mathlib.RingTheory.GradedAlgebra.Homogeneous.Submodule
import Mathlib.RingTheory.GradedAlgebra.HomogeneousLocalization
import Mathlib.RingTheory.GradedAlgebra.Noetherian
import Mathlib.RingTheory.GradedAlgebra.Radical
import Mathlib.RingTheory.Grassmannian
import Mathlib.RingTheory.HahnSeries.Addition
import Mathlib.RingTheory.HahnSeries.Basic
import Mathlib.RingTheory.HahnSeries.HEval
import Mathlib.RingTheory.HahnSeries.Lex
import Mathlib.RingTheory.HahnSeries.Multiplication
import Mathlib.RingTheory.HahnSeries.PowerSeries
import Mathlib.RingTheory.HahnSeries.Summable
import Mathlib.RingTheory.HahnSeries.Valuation
import Mathlib.RingTheory.Henselian
import Mathlib.RingTheory.HopfAlgebra.Basic
import Mathlib.RingTheory.HopfAlgebra.MonoidAlgebra
import Mathlib.RingTheory.HopfAlgebra.TensorProduct
import Mathlib.RingTheory.HopkinsLevitzki
import Mathlib.RingTheory.Ideal.AssociatedPrime
import Mathlib.RingTheory.Ideal.AssociatedPrime.Basic
import Mathlib.RingTheory.Ideal.AssociatedPrime.Finiteness
import Mathlib.RingTheory.Ideal.AssociatedPrime.Localization
import Mathlib.RingTheory.Ideal.Basic
import Mathlib.RingTheory.Ideal.Basis
import Mathlib.RingTheory.Ideal.BigOperators
import Mathlib.RingTheory.Ideal.Colon
import Mathlib.RingTheory.Ideal.Cotangent
import Mathlib.RingTheory.Ideal.Defs
import Mathlib.RingTheory.Ideal.GoingDown
import Mathlib.RingTheory.Ideal.GoingUp
import Mathlib.RingTheory.Ideal.Height
import Mathlib.RingTheory.Ideal.IdempotentFG
import Mathlib.RingTheory.Ideal.Int
import Mathlib.RingTheory.Ideal.IsPrimary
import Mathlib.RingTheory.Ideal.IsPrincipal
import Mathlib.RingTheory.Ideal.IsPrincipalPowQuotient
import Mathlib.RingTheory.Ideal.KrullsHeightTheorem
import Mathlib.RingTheory.Ideal.Lattice
import Mathlib.RingTheory.Ideal.Maps
import Mathlib.RingTheory.Ideal.Maximal
import Mathlib.RingTheory.Ideal.MinimalPrime.Basic
import Mathlib.RingTheory.Ideal.MinimalPrime.Localization
import Mathlib.RingTheory.Ideal.NatInt
import Mathlib.RingTheory.Ideal.Nonunits
import Mathlib.RingTheory.Ideal.Norm.AbsNorm
import Mathlib.RingTheory.Ideal.Norm.RelNorm
import Mathlib.RingTheory.Ideal.Operations
import Mathlib.RingTheory.Ideal.Over
import Mathlib.RingTheory.Ideal.Pointwise
import Mathlib.RingTheory.Ideal.Prime
import Mathlib.RingTheory.Ideal.Prod
import Mathlib.RingTheory.Ideal.Quotient.Basic
import Mathlib.RingTheory.Ideal.Quotient.Defs
import Mathlib.RingTheory.Ideal.Quotient.Index
import Mathlib.RingTheory.Ideal.Quotient.Nilpotent
import Mathlib.RingTheory.Ideal.Quotient.Noetherian
import Mathlib.RingTheory.Ideal.Quotient.Operations
import Mathlib.RingTheory.Ideal.Quotient.PowTransition
import Mathlib.RingTheory.Ideal.Span
import Mathlib.RingTheory.Idempotents
import Mathlib.RingTheory.Int.Basic
import Mathlib.RingTheory.IntegralClosure.Algebra.Basic
import Mathlib.RingTheory.IntegralClosure.Algebra.Defs
import Mathlib.RingTheory.IntegralClosure.IntegralRestrict
import Mathlib.RingTheory.IntegralClosure.IntegrallyClosed
import Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic
import Mathlib.RingTheory.IntegralClosure.IsIntegral.Defs
import Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic
import Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Defs
import Mathlib.RingTheory.IntegralDomain
import Mathlib.RingTheory.Invariant
import Mathlib.RingTheory.Invariant.Basic
import Mathlib.RingTheory.Invariant.Defs
import Mathlib.RingTheory.Invariant.Profinite
import Mathlib.RingTheory.IsAdjoinRoot
import Mathlib.RingTheory.IsPrimary
import Mathlib.RingTheory.IsTensorProduct
import Mathlib.RingTheory.Jacobson.Artinian
import Mathlib.RingTheory.Jacobson.Ideal
import Mathlib.RingTheory.Jacobson.Polynomial
import Mathlib.RingTheory.Jacobson.Radical
import Mathlib.RingTheory.Jacobson.Ring
import Mathlib.RingTheory.Jacobson.Semiprimary
import Mathlib.RingTheory.Kaehler.Basic
import Mathlib.RingTheory.Kaehler.CotangentComplex
import Mathlib.RingTheory.Kaehler.JacobiZariski
import Mathlib.RingTheory.Kaehler.Polynomial
import Mathlib.RingTheory.Kaehler.TensorProduct
import Mathlib.RingTheory.KrullDimension.Basic
import Mathlib.RingTheory.KrullDimension.Field
import Mathlib.RingTheory.KrullDimension.Module
import Mathlib.RingTheory.KrullDimension.NonZeroDivisors
import Mathlib.RingTheory.KrullDimension.PID
import Mathlib.RingTheory.KrullDimension.Polynomial
import Mathlib.RingTheory.KrullDimension.Zero
import Mathlib.RingTheory.Lasker
import Mathlib.RingTheory.LaurentSeries
import Mathlib.RingTheory.Length
import Mathlib.RingTheory.LinearDisjoint
import Mathlib.RingTheory.LittleWedderburn
import Mathlib.RingTheory.LocalProperties.Basic
import Mathlib.RingTheory.LocalProperties.Exactness
import Mathlib.RingTheory.LocalProperties.IntegrallyClosed
import Mathlib.RingTheory.LocalProperties.Projective
import Mathlib.RingTheory.LocalProperties.Reduced
import Mathlib.RingTheory.LocalProperties.Submodule
import Mathlib.RingTheory.LocalRing.Basic
import Mathlib.RingTheory.LocalRing.Defs
import Mathlib.RingTheory.LocalRing.LocalSubring
import Mathlib.RingTheory.LocalRing.MaximalIdeal.Basic
import Mathlib.RingTheory.LocalRing.MaximalIdeal.Defs
import Mathlib.RingTheory.LocalRing.Module
import Mathlib.RingTheory.LocalRing.NonLocalRing
import Mathlib.RingTheory.LocalRing.Quotient
import Mathlib.RingTheory.LocalRing.ResidueField.Algebraic
import Mathlib.RingTheory.LocalRing.ResidueField.Basic
import Mathlib.RingTheory.LocalRing.ResidueField.Defs
import Mathlib.RingTheory.LocalRing.ResidueField.Fiber
import Mathlib.RingTheory.LocalRing.ResidueField.Ideal
import Mathlib.RingTheory.LocalRing.ResidueField.Instances
import Mathlib.RingTheory.LocalRing.RingHom.Basic
import Mathlib.RingTheory.LocalRing.Subring
import Mathlib.RingTheory.Localization.Algebra
import Mathlib.RingTheory.Localization.AsSubring
import Mathlib.RingTheory.Localization.AtPrime
import Mathlib.RingTheory.Localization.AtPrime.Basic
import Mathlib.RingTheory.Localization.Away.AdjoinRoot
import Mathlib.RingTheory.Localization.Away.Basic
import Mathlib.RingTheory.Localization.Away.Lemmas
import Mathlib.RingTheory.Localization.BaseChange
import Mathlib.RingTheory.Localization.Basic
import Mathlib.RingTheory.Localization.Cardinality
import Mathlib.RingTheory.Localization.Defs
import Mathlib.RingTheory.Localization.Finiteness
import Mathlib.RingTheory.Localization.FractionRing
import Mathlib.RingTheory.Localization.Free
import Mathlib.RingTheory.Localization.Ideal
import Mathlib.RingTheory.Localization.Integer
import Mathlib.RingTheory.Localization.Integral
import Mathlib.RingTheory.Localization.InvSubmonoid
import Mathlib.RingTheory.Localization.LocalizationLocalization
import Mathlib.RingTheory.Localization.Module
import Mathlib.RingTheory.Localization.NormTrace
import Mathlib.RingTheory.Localization.NumDen
import Mathlib.RingTheory.Localization.Pi
import Mathlib.RingTheory.Localization.Submodule
import Mathlib.RingTheory.MatrixAlgebra
import Mathlib.RingTheory.MatrixPolynomialAlgebra
import Mathlib.RingTheory.Morita.Basic
import Mathlib.RingTheory.Multiplicity
import Mathlib.RingTheory.MvPolynomial
import Mathlib.RingTheory.MvPolynomial.Basic
import Mathlib.RingTheory.MvPolynomial.EulerIdentity
import Mathlib.RingTheory.MvPolynomial.FreeCommRing
import Mathlib.RingTheory.MvPolynomial.Groebner
import Mathlib.RingTheory.MvPolynomial.Homogeneous
import Mathlib.RingTheory.MvPolynomial.Ideal
import Mathlib.RingTheory.MvPolynomial.Localization
import Mathlib.RingTheory.MvPolynomial.MonomialOrder
import Mathlib.RingTheory.MvPolynomial.MonomialOrder.DegLex
import Mathlib.RingTheory.MvPolynomial.Symmetric.Defs
import Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem
import Mathlib.RingTheory.MvPolynomial.Symmetric.NewtonIdentities
import Mathlib.RingTheory.MvPolynomial.Tower
import Mathlib.RingTheory.MvPolynomial.WeightedHomogeneous
import Mathlib.RingTheory.MvPowerSeries.Basic
import Mathlib.RingTheory.MvPowerSeries.Evaluation
import Mathlib.RingTheory.MvPowerSeries.Inverse
import Mathlib.RingTheory.MvPowerSeries.LexOrder
import Mathlib.RingTheory.MvPowerSeries.LinearTopology
import Mathlib.RingTheory.MvPowerSeries.NoZeroDivisors
import Mathlib.RingTheory.MvPowerSeries.Order
import Mathlib.RingTheory.MvPowerSeries.PiTopology
import Mathlib.RingTheory.MvPowerSeries.Substitution
import Mathlib.RingTheory.MvPowerSeries.Trunc
import Mathlib.RingTheory.Nakayama
import Mathlib.RingTheory.Nilpotent.Basic
import Mathlib.RingTheory.Nilpotent.Defs
import Mathlib.RingTheory.Nilpotent.Exp
import Mathlib.RingTheory.Nilpotent.Lemmas
import Mathlib.RingTheory.NoetherNormalization
import Mathlib.RingTheory.Noetherian.Basic
import Mathlib.RingTheory.Noetherian.Defs
import Mathlib.RingTheory.Noetherian.Filter
import Mathlib.RingTheory.Noetherian.Nilpotent
import Mathlib.RingTheory.Noetherian.Orzech
import Mathlib.RingTheory.Noetherian.UniqueFactorizationDomain
import Mathlib.RingTheory.NonUnitalSubring.Basic
import Mathlib.RingTheory.NonUnitalSubring.Defs
import Mathlib.RingTheory.NonUnitalSubsemiring.Basic
import Mathlib.RingTheory.NonUnitalSubsemiring.Defs
import Mathlib.RingTheory.Norm.Basic
import Mathlib.RingTheory.Norm.Defs
import Mathlib.RingTheory.Norm.Transitivity
import Mathlib.RingTheory.NormTrace
import Mathlib.RingTheory.Nullstellensatz
import Mathlib.RingTheory.OrderOfVanishing
import Mathlib.RingTheory.OreLocalization.Basic
import Mathlib.RingTheory.OreLocalization.Cardinality
import Mathlib.RingTheory.OreLocalization.OreSet
import Mathlib.RingTheory.OreLocalization.Ring
import Mathlib.RingTheory.OrzechProperty
import Mathlib.RingTheory.Perfection
import Mathlib.RingTheory.Perfectoid.Untilt
import Mathlib.RingTheory.PiTensorProduct
import Mathlib.RingTheory.Polynomial.Basic
import Mathlib.RingTheory.Polynomial.Bernstein
import Mathlib.RingTheory.Polynomial.Chebyshev
import Mathlib.RingTheory.Polynomial.Content
import Mathlib.RingTheory.Polynomial.ContentIdeal
import Mathlib.RingTheory.Polynomial.Cyclotomic.Basic
import Mathlib.RingTheory.Polynomial.Cyclotomic.Eval
import Mathlib.RingTheory.Polynomial.Cyclotomic.Expand
import Mathlib.RingTheory.Polynomial.Cyclotomic.Roots
import Mathlib.RingTheory.Polynomial.DegreeLT
import Mathlib.RingTheory.Polynomial.Dickson
import Mathlib.RingTheory.Polynomial.Eisenstein.Basic
import Mathlib.RingTheory.Polynomial.Eisenstein.Criterion
import Mathlib.RingTheory.Polynomial.Eisenstein.Distinguished
import Mathlib.RingTheory.Polynomial.Eisenstein.Generalized
import Mathlib.RingTheory.Polynomial.Eisenstein.IsIntegral
import Mathlib.RingTheory.Polynomial.GaussLemma
import Mathlib.RingTheory.Polynomial.GaussNorm
import Mathlib.RingTheory.Polynomial.Hermite.Basic
import Mathlib.RingTheory.Polynomial.Hermite.Gaussian
import Mathlib.RingTheory.Polynomial.HilbertPoly
import Mathlib.RingTheory.Polynomial.Ideal
import Mathlib.RingTheory.Polynomial.IntegralNormalization
import Mathlib.RingTheory.Polynomial.IrreducibleRing
import Mathlib.RingTheory.Polynomial.Nilpotent
import Mathlib.RingTheory.Polynomial.Opposites
import Mathlib.RingTheory.Polynomial.Pochhammer
import Mathlib.RingTheory.Polynomial.Quotient
import Mathlib.RingTheory.Polynomial.Radical
import Mathlib.RingTheory.Polynomial.RationalRoot
import Mathlib.RingTheory.Polynomial.Resultant.Basic
import Mathlib.RingTheory.Polynomial.ScaleRoots
import Mathlib.RingTheory.Polynomial.Selmer
import Mathlib.RingTheory.Polynomial.SeparableDegree
import Mathlib.RingTheory.Polynomial.ShiftedLegendre
import Mathlib.RingTheory.Polynomial.SmallDegreeVieta
import Mathlib.RingTheory.Polynomial.Tower
import Mathlib.RingTheory.Polynomial.UniqueFactorization
import Mathlib.RingTheory.Polynomial.Vieta
import Mathlib.RingTheory.Polynomial.Wronskian
import Mathlib.RingTheory.PolynomialAlgebra
import Mathlib.RingTheory.PolynomialLaw.Basic
import Mathlib.RingTheory.PowerBasis
import Mathlib.RingTheory.PowerSeries.Basic
import Mathlib.RingTheory.PowerSeries.Binomial
import Mathlib.RingTheory.PowerSeries.CoeffMulMem
import Mathlib.RingTheory.PowerSeries.Derivative
import Mathlib.RingTheory.PowerSeries.Evaluation
import Mathlib.RingTheory.PowerSeries.GaussNorm
import Mathlib.RingTheory.PowerSeries.Inverse
import Mathlib.RingTheory.PowerSeries.NoZeroDivisors
import Mathlib.RingTheory.PowerSeries.Order
import Mathlib.RingTheory.PowerSeries.PiTopology
import Mathlib.RingTheory.PowerSeries.Substitution
import Mathlib.RingTheory.PowerSeries.Trunc
import Mathlib.RingTheory.PowerSeries.WeierstrassPreparation
import Mathlib.RingTheory.PowerSeries.WellKnown
import Mathlib.RingTheory.Presentation
import Mathlib.RingTheory.Prime
import Mathlib.RingTheory.PrincipalIdealDomain
import Mathlib.RingTheory.PrincipalIdealDomainOfPrime
import Mathlib.RingTheory.QuotSMulTop
import Mathlib.RingTheory.Radical
import Mathlib.RingTheory.ReesAlgebra
import Mathlib.RingTheory.Regular.Category
import Mathlib.RingTheory.Regular.Depth
import Mathlib.RingTheory.Regular.IsSMulRegular
import Mathlib.RingTheory.Regular.RegularSequence
import Mathlib.RingTheory.RingHom.Etale
import Mathlib.RingTheory.RingHom.Finite
import Mathlib.RingTheory.RingHom.FinitePresentation
import Mathlib.RingTheory.RingHom.FiniteType
import Mathlib.RingTheory.RingHom.Flat
import Mathlib.RingTheory.RingHom.Injective
import Mathlib.RingTheory.RingHom.Integral
import Mathlib.RingTheory.RingHom.Locally
import Mathlib.RingTheory.RingHom.Smooth
import Mathlib.RingTheory.RingHom.StandardSmooth
import Mathlib.RingTheory.RingHom.Surjective
import Mathlib.RingTheory.RingHom.Unramified
import Mathlib.RingTheory.RingHomProperties
import Mathlib.RingTheory.RingInvo
import Mathlib.RingTheory.RootsOfUnity.AlgebraicallyClosed
import Mathlib.RingTheory.RootsOfUnity.Basic
import Mathlib.RingTheory.RootsOfUnity.Complex
import Mathlib.RingTheory.RootsOfUnity.EnoughRootsOfUnity
import Mathlib.RingTheory.RootsOfUnity.Lemmas
import Mathlib.RingTheory.RootsOfUnity.Minpoly
import Mathlib.RingTheory.RootsOfUnity.PrimitiveRoots
import Mathlib.RingTheory.SimpleModule.Basic
import Mathlib.RingTheory.SimpleModule.InjectiveProjective
import Mathlib.RingTheory.SimpleModule.IsAlgClosed
import Mathlib.RingTheory.SimpleModule.Isotypic
import Mathlib.RingTheory.SimpleModule.Rank
import Mathlib.RingTheory.SimpleModule.WedderburnArtin
import Mathlib.RingTheory.SimpleRing.Basic
import Mathlib.RingTheory.SimpleRing.Congr
import Mathlib.RingTheory.SimpleRing.Defs
import Mathlib.RingTheory.SimpleRing.Field
import Mathlib.RingTheory.SimpleRing.Matrix
import Mathlib.RingTheory.SimpleRing.Principal
import Mathlib.RingTheory.Smooth.Basic
import Mathlib.RingTheory.Smooth.Kaehler
import Mathlib.RingTheory.Smooth.Local
import Mathlib.RingTheory.Smooth.Locus
import Mathlib.RingTheory.Smooth.Pi
import Mathlib.RingTheory.Smooth.StandardSmooth
import Mathlib.RingTheory.Smooth.StandardSmoothCotangent
import Mathlib.RingTheory.Spectrum.Maximal.Basic
import Mathlib.RingTheory.Spectrum.Maximal.Defs
import Mathlib.RingTheory.Spectrum.Maximal.Localization
import Mathlib.RingTheory.Spectrum.Maximal.Topology
import Mathlib.RingTheory.Spectrum.Prime.Basic
import Mathlib.RingTheory.Spectrum.Prime.Chevalley
import Mathlib.RingTheory.Spectrum.Prime.ChevalleyComplexity
import Mathlib.RingTheory.Spectrum.Prime.ConstructibleSet
import Mathlib.RingTheory.Spectrum.Prime.Defs
import Mathlib.RingTheory.Spectrum.Prime.FreeLocus
import Mathlib.RingTheory.Spectrum.Prime.Homeomorph
import Mathlib.RingTheory.Spectrum.Prime.IsOpenComapC
import Mathlib.RingTheory.Spectrum.Prime.Jacobson
import Mathlib.RingTheory.Spectrum.Prime.LTSeries
import Mathlib.RingTheory.Spectrum.Prime.Module
import Mathlib.RingTheory.Spectrum.Prime.Noetherian
import Mathlib.RingTheory.Spectrum.Prime.Polynomial
import Mathlib.RingTheory.Spectrum.Prime.RingHom
import Mathlib.RingTheory.Spectrum.Prime.TensorProduct
import Mathlib.RingTheory.Spectrum.Prime.Topology
import Mathlib.RingTheory.Support
import Mathlib.RingTheory.SurjectiveOnStalks
import Mathlib.RingTheory.TensorProduct.Basic
import Mathlib.RingTheory.TensorProduct.DirectLimitFG
import Mathlib.RingTheory.TensorProduct.Finite
import Mathlib.RingTheory.TensorProduct.Free
import Mathlib.RingTheory.TensorProduct.IsBaseChangePi
import Mathlib.RingTheory.TensorProduct.MvPolynomial
import Mathlib.RingTheory.TensorProduct.Nontrivial
import Mathlib.RingTheory.TensorProduct.Pi
import Mathlib.RingTheory.TensorProduct.Quotient
import Mathlib.RingTheory.Trace.Basic
import Mathlib.RingTheory.Trace.Defs
import Mathlib.RingTheory.Trace.Quotient
import Mathlib.RingTheory.TwoSidedIdeal.Basic
import Mathlib.RingTheory.TwoSidedIdeal.BigOperators
import Mathlib.RingTheory.TwoSidedIdeal.Instances
import Mathlib.RingTheory.TwoSidedIdeal.Kernel
import Mathlib.RingTheory.TwoSidedIdeal.Lattice
import Mathlib.RingTheory.TwoSidedIdeal.Operations
import Mathlib.RingTheory.UniqueFactorizationDomain.Basic
import Mathlib.RingTheory.UniqueFactorizationDomain.Defs
import Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet
import Mathlib.RingTheory.UniqueFactorizationDomain.Finite
import Mathlib.RingTheory.UniqueFactorizationDomain.Finsupp
import Mathlib.RingTheory.UniqueFactorizationDomain.GCDMonoid
import Mathlib.RingTheory.UniqueFactorizationDomain.Ideal
import Mathlib.RingTheory.UniqueFactorizationDomain.Multiplicative
import Mathlib.RingTheory.UniqueFactorizationDomain.Multiplicity
import Mathlib.RingTheory.UniqueFactorizationDomain.Nat
import Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors
import Mathlib.RingTheory.Unramified.Basic
import Mathlib.RingTheory.Unramified.Field
import Mathlib.RingTheory.Unramified.Finite
import Mathlib.RingTheory.Unramified.LocalRing
import Mathlib.RingTheory.Unramified.Locus
import Mathlib.RingTheory.Unramified.Pi
import Mathlib.RingTheory.Valuation.AlgebraInstances
import Mathlib.RingTheory.Valuation.Archimedean
import Mathlib.RingTheory.Valuation.Basic
import Mathlib.RingTheory.Valuation.Discrete.Basic
import Mathlib.RingTheory.Valuation.ExtendToLocalization
import Mathlib.RingTheory.Valuation.Extension
import Mathlib.RingTheory.Valuation.Integers
import Mathlib.RingTheory.Valuation.Integral
import Mathlib.RingTheory.Valuation.IntegrallyClosed
import Mathlib.RingTheory.Valuation.LocalSubring
import Mathlib.RingTheory.Valuation.Minpoly
import Mathlib.RingTheory.Valuation.PrimeMultiplicity
import Mathlib.RingTheory.Valuation.Quotient
import Mathlib.RingTheory.Valuation.RamificationGroup
import Mathlib.RingTheory.Valuation.RankOne
import Mathlib.RingTheory.Valuation.ValExtension
import Mathlib.RingTheory.Valuation.ValuationRing
import Mathlib.RingTheory.Valuation.ValuationSubring
import Mathlib.RingTheory.Valuation.ValuativeRel
import Mathlib.RingTheory.WittVector.Basic
import Mathlib.RingTheory.WittVector.Compare
import Mathlib.RingTheory.WittVector.Complete
import Mathlib.RingTheory.WittVector.Defs
import Mathlib.RingTheory.WittVector.DiscreteValuationRing
import Mathlib.RingTheory.WittVector.Domain
import Mathlib.RingTheory.WittVector.Frobenius
import Mathlib.RingTheory.WittVector.FrobeniusFractionField
import Mathlib.RingTheory.WittVector.Identities
import Mathlib.RingTheory.WittVector.InitTail
import Mathlib.RingTheory.WittVector.IsPoly
import Mathlib.RingTheory.WittVector.Isocrystal
import Mathlib.RingTheory.WittVector.MulCoeff
import Mathlib.RingTheory.WittVector.MulP
import Mathlib.RingTheory.WittVector.StructurePolynomial
import Mathlib.RingTheory.WittVector.Teichmuller
import Mathlib.RingTheory.WittVector.Truncated
import Mathlib.RingTheory.WittVector.Verschiebung
import Mathlib.RingTheory.WittVector.WittPolynomial
import Mathlib.RingTheory.ZMod
import Mathlib.RingTheory.ZMod.UnitsCyclic
import Mathlib.SetTheory.Cardinal.Aleph
import Mathlib.SetTheory.Cardinal.Arithmetic
import Mathlib.SetTheory.Cardinal.Basic
import Mathlib.SetTheory.Cardinal.Cofinality
import Mathlib.SetTheory.Cardinal.Continuum
import Mathlib.SetTheory.Cardinal.CountableCover
import Mathlib.SetTheory.Cardinal.Defs
import Mathlib.SetTheory.Cardinal.Divisibility
import Mathlib.SetTheory.Cardinal.ENat
import Mathlib.SetTheory.Cardinal.Embedding
import Mathlib.SetTheory.Cardinal.Finite
import Mathlib.SetTheory.Cardinal.Finsupp
import Mathlib.SetTheory.Cardinal.Free
import Mathlib.SetTheory.Cardinal.HasCardinalLT
import Mathlib.SetTheory.Cardinal.NatCount
import Mathlib.SetTheory.Cardinal.Order
import Mathlib.SetTheory.Cardinal.Ordinal
import Mathlib.SetTheory.Cardinal.Pigeonhole
import Mathlib.SetTheory.Cardinal.Regular
import Mathlib.SetTheory.Cardinal.SchroederBernstein
import Mathlib.SetTheory.Cardinal.Subfield
import Mathlib.SetTheory.Cardinal.ToNat
import Mathlib.SetTheory.Cardinal.UnivLE
import Mathlib.SetTheory.Descriptive.Tree
import Mathlib.SetTheory.Game.Basic
import Mathlib.SetTheory.Game.Birthday
import Mathlib.SetTheory.Game.Domineering
import Mathlib.SetTheory.Game.Impartial
import Mathlib.SetTheory.Game.Nim
import Mathlib.SetTheory.Game.Ordinal
import Mathlib.SetTheory.Game.Short
import Mathlib.SetTheory.Game.State
import Mathlib.SetTheory.Lists
import Mathlib.SetTheory.Nimber.Basic
import Mathlib.SetTheory.Nimber.Field
import Mathlib.SetTheory.Ordinal.Arithmetic
import Mathlib.SetTheory.Ordinal.Basic
import Mathlib.SetTheory.Ordinal.CantorNormalForm
import Mathlib.SetTheory.Ordinal.Enum
import Mathlib.SetTheory.Ordinal.Exponential
import Mathlib.SetTheory.Ordinal.Family
import Mathlib.SetTheory.Ordinal.FixedPoint
import Mathlib.SetTheory.Ordinal.FixedPointApproximants
import Mathlib.SetTheory.Ordinal.NaturalOps
import Mathlib.SetTheory.Ordinal.Notation
import Mathlib.SetTheory.Ordinal.Principal
import Mathlib.SetTheory.Ordinal.Rank
import Mathlib.SetTheory.Ordinal.Topology
import Mathlib.SetTheory.Ordinal.Veblen
import Mathlib.SetTheory.PGame.Algebra
import Mathlib.SetTheory.PGame.Basic
import Mathlib.SetTheory.PGame.Order
import Mathlib.SetTheory.Surreal.Basic
import Mathlib.SetTheory.Surreal.Dyadic
import Mathlib.SetTheory.Surreal.Multiplication
import Mathlib.SetTheory.ZFC.Basic
import Mathlib.SetTheory.ZFC.Class
import Mathlib.SetTheory.ZFC.Ordinal
import Mathlib.SetTheory.ZFC.PSet
import Mathlib.SetTheory.ZFC.Rank
import Mathlib.SetTheory.ZFC.VonNeumann
import Mathlib.Std.Data.HashMap
import Mathlib.Tactic
import Mathlib.Tactic.Abel
import Mathlib.Tactic.AdaptationNote
import Mathlib.Tactic.Algebraize
import Mathlib.Tactic.ApplyAt
import Mathlib.Tactic.ApplyCongr
import Mathlib.Tactic.ApplyFun
import Mathlib.Tactic.ApplyWith
import Mathlib.Tactic.ArithMult
import Mathlib.Tactic.ArithMult.Init
import Mathlib.Tactic.Attr.Core
import Mathlib.Tactic.Attr.Register
import Mathlib.Tactic.Basic
import Mathlib.Tactic.Bound
import Mathlib.Tactic.Bound.Attribute
import Mathlib.Tactic.Bound.Init
import Mathlib.Tactic.ByContra
import Mathlib.Tactic.CC
import Mathlib.Tactic.CC.Addition
import Mathlib.Tactic.CC.Datatypes
import Mathlib.Tactic.CC.Lemmas
import Mathlib.Tactic.CC.MkProof
import Mathlib.Tactic.CancelDenoms
import Mathlib.Tactic.CancelDenoms.Core
import Mathlib.Tactic.Cases
import Mathlib.Tactic.CasesM
import Mathlib.Tactic.CategoryTheory.BicategoricalComp
import Mathlib.Tactic.CategoryTheory.Bicategory.Basic
import Mathlib.Tactic.CategoryTheory.Bicategory.Datatypes
import Mathlib.Tactic.CategoryTheory.Bicategory.Normalize
import Mathlib.Tactic.CategoryTheory.Bicategory.PureCoherence
import Mathlib.Tactic.CategoryTheory.BicategoryCoherence
import Mathlib.Tactic.CategoryTheory.CheckCompositions
import Mathlib.Tactic.CategoryTheory.Coherence
import Mathlib.Tactic.CategoryTheory.Coherence.Basic
import Mathlib.Tactic.CategoryTheory.Coherence.Datatypes
import Mathlib.Tactic.CategoryTheory.Coherence.Normalize
import Mathlib.Tactic.CategoryTheory.Coherence.PureCoherence
import Mathlib.Tactic.CategoryTheory.Elementwise
import Mathlib.Tactic.CategoryTheory.IsoReassoc
import Mathlib.Tactic.CategoryTheory.Monoidal.Basic
import Mathlib.Tactic.CategoryTheory.Monoidal.Datatypes
import Mathlib.Tactic.CategoryTheory.Monoidal.Normalize
import Mathlib.Tactic.CategoryTheory.Monoidal.PureCoherence
import Mathlib.Tactic.CategoryTheory.MonoidalComp
import Mathlib.Tactic.CategoryTheory.Reassoc
import Mathlib.Tactic.CategoryTheory.Slice
import Mathlib.Tactic.CategoryTheory.ToApp
import Mathlib.Tactic.Change
import Mathlib.Tactic.Check
import Mathlib.Tactic.Choose
import Mathlib.Tactic.Clean
import Mathlib.Tactic.ClearExcept
import Mathlib.Tactic.ClearExclamation
import Mathlib.Tactic.Clear_
import Mathlib.Tactic.Coe
import Mathlib.Tactic.Common
import Mathlib.Tactic.ComputeDegree
import Mathlib.Tactic.CongrExclamation
import Mathlib.Tactic.CongrM
import Mathlib.Tactic.Constructor
import Mathlib.Tactic.Continuity
import Mathlib.Tactic.Continuity.Init
import Mathlib.Tactic.ContinuousFunctionalCalculus
import Mathlib.Tactic.Contrapose
import Mathlib.Tactic.Conv
import Mathlib.Tactic.Convert
import Mathlib.Tactic.Core
import Mathlib.Tactic.DeclarationNames
import Mathlib.Tactic.DefEqTransformations
import Mathlib.Tactic.DepRewrite
import Mathlib.Tactic.DeprecateTo
import Mathlib.Tactic.DeriveCountable
import Mathlib.Tactic.DeriveEncodable
import Mathlib.Tactic.DeriveFintype
import Mathlib.Tactic.DeriveTraversable
import Mathlib.Tactic.ENatToNat
import Mathlib.Tactic.Eqns
import Mathlib.Tactic.ErwQuestion
import Mathlib.Tactic.Eval
import Mathlib.Tactic.ExistsI
import Mathlib.Tactic.Explode
import Mathlib.Tactic.Explode.Datatypes
import Mathlib.Tactic.Explode.Pretty
import Mathlib.Tactic.ExtendDoc
import Mathlib.Tactic.ExtractGoal
import Mathlib.Tactic.ExtractLets
import Mathlib.Tactic.FBinop
import Mathlib.Tactic.FailIfNoProgress
import Mathlib.Tactic.FastInstance
import Mathlib.Tactic.FieldSimp
import Mathlib.Tactic.FinCases
import Mathlib.Tactic.Find
import Mathlib.Tactic.FindSyntax
import Mathlib.Tactic.Finiteness
import Mathlib.Tactic.Finiteness.Attr
import Mathlib.Tactic.FunProp
import Mathlib.Tactic.FunProp.Attr
import Mathlib.Tactic.FunProp.ContDiff
import Mathlib.Tactic.FunProp.Core
import Mathlib.Tactic.FunProp.Decl
import Mathlib.Tactic.FunProp.Differentiable
import Mathlib.Tactic.FunProp.Elab
import Mathlib.Tactic.FunProp.FunctionData
import Mathlib.Tactic.FunProp.Mor
import Mathlib.Tactic.FunProp.Theorems
import Mathlib.Tactic.FunProp.ToBatteries
import Mathlib.Tactic.FunProp.Types
import Mathlib.Tactic.GCongr
import Mathlib.Tactic.GCongr.Core
import Mathlib.Tactic.GCongr.CoreAttrs
import Mathlib.Tactic.GCongr.ForwardAttr
import Mathlib.Tactic.GRewrite
import Mathlib.Tactic.GRewrite.Core
import Mathlib.Tactic.GRewrite.Elab
import Mathlib.Tactic.Generalize
import Mathlib.Tactic.GeneralizeProofs
import Mathlib.Tactic.Group
import Mathlib.Tactic.GuardGoalNums
import Mathlib.Tactic.GuardHypNums
import Mathlib.Tactic.Have
import Mathlib.Tactic.HaveI
import Mathlib.Tactic.HigherOrder
import Mathlib.Tactic.Hint
import Mathlib.Tactic.ITauto
import Mathlib.Tactic.InferParam
import Mathlib.Tactic.Inhabit
import Mathlib.Tactic.IntervalCases
import Mathlib.Tactic.IrreducibleDef
import Mathlib.Tactic.Lemma
import Mathlib.Tactic.Lift
import Mathlib.Tactic.LiftLets
import Mathlib.Tactic.Linarith
import Mathlib.Tactic.Linarith.Datatypes
import Mathlib.Tactic.Linarith.Frontend
import Mathlib.Tactic.Linarith.Lemmas
import Mathlib.Tactic.Linarith.Oracle.FourierMotzkin
import Mathlib.Tactic.Linarith.Oracle.SimplexAlgorithm
import Mathlib.Tactic.Linarith.Oracle.SimplexAlgorithm.Datatypes
import Mathlib.Tactic.Linarith.Oracle.SimplexAlgorithm.Gauss
import Mathlib.Tactic.Linarith.Oracle.SimplexAlgorithm.PositiveVector
import Mathlib.Tactic.Linarith.Oracle.SimplexAlgorithm.SimplexAlgorithm
import Mathlib.Tactic.Linarith.Parsing
import Mathlib.Tactic.Linarith.Preprocessing
import Mathlib.Tactic.Linarith.Verification
import Mathlib.Tactic.LinearCombination
import Mathlib.Tactic.LinearCombination'
import Mathlib.Tactic.LinearCombination.Lemmas
import Mathlib.Tactic.Linter
import Mathlib.Tactic.Linter.CommandStart
import Mathlib.Tactic.Linter.DeprecatedModule
import Mathlib.Tactic.Linter.DeprecatedSyntaxLinter
import Mathlib.Tactic.Linter.DirectoryDependency
import Mathlib.Tactic.Linter.DocPrime
import Mathlib.Tactic.Linter.DocString
import Mathlib.Tactic.Linter.FlexibleLinter
import Mathlib.Tactic.Linter.GlobalAttributeIn
import Mathlib.Tactic.Linter.HashCommandLinter
import Mathlib.Tactic.Linter.HaveLetLinter
import Mathlib.Tactic.Linter.Header
import Mathlib.Tactic.Linter.Lint
import Mathlib.Tactic.Linter.MinImports
import Mathlib.Tactic.Linter.Multigoal
import Mathlib.Tactic.Linter.OldObtain
import Mathlib.Tactic.Linter.PPRoundtrip
import Mathlib.Tactic.Linter.Style
import Mathlib.Tactic.Linter.TextBased
import Mathlib.Tactic.Linter.UnusedTactic
import Mathlib.Tactic.Linter.UnusedTacticExtension
import Mathlib.Tactic.Linter.UpstreamableDecl
import Mathlib.Tactic.Measurability
import Mathlib.Tactic.Measurability.Init
import Mathlib.Tactic.MinImports
import Mathlib.Tactic.MkIffOfInductiveProp
import Mathlib.Tactic.ModCases
import Mathlib.Tactic.Module
import Mathlib.Tactic.Monotonicity
import Mathlib.Tactic.Monotonicity.Attr
import Mathlib.Tactic.Monotonicity.Basic
import Mathlib.Tactic.Monotonicity.Lemmas
import Mathlib.Tactic.MoveAdd
import Mathlib.Tactic.NoncommRing
import Mathlib.Tactic.Nontriviality
import Mathlib.Tactic.Nontriviality.Core
import Mathlib.Tactic.NormNum
import Mathlib.Tactic.NormNum.Basic
import Mathlib.Tactic.NormNum.BigOperators
import Mathlib.Tactic.NormNum.Core
import Mathlib.Tactic.NormNum.DivMod
import Mathlib.Tactic.NormNum.Eq
import Mathlib.Tactic.NormNum.GCD
import Mathlib.Tactic.NormNum.Ineq
import Mathlib.Tactic.NormNum.Inv
import Mathlib.Tactic.NormNum.Irrational
import Mathlib.Tactic.NormNum.IsCoprime
import Mathlib.Tactic.NormNum.LegendreSymbol
import Mathlib.Tactic.NormNum.NatFactorial
import Mathlib.Tactic.NormNum.NatFib
import Mathlib.Tactic.NormNum.NatLog
import Mathlib.Tactic.NormNum.NatSqrt
import Mathlib.Tactic.NormNum.OfScientific
import Mathlib.Tactic.NormNum.Ordinal
import Mathlib.Tactic.NormNum.Pow
import Mathlib.Tactic.NormNum.PowMod
import Mathlib.Tactic.NormNum.Prime
import Mathlib.Tactic.NormNum.RealSqrt
import Mathlib.Tactic.NormNum.Result
import Mathlib.Tactic.NthRewrite
import Mathlib.Tactic.Observe
import Mathlib.Tactic.OfNat
import Mathlib.Tactic.Order
import Mathlib.Tactic.Order.CollectFacts
import Mathlib.Tactic.Order.Graph.Basic
import Mathlib.Tactic.Order.Graph.Tarjan
import Mathlib.Tactic.Order.Preprocessing
import Mathlib.Tactic.PNatToNat
import Mathlib.Tactic.PPWithUniv
import Mathlib.Tactic.Peel
import Mathlib.Tactic.Polyrith
import Mathlib.Tactic.Positivity
import Mathlib.Tactic.Positivity.Basic
import Mathlib.Tactic.Positivity.Core
import Mathlib.Tactic.Positivity.Finset
import Mathlib.Tactic.ProdAssoc
import Mathlib.Tactic.Propose
import Mathlib.Tactic.ProxyType
import Mathlib.Tactic.Push
import Mathlib.Tactic.Qify
import Mathlib.Tactic.RSuffices
import Mathlib.Tactic.Recall
import Mathlib.Tactic.Recover
import Mathlib.Tactic.ReduceModChar
import Mathlib.Tactic.ReduceModChar.Ext
import Mathlib.Tactic.Relation.Rfl
import Mathlib.Tactic.Relation.Symm
import Mathlib.Tactic.Rename
import Mathlib.Tactic.RenameBVar
import Mathlib.Tactic.Replace
import Mathlib.Tactic.RewriteSearch
import Mathlib.Tactic.Rify
import Mathlib.Tactic.Ring
import Mathlib.Tactic.Ring.Basic
import Mathlib.Tactic.Ring.Compare
import Mathlib.Tactic.Ring.NamePolyVars
import Mathlib.Tactic.Ring.PNat
import Mathlib.Tactic.Ring.RingNF
import Mathlib.Tactic.Sat.FromLRAT
import Mathlib.Tactic.Says
import Mathlib.Tactic.ScopedNS
import Mathlib.Tactic.Set
import Mathlib.Tactic.SetLike
import Mathlib.Tactic.SimpIntro
import Mathlib.Tactic.SimpRw
import Mathlib.Tactic.Simproc.Divisors
import Mathlib.Tactic.Simproc.ExistsAndEq
import Mathlib.Tactic.Simproc.Factors
import Mathlib.Tactic.Simps.Basic
import Mathlib.Tactic.Simps.NotationClass
import Mathlib.Tactic.SplitIfs
import Mathlib.Tactic.Spread
import Mathlib.Tactic.StacksAttribute
import Mathlib.Tactic.Subsingleton
import Mathlib.Tactic.Substs
import Mathlib.Tactic.SuccessIfFailWithMsg
import Mathlib.Tactic.SudoSetOption
import Mathlib.Tactic.SuppressCompilation
import Mathlib.Tactic.SwapVar
import Mathlib.Tactic.TFAE
import Mathlib.Tactic.Tauto
import Mathlib.Tactic.TautoSet
import Mathlib.Tactic.TermCongr
import Mathlib.Tactic.ToAdditive
import Mathlib.Tactic.ToAdditive.Frontend
import Mathlib.Tactic.ToExpr
import Mathlib.Tactic.ToLevel
import Mathlib.Tactic.Trace
import Mathlib.Tactic.TryThis
import Mathlib.Tactic.TypeCheck
import Mathlib.Tactic.TypeStar
import Mathlib.Tactic.UnsetOption
import Mathlib.Tactic.Use
import Mathlib.Tactic.Variable
import Mathlib.Tactic.WLOG
import Mathlib.Tactic.Widget.Calc
import Mathlib.Tactic.Widget.CommDiag
import Mathlib.Tactic.Widget.CongrM
import Mathlib.Tactic.Widget.Conv
import Mathlib.Tactic.Widget.GCongr
import Mathlib.Tactic.Widget.InteractiveUnfold
import Mathlib.Tactic.Widget.LibraryRewrite
import Mathlib.Tactic.Widget.SelectInsertParamsClass
import Mathlib.Tactic.Widget.SelectPanelUtils
import Mathlib.Tactic.Widget.StringDiagram
import Mathlib.Tactic.WithoutCDot
import Mathlib.Tactic.Zify
import Mathlib.Testing.Plausible.Functions
import Mathlib.Testing.Plausible.Sampleable
import Mathlib.Testing.Plausible.Testable
import Mathlib.Topology.AlexandrovDiscrete
import Mathlib.Topology.Algebra.Affine
import Mathlib.Topology.Algebra.AffineSubspace
import Mathlib.Topology.Algebra.Algebra
import Mathlib.Topology.Algebra.Algebra.Equiv
import Mathlib.Topology.Algebra.Algebra.Rat
import Mathlib.Topology.Algebra.Category.ProfiniteGrp.Basic
import Mathlib.Topology.Algebra.Category.ProfiniteGrp.Limits
import Mathlib.Topology.Algebra.ClopenNhdofOne
import Mathlib.Topology.Algebra.ClosedSubgroup
import Mathlib.Topology.Algebra.ConstMulAction
import Mathlib.Topology.Algebra.Constructions
import Mathlib.Topology.Algebra.Constructions.DomMulAct
import Mathlib.Topology.Algebra.ContinuousAffineMap
import Mathlib.Topology.Algebra.ContinuousMonoidHom
import Mathlib.Topology.Algebra.Equicontinuity
import Mathlib.Topology.Algebra.Field
import Mathlib.Topology.Algebra.FilterBasis
import Mathlib.Topology.Algebra.Group.Basic
import Mathlib.Topology.Algebra.Group.ClosedSubgroup
import Mathlib.Topology.Algebra.Group.Compact
import Mathlib.Topology.Algebra.Group.CompactOpen
import Mathlib.Topology.Algebra.Group.Defs
import Mathlib.Topology.Algebra.Group.GroupTopology
import Mathlib.Topology.Algebra.Group.OpenMapping
import Mathlib.Topology.Algebra.Group.Pointwise
import Mathlib.Topology.Algebra.Group.Quotient
import Mathlib.Topology.Algebra.Group.SubmonoidClosure
import Mathlib.Topology.Algebra.Group.TopologicalAbelianization
import Mathlib.Topology.Algebra.GroupCompletion
import Mathlib.Topology.Algebra.GroupWithZero
import Mathlib.Topology.Algebra.Indicator
import Mathlib.Topology.Algebra.InfiniteSum.Basic
import Mathlib.Topology.Algebra.InfiniteSum.Constructions
import Mathlib.Topology.Algebra.InfiniteSum.Defs
import Mathlib.Topology.Algebra.InfiniteSum.ENNReal
import Mathlib.Topology.Algebra.InfiniteSum.Field
import Mathlib.Topology.Algebra.InfiniteSum.Group
import Mathlib.Topology.Algebra.InfiniteSum.GroupCompletion
import Mathlib.Topology.Algebra.InfiniteSum.Module
import Mathlib.Topology.Algebra.InfiniteSum.NatInt
import Mathlib.Topology.Algebra.InfiniteSum.Nonarchimedean
import Mathlib.Topology.Algebra.InfiniteSum.Order
import Mathlib.Topology.Algebra.InfiniteSum.Real
import Mathlib.Topology.Algebra.InfiniteSum.Ring
import Mathlib.Topology.Algebra.InfiniteSum.UniformOn
import Mathlib.Topology.Algebra.IntermediateField
import Mathlib.Topology.Algebra.IsOpenUnits
import Mathlib.Topology.Algebra.IsUniformGroup.Basic
import Mathlib.Topology.Algebra.IsUniformGroup.Defs
import Mathlib.Topology.Algebra.IsUniformGroup.Order
import Mathlib.Topology.Algebra.LinearTopology
import Mathlib.Topology.Algebra.Localization
import Mathlib.Topology.Algebra.MetricSpace.Lipschitz
import Mathlib.Topology.Algebra.Module.Alternating.Basic
import Mathlib.Topology.Algebra.Module.Alternating.Topology
import Mathlib.Topology.Algebra.Module.Basic
import Mathlib.Topology.Algebra.Module.Cardinality
import Mathlib.Topology.Algebra.Module.CharacterSpace
import Mathlib.Topology.Algebra.Module.ClosedSubmodule
import Mathlib.Topology.Algebra.Module.Compact
import Mathlib.Topology.Algebra.Module.Determinant
import Mathlib.Topology.Algebra.Module.Equiv
import Mathlib.Topology.Algebra.Module.FiniteDimension
import Mathlib.Topology.Algebra.Module.LinearMap
import Mathlib.Topology.Algebra.Module.LinearMapPiProd
import Mathlib.Topology.Algebra.Module.LinearPMap
import Mathlib.Topology.Algebra.Module.LocallyConvex
import Mathlib.Topology.Algebra.Module.ModuleTopology
import Mathlib.Topology.Algebra.Module.Multilinear.Basic
import Mathlib.Topology.Algebra.Module.Multilinear.Bounded
import Mathlib.Topology.Algebra.Module.Multilinear.Topology
import Mathlib.Topology.Algebra.Module.PerfectPairing
import Mathlib.Topology.Algebra.Module.PerfectSpace
import Mathlib.Topology.Algebra.Module.Simple
import Mathlib.Topology.Algebra.Module.Star
import Mathlib.Topology.Algebra.Module.StrongTopology
import Mathlib.Topology.Algebra.Module.UniformConvergence
import Mathlib.Topology.Algebra.Module.WeakBilin
import Mathlib.Topology.Algebra.Module.WeakDual
import Mathlib.Topology.Algebra.Monoid
import Mathlib.Topology.Algebra.Monoid.AddChar
import Mathlib.Topology.Algebra.Monoid.Defs
import Mathlib.Topology.Algebra.MulAction
import Mathlib.Topology.Algebra.MvPolynomial
import Mathlib.Topology.Algebra.NonUnitalAlgebra
import Mathlib.Topology.Algebra.NonUnitalStarAlgebra
import Mathlib.Topology.Algebra.Nonarchimedean.AdicTopology
import Mathlib.Topology.Algebra.Nonarchimedean.Bases
import Mathlib.Topology.Algebra.Nonarchimedean.Basic
import Mathlib.Topology.Algebra.Nonarchimedean.Completion
import Mathlib.Topology.Algebra.Nonarchimedean.TotallyDisconnected
import Mathlib.Topology.Algebra.OpenSubgroup
import Mathlib.Topology.Algebra.Order.Archimedean
import Mathlib.Topology.Algebra.Order.Field
import Mathlib.Topology.Algebra.Order.Floor
import Mathlib.Topology.Algebra.Order.Group
import Mathlib.Topology.Algebra.Order.LiminfLimsup
import Mathlib.Topology.Algebra.Order.Module
import Mathlib.Topology.Algebra.Order.Support
import Mathlib.Topology.Algebra.Order.UpperLower
import Mathlib.Topology.Algebra.Polynomial
import Mathlib.Topology.Algebra.PontryaginDual
import Mathlib.Topology.Algebra.ProperAction.Basic
import Mathlib.Topology.Algebra.ProperAction.ProperlyDiscontinuous
import Mathlib.Topology.Algebra.ProperConstSMul
import Mathlib.Topology.Algebra.RestrictedProduct
import Mathlib.Topology.Algebra.RestrictedProduct.Basic
import Mathlib.Topology.Algebra.RestrictedProduct.TopologicalSpace
import Mathlib.Topology.Algebra.Ring.Basic
import Mathlib.Topology.Algebra.Ring.Compact
import Mathlib.Topology.Algebra.Ring.Ideal
import Mathlib.Topology.Algebra.Ring.Real
import Mathlib.Topology.Algebra.Semigroup
import Mathlib.Topology.Algebra.SeparationQuotient.Basic
import Mathlib.Topology.Algebra.SeparationQuotient.FiniteDimensional
import Mathlib.Topology.Algebra.SeparationQuotient.Hom
import Mathlib.Topology.Algebra.SeparationQuotient.Section
import Mathlib.Topology.Algebra.Star
import Mathlib.Topology.Algebra.Star.Real
import Mathlib.Topology.Algebra.Star.Unitary
import Mathlib.Topology.Algebra.StarSubalgebra
import Mathlib.Topology.Algebra.Support
import Mathlib.Topology.Algebra.TopologicallyNilpotent
import Mathlib.Topology.Algebra.UniformConvergence
import Mathlib.Topology.Algebra.UniformField
import Mathlib.Topology.Algebra.UniformFilterBasis
import Mathlib.Topology.Algebra.UniformMulAction
import Mathlib.Topology.Algebra.UniformRing
import Mathlib.Topology.Algebra.Valued.LocallyCompact
import Mathlib.Topology.Algebra.Valued.NormedValued
import Mathlib.Topology.Algebra.Valued.ValuationTopology
import Mathlib.Topology.Algebra.Valued.ValuativeRel
import Mathlib.Topology.Algebra.Valued.ValuedField
import Mathlib.Topology.Algebra.Valued.WithVal
import Mathlib.Topology.Algebra.Valued.WithZeroMulInt
import Mathlib.Topology.Algebra.WithZeroTopology
import Mathlib.Topology.ApproximateUnit
import Mathlib.Topology.Baire.BaireMeasurable
import Mathlib.Topology.Baire.CompleteMetrizable
import Mathlib.Topology.Baire.Lemmas
import Mathlib.Topology.Baire.LocallyCompactRegular
import Mathlib.Topology.Bases
import Mathlib.Topology.Basic
import Mathlib.Topology.Bornology.Absorbs
import Mathlib.Topology.Bornology.Basic
import Mathlib.Topology.Bornology.BoundedOperation
import Mathlib.Topology.Bornology.Constructions
import Mathlib.Topology.Bornology.Hom
import Mathlib.Topology.Bornology.Real
import Mathlib.Topology.CWComplex.Abstract.Basic
import Mathlib.Topology.CWComplex.Classical.Basic
import Mathlib.Topology.CWComplex.Classical.Finite
import Mathlib.Topology.Category.Born
import Mathlib.Topology.Category.CompHaus.Basic
import Mathlib.Topology.Category.CompHaus.EffectiveEpi
import Mathlib.Topology.Category.CompHaus.Frm
import Mathlib.Topology.Category.CompHaus.Limits
import Mathlib.Topology.Category.CompHaus.Projective
import Mathlib.Topology.Category.CompHausLike.Basic
import Mathlib.Topology.Category.CompHausLike.EffectiveEpi
import Mathlib.Topology.Category.CompHausLike.Limits
import Mathlib.Topology.Category.CompHausLike.SigmaComparison
import Mathlib.Topology.Category.CompactlyGenerated
import Mathlib.Topology.Category.Compactum
import Mathlib.Topology.Category.DeltaGenerated
import Mathlib.Topology.Category.FinTopCat
import Mathlib.Topology.Category.LightProfinite.AsLimit
import Mathlib.Topology.Category.LightProfinite.Basic
import Mathlib.Topology.Category.LightProfinite.EffectiveEpi
import Mathlib.Topology.Category.LightProfinite.Extend
import Mathlib.Topology.Category.LightProfinite.Limits
import Mathlib.Topology.Category.LightProfinite.Sequence
import Mathlib.Topology.Category.Locale
import Mathlib.Topology.Category.Profinite.AsLimit
import Mathlib.Topology.Category.Profinite.Basic
import Mathlib.Topology.Category.Profinite.CofilteredLimit
import Mathlib.Topology.Category.Profinite.EffectiveEpi
import Mathlib.Topology.Category.Profinite.Extend
import Mathlib.Topology.Category.Profinite.Limits
import Mathlib.Topology.Category.Profinite.Nobeling
import Mathlib.Topology.Category.Profinite.Nobeling.Basic
import Mathlib.Topology.Category.Profinite.Nobeling.Induction
import Mathlib.Topology.Category.Profinite.Nobeling.Span
import Mathlib.Topology.Category.Profinite.Nobeling.Successor
import Mathlib.Topology.Category.Profinite.Nobeling.ZeroLimit
import Mathlib.Topology.Category.Profinite.Product
import Mathlib.Topology.Category.Profinite.Projective
import Mathlib.Topology.Category.Sequential
import Mathlib.Topology.Category.Stonean.Adjunctions
import Mathlib.Topology.Category.Stonean.Basic
import Mathlib.Topology.Category.Stonean.EffectiveEpi
import Mathlib.Topology.Category.Stonean.Limits
import Mathlib.Topology.Category.TopCat.Adjunctions
import Mathlib.Topology.Category.TopCat.Basic
import Mathlib.Topology.Category.TopCat.EffectiveEpi
import Mathlib.Topology.Category.TopCat.EpiMono
import Mathlib.Topology.Category.TopCat.Limits.Basic
import Mathlib.Topology.Category.TopCat.Limits.Cofiltered
import Mathlib.Topology.Category.TopCat.Limits.Konig
import Mathlib.Topology.Category.TopCat.Limits.Products
import Mathlib.Topology.Category.TopCat.Limits.Pullbacks
import Mathlib.Topology.Category.TopCat.OpenNhds
import Mathlib.Topology.Category.TopCat.Opens
import Mathlib.Topology.Category.TopCat.Sphere
import Mathlib.Topology.Category.TopCat.ULift
import Mathlib.Topology.Category.TopCat.Yoneda
import Mathlib.Topology.Category.TopCommRingCat
import Mathlib.Topology.Category.UniformSpace
import Mathlib.Topology.Clopen
import Mathlib.Topology.ClopenBox
import Mathlib.Topology.Closure
import Mathlib.Topology.ClusterPt
import Mathlib.Topology.Coherent
import Mathlib.Topology.CompactOpen
import Mathlib.Topology.Compactification.OnePoint
import Mathlib.Topology.Compactification.OnePoint.Basic
import Mathlib.Topology.Compactification.OnePoint.ProjectiveLine
import Mathlib.Topology.Compactification.OnePoint.Sphere
import Mathlib.Topology.Compactification.OnePointEquiv
import Mathlib.Topology.Compactification.StoneCech
import Mathlib.Topology.Compactness.Bases
import Mathlib.Topology.Compactness.Compact
import Mathlib.Topology.Compactness.CompactlyCoherentSpace
import Mathlib.Topology.Compactness.CompactlyGeneratedSpace
import Mathlib.Topology.Compactness.DeltaGeneratedSpace
import Mathlib.Topology.Compactness.Exterior
import Mathlib.Topology.Compactness.HilbertCubeEmbedding
import Mathlib.Topology.Compactness.Lindelof
import Mathlib.Topology.Compactness.LocallyCompact
import Mathlib.Topology.Compactness.LocallyFinite
import Mathlib.Topology.Compactness.NhdsKer
import Mathlib.Topology.Compactness.Paracompact
import Mathlib.Topology.Compactness.PseudometrizableLindelof
import Mathlib.Topology.Compactness.SigmaCompact
import Mathlib.Topology.Connected.Basic
import Mathlib.Topology.Connected.Clopen
import Mathlib.Topology.Connected.LocPathConnected
import Mathlib.Topology.Connected.LocallyConnected
import Mathlib.Topology.Connected.PathComponentOne
import Mathlib.Topology.Connected.PathConnected
import Mathlib.Topology.Connected.Separation
import Mathlib.Topology.Connected.TotallyDisconnected
import Mathlib.Topology.Constructible
import Mathlib.Topology.Constructions
import Mathlib.Topology.Constructions.SumProd
import Mathlib.Topology.Continuous
import Mathlib.Topology.ContinuousMap.Algebra
import Mathlib.Topology.ContinuousMap.Basic
import Mathlib.Topology.ContinuousMap.Bounded.ArzelaAscoli
import Mathlib.Topology.ContinuousMap.Bounded.Basic
import Mathlib.Topology.ContinuousMap.Bounded.Normed
import Mathlib.Topology.ContinuousMap.Bounded.Star
import Mathlib.Topology.ContinuousMap.BoundedCompactlySupported
import Mathlib.Topology.ContinuousMap.CocompactMap
import Mathlib.Topology.ContinuousMap.Compact
import Mathlib.Topology.ContinuousMap.CompactlySupported
import Mathlib.Topology.ContinuousMap.ContinuousMapZero
import Mathlib.Topology.ContinuousMap.ContinuousSqrt
import Mathlib.Topology.ContinuousMap.Defs
import Mathlib.Topology.ContinuousMap.Ideals
import Mathlib.Topology.ContinuousMap.Interval
import Mathlib.Topology.ContinuousMap.Lattice
import Mathlib.Topology.ContinuousMap.LocallyConstant
import Mathlib.Topology.ContinuousMap.LocallyConvex
import Mathlib.Topology.ContinuousMap.Ordered
import Mathlib.Topology.ContinuousMap.Periodic
import Mathlib.Topology.ContinuousMap.Polynomial
import Mathlib.Topology.ContinuousMap.SecondCountableSpace
import Mathlib.Topology.ContinuousMap.Sigma
import Mathlib.Topology.ContinuousMap.Star
import Mathlib.Topology.ContinuousMap.StarOrdered
import Mathlib.Topology.ContinuousMap.StoneWeierstrass
import Mathlib.Topology.ContinuousMap.T0Sierpinski
import Mathlib.Topology.ContinuousMap.Units
import Mathlib.Topology.ContinuousMap.Weierstrass
import Mathlib.Topology.ContinuousMap.ZeroAtInfty
import Mathlib.Topology.ContinuousOn
import Mathlib.Topology.Covering
import Mathlib.Topology.Defs.Basic
import Mathlib.Topology.Defs.Filter
import Mathlib.Topology.Defs.Induced
import Mathlib.Topology.Defs.Sequences
import Mathlib.Topology.Defs.Ultrafilter
import Mathlib.Topology.DenseEmbedding
import Mathlib.Topology.DerivedSet
import Mathlib.Topology.DiscreteQuotient
import Mathlib.Topology.DiscreteSubset
import Mathlib.Topology.EMetricSpace.Basic
import Mathlib.Topology.EMetricSpace.BoundedVariation
import Mathlib.Topology.EMetricSpace.Defs
import Mathlib.Topology.EMetricSpace.Diam
import Mathlib.Topology.EMetricSpace.Lipschitz
import Mathlib.Topology.EMetricSpace.Paracompact
import Mathlib.Topology.EMetricSpace.Pi
import Mathlib.Topology.ExtendFrom
import Mathlib.Topology.Exterior
import Mathlib.Topology.ExtremallyDisconnected
import Mathlib.Topology.FiberBundle.Basic
import Mathlib.Topology.FiberBundle.Constructions
import Mathlib.Topology.FiberBundle.IsHomeomorphicTrivialBundle
import Mathlib.Topology.FiberBundle.Trivialization
import Mathlib.Topology.FiberPartition
import Mathlib.Topology.Filter
import Mathlib.Topology.GDelta.Basic
import Mathlib.Topology.GDelta.MetrizableSpace
import Mathlib.Topology.GDelta.UniformSpace
import Mathlib.Topology.Germ
import Mathlib.Topology.Gluing
import Mathlib.Topology.Hom.ContinuousEval
import Mathlib.Topology.Hom.ContinuousEvalConst
import Mathlib.Topology.Hom.Open
import Mathlib.Topology.Homeomorph.Defs
import Mathlib.Topology.Homeomorph.Lemmas
import Mathlib.Topology.Homotopy.Basic
import Mathlib.Topology.Homotopy.Contractible
import Mathlib.Topology.Homotopy.Equiv
import Mathlib.Topology.Homotopy.HSpaces
import Mathlib.Topology.Homotopy.HomotopyGroup
import Mathlib.Topology.Homotopy.Lifting
import Mathlib.Topology.Homotopy.Path
import Mathlib.Topology.Homotopy.Product
import Mathlib.Topology.IndicatorConstPointwise
import Mathlib.Topology.Inseparable
import Mathlib.Topology.Instances.AddCircle.Defs
import Mathlib.Topology.Instances.AddCircle.DenseSubgroup
import Mathlib.Topology.Instances.AddCircle.Real
import Mathlib.Topology.Instances.CantorSet
import Mathlib.Topology.Instances.Complex
import Mathlib.Topology.Instances.Discrete
import Mathlib.Topology.Instances.ENNReal.Lemmas
import Mathlib.Topology.Instances.ENat
import Mathlib.Topology.Instances.EReal.Lemmas
import Mathlib.Topology.Instances.Int
import Mathlib.Topology.Instances.Irrational
import Mathlib.Topology.Instances.Matrix
import Mathlib.Topology.Instances.NNReal.Lemmas
import Mathlib.Topology.Instances.Nat
import Mathlib.Topology.Instances.PNat
import Mathlib.Topology.Instances.Rat
import Mathlib.Topology.Instances.RatLemmas
import Mathlib.Topology.Instances.Real.Lemmas
import Mathlib.Topology.Instances.RealVectorSpace
import Mathlib.Topology.Instances.Shrink
import Mathlib.Topology.Instances.Sign
import Mathlib.Topology.Instances.TrivSqZeroExt
import Mathlib.Topology.Instances.ZMod
import Mathlib.Topology.Instances.ZMultiples
import Mathlib.Topology.Irreducible
import Mathlib.Topology.IsClosedRestrict
import Mathlib.Topology.IsLocalHomeomorph
import Mathlib.Topology.JacobsonSpace
import Mathlib.Topology.KrullDimension
import Mathlib.Topology.List
import Mathlib.Topology.LocalAtTarget
import Mathlib.Topology.LocallyClosed
import Mathlib.Topology.LocallyConstant.Algebra
import Mathlib.Topology.LocallyConstant.Basic
import Mathlib.Topology.LocallyFinite
import Mathlib.Topology.LocallyFinsupp
import Mathlib.Topology.Maps.Basic
import Mathlib.Topology.Maps.OpenQuotient
import Mathlib.Topology.Maps.Proper.Basic
import Mathlib.Topology.Maps.Proper.CompactlyGenerated
import Mathlib.Topology.Maps.Proper.UniversallyClosed
import Mathlib.Topology.MetricSpace.Algebra
import Mathlib.Topology.MetricSpace.Antilipschitz
import Mathlib.Topology.MetricSpace.Basic
import Mathlib.Topology.MetricSpace.Bilipschitz
import Mathlib.Topology.MetricSpace.Bounded
import Mathlib.Topology.MetricSpace.BundledFun
import Mathlib.Topology.MetricSpace.CantorScheme
import Mathlib.Topology.MetricSpace.CauSeqFilter
import Mathlib.Topology.MetricSpace.Cauchy
import Mathlib.Topology.MetricSpace.Closeds
import Mathlib.Topology.MetricSpace.Completion
import Mathlib.Topology.MetricSpace.Congruence
import Mathlib.Topology.MetricSpace.Contracting
import Mathlib.Topology.MetricSpace.Defs
import Mathlib.Topology.MetricSpace.Dilation
import Mathlib.Topology.MetricSpace.DilationEquiv
import Mathlib.Topology.MetricSpace.Equicontinuity
import Mathlib.Topology.MetricSpace.Gluing
import Mathlib.Topology.MetricSpace.GromovHausdorff
import Mathlib.Topology.MetricSpace.GromovHausdorffRealized
import Mathlib.Topology.MetricSpace.HausdorffDimension
import Mathlib.Topology.MetricSpace.HausdorffDistance
import Mathlib.Topology.MetricSpace.Holder
import Mathlib.Topology.MetricSpace.HolderNorm
import Mathlib.Topology.MetricSpace.Infsep
import Mathlib.Topology.MetricSpace.IsometricSMul
import Mathlib.Topology.MetricSpace.Isometry
import Mathlib.Topology.MetricSpace.Kuratowski
import Mathlib.Topology.MetricSpace.Lipschitz
import Mathlib.Topology.MetricSpace.MetricSeparated
import Mathlib.Topology.MetricSpace.PartitionOfUnity
import Mathlib.Topology.MetricSpace.Perfect
import Mathlib.Topology.MetricSpace.PiNat
import Mathlib.Topology.MetricSpace.Polish
import Mathlib.Topology.MetricSpace.ProperSpace
import Mathlib.Topology.MetricSpace.ProperSpace.Lemmas
import Mathlib.Topology.MetricSpace.ProperSpace.Real
import Mathlib.Topology.MetricSpace.Pseudo.Basic
import Mathlib.Topology.MetricSpace.Pseudo.Constructions
import Mathlib.Topology.MetricSpace.Pseudo.Defs
import Mathlib.Topology.MetricSpace.Pseudo.Lemmas
import Mathlib.Topology.MetricSpace.Pseudo.Pi
import Mathlib.Topology.MetricSpace.Pseudo.Real
import Mathlib.Topology.MetricSpace.Sequences
import Mathlib.Topology.MetricSpace.ShrinkingLemma
import Mathlib.Topology.MetricSpace.Similarity
import Mathlib.Topology.MetricSpace.ThickenedIndicator
import Mathlib.Topology.MetricSpace.Thickening
import Mathlib.Topology.MetricSpace.Ultra.Basic
import Mathlib.Topology.MetricSpace.Ultra.ContinuousMaps
import Mathlib.Topology.MetricSpace.Ultra.Pi
import Mathlib.Topology.MetricSpace.Ultra.TotallySeparated
import Mathlib.Topology.MetricSpace.UniformConvergence
import Mathlib.Topology.Metrizable.Basic
import Mathlib.Topology.Metrizable.CompletelyMetrizable
import Mathlib.Topology.Metrizable.ContinuousMap
import Mathlib.Topology.Metrizable.Real
import Mathlib.Topology.Metrizable.Uniformity
import Mathlib.Topology.Metrizable.Urysohn
import Mathlib.Topology.Neighborhoods
import Mathlib.Topology.NhdsKer
import Mathlib.Topology.NhdsSet
import Mathlib.Topology.NoetherianSpace
import Mathlib.Topology.OmegaCompletePartialOrder
import Mathlib.Topology.Order
import Mathlib.Topology.Order.Basic
import Mathlib.Topology.Order.Bornology
import Mathlib.Topology.Order.Category.AlexDisc
import Mathlib.Topology.Order.Category.FrameAdjunction
import Mathlib.Topology.Order.Compact
import Mathlib.Topology.Order.CountableSeparating
import Mathlib.Topology.Order.DenselyOrdered
import Mathlib.Topology.Order.ExtendFrom
import Mathlib.Topology.Order.ExtrClosure
import Mathlib.Topology.Order.Filter
import Mathlib.Topology.Order.Hom.Basic
import Mathlib.Topology.Order.Hom.Esakia
import Mathlib.Topology.Order.HullKernel
import Mathlib.Topology.Order.IntermediateValue
import Mathlib.Topology.Order.IsLUB
import Mathlib.Topology.Order.IsLocallyClosed
import Mathlib.Topology.Order.Lattice
import Mathlib.Topology.Order.LawsonTopology
import Mathlib.Topology.Order.LeftRight
import Mathlib.Topology.Order.LeftRightLim
import Mathlib.Topology.Order.LeftRightNhds
import Mathlib.Topology.Order.LiminfLimsup
import Mathlib.Topology.Order.LocalExtr
import Mathlib.Topology.Order.LowerUpperTopology
import Mathlib.Topology.Order.Monotone
import Mathlib.Topology.Order.MonotoneContinuity
import Mathlib.Topology.Order.MonotoneConvergence
import Mathlib.Topology.Order.NhdsSet
import Mathlib.Topology.Order.OrderClosed
import Mathlib.Topology.Order.OrderClosedExtr
import Mathlib.Topology.Order.PartialSups
import Mathlib.Topology.Order.Priestley
import Mathlib.Topology.Order.ProjIcc
import Mathlib.Topology.Order.Real
import Mathlib.Topology.Order.Rolle
import Mathlib.Topology.Order.ScottTopology
import Mathlib.Topology.Order.T5
import Mathlib.Topology.Order.UpperLowerSetTopology
import Mathlib.Topology.Partial
import Mathlib.Topology.PartialHomeomorph
import Mathlib.Topology.PartitionOfUnity
import Mathlib.Topology.Path
import Mathlib.Topology.Perfect
import Mathlib.Topology.Piecewise
import Mathlib.Topology.PreorderRestrict
import Mathlib.Topology.QuasiSeparated
import Mathlib.Topology.Semicontinuous
import Mathlib.Topology.SeparatedMap
import Mathlib.Topology.Separation.AlexandrovDiscrete
import Mathlib.Topology.Separation.Basic
import Mathlib.Topology.Separation.CompletelyRegular
import Mathlib.Topology.Separation.Connected
import Mathlib.Topology.Separation.CountableSeparatingOn
import Mathlib.Topology.Separation.DisjointCover
import Mathlib.Topology.Separation.GDelta
import Mathlib.Topology.Separation.Hausdorff
import Mathlib.Topology.Separation.NotNormal
import Mathlib.Topology.Separation.Profinite
import Mathlib.Topology.Separation.Regular
import Mathlib.Topology.Separation.SeparatedNhds
import Mathlib.Topology.Sequences
import Mathlib.Topology.Sets.Closeds
import Mathlib.Topology.Sets.CompactOpenCovered
import Mathlib.Topology.Sets.Compacts
import Mathlib.Topology.Sets.OpenCover
import Mathlib.Topology.Sets.Opens
import Mathlib.Topology.Sets.Order
import Mathlib.Topology.Sheaves.Alexandrov
import Mathlib.Topology.Sheaves.CommRingCat
import Mathlib.Topology.Sheaves.Forget
import Mathlib.Topology.Sheaves.Functors
import Mathlib.Topology.Sheaves.Init
import Mathlib.Topology.Sheaves.Limits
import Mathlib.Topology.Sheaves.LocalPredicate
import Mathlib.Topology.Sheaves.LocallySurjective
import Mathlib.Topology.Sheaves.MayerVietoris
import Mathlib.Topology.Sheaves.PUnit
import Mathlib.Topology.Sheaves.Presheaf
import Mathlib.Topology.Sheaves.PresheafOfFunctions
import Mathlib.Topology.Sheaves.Sheaf
import Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts
import Mathlib.Topology.Sheaves.SheafCondition.OpensLeCover
import Mathlib.Topology.Sheaves.SheafCondition.PairwiseIntersections
import Mathlib.Topology.Sheaves.SheafCondition.Sites
import Mathlib.Topology.Sheaves.SheafCondition.UniqueGluing
import Mathlib.Topology.Sheaves.SheafOfFunctions
import Mathlib.Topology.Sheaves.Sheafify
import Mathlib.Topology.Sheaves.Skyscraper
import Mathlib.Topology.Sheaves.Stalks
import Mathlib.Topology.ShrinkingLemma
import Mathlib.Topology.Sober
import Mathlib.Topology.Specialization
import Mathlib.Topology.Spectral.Basic
import Mathlib.Topology.Spectral.Hom
import Mathlib.Topology.Spectral.Prespectral
import Mathlib.Topology.StoneCech
import Mathlib.Topology.TietzeExtension
import Mathlib.Topology.Ultrafilter
import Mathlib.Topology.UniformSpace.AbsoluteValue
import Mathlib.Topology.UniformSpace.AbstractCompletion
import Mathlib.Topology.UniformSpace.Ascoli
import Mathlib.Topology.UniformSpace.Basic
import Mathlib.Topology.UniformSpace.Cauchy
import Mathlib.Topology.UniformSpace.Compact
import Mathlib.Topology.UniformSpace.CompactConvergence
import Mathlib.Topology.UniformSpace.CompareReals
import Mathlib.Topology.UniformSpace.CompleteSeparated
import Mathlib.Topology.UniformSpace.Completion
import Mathlib.Topology.UniformSpace.Defs
import Mathlib.Topology.UniformSpace.Dini
import Mathlib.Topology.UniformSpace.DiscreteUniformity
import Mathlib.Topology.UniformSpace.Equicontinuity
import Mathlib.Topology.UniformSpace.Equiv
import Mathlib.Topology.UniformSpace.HeineCantor
import Mathlib.Topology.UniformSpace.LocallyUniformConvergence
import Mathlib.Topology.UniformSpace.Matrix
import Mathlib.Topology.UniformSpace.OfCompactT2
import Mathlib.Topology.UniformSpace.OfFun
import Mathlib.Topology.UniformSpace.Pi
import Mathlib.Topology.UniformSpace.ProdApproximation
import Mathlib.Topology.UniformSpace.Real
import Mathlib.Topology.UniformSpace.Separation
import Mathlib.Topology.UniformSpace.Ultra.Basic
import Mathlib.Topology.UniformSpace.Ultra.Constructions
import Mathlib.Topology.UniformSpace.UniformApproximation
import Mathlib.Topology.UniformSpace.UniformConvergence
import Mathlib.Topology.UniformSpace.UniformConvergenceTopology
import Mathlib.Topology.UniformSpace.UniformEmbedding
import Mathlib.Topology.UnitInterval
import Mathlib.Topology.UrysohnsBounded
import Mathlib.Topology.UrysohnsLemma
import Mathlib.Topology.VectorBundle.Basic
import Mathlib.Topology.VectorBundle.Constructions
import Mathlib.Topology.VectorBundle.Hom
import Mathlib.Topology.VectorBundle.Riemannian
import Mathlib.Util.AddRelatedDecl
import Mathlib.Util.AssertExists
import Mathlib.Util.AssertExistsExt
import Mathlib.Util.AssertNoSorry
import Mathlib.Util.AtomM
import Mathlib.Util.CompileInductive
import Mathlib.Util.CountHeartbeats
import Mathlib.Util.Delaborators
import Mathlib.Util.DischargerAsTactic
import Mathlib.Util.Export
import Mathlib.Util.FormatTable
import Mathlib.Util.GetAllModules
import Mathlib.Util.LongNames
import Mathlib.Util.MemoFix
import Mathlib.Util.Notation3
import Mathlib.Util.PPOptions
import Mathlib.Util.ParseCommand
import Mathlib.Util.Qq
import Mathlib.Util.Simp
import Mathlib.Util.SleepHeartbeats
import Mathlib.Util.Superscript
import Mathlib.Util.SynthesizeUsing
import Mathlib.Util.Tactic
import Mathlib.Util.TermReduce
import Mathlib.Util.TransImports
import Mathlib.Util.WhatsNew
import Mathlib.Util.WithWeakNamespace



=== LEAN SOURCE: Arithcc.lean ===
/-
Copyright (c) 2020 Xi Wang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Xi Wang
-/
import Mathlib.Data.Nat.Basic
import Mathlib.Order.Basic
import Mathlib.Tactic.Common

/-!
# A compiler for arithmetic expressions

A formalization of the correctness of a compiler from arithmetic expressions to machine language
described by McCarthy and Painter, which is considered the first proof of compiler correctness.

## Main definitions

* `Expr`       : the syntax of the source language.
* `value`      : the semantics of the source language.
* `Instruction`: the syntax of the target language.
* `step`       : the semantics of the target language.
* `compile`    : the compiler.

## Main results

* `compiler_correctness`: the compiler correctness theorem.

## Notation

* `≃[t]/ac`: partial equality of two machine states excluding registers x ≥ t and the accumulator.
* `≃[t]`   : partial equality of two machine states excluding registers x ≥ t.

## References

* John McCarthy and James Painter. Correctness of a compiler for arithmetic expressions.
  In Mathematical Aspects of Computer Science, volume 19 of Proceedings of Symposia in
  Applied Mathematics. American Mathematical Society, 1967.
  <http://jmc.stanford.edu/articles/mcpain/mcpain.pdf>

## Tags

compiler
-/


namespace Arithcc

section Types

/-! ### Types -/


/-- Value type shared by both source and target languages. -/
abbrev Word :=
  ℕ

/-- Variable identifier type in the source language. -/
abbrev Identifier :=
  String

/-- Register name type in the target language. -/
abbrev Register :=
  ℕ

theorem Register.lt_succ_self : ∀ r : Register, r < r + 1 :=
  Nat.lt_succ_self

theorem Register.le_of_lt_succ {r₁ r₂ : Register} : r₁ < r₂ + 1 → r₁ ≤ r₂ :=
  Nat.le_of_succ_le_succ

end Types

section Source

/-! ### Source language -/


/-- An expression in the source language is formed by constants, variables, and sums. -/
inductive Expr
  | const (v : Word) : Expr
  | var (x : Identifier) : Expr
  | sum (s₁ s₂ : Expr) : Expr
  deriving Inhabited

/-- The semantics of the source language (2.1). -/
@[simp]
def value : Expr → (Identifier → Word) → Word
  | Expr.const v, _ => v
  | Expr.var x, ξ => ξ x
  | Expr.sum s₁ s₂, ξ => value s₁ ξ + value s₂ ξ

end Source

section Target

/-! ### Target language -/


/-- Instructions of the target machine language (3.1--3.7). -/
inductive Instruction
  | li : Word → Instruction
  | load : Register → Instruction
  | sto : Register → Instruction
  | add : Register → Instruction
  deriving Inhabited

/-- Machine state consists of the accumulator and a vector of registers.

The paper uses two functions `c` and `a` for accessing both the accumulator and registers.
For clarity, we make accessing the accumulator explicit and use `read`/`write` for registers.
-/
structure State where mk ::
  ac : Word
  rs : Register → Word

instance : Inhabited State :=
  ⟨{  ac := 0
      rs := fun _ => 0 }⟩

/-- This is similar to the `c` function (3.8), but for registers only. -/
@[simp]
def read (r : Register) (η : State) : Word :=
  η.rs r

/-- This is similar to the `a` function (3.9), but for registers only. -/
@[simp]
def write (r : Register) (v : Word) (η : State) : State :=
  { η with rs := fun x => if x = r then v else η.rs x }

/-- The semantics of the target language (3.11). -/
def step : Instruction → State → State
  | Instruction.li v, η => { η with ac := v }
  | Instruction.load r, η => { η with ac := read r η }
  | Instruction.sto r, η => write r η.ac η
  | Instruction.add r, η => { η with ac := read r η + η.ac }

/-- The resulting machine state of running a target program from a given machine state (3.12). -/
@[simp]
def outcome : List Instruction → State → State
  | [], η => η
  | i :: is, η => outcome is (step i η)

/-- A lemma on the concatenation of two programs (3.13). -/
@[simp]
theorem outcome_append (p₁ p₂ : List Instruction) (η : State) :
    outcome (p₁ ++ p₂) η = outcome p₂ (outcome p₁ η) := by
  induction p₁ generalizing η with
  | nil => simp
  | cons _ _ p₁_ih => simp [p₁_ih]

end Target

section Compiler

open Instruction

/-! ### Compiler -/


/-- Map a variable in the source expression to a machine register. -/
@[simp]
def loc (ν : Identifier) (map : Identifier → Register) : Register :=
  map ν

/-- The implementation of the compiler (4.2).

This definition explicitly takes a map from variables to registers.
-/
@[simp↓]
def compile (map : Identifier → Register) : Expr → Register → List Instruction
  | Expr.const v, _ => [li v]
  | Expr.var x, _ => [load (loc x map)]
  | Expr.sum s₁ s₂, t => compile map s₁ t ++ [sto t] ++ compile map s₂ (t + 1) ++ [add t]

end Compiler

section Correctness

/-! ### Correctness -/


/-- Machine states ζ₁ and ζ₂ are equal except for the accumulator and registers {x | x ≥ t}. -/
def StateEqRs (t : Register) (ζ₁ ζ₂ : State) : Prop :=
  ∀ r : Register, r < t → ζ₁.rs r = ζ₂.rs r

notation:50 ζ₁ " ≃[" t "]/ac " ζ₂:50 => StateEqRs t ζ₁ ζ₂

@[refl]
protected theorem StateEqRs.refl (t : Register) (ζ : State) : ζ ≃[t]/ac ζ := by simp [StateEqRs]

@[symm]
protected theorem StateEqRs.symm {t : Register} (ζ₁ ζ₂ : State) :
    ζ₁ ≃[t]/ac ζ₂ → ζ₂ ≃[t]/ac ζ₁ := by
  simp_all [StateEqRs]

@[trans]
protected theorem StateEqRs.trans {t : Register} (ζ₁ ζ₂ ζ₃ : State) :
    ζ₁ ≃[t]/ac ζ₂ → ζ₂ ≃[t]/ac ζ₃ → ζ₁ ≃[t]/ac ζ₃ := by
  simp_all [StateEqRs]

/-- Machine states ζ₁ and ζ₂ are equal except for registers {x | x ≥ t}. -/
def StateEq (t : Register) (ζ₁ ζ₂ : State) : Prop :=
  ζ₁.ac = ζ₂.ac ∧ StateEqRs t ζ₁ ζ₂

notation:50 ζ₁ " ≃[" t "] " ζ₂:50 => StateEq t ζ₁ ζ₂

@[refl]
protected theorem StateEq.refl (t : Register) (ζ : State) : ζ ≃[t] ζ := by simp [StateEq]; rfl

@[symm]
protected theorem StateEq.symm {t : Register} (ζ₁ ζ₂ : State) : ζ₁ ≃[t] ζ₂ → ζ₂ ≃[t] ζ₁ := by
  simp [StateEq]; intros
  constructor <;> (symm; assumption)

@[trans]
protected theorem StateEq.trans {t : Register} (ζ₁ ζ₂ ζ₃ : State) :
    ζ₁ ≃[t] ζ₂ → ζ₂ ≃[t] ζ₃ → ζ₁ ≃[t] ζ₃ := by
  simp [StateEq]; intros
  constructor
  · simp_all only
  · trans ζ₂ <;> assumption

instance (t : Register) : Trans (StateEq (t + 1)) (StateEq (t + 1)) (StateEq (t + 1)) :=
  ⟨@StateEq.trans _⟩

/-- Transitivity of chaining `≃[t]` and `≃[t]/ac`. -/
@[trans]
protected theorem StateEqStateEqRs.trans (t : Register) (ζ₁ ζ₂ ζ₃ : State) :
    ζ₁ ≃[t] ζ₂ → ζ₂ ≃[t]/ac ζ₃ → ζ₁ ≃[t]/ac ζ₃ := by
  simp [StateEq]; intros
  trans ζ₂ <;> assumption

instance (t : Register) : Trans (StateEq (t + 1)) (StateEqRs (t + 1)) (StateEqRs (t + 1)) :=
  ⟨@StateEqStateEqRs.trans _⟩

/-- Writing the same value to register `t` gives `≃[t + 1]` from `≃[t]`. -/
theorem stateEq_implies_write_eq {t : Register} {ζ₁ ζ₂ : State} (h : ζ₁ ≃[t] ζ₂) (v : Word) :
    write t v ζ₁ ≃[t + 1] write t v ζ₂ := by
  simp [StateEq, StateEqRs] at *
  constructor; · exact h.1
  intro r hr
  have hr : r ≤ t := Register.le_of_lt_succ hr
  rcases lt_or_eq_of_le hr with hr | hr
  · obtain ⟨_, h⟩ := h
    specialize h r hr
    simp_all
  · simp_all

/-- Writing the same value to any register preserves `≃[t]/ac`. -/
theorem stateEqRs_implies_write_eq_rs {t : Register} {ζ₁ ζ₂ : State} (h : ζ₁ ≃[t]/ac ζ₂)
    (r : Register) (v : Word) : write r v ζ₁ ≃[t]/ac write r v ζ₂ := by
  simp [StateEqRs] at *
  intro r' hr'
  specialize h r' hr'
  congr

/-- `≃[t + 1]` with writing to register `t` implies `≃[t]`. -/
theorem write_eq_implies_stateEq {t : Register} {v : Word} {ζ₁ ζ₂ : State}
    (h : ζ₁ ≃[t + 1] write t v ζ₂) : ζ₁ ≃[t] ζ₂ := by
  simp [StateEq, StateEqRs] at *
  constructor; · exact h.1
  intro r hr
  obtain ⟨_, h⟩ := h
  specialize h r (lt_trans hr (Register.lt_succ_self _))
  rwa [if_neg (ne_of_lt hr)] at h

/-- The main **compiler correctness theorem**.

Unlike Theorem 1 in the paper, both `map` and the assumption on `t` are explicit.
-/
theorem compiler_correctness
    (map : Identifier → Register) (e : Expr) (ξ : Identifier → Word) (η : State) (t : Register)
    (hmap : ∀ x, read (loc x map) η = ξ x) (ht : ∀ x, loc x map < t) :
    outcome (compile map e t) η ≃[t] { η with ac := value e ξ } := by
  induction e generalizing η t with
  -- 5.I
  | const => simp [StateEq, step]; rfl
  -- 5.II
  | var =>
    simp_all [StateEq, StateEqRs, step]
  -- 5.III
  | sum =>
    rename_i e_s₁ e_s₂ e_ih_s₁ e_ih_s₂
    simp only [compile, List.append_assoc, List.cons_append, outcome_append, outcome, value]
    generalize value e_s₁ ξ = ν₁ at e_ih_s₁ ⊢
    generalize value e_s₂ ξ = ν₂ at e_ih_s₂ ⊢
    generalize dν : ν₁ + ν₂ = ν
    generalize dζ₁ : outcome (compile _ e_s₁ t) η = ζ₁
    generalize dζ₂ : step (Instruction.sto t) ζ₁ = ζ₂
    generalize dζ₃ : outcome (compile _ e_s₂ (t + 1)) ζ₂ = ζ₃
    generalize dζ₄ : step (Instruction.add t) ζ₃ = ζ₄
    have hζ₁ : ζ₁ ≃[t] { η with ac := ν₁ } := calc
      ζ₁ = outcome (compile map e_s₁ t) η := by simp_all
      _ ≃[t] { η with ac := ν₁ } := by apply e_ih_s₁ <;> assumption
    have hζ₁_ν₁ : ζ₁.ac = ν₁ := by simp_all [StateEq]
    have hζ₂ : ζ₂ ≃[t + 1]/ac write t ν₁ η := calc
      ζ₂ = step (Instruction.sto t) ζ₁ := by simp_all
      _ = write t ζ₁.ac ζ₁ := by simp [step]
      _ = write t ν₁ ζ₁ := by simp_all
      _ ≃[t + 1] write t ν₁ { η with ac := ν₁ } := by apply stateEq_implies_write_eq hζ₁
      _ ≃[t + 1]/ac write t ν₁ η := by
        apply stateEqRs_implies_write_eq_rs
        simp [StateEqRs]
    have ht' : ∀ x, loc x map < t + 1 := by
      intros
      apply lt_trans (ht _) (Register.lt_succ_self _)
    have hmap' : ∀ x, read (loc x map) ζ₂ = ξ x := by
      intro x
      calc
        read (loc x map) ζ₂ = read (loc x map) (write t ν₁ η) := hζ₂ _ (ht' _)
        _ = read (loc x map) η := by simp only [loc] at ht; simp [(ht _).ne]
        _ = ξ x := hmap x
    have hζ₃ : ζ₃ ≃[t + 1] { write t ν₁ η with ac := ν₂ } := calc
      ζ₃ = outcome (compile map e_s₂ (t + 1)) ζ₂ := by simp_all
      _ ≃[t + 1] { ζ₂ with ac := ν₂ } := by apply e_ih_s₂ <;> assumption
      _ ≃[t + 1] { write t ν₁ η with ac := ν₂ } := by simp [StateEq]; apply hζ₂
    have hζ₃_ν₂ : ζ₃.ac = ν₂ := by simp_all [StateEq]
    have hζ₃_ν₁ : read t ζ₃ = ν₁ := by
      simp [StateEq, StateEqRs] at hζ₃ ⊢
      obtain ⟨_, hζ₃⟩ := hζ₃
      specialize hζ₃ t (Register.lt_succ_self _)
      simp_all
    have hζ₄ : ζ₄ ≃[t + 1] { write t ν₁ η with ac := ν } := calc
      ζ₄ = step (Instruction.add t) ζ₃ := by simp_all
      _  = { ζ₃ with ac := read t ζ₃ + ζ₃.ac } := by simp [step]
      _  = { ζ₃ with ac := ν } := by simp_all
      _  ≃[t + 1] { { write t ν₁ η with ac := ν₂ } with ac := ν } := by
        simp [StateEq] at hζ₃ ⊢; cases hζ₃; assumption
      _  ≃[t + 1] { write t ν₁ η with ac := ν } := by simp_all; rfl
    apply write_eq_implies_stateEq <;> assumption

end Correctness

section Test

open Instruction

/-- The example in the paper for compiling (x + 3) + (x + (y + 2)). -/
example (x y t : Register) :
    let map v := if v = "x" then x else if v = "y" then y else 0
    let p :=
      Expr.sum (Expr.sum (Expr.var "x") (Expr.const 3))
        (Expr.sum (Expr.var "x") (Expr.sum (Expr.var "y") (Expr.const 2)))
    compile map p t =
      [load x, sto t, li 3, add t, sto t, load x, sto (t + 1), load y, sto (t + 2), li 2,
        add (t + 2), add (t + 1), add t] :=
  rfl

end Test

end Arithcc



=== LEAN SOURCE: Hairer.lean ===
/-
Copyright (c) 2023 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin, Sébastien Gouëzel, Patrick Massot, Ruben Van de Velde, Floris van Doorn,
Junyan Xu
-/
import Mathlib.Algebra.MvPolynomial.Funext
import Mathlib.Analysis.Analytic.Polynomial
import Mathlib.Analysis.Analytic.Uniqueness
import Mathlib.Analysis.Distribution.AEEqOfIntegralContDiff
import Mathlib.LinearAlgebra.Dual.Lemmas
import Mathlib.RingTheory.MvPolynomial.Basic
import Mathlib.Topology.Algebra.MvPolynomial

/-!
# Smooth functions whose integral calculates the values of polynomials

In any space `ℝᵈ` and given any `N`, we construct a smooth function supported in the unit ball
whose integral against a multivariate polynomial `P` of total degree at most `N` is `P 0`.

This is a test of the state of the library suggested by Martin Hairer.
-/

noncomputable section

open Metric Set MeasureTheory
open MvPolynomial hiding support
open Function hiding eval
open scoped ContDiff

variable {ι : Type*} [Fintype ι]

section normed
variable {𝕜 E F : Type*} [NontriviallyNormedField 𝕜]
variable [NormedAddCommGroup E] [NormedSpace 𝕜 E] [NormedAddCommGroup F] [NormedSpace 𝕜 F]

variable (𝕜 E F) in
/-- The set of `C^n` functions supported in a set `s`, as a submodule of the space of functions. -/
def ContDiffSupportedOn (n : ℕ∞) (s : Set E) : Submodule 𝕜 (E → F) where
  carrier := { f : E → F | tsupport f ⊆ s ∧ ContDiff 𝕜 n f }
  add_mem' hf hg := ⟨tsupport_add.trans <| union_subset hf.1 hg.1, hf.2.add hg.2⟩
  zero_mem' :=
    ⟨(tsupport_eq_empty_iff.mpr rfl).subset.trans (empty_subset _), contDiff_const (c := 0)⟩
  smul_mem' r f hf :=
    ⟨(closure_mono <| support_const_smul_subset r f).trans hf.1, contDiff_const.smul hf.2⟩

namespace ContDiffSupportedOn

variable {n : ℕ∞} {s : Set E}

instance : FunLike (ContDiffSupportedOn 𝕜 E F n s) E F where
  coe := Subtype.val
  coe_injective' := Subtype.coe_injective

@[simp]
lemma coe_mk (f : E → F) (h) : (⟨f, h⟩ : ContDiffSupportedOn 𝕜 E F n s) = f := rfl

lemma tsupport_subset (f : ContDiffSupportedOn 𝕜 E F n s) : tsupport f ⊆ s := f.2.1

lemma support_subset (f : ContDiffSupportedOn 𝕜 E F n s) :
    support f ⊆ s := subset_tsupport _ |>.trans (tsupport_subset f)

lemma contDiff (f : ContDiffSupportedOn 𝕜 E F n s) :
    ContDiff 𝕜 n f := f.2.2

theorem continuous (f : ContDiffSupportedOn 𝕜 E F n s) : Continuous f :=
  (ContDiffSupportedOn.contDiff _).continuous

lemma hasCompactSupport [ProperSpace E] (f : ContDiffSupportedOn 𝕜 E F n (closedBall 0 1)) :
    HasCompactSupport f :=
  HasCompactSupport.of_support_subset_isCompact (isCompact_closedBall 0 1) (support_subset f)

theorem integrable_eval_mul (p : MvPolynomial ι ℝ)
    (f : ContDiffSupportedOn ℝ (EuclideanSpace ℝ ι) ℝ ⊤ (closedBall 0 1)) :
    Integrable fun (x : EuclideanSpace ℝ ι) ↦ eval x p * f x :=
  p.continuous_eval.mul (ContDiffSupportedOn.contDiff f).continuous
    |>.integrable_of_hasCompactSupport (hasCompactSupport f).mul_left

end ContDiffSupportedOn

end normed
open ContDiffSupportedOn

variable (ι)
/-- Interpreting a multivariate polynomial as an element of the dual of smooth functions supported
in the unit ball, via integration against Lebesgue measure. -/
def L : MvPolynomial ι ℝ →ₗ[ℝ]
    Module.Dual ℝ (ContDiffSupportedOn ℝ (EuclideanSpace ℝ ι) ℝ ⊤ (closedBall 0 1)) :=
  have int := ContDiffSupportedOn.integrable_eval_mul (ι := ι)
  .mk₂ ℝ (fun p f ↦ ∫ x : EuclideanSpace ℝ ι, eval x p • f x)
    (fun p₁ p₂ f ↦ by simp [add_mul, integral_add (int p₁ f) (int p₂ f)])
    (fun r p f ↦ by simp [mul_assoc, integral_const_mul])
    (fun p f₁ f₂ ↦ by simp_rw [smul_eq_mul, ← integral_add (int p _) (int p _), ← mul_add]; rfl)
    fun r p f ↦ by simp_rw [← integral_smul, smul_comm r]; rfl

lemma inj_L : Injective (L ι) :=
  (injective_iff_map_eq_zero _).mpr fun p hp ↦ by
    have H : ∀ᵐ x : EuclideanSpace ℝ ι, x ∈ ball 0 1 → eval x p = 0 :=
      isOpen_ball.ae_eq_zero_of_integral_contDiff_smul_eq_zero
        (continuous_eval p |>.locallyIntegrable.locallyIntegrableOn _)
        fun g hg _h2g g_supp ↦ by
          simpa [mul_comm (g _), L] using congr($hp ⟨g, g_supp.trans ball_subset_closedBall, hg⟩)
    simp_rw [MvPolynomial.funext_iff, map_zero]
    refine fun x ↦ AnalyticOnNhd.eval_linearMap (EuclideanSpace.equiv ι ℝ).toLinearMap p
      |>.eqOn_zero_of_preconnected_of_eventuallyEq_zero
      (preconnectedSpace_iff_univ.mp inferInstance) (z₀ := 0) trivial
      (Filter.mem_of_superset (Metric.ball_mem_nhds 0 zero_lt_one) ?_) trivial
    rw [← ae_restrict_iff'₀ measurableSet_ball.nullMeasurableSet] at H
    apply Measure.eqOn_of_ae_eq H p.continuous_eval.continuousOn continuousOn_const
    rw [isOpen_ball.interior_eq]
    apply subset_closure

lemma hairer (N : ℕ) (ι : Type*) [Fintype ι] :
    ∃ (ρ : EuclideanSpace ℝ ι → ℝ), tsupport ρ ⊆ closedBall 0 1 ∧ ContDiff ℝ ∞ ρ ∧
    ∀ (p : MvPolynomial ι ℝ), p.totalDegree ≤ N →
    ∫ x : EuclideanSpace ℝ ι, eval x p • ρ x = eval 0 p := by
  have := (inj_L ι).comp (restrictTotalDegree ι ℝ N).injective_subtype
  rw [← LinearMap.coe_comp] at this
  obtain ⟨⟨φ, supφ, difφ⟩, hφ⟩ :=
    LinearMap.flip_surjective_iff₁.2 this ((aeval 0).toLinearMap.comp <| Submodule.subtype _)
  exact ⟨φ, supφ, difφ, fun P hP ↦ congr($hφ ⟨P, (mem_restrictTotalDegree ι N P).mpr hP⟩)⟩



=== LEAN SOURCE: Sensitivity.lean ===
/-
Copyright (c) 2019 Reid Barton, Johan Commelin, Jesse Michael Han, Chris Hughes, Robert Y. Lewis,
Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Reid Barton, Johan Commelin, Jesse Michael Han, Chris Hughes, Robert Y. Lewis,
  Patrick Massot
-/
import Mathlib.Analysis.Normed.Module.Basic
import Mathlib.Data.Real.Sqrt
import Mathlib.LinearAlgebra.Dual.Lemmas
import Mathlib.LinearAlgebra.FiniteDimensional.Lemmas
import Mathlib.Tactic.ApplyFun
import Mathlib.Tactic.FinCases

/-!
# Huang's sensitivity theorem

A formalization of Hao Huang's sensitivity theorem: in the hypercube of
dimension n ≥ 1, if one colors more than half the vertices then at least one
vertex has at least √n colored neighbors.

A fun summer collaboration by
Reid Barton, Johan Commelin, Jesse Michael Han, Chris Hughes, Robert Y. Lewis, and Patrick Massot,
based on Don Knuth's account of the story
(https://www.cs.stanford.edu/~knuth/papers/huang.pdf),
using the Lean theorem prover (https://leanprover.github.io/),
by Leonardo de Moura at Microsoft Research, and his collaborators
(https://leanprover.github.io/people/),
and using Lean's user maintained mathematics library
(https://github.com/leanprover-community/mathlib).

The project was developed at https://github.com/leanprover-community/lean-sensitivity and is now
archived at https://github.com/leanprover-community/mathlib/blob/master/archive/sensitivity.lean
-/

namespace Sensitivity

/-! The next two lines assert we do not want to give a constructive proof,
but rather use classical logic. -/
noncomputable section

local notation "√" => Real.sqrt

open Bool Finset Fintype Function LinearMap Module Module.DualBases

/-!
### The hypercube

Notations:
- `ℕ` denotes natural numbers (including zero).
- `Fin n` = {0, ⋯ , n - 1}.
- `Bool` = {`true`, `false`}.
-/


/-- The hypercube in dimension `n`. -/
def Q (n : ℕ) :=
  Fin n → Bool

instance (n) : Inhabited (Q n) := inferInstanceAs (Inhabited (Fin n → Bool))

instance (n) : Fintype (Q n) := inferInstanceAs (Fintype (Fin n → Bool))

/-- The projection from `Q n.succ` to `Q n` forgetting the first value
(ie. the image of zero). -/
def π {n : ℕ} : Q n.succ → Q n := fun p => p ∘ Fin.succ

namespace Q

@[ext]
theorem ext {n} {f g : Q n} (h : ∀ x, f x = g x) : f = g := funext h

/-! `n` will always denote a natural number. -/

variable (n : ℕ)

/-- `Q 0` has a unique element. -/
instance : Unique (Q 0) :=
  ⟨⟨fun _ => true⟩, by intro; ext x; fin_cases x⟩

/-- `Q n` has 2^n elements. -/
theorem card : card (Q n) = 2 ^ n := by simp [Q]

/-! Until the end of this namespace, `n` will be an implicit argument (still
a natural number). -/

variable {n}

theorem succ_n_eq (p q : Q n.succ) : p = q ↔ p 0 = q 0 ∧ π p = π q := by
  constructor
  · rintro rfl; exact ⟨rfl, rfl⟩
  · rintro ⟨h₀, h⟩
    ext x
    by_cases hx : x = 0
    · rwa [hx]
    · rw [← Fin.succ_pred x hx]
      convert congr_fun h (Fin.pred x hx)

/-- The adjacency relation defining the graph structure on `Q n`:
`p.adjacent q` if there is an edge from `p` to `q` in `Q n`. -/
def adjacent {n : ℕ} (p : Q n) : Set (Q n) := { q | ∃! i, p i ≠ q i }

/-- In `Q 0`, no two vertices are adjacent. -/
theorem not_adjacent_zero (p q : Q 0) : q ∉ p.adjacent := by rintro ⟨v, _⟩; apply finZeroElim v

/-- If `p` and `q` in `Q n.succ` have different values at zero then they are adjacent
iff their projections to `Q n` are equal. -/
theorem adj_iff_proj_eq {p q : Q n.succ} (h₀ : p 0 ≠ q 0) : q ∈ p.adjacent ↔ π p = π q := by
  constructor
  · rintro ⟨i, _, h_uni⟩
    ext x; by_contra hx
    apply Fin.succ_ne_zero x
    rw [h_uni _ hx, h_uni _ h₀]
  · intro heq
    use 0, h₀
    intro y hy
    contrapose! hy
    rw [← Fin.succ_pred _ hy]
    apply congr_fun heq

/-- If `p` and `q` in `Q n.succ` have the same value at zero then they are adjacent
iff their projections to `Q n` are adjacent. -/
theorem adj_iff_proj_adj {p q : Q n.succ} (h₀ : p 0 = q 0) :
    q ∈ p.adjacent ↔ π q ∈ (π p).adjacent := by
  constructor
  · rintro ⟨i, h_eq, h_uni⟩
    have h_i : i ≠ 0 := fun h_i => absurd h₀ (by rwa [h_i] at h_eq)
    use i.pred h_i,
      show p (Fin.succ (Fin.pred i _)) ≠ q (Fin.succ (Fin.pred i _)) by rwa [Fin.succ_pred]
    intro y hy
    simp [Eq.symm (h_uni _ hy)]
  · rintro ⟨i, h_eq, h_uni⟩
    use i.succ, h_eq
    intro y hy
    rw [← Fin.pred_inj (ha := (?ha : y ≠ 0)) (hb := (?hb : i.succ ≠ 0)),
      Fin.pred_succ]
    case ha =>
      contrapose! hy
      rw [hy, h₀]
    case hb =>
      apply Fin.succ_ne_zero
    apply h_uni
    simp [π, hy]

@[symm]
theorem adjacent.symm {p q : Q n} : q ∈ p.adjacent ↔ p ∈ q.adjacent := by
  simp only [adjacent, ne_comm, Set.mem_setOf_eq]

end Q

/-! ### The vector space -/


/-- The free vector space on vertices of a hypercube, defined inductively. -/
def V : ℕ → Type
  | 0 => ℝ
  | n + 1 => V n × V n

@[simp]
theorem V_zero : V 0 = ℝ := rfl

@[simp]
theorem V_succ {n : ℕ} : V (n + 1) = (V n × V n) := rfl

namespace V

@[ext]
theorem ext {n : ℕ} {p q : V n.succ} (h₁ : p.1 = q.1) (h₂ : p.2 = q.2) : p = q := Prod.ext h₁ h₂

variable (n : ℕ)

/-! `V n` is a real vector space whose equality relation is computable. -/


instance : DecidableEq (V n) := by induction n <;> · dsimp only [V]; infer_instance

instance : AddCommGroup (V n) := by induction n <;> · dsimp only [V]; infer_instance

instance : Module ℝ (V n) := by induction n <;> · dsimp only [V]; infer_instance

end V

/-- The basis of `V` indexed by the hypercube, defined inductively. -/
noncomputable def e : ∀ {n}, Q n → V n
  | 0 => fun _ => (1 : ℝ)
  | Nat.succ _ => fun x => cond (x 0) (e (π x), 0) (0, e (π x))

@[simp]
theorem e_zero_apply (x : Q 0) : e x = (1 : ℝ) :=
  rfl

/-- The dual basis to `e`, defined inductively. -/
noncomputable def ε : ∀ {n : ℕ}, Q n → V n →ₗ[ℝ] ℝ
  | 0, _ => LinearMap.id
  | Nat.succ _, p =>
    cond (p 0) ((ε <| π p).comp <| LinearMap.fst _ _ _) ((ε <| π p).comp <| LinearMap.snd _ _ _)

variable {n : ℕ}

open Classical in
theorem duality (p q : Q n) : ε p (e q) = if p = q then 1 else 0 := by
  induction n with
  | zero => simp [Subsingleton.elim (α := Q 0) p q, ε, e]
  | succ n IH =>
    dsimp [ε, e]
    cases hp : p 0 <;> cases hq : q 0
    all_goals
      simp only [Bool.cond_true, Bool.cond_false, LinearMap.fst_apply, LinearMap.snd_apply,
        LinearMap.comp_apply, IH]
      congr 1; rw [Q.succ_n_eq]; simp [hp, hq]

/-- Any vector in `V n` annihilated by all `ε p`'s is zero. -/
theorem epsilon_total {v : V n} (h : ∀ p : Q n, (ε p) v = 0) : v = 0 := by
  induction n with
  | zero => dsimp [ε] at h; exact h fun _ => true
  | succ n ih =>
    obtain ⟨v₁, v₂⟩ := v
    ext <;> change _ = (0 : V n) <;> simp only <;> apply ih <;> intro p <;>
      [let q : Q n.succ := fun i => if h : i = 0 then true else p (i.pred h);
      let q : Q n.succ := fun i => if h : i = 0 then false else p (i.pred h)]
    all_goals
      specialize h q
      first
      | rw [ε, show q 0 = true from rfl, Bool.cond_true] at h
      | rw [ε, show q 0 = false from rfl, Bool.cond_false] at h
      rwa [show p = π q by ext; simp [q, Fin.succ_ne_zero, π]]

open Module

open Classical in
/-- `e` and `ε` are dual families of vectors. It implies that `e` is indeed a basis
and `ε` computes coefficients of decompositions of vectors on that basis. -/
theorem dualBases_e_ε (n : ℕ) : DualBases (@e n) (@ε n) where
  eval_same := by simp [duality]
  eval_of_ne _ _ h := by simp [duality, h]
  total h := sub_eq_zero.mp <| epsilon_total fun i ↦ by
    simpa only [map_sub, sub_eq_zero] using h i

/-! We will now derive the dimension of `V`, first as a cardinal in `dim_V` and,
since this cardinal is finite, as a natural number in `finrank_V` -/


theorem dim_V : Module.rank ℝ (V n) = 2 ^ n := by
  have : Module.rank ℝ (V n) = (2 ^ n : ℕ) := by
    classical
    rw [rank_eq_card_basis (dualBases_e_ε _).basis, Q.card]
  assumption_mod_cast

open Classical in
instance : FiniteDimensional ℝ (V n) :=
  FiniteDimensional.of_fintype_basis (dualBases_e_ε _).basis

theorem finrank_V : finrank ℝ (V n) = 2 ^ n := by
  have := @dim_V n
  rw [← finrank_eq_rank] at this; assumption_mod_cast

/-! ### The linear map -/


/-- The linear operator $f_n$ corresponding to Huang's matrix $A_n$,
defined inductively as a ℝ-linear map from `V n` to `V n`. -/
noncomputable def f : ∀ n, V n →ₗ[ℝ] V n
  | 0 => 0
  | n + 1 =>
    LinearMap.prod (LinearMap.coprod (f n) LinearMap.id) (LinearMap.coprod LinearMap.id (-f n))

/-! The preceding definition uses linear map constructions to automatically
get that `f` is linear, but its values are somewhat buried as a side-effect.
The next two lemmas unbury them. -/


@[simp]
theorem f_zero : f 0 = 0 :=
  rfl

theorem f_succ_apply (v : V n.succ) : f n.succ v = (f n v.1 + v.2, v.1 - f n v.2) := by
  cases v
  rw [f]
  simp only [sub_eq_add_neg]
  exact rfl

/-! In the next statement, the explicit conversion `(n : ℝ)` of `n` to a real number
is necessary since otherwise `n • v` refers to the multiplication defined
using only the addition of `V`. -/


theorem f_squared (v : V n) : (f n) (f n v) = (n : ℝ) • v := by
  induction n with
  | zero =>  simp only [Nat.cast_zero, zero_smul, f_zero, zero_apply]
  | succ n IH =>
    cases v; rw [f_succ_apply, f_succ_apply]; simp [IH, add_smul (n : ℝ) 1, add_assoc]; abel

/-! We now compute the matrix of `f` in the `e` basis (`p` is the line index,
`q` the column index). -/

open Classical in
theorem f_matrix (p q : Q n) : |ε q (f n (e p))| = if p ∈ q.adjacent then 1 else 0 := by
  induction n with
  | zero =>
    dsimp [f]
    simp [Q.not_adjacent_zero]
    rfl
  | succ n IH =>
    have ite_nonneg : ite (π q = π p) (1 : ℝ) 0 ≥ 0 := by split_ifs <;> norm_num
    dsimp only [e, ε, f, V]; rw [LinearMap.prod_apply]; dsimp; cases hp : p 0 <;> cases hq : q 0
    all_goals
      repeat rw [Bool.cond_true]
      repeat rw [Bool.cond_false]
      simp [hp, hq, IH, duality, abs_of_nonneg ite_nonneg, Q.adj_iff_proj_eq,
        Q.adj_iff_proj_adj]

/-- The linear operator $g_m$ corresponding to Knuth's matrix $B_m$. -/
noncomputable def g (m : ℕ) : V m →ₗ[ℝ] V m.succ :=
  LinearMap.prod (f m + √ (m + 1) • LinearMap.id) LinearMap.id

/-! In the following lemmas, `m` will denote a natural number. -/


variable {m : ℕ}

/-! Again we unpack what are the values of `g`. -/


theorem g_apply : ∀ v, g m v = (f m v + √ (m + 1) • v, v) := by
  delta g; intro v; simp

theorem g_injective : Injective (g m) := by
  rw [g]
  intro x₁ x₂ h
  simp only [V, LinearMap.prod_apply, LinearMap.id_apply, Prod.mk_inj, Pi.prod] at h
  exact h.right

theorem f_image_g (w : V m.succ) (hv : ∃ v, g m v = w) : f m.succ w = √ (m + 1) • w := by
  rcases hv with ⟨v, rfl⟩
  have : √ (m + 1) * √ (m + 1) = m + 1 := Real.mul_self_sqrt (mod_cast zero_le _)
  rw [f_succ_apply, g_apply]
  simp [this, f_squared, smul_add, add_smul, smul_smul]
  abel

/-!
### The main proof

In this section, in order to enforce that `n` is positive, we write it as
`m + 1` for some natural number `m`. -/


/-! `dim X` will denote the dimension of a subspace `X` as a cardinal. -/


local notation "dim " X:70 => Module.rank ℝ { x // x ∈ X }

/-! `fdim X` will denote the (finite) dimension of a subspace `X` as a natural number. -/


local notation "fdim" => finrank ℝ

/-! `Span S` will denote the ℝ-subspace spanned by `S`. -/


local notation "Span" => Submodule.span ℝ

/-! `Card X` will denote the cardinal of a subset of a finite type, as a
natural number. -/


local notation "Card " X:70 => #(Set.toFinset X)

/-! In the following, `⊓` and `⊔` will denote intersection and sums of ℝ-subspaces,
equipped with their subspace structures. The notations come from the general
theory of lattices, with inf and sup (also known as meet and join). -/

open Classical in
/-- If a subset `H` of `Q (m+1)` has cardinal at least `2^m + 1` then the
subspace of `V (m+1)` spanned by the corresponding basis vectors non-trivially
intersects the range of `g m`. -/
theorem exists_eigenvalue (H : Set (Q m.succ)) (hH : Card H ≥ 2 ^ m + 1) :
    ∃ y ∈ Span (e '' H) ⊓ range (g m), y ≠ 0 := by
  let W := Span (e '' H)
  let img := range (g m)
  suffices 0 < dim (W ⊓ img) by
    exact mod_cast exists_mem_ne_zero_of_rank_pos this
  have dim_le : dim (W ⊔ img) ≤ 2 ^ (m + 1 : Cardinal) := by
    convert ← Submodule.rank_le (W ⊔ img)
    rw [← Nat.cast_succ]
    apply dim_V
  have dim_add : dim (W ⊔ img) + dim (W ⊓ img) = dim W + 2 ^ m := by
    convert ← Submodule.rank_sup_add_rank_inf_eq W img
    rw [rank_range_of_injective (g m) g_injective]
    apply dim_V
  have dimW : dim W = card H := by
    have li : LinearIndependent ℝ (H.restrict e) := by
      convert (dualBases_e_ε m.succ).basis.linearIndependent.comp _ Subtype.val_injective
      rw [(dualBases_e_ε _).coe_basis]
      rfl
    have hdW := rank_span li
    rw [Set.range_restrict] at hdW
    convert hdW
    rw [← (dualBases_e_ε _).coe_basis, Cardinal.mk_image_eq (dualBases_e_ε _).basis.injective,
      Cardinal.mk_fintype]
  rw [← finrank_eq_rank ℝ] at dim_le dim_add dimW ⊢
  rw [← finrank_eq_rank ℝ, ← finrank_eq_rank ℝ] at dim_add
  norm_cast at dim_le dim_add dimW ⊢
  rw [pow_succ'] at dim_le
  rw [Set.toFinset_card] at hH
  linarith

open Classical in
/-- **Huang sensitivity theorem** also known as the **Huang degree theorem** -/
theorem huang_degree_theorem (H : Set (Q m.succ)) (hH : Card H ≥ 2 ^ m + 1) :
    ∃ q, q ∈ H ∧ √ (m + 1) ≤ Card H ∩ q.adjacent := by
  rcases exists_eigenvalue H hH with ⟨y, ⟨⟨y_mem_H, y_mem_g⟩, y_ne⟩⟩
  have coeffs_support : ((dualBases_e_ε m.succ).coeffs y).support ⊆ H.toFinset := by
    intro p p_in
    rw [Finsupp.mem_support_iff] at p_in
    rw [Set.mem_toFinset]
    exact (dualBases_e_ε _).mem_of_mem_span y_mem_H p p_in
  obtain ⟨q, H_max⟩ : ∃ q : Q m.succ, ∀ q' : Q m.succ, |(ε q' :) y| ≤ |ε q y| :=
    Finite.exists_max _
  have H_q_pos : 0 < |ε q y| := by
    contrapose! y_ne
    exact epsilon_total fun p => abs_nonpos_iff.mp (le_trans (H_max p) y_ne)
  refine ⟨q, (dualBases_e_ε _).mem_of_mem_span y_mem_H q (abs_pos.mp H_q_pos), ?_⟩
  let s := √ (m + 1)
  suffices s * |ε q y| ≤ _ * |ε q y| from (mul_le_mul_right H_q_pos).mp ‹_›
  let coeffs := (dualBases_e_ε m.succ).coeffs
  calc
    s * |ε q y| = |ε q (s • y)| := by
      rw [map_smul, smul_eq_mul, abs_mul, abs_of_nonneg (Real.sqrt_nonneg _)]
    _ = |ε q (f m.succ y)| := by rw [← f_image_g y (by simpa using y_mem_g)]
    _ = |ε q (f m.succ (lc _ (coeffs y)))| := by rw [(dualBases_e_ε _).lc_coeffs y]
    _ =
        |(coeffs y).sum fun (i : Q m.succ) (a : ℝ) =>
            a • (ε q ∘ f m.succ ∘ fun i : Q m.succ => e i) i| := by
      rw [lc_def, (f m.succ).map_finsupp_linearCombination, (ε q).map_finsupp_linearCombination,
           Finsupp.linearCombination_apply]
    _ ≤ ∑ p ∈ (coeffs y).support, |coeffs y p * (ε q <| f m.succ <| e p)| :=
      (norm_sum_le _ fun p => coeffs y p * _)
    _ = ∑ p ∈ (coeffs y).support, |coeffs y p| * ite (p ∈ q.adjacent) 1 0 := by
      simp only [abs_mul, f_matrix]
    _ = ∑ p ∈ (coeffs y).support with q.adjacent p, |coeffs y p| := by
      simp [sum_filter]; rfl
    _ ≤ ∑ p ∈ (coeffs y).support with q.adjacent p, |coeffs y q| := sum_le_sum fun p _ ↦ H_max p
    _ = #{p ∈ (coeffs y).support | q.adjacent p} * |coeffs y q| := by
      rw [sum_const, nsmul_eq_mul]
    _ = #((coeffs y).support ∩ q.adjacent.toFinset) * |coeffs y q| := by
      congr with x; simp; rfl
    _ ≤ #(H ∩ q.adjacent).toFinset * |ε q y| := by
      refine (mul_le_mul_right H_q_pos).2 ?_
      norm_cast
      apply card_le_card
      rw [Set.toFinset_inter]
      convert inter_subset_inter_right coeffs_support

end

end Sensitivity



=== LEAN SOURCE: ZagierTwoSquares.lean ===
/-
Copyright (c) 2023 Jeremy Tan. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Tan, Thomas Browning
-/
import Mathlib.GroupTheory.Perm.Cycle.Type
import Mathlib.Tactic.Linarith

/-!
# Zagier's "one-sentence proof" of Fermat's theorem on sums of two squares

"The involution on the finite set `S = {(x, y, z) : ℕ × ℕ × ℕ | x ^ 2 + 4 * y * z = p}` defined by
```
(x, y, z) ↦ (x + 2 * z, z, y - x - z) if x < y - z
            (2 * y - x, y, x - y + z) if y - z < x < 2 * y
            (x - 2 * y, x - y + z, y) if x > 2 * y
```
has exactly one fixed point, so `|S|` is odd and the involution defined by
`(x, y, z) ↦ (x, z, y)` also has a fixed point." — [Don Zagier](Zagier1990)

This elementary proof (`Nat.Prime.sq_add_sq'`) is independent of `Nat.Prime.sq_add_sq` in
`Mathlib/NumberTheory/SumTwoSquares.lean`, which uses the unique factorisation of `ℤ[i]`.
For a geometric interpretation of the piecewise involution (`Zagier.complexInvo`)
see [Moritz Firsching's MathOverflow answer](https://mathoverflow.net/a/299696).
-/


namespace Zagier

section Sets

open Set

variable (k : ℕ) [hk : Fact (4 * k + 1).Prime]

/-- The set of all triples of natural numbers `(x, y, z)` satisfying
`x * x + 4 * y * z = 4 * k + 1`. -/
def zagierSet : Set (ℕ × ℕ × ℕ) := {t | t.1 * t.1 + 4 * t.2.1 * t.2.2 = 4 * k + 1}

lemma zagierSet_lower_bound {x y z : ℕ} (h : (x, y, z) ∈ zagierSet k) : 0 < x ∧ 0 < y ∧ 0 < z := by
  rw [zagierSet, mem_setOf_eq] at h
  refine ⟨?_, ?_, ?_⟩
  all_goals
    by_contra q
    rw [not_lt, nonpos_iff_eq_zero] at q
    simp only [q, mul_zero, zero_mul, zero_add, add_zero] at h
  · apply_fun (· % 4) at h
    simp [mul_assoc, Nat.add_mod] at h
  all_goals
    rcases (Nat.dvd_prime hk.out).1 (dvd_of_mul_left_eq _ h) with e | e
    all_goals
      simp only [e, right_eq_add, ne_eq, add_eq_zero, and_false, not_false_eq_true,
        mul_eq_left₀, reduceCtorEq] at h
      simp only [h, zero_add] at hk
      exact Nat.not_prime_one hk.out

lemma zagierSet_upper_bound {x y z : ℕ} (h : (x, y, z) ∈ zagierSet k) :
    x ≤ k + 1 ∧ y ≤ k ∧ z ≤ k := by
  obtain ⟨_, _, _⟩ := zagierSet_lower_bound k h
  rw [zagierSet, mem_setOf_eq] at h
  refine ⟨?_, ?_, ?_⟩ <;> nlinarith

lemma zagierSet_subset : zagierSet k ⊆ Ioc 0 (k + 1) ×ˢ Ioc 0 k ×ˢ Ioc 0 k := by
  intro x h
  have lb := zagierSet_lower_bound k h
  have ub := zagierSet_upper_bound k h
  exact ⟨⟨lb.1, ub.1⟩, ⟨lb.2.1, ub.2.1⟩, ⟨lb.2.2, ub.2.2⟩⟩

noncomputable instance : Fintype (zagierSet k) :=
  (((finite_Ioc 0 (k + 1)).prod ((finite_Ioc 0 k).prod (finite_Ioc 0 k))).subset
    (zagierSet_subset k)).fintype

end Sets

section Involutions

open Function

variable (k : ℕ)

/-- The obvious involution `(x, y, z) ↦ (x, z, y)`. -/
def obvInvo : Function.End (zagierSet k) := fun ⟨⟨x, y, z⟩, h⟩ => ⟨⟨x, z, y⟩, by
  simp only [zagierSet, Set.mem_setOf_eq] at h ⊢
  linarith [h]⟩

theorem obvInvo_sq : obvInvo k ^ 2 = 1 := rfl

/-- If `obvInvo k` has a fixed point, a representation of `4 * k + 1` as a sum of two squares
can be extracted from it. -/
theorem sq_add_sq_of_nonempty_fixedPoints (hn : (fixedPoints (obvInvo k)).Nonempty) :
    ∃ a b : ℕ, a ^ 2 + b ^ 2 = 4 * k + 1 := by
  simp only [sq]
  obtain ⟨⟨⟨x, y, z⟩, he⟩, hf⟩ := hn
  have := mem_fixedPoints_iff.mp hf
  simp only [obvInvo, Subtype.mk.injEq, Prod.mk.injEq, true_and] at this
  simp only [zagierSet, Set.mem_setOf_eq] at he
  use x, (2 * y)
  rw [show 2 * y * (2 * y) = 4 * y * y by linarith, ← he, this.1]

/-- The complicated involution, defined piecewise according to how `x` compares with
`y - z` and `2 * y`. -/
def complexInvo : Function.End (zagierSet k) := fun ⟨⟨x, y, z⟩, h⟩ =>
  ⟨if x + z < y then ⟨x + 2 * z, z, y - x - z⟩ else
   if 2 * y < x then ⟨x - 2 * y, x + z - y, y⟩ else
                     ⟨2 * y - x, y, x + z - y⟩, by
  split_ifs with less more <;> simp only [zagierSet, Set.mem_setOf_eq] at h ⊢
  · -- less: `x + z < y` (`x < y - z` as stated by Zagier)
    rw [Nat.sub_sub]; zify [less.le] at h ⊢; linarith [h]
  · -- more: `2 * y < x`
    push_neg at less; zify [less, more.le] at h ⊢; linarith [h]
  · -- middle: `x` is neither less than `y - z` or more than `2 * y`
    push_neg at less more; zify [less, more] at h ⊢; linarith [h]⟩

variable [hk : Fact (4 * k + 1).Prime]

/-- `complexInvo k` is indeed an involution. -/
theorem complexInvo_sq : complexInvo k ^ 2 = 1 := by
  change complexInvo k ∘ complexInvo k = id
  funext ⟨⟨x, y, z⟩, h⟩
  rw [comp_apply]
  obtain ⟨xb, _, _⟩ := zagierSet_lower_bound k h
  conv_lhs => arg 2; simp only [complexInvo]
  split_ifs with less more <;> rw [complexInvo, Subtype.mk.injEq, id_eq]
  · -- less
    simp only [show ¬(x + 2 * z + (y - x - z) < z) by linarith [less], ite_false,
      lt_add_iff_pos_left, xb, add_tsub_cancel_right, ite_true]
    rw [Nat.sub_sub, two_mul, ← tsub_add_eq_add_tsub (by linarith), ← add_assoc,
      Nat.add_sub_cancel, add_comm (x + z), Nat.sub_add_cancel less.le]
  · -- more
    push_neg at less
    simp only [show x - 2 * y + y < x + z - y by zify [less, more.le]; linarith, ite_true]
    rw [Nat.sub_add_cancel more.le, Nat.sub_right_comm, Nat.sub_sub _ _ y, ← two_mul, add_comm,
      Nat.add_sub_assoc more.le, Nat.add_sub_cancel]
  · -- middle
    push_neg at less more
    simp only [show ¬(2 * y - x + (x + z - y) < y) by zify [less, more]; linarith,
      show ¬(2 * y < 2 * y - x) by zify [more]; linarith, ite_false]
    rw [tsub_tsub_assoc (2 * y).le_refl more, tsub_self, zero_add,
      ← Nat.add_sub_assoc less, ← add_assoc, Nat.sub_add_cancel more, Nat.sub_sub _ _ y,
      ← two_mul, add_comm, Nat.add_sub_cancel]

/-- Any fixed point of `complexInvo k` must be `(1, 1, k)`. -/
theorem eq_of_mem_fixedPoints {t : zagierSet k} (mem : t ∈ fixedPoints (complexInvo k)) :
    t.val = (1, 1, k) := by
  obtain ⟨⟨x, y, z⟩, h⟩ := t
  obtain ⟨_, _, _⟩ := zagierSet_lower_bound k h
  rw [mem_fixedPoints_iff, complexInvo, Subtype.mk.injEq] at mem
  split_ifs at mem with less more <;>
    -- less (completely handled by the pre-applied `simp_all only`)
    simp_all only [not_lt, Prod.mk.injEq, add_eq_left, mul_eq_zero, false_or,
      lt_self_iff_false, reduceCtorEq]
  · -- more
    obtain ⟨_, _, _⟩ := mem; simp_all
  · -- middle (the one fixed point falls under this case)
    simp only [zagierSet, Set.mem_setOf_eq] at h
    replace mem := mem.1
    rw [tsub_eq_iff_eq_add_of_le more, ← two_mul] at mem
    replace mem := (mul_left_cancel₀ two_ne_zero mem).symm
    subst mem
    rw [show x * x + 4 * x * z = x * (x + 4 * z) by linarith] at h
    rcases (Nat.dvd_prime hk.out).1 (dvd_of_mul_left_eq _ h) with e | e
    · rw [e, mul_one] at h
      simp_all [show z = 0 by linarith [e]]
    · simp only [e, mul_left_eq_self₀, add_eq_zero, and_false, or_false, reduceCtorEq] at h
      simp only [h, true_and]
      linarith [e]

/-- The singleton containing `(1, 1, k)`. -/
def singletonFixedPoint : Finset (zagierSet k) :=
  {⟨(1, 1, k), (by simp only [zagierSet, Set.mem_setOf_eq]; linarith)⟩}

/-- `complexInvo k` has exactly one fixed point. -/
theorem card_fixedPoints_eq_one : Fintype.card (fixedPoints (complexInvo k)) = 1 := by
  rw [show 1 = Finset.card (singletonFixedPoint k) by rfl, ← Set.toFinset_card]
  congr
  rw [singletonFixedPoint, Finset.eq_singleton_iff_unique_mem]
  constructor
  · simp [IsFixedPt, complexInvo]
  · intro _ mem
    simp only [Set.mem_toFinset] at mem
    replace mem := eq_of_mem_fixedPoints k mem
    congr!

end Involutions

end Zagier

open Zagier

/-- **Fermat's theorem on sums of two squares** (Wiedijk #20).
Every prime congruent to 1 mod 4 is the sum of two squares, proved using Zagier's involutions. -/
theorem Nat.Prime.sq_add_sq' {p : ℕ} [h : Fact p.Prime] (hp : p % 4 = 1) :
    ∃ a b : ℕ, a ^ 2 + b ^ 2 = p := by
  rw [← div_add_mod p 4, hp] at h ⊢
  let k := p / 4
  apply sq_add_sq_of_nonempty_fixedPoints
  have key := (Equiv.Perm.card_fixedPoints_modEq (p := 2) (n := 1) (obvInvo_sq k)).symm.trans
    (Equiv.Perm.card_fixedPoints_modEq (p := 2) (n := 1) (complexInvo_sq k))
  contrapose key
  rw [Set.not_nonempty_iff_eq_empty] at key
  simp_rw [k, key, Fintype.card_eq_zero, card_fixedPoints_eq_one]
  decide



=== LEAN SOURCE: Eisenstein.lean ===
/-
Copyright (c) 2025 Antoine Chambert-Loir. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Chambert-Loir
-/

import Mathlib.Algebra.CharP.Quotient
import Mathlib.Algebra.Field.ZMod
import Mathlib.Algebra.Polynomial.SpecificDegree
import Mathlib.RingTheory.Ideal.Quotient.Operations
import Mathlib.RingTheory.Polynomial.Eisenstein.Basic
import Mathlib.Tactic.ComputeDegree

/-! # Example of an application of the generalized Eisenstein criterion

We show here how `Polynomial.generalizedEisenstein` can be applied
to establish the irreducibility of the explicit polynomial of degree 4
  `X ^ 4 - 10 * X ^ 2 + 1 : ℤ[X]`.
(to which the standard criterion) wouldn't apply.
One argues modulo `3`, with `q := X ^ 2 + 1`.

-/

namespace Polynomial

open Ideal.Quotient Ideal RingHom

example : Irreducible (X ^ 4 - 10 * X ^ 2 + 1 : ℤ[X]) := by
  -- We will apply the generalized Eisenstein criterion with `q = X ^ 2 + 1` and `K = ZMod 3`.
  set f : ℤ[X] := X ^ 4 - 10 * X ^ 2 + 1 with hf_eq
  have hdeg_f : f.natDegree = 4 := by unfold f; compute_degree!
  have hf_lC : f.leadingCoeff = 1 := by
    simp only [f, leadingCoeff, hdeg_f]; compute_degree!
  set q : ℤ [X] := X ^ 2 + 1 with hq_eq
  have hq_deg : q.natDegree = 2 := by unfold q; compute_degree!
  have hq_monic : q.Monic := by unfold q; monicity!
  have hfq : f = q ^ 2 - 12 * q + 12 := by ring
   -- On the other hand, `f %ₘ q = 12`, which is not a multiple of `9`.
  apply generalizedEisenstein (K := ZMod 3) (q := q) (p := 2)
  · set q₃ : (ZMod 3)[X] := X ^ 2 + 1
    have hdeg_q₃ : q₃.natDegree = 2 := by unfold q₃; compute_degree!
    suffices Irreducible q₃ by simpa [q] using this
    apply irreducible_of_degree_le_three_of_not_isRoot
      (by simp_all) (by simp_all [q₃]; decide)
  · unfold q; monicity!
  · exact Monic.isPrimitive hf_lC
  · simp_all
  · suffices f.leadingCoeff = 1 by
      simp [this, map_one, one_ne_zero]
    simp only [leadingCoeff, hdeg_f]
    unfold f; compute_degree!
  · nth_rewrite 1 [hfq]
    rw [hf_lC, ← map_C, C_1, Polynomial.map_one, one_mul, ← sub_eq_zero]
    have : (12 : (ZMod 3)[X]) = 0 := by apply CharP.ofNat_eq_zero' _ 3 12; norm_num
    simp [this]
  · suffices f %ₘ q = 12 by
      rw [this, ← map_ofNat C, Polynomial.map_C, ne_eq, C_eq_zero, eq_zero_iff_mem,
      CharP.ker_intAlgebraMap_eq_span 3, span_singleton_pow, mem_span_singleton]
      norm_num
    rw [hfq, ← modByMonicHom_apply, LinearMap.map_add]
    convert zero_add _
    · rw [← LinearMap.mem_ker, mem_ker_modByMonic hq_monic]
      rw [pow_two, ← sub_mul]
      apply dvd_mul_left
    · symm
      simp only [modByMonicHom_apply, Polynomial.modByMonic_eq_self_iff hq_monic]
      rw [show q.degree = 2 by unfold q; compute_degree!]
      rw [show degree _ = 0 by compute_degree!]
      norm_num

end Polynomial



=== LEAN SOURCE: MersennePrimes.lean ===
/-
Copyright (c) 2020 Kim Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import Mathlib.NumberTheory.LucasLehmer

/-!
# Explicit Mersenne primes

We run some Lucas-Lehmer tests to prove the first Mersenne primes are prime.

See the discussion at the end of [Mathlib/NumberTheory/LucasLehmer.lean]
for ideas about extending this to larger Mersenne primes.
-/

-- The Lucas-Lehmer test does not apply to `mersenne 2`
example : ¬ LucasLehmerTest 2 := by norm_num

example : (mersenne 2).Prime := by decide

example : (mersenne 3).Prime :=
  lucas_lehmer_sufficiency _ (by simp) (by norm_num)

example : (mersenne 5).Prime :=
  lucas_lehmer_sufficiency _ (by simp) (by norm_num)

example : (mersenne 7).Prime :=
  lucas_lehmer_sufficiency _ (by simp) (by norm_num)

example : (mersenne 13).Prime :=
  lucas_lehmer_sufficiency _ (by simp) (by norm_num)

example : (mersenne 17).Prime :=
  lucas_lehmer_sufficiency _ (by simp) (by norm_num)

example : (mersenne 19).Prime :=
  lucas_lehmer_sufficiency _ (by simp) (by norm_num)

/-- 2147483647.Prime, Euler (1772) -/
example : (mersenne 31).Prime :=
  lucas_lehmer_sufficiency _ (by simp) (by norm_num)

/-- Pervushin (1883), Seelhoff (1886) -/
example : (mersenne 61).Prime :=
  lucas_lehmer_sufficiency _ (by simp) (by norm_num)

example : (mersenne 89).Prime :=
  lucas_lehmer_sufficiency _ (by simp) (by norm_num)

example : (mersenne 107).Prime :=
  lucas_lehmer_sufficiency _ (by simp) (by norm_num)

/-- Édouard Lucas (1876) -/
example : (mersenne 127).Prime :=
  lucas_lehmer_sufficiency _ (by simp) (by norm_num)

/-- Lehmer and Robinson using SWAC computer, (1952) -/
example : (mersenne 521).Prime :=
  lucas_lehmer_sufficiency _ (by simp) (by norm_num)

example : (mersenne 607).Prime :=
  lucas_lehmer_sufficiency _ (by simp) (by norm_num)

example : (mersenne 1279).Prime :=
  lucas_lehmer_sufficiency _ (by simp) (by norm_num)

example : (mersenne 2203).Prime :=
  lucas_lehmer_sufficiency _ (by simp) (by norm_num)

example : (mersenne 2281).Prime :=
  lucas_lehmer_sufficiency _ (by simp) (by norm_num)

example : (mersenne 3217).Prime :=
  lucas_lehmer_sufficiency _ (by simp) (by norm_num)

example : (mersenne 4253).Prime :=
  lucas_lehmer_sufficiency _ (by simp) (by norm_num)

example : (mersenne 4423).Prime :=
  lucas_lehmer_sufficiency _ (by simp) (by norm_num)

/-
`mersenne 9689` seems to be system dependent:
locally it works fine, but in CI it fails with `(kernel) deep recursion detected`
-/
-- example : (mersenne 9689).Prime :=
--   lucas_lehmer_sufficiency _ (by norm_num) (by norm_num)

/-
`mersenne 9941` seems to be system dependent:
locally it works fine, but in CI it fails with `(kernel) deep recursion detected`
-/
-- example : (mersenne 9941).Prime :=
--   lucas_lehmer_sufficiency _ (by norm_num) (by norm_num)

/-
`mersenne 11213` fails with `(kernel) deep recursion detected` locally as well.
-/
-- example : (mersenne 11213).Prime :=
--   lucas_lehmer_sufficiency _ (by norm_num) (by norm_num)



=== LEAN SOURCE: PropEncodable.lean ===
/-
Copyright (c) 2019 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad
-/
import Mathlib.Data.W.Basic
import Mathlib.Data.Fin.VecNotation

/-!
# W types

The file `Mathlib/Data/W/Basic.lean` shows that if `α` is an encodable fintype and for every
`a : α`, `β a` is encodable, then `W β` is encodable.

As an example of how this can be used, we show that the type of propositional formulas with
variables labeled from an encodable type is encodable.

The strategy is to define a type of labels corresponding to the constructors.
From the definition (using `sum`, `unit`, and an encodable type), Lean can infer
that it is encodable. We then define a map from propositional formulas to the
corresponding `Wfin` type, and show that map has a left inverse.

We mark the auxiliary constructions `private`, since their only purpose is to
show encodability.
-/


namespace PropEncodable

/-- Propositional formulas with labels from `α`. -/
inductive PropForm (α : Type*)
  | var : α → PropForm α
  | not : PropForm α → PropForm α
  | and : PropForm α → PropForm α → PropForm α
  | or : PropForm α → PropForm α → PropForm α

namespace PropForm

private def Constructors (α : Type*) :=
  α ⊕ (Unit ⊕ (Unit ⊕ Unit))

local notation "cvar " a => Sum.inl a

local notation "cnot" => Sum.inr (Sum.inl Unit.unit)

local notation "cand" => Sum.inr (Sum.inr (Sum.inr Unit.unit))

local notation "cor" => Sum.inr (Sum.inr (Sum.inl Unit.unit))

@[simp]
private def arity (α : Type*) : Constructors α → Nat
  | cvar _ => 0
  | cnot => 1
  | cand => 2
  | cor => 2

variable {α : Type*}

instance : ∀ c : Unit ⊕ (Unit ⊕ Unit), NeZero (arity α (.inr c))
  | .inl () => ⟨one_ne_zero⟩
  | .inr (.inl ()) => ⟨two_ne_zero⟩
  | .inr (.inr ()) => ⟨two_ne_zero⟩

private def f : PropForm α → WType fun i => Fin (arity α i)
  | var a => ⟨cvar a, ![]⟩
  | not p => ⟨cnot, ![f p]⟩
  | and p q => ⟨cand, ![f p, f q]⟩
  | or p q => ⟨cor, ![f p, f q]⟩

private def finv : (WType fun i => Fin (arity α i)) → PropForm α
  | ⟨cvar a, _⟩ => var a
  | ⟨cnot, fn⟩ => not (finv (fn 0))
  | ⟨cand, fn⟩ => and (finv (fn 0)) (finv (fn 1))
  | ⟨cor, fn⟩ => or (finv (fn 0)) (finv (fn 1))

instance [Encodable α] : Encodable (PropForm α) :=
  haveI : Encodable (Constructors α) := by unfold Constructors; infer_instance
  Encodable.ofLeftInverse f finv (by intro p; induction p <;> simp [f, finv, *])

end PropForm

end PropEncodable



=== LEAN SOURCE: Result.lean ===
/-
Copyright (c) 2023 Chris Hughes. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Chris Hughes
-/
import Archive.Examples.IfNormalization.Statement
import Mathlib.Data.List.AList
import Mathlib.Tactic.Recall

/-!
# A solution to the if normalization challenge in Lean.

See `Statement.lean` for background.
-/

macro "◾" : tactic => `(tactic| aesop)
macro "◾" : term => `(term| by aesop)

namespace IfExpr

/-!
We add some local simp lemmas so we can unfold the definitions of the normalization condition.
-/
attribute [local simp] normalized hasNestedIf hasConstantIf hasRedundantIf disjoint vars
  List.disjoint

attribute [local simp] apply_ite ite_eq_iff'

variable {b : Bool} {f : ℕ → Bool} {i : ℕ} {t e : IfExpr}

/-!
Simp lemmas for `eval`.
We don't want a `simp` lemma for `(ite i t e).eval` in general, only once we know the shape of `i`.
-/
@[simp] theorem eval_lit : (lit b).eval f = b := rfl
@[simp] theorem eval_var : (var i).eval f = f i := rfl
@[simp] theorem eval_ite_lit :
    (ite (.lit b) t e).eval f = bif b then t.eval f else e.eval f := rfl
@[simp] theorem eval_ite_var :
    (ite (.var i) t e).eval f = bif f i then t.eval f else e.eval f := rfl
@[simp] theorem eval_ite_ite {a b c d e : IfExpr} :
    (ite (ite a b c) d e).eval f = (ite a (ite b d e) (ite c d e)).eval f := by
  cases h : eval f a <;> simp_all [eval]

/-- Custom size function for if-expressions, used for proving termination. -/
@[simp] def normSize : IfExpr → Nat
  | lit _ => 0
  | var _ => 1
  | .ite i t e => 2 * normSize i + max (normSize t) (normSize e) + 1

/-- Normalizes the expression at the same time as assigning all variables in
`e` to the literal booleans given by `l` -/
def normalize (l : AList (fun _ : ℕ => Bool)) :
    (e : IfExpr) → { e' : IfExpr //
        (∀ f, e'.eval f = e.eval (fun w => (l.lookup w).elim (f w) id))
        ∧ e'.normalized
        ∧ ∀ (v : ℕ), v ∈ vars e' → l.lookup v = none }
  | lit b => ⟨lit b, ◾⟩
  | var v =>
    match h : l.lookup v with
    | none => ⟨var v, ◾⟩
    | some b => ⟨lit b, ◾⟩
  | .ite (lit true)   t e => have t' := normalize l t; ⟨t'.1, ◾⟩
  | .ite (lit false)  t e => have e' := normalize l e; ⟨e'.1, ◾⟩
  | .ite (.ite a b c) t e => have i' := normalize l (.ite a (.ite b t e) (.ite c t e)); ⟨i'.1, ◾⟩
  | .ite (var v)      t e =>
    match h : l.lookup v with
    | none =>
      have ⟨t', ht₁, ht₂, ht₃⟩ := normalize (l.insert v true) t
      have ⟨e', he₁, he₂, he₃⟩ := normalize (l.insert v false) e
      ⟨if t' = e' then t' else .ite (var v) t' e', by
        refine ⟨fun f => ?_, ?_, fun w b => ?_⟩
        · -- eval = eval
          simp? says simp only [apply_ite, eval_ite_var, ite_eq_iff']
          cases hfv : f v
          · simp_all
            congr
            ext w
            by_cases w = v <;> ◾
          · simp [h, ht₁]
            congr
            ext w
            by_cases w = v <;> ◾
        · -- normalized
          have := ht₃ v
          have := he₃ v
          split <;> ◾
        · -- lookup = none
          have := ht₃ w
          have := he₃ w
          by_cases w = v <;> ◾⟩
    | some b =>
      have i' := normalize l (.ite (lit b) t e); ⟨i'.1, ◾⟩
  termination_by e => e.normSize

/-
We recall the statement of the if-normalization problem.

We want a function from if-expressions to if-expressions,
that outputs normalized if-expressions and preserves meaning.
-/
recall IfNormalization :=
  { Z : IfExpr → IfExpr // ∀ e, (Z e).normalized ∧ (Z e).eval = e.eval }

example : IfNormalization :=
  ⟨_, fun e => ⟨(IfExpr.normalize ∅ e).2.2.1, by simp [(IfExpr.normalize ∅ e).2.1]⟩⟩

end IfExpr



=== LEAN SOURCE: Statement.lean ===
/-
Copyright (c) 2023 Lean FRO LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/

/-!
# If normalization

Rustan Leino, Stephan Merz, and Natarajan Shankar have recently been discussing challenge problems
to compare proof assistants.
(See https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Rustan's.20challenge)

Their first suggestion was "if-normalization".

This file contains a Lean formulation of the problem. See `Result.lean` for a Lean solution.
-/

/-- An if-expression is either boolean literal, a numbered variable,
or an if-then-else expression where each subexpression is an if-expression. -/
inductive IfExpr
  | lit : Bool → IfExpr
  | var : Nat → IfExpr
  | ite : IfExpr → IfExpr → IfExpr → IfExpr
deriving DecidableEq, Repr

namespace IfExpr

/--
An if-expression has a "nested if" if it contains
an if-then-else where the "if" is itself an if-then-else.
-/
def hasNestedIf : IfExpr → Bool
  | lit _ => false
  | var _ => false
  | ite (ite _ _ _) _ _ => true
  | ite _ t e => t.hasNestedIf || e.hasNestedIf

/--
An if-expression has a "constant if" if it contains
an if-then-else where the "if" is itself a literal.
-/
def hasConstantIf : IfExpr → Bool
  | lit _ => false
  | var _ => false
  | ite (lit _) _ _ => true
  | ite i t e => i.hasConstantIf || t.hasConstantIf || e.hasConstantIf

/--
An if-expression has a "redundant if" if it contains
an if-then-else where the then and else clauses are identical.
-/
def hasRedundantIf : IfExpr → Bool
  | lit _ => false
  | var _ => false
  | ite i t e => t == e || i.hasRedundantIf || t.hasRedundantIf || e.hasRedundantIf

/--
All the variables appearing in an if-expressions, read left to right, without removing duplicates.
-/
def vars : IfExpr → List Nat
  | lit _ => []
  | var i => [i]
  | ite i t e => i.vars ++ t.vars ++ e.vars

/--
A helper function to specify that two lists are disjoint.
-/
def _root_.List.disjoint {α} [DecidableEq α] : List α → List α → Bool
  | [], _ => true
  | x::xs, ys => x ∉ ys && xs.disjoint ys

/--
An if expression evaluates each variable at most once if for each if-then-else
the variables in the if clause are disjoint from the variables in the then clause, and
the variables in the if clause are disjoint from the variables in the else clause.
-/
def disjoint : IfExpr → Bool
  | lit _ => true
  | var _ => true
  | ite i t e =>
      i.vars.disjoint t.vars && i.vars.disjoint e.vars && i.disjoint && t.disjoint && e.disjoint

/--
An if expression is "normalized" if it has not nested, constant, or redundant ifs,
and it evaluates each variable at most once.
-/
def normalized (e : IfExpr) : Bool :=
  !e.hasNestedIf && !e.hasConstantIf && !e.hasRedundantIf && e.disjoint

/--
The evaluation of an if expression at some assignment of variables.
-/
def eval (f : Nat → Bool) : IfExpr → Bool
  | lit b => b
  | var i => f i
  | ite i t e => bif i.eval f then t.eval f else e.eval f

end IfExpr

/--
This is the statement of the if normalization problem.

We require a function from that transforms if expressions to normalized if expressions,
preserving all evaluations.
-/
def IfNormalization : Type := { Z : IfExpr → IfExpr // ∀ e, (Z e).normalized ∧ (Z e).eval = e.eval }



=== LEAN SOURCE: WithoutAesop.lean ===
/-
Copyright (c) 2023 Chris Hughes. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Chris Hughes, Kim Morrison
-/
import Archive.Examples.IfNormalization.Statement
import Mathlib.Data.List.AList

/-!
# A variant of Chris Hughes' solution for the if normalization challenge.

In this variant we eschew the use of `aesop`, and instead write out the proofs.

(In order to avoid duplicated names with `Result.lean`,
we put primes on the declarations in the file.)
-/

namespace IfExpr

attribute [local simp] eval normalized hasNestedIf hasConstantIf hasRedundantIf disjoint vars
  List.disjoint

theorem eval_ite_ite' {a b c d e : IfExpr} {f : ℕ → Bool} :
    (ite (ite a b c) d e).eval f = (ite a (ite b d e) (ite c d e)).eval f := by
  cases h : eval f a <;> simp_all

/-- Custom size function for if-expressions, used for proving termination. -/
@[simp] def normSize' : IfExpr → ℕ
  | lit _ => 0
  | var _ => 1
  | .ite i t e => 2 * normSize' i + max (normSize' t) (normSize' e) + 1

/-- Normalizes the expression at the same time as assigning all variables in
`e` to the literal booleans given by `l` -/
def normalize' (l : AList (fun _ : ℕ => Bool)) :
    (e : IfExpr) → { e' : IfExpr //
        (∀ f, e'.eval f = e.eval (fun w => (l.lookup w).elim (f w) id))
        ∧ e'.normalized
        ∧ ∀ (v : ℕ), v ∈ vars e' → l.lookup v = none }
  | lit b => ⟨lit b, by simp⟩
  | var v =>
    match h : l.lookup v with
    | none => ⟨var v, by simp_all⟩
    | some b => ⟨lit b, by simp_all⟩
  | .ite (lit true) t e =>
    have ⟨t', ht'⟩ := normalize' l t
    ⟨t', by simp_all⟩
  | .ite (lit false) t e =>
    have ⟨e', he'⟩ := normalize' l e
    ⟨e', by simp_all⟩
  | .ite (.ite a b c) d e =>
    have ⟨t', ht₁, ht₂⟩ := normalize' l (.ite a (.ite b d e) (.ite c d e))
    ⟨t', fun f => by rw [ht₁, eval_ite_ite'], ht₂⟩
  | .ite (var v) t e =>
    match h : l.lookup v with
    | none =>
      have ⟨t', ht₁, ht₂, ht₃⟩ := normalize' (l.insert v true) t
      have ⟨e', he₁, he₂, he₃⟩ := normalize' (l.insert v false) e
      ⟨if t' = e' then t' else .ite (var v) t' e', by
        refine ⟨fun f => ?_, ?_, fun w b => ?_⟩
        · simp only [eval, apply_ite, ite_eq_iff']
          cases hfv : f v
          · simp +contextual only [cond_false, h, he₁]
            refine ⟨fun _ => ?_, fun _ => ?_⟩
            · congr
              ext w
              by_cases h : w = v
              · substs h
                simp_all
              · simp_all
            · congr
              ext w
              by_cases h : w = v
              · substs h
                simp_all
              · simp_all
          · simp only [cond_true, h, ht₁]
            refine ⟨fun _ => ?_, fun _ => ?_⟩
            · congr
              ext w
              by_cases h : w = v
              · substs h
                simp_all
              · simp_all
            · congr
              ext w
              by_cases h : w = v
              · substs h
                simp_all
              · simp_all
        · have := ht₃ v
          have := he₃ v
          simp_all? says
            simp_all only [normalized, Bool.and_eq_true, Bool.not_eq_eq_eq_not, Bool.not_true,
              AList.lookup_insert_eq_none, ne_eq, AList.lookup_insert, reduceCtorEq, imp_false]
          obtain ⟨⟨⟨tn, tc⟩, tr⟩, td⟩ := ht₂
          split <;> rename_i h'
          · subst h'
            simp_all
          · simp_all
        · have := ht₃ w
          have := he₃ w
          by_cases h : w = v
          · subst h; simp_all
          · simp_all? says
              simp_all only [normalized, Bool.and_eq_true, Bool.not_eq_eq_eq_not, Bool.not_true,
                AList.lookup_insert_eq_none, ne_eq, not_false_eq_true, AList.lookup_insert_ne,
                implies_true]
            obtain ⟨⟨⟨en, ec⟩, er⟩, ed⟩ := he₂
            split at b <;> rename_i h'
            · subst h'; simp_all
            · simp_all only [vars, List.cons_append, List.mem_cons, List.mem_append, false_or]
              cases b <;> simp_all⟩
    | some b =>
      have ⟨e', he'⟩ := normalize' l (.ite (lit b) t e)
      ⟨e', by simp_all⟩
  termination_by e' => e'.normSize'

example : IfNormalization :=
  ⟨fun e => (normalize' ∅ e).1,
   fun e => ⟨(normalize' ∅ e).2.2.1, by simp [(normalize' ∅ e).2.1]⟩⟩

end IfExpr



=== LEAN SOURCE: Imo1959Q1.lean ===
/-
Copyright (c) 2020 Kevin Lacker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kevin Lacker
-/
import Mathlib.Tactic.Ring
import Mathlib.Data.Nat.Prime.Basic

/-!
# IMO 1959 Q1

Prove that the fraction `(21n+4)/(14n+3)` is irreducible for every natural number `n`.

Since Lean doesn't have a concept of "irreducible fractions" per se, we just formalize this
as saying the numerator and denominator are relatively prime.
-/


open Nat

namespace Imo1959Q1

theorem calculation (n k : ℕ) (h1 : k ∣ 21 * n + 4) (h2 : k ∣ 14 * n + 3) : k ∣ 1 :=
  have h3 : k ∣ 2 * (21 * n + 4) := h1.mul_left 2
  have h4 : k ∣ 3 * (14 * n + 3) := h2.mul_left 3
  have h5 : 3 * (14 * n + 3) = 2 * (21 * n + 4) + 1 := by ring
  (Nat.dvd_add_right h3).mp (h5 ▸ h4)

end Imo1959Q1

open Imo1959Q1

theorem imo1959_q1 : ∀ n : ℕ, Coprime (21 * n + 4) (14 * n + 3) := fun n =>
  coprime_of_dvd' fun k _ h1 h2 => calculation n k h1 h2



=== LEAN SOURCE: Imo1959Q2.lean ===
/-
Copyright (c) 2024 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/
import Mathlib.Data.Real.Sqrt

/-!
# IMO 1959 Q2

For what real values of $x$ is

$\sqrt{x+\sqrt{2x-1}} + \sqrt{x-\sqrt{2x-1}} = A,$

given (a) $A=\sqrt{2}$, (b) $A=1$, (c) $A=2$,
where only non-negative real numbers are admitted for square roots?

We encode the equation as a predicate saying both that the equation holds
and that all arguments of square roots are nonnegative.

Then we follow second solution from the
[Art of Problem Solving](https://artofproblemsolving.com/wiki/index.php/1959_IMO_Problems/Problem_2)
website.
Namely, we rewrite the equation as $\sqrt{2x-1}+1+|\sqrt{2x-1}-1|=A\sqrt{2}$,
then consider the cases $\sqrt{2x-1}\le 1$ and $1 < \sqrt{2x-1}$ separately.
-/

open Set Real

namespace Imo1959Q2

def IsGood (x A : ℝ) : Prop :=
  sqrt (x + sqrt (2 * x - 1)) + sqrt (x - sqrt (2 * x - 1)) = A ∧ 0 ≤ 2 * x - 1 ∧
    0 ≤ x + sqrt (2 * x - 1) ∧ 0 ≤ x - sqrt (2 * x - 1)

variable {x A : ℝ}

theorem isGood_iff : IsGood x A ↔
    sqrt (2 * x - 1) + 1 + |sqrt (2 * x - 1) - 1| = A * sqrt 2 ∧ 1 / 2 ≤ x := by
  cases le_or_gt (1 / 2) x with
  | inl hx =>
    have hx' : 0 ≤ 2 * x - 1 := by linarith
    have h₁ : x + sqrt (2 * x - 1) = (sqrt (2 * x - 1) + 1) ^ 2 / 2 := by
      rw [add_sq, sq_sqrt hx']; field_simp; ring
    have h₂ : x - sqrt (2 * x - 1) = (sqrt (2 * x - 1) - 1) ^ 2 / 2 := by
      rw [sub_sq, sq_sqrt hx']; field_simp; ring
    simp only [IsGood, *, div_nonneg (sq_nonneg _) (zero_le_two (α := ℝ)), sqrt_div (sq_nonneg _),
      and_true]
    rw [sqrt_sq, sqrt_sq_eq_abs] <;> [skip; positivity]
    field_simp
  | inr hx =>
    have : 2 * x - 1 < 0 := by linarith
    simp only [IsGood, this.not_ge, hx.not_ge]; simp

theorem IsGood.one_half_le (h : IsGood x A) : 1 / 2 ≤ x := (isGood_iff.1 h).2

theorem sqrt_two_mul_sub_one_le_one : sqrt (2 * x - 1) ≤ 1 ↔ x ≤ 1 := by
  simp [sqrt_le_iff, ← two_mul]

theorem isGood_iff_eq_sqrt_two (hx : x ∈ Icc (1 / 2) 1) : IsGood x A ↔ A = sqrt 2 := by
  have : sqrt (2 * x - 1) ≤ 1 := sqrt_two_mul_sub_one_le_one.2 hx.2
  simp only [isGood_iff, hx.1, abs_sub_comm _ (1 : ℝ), abs_of_nonneg (sub_nonneg.2 this), and_true]
  suffices 2 = A * sqrt 2 ↔ A = sqrt 2 by convert this using 2; ring
  rw [← div_eq_iff, div_sqrt, eq_comm]
  positivity

theorem isGood_iff_eq_sqrt (hx : 1 < x) : IsGood x A ↔ A = sqrt (4 * x - 2) := by
  have h₁ : 1 < sqrt (2 * x - 1) := by simpa only [← not_le, sqrt_two_mul_sub_one_le_one] using hx
  have h₂ : 1 / 2 ≤ x := by linarith
  simp only [isGood_iff, h₂, abs_of_pos (sub_pos.2 h₁), add_add_sub_cancel, and_true]
  rw [← mul_two, ← div_eq_iff (by positivity), mul_div_assoc, div_sqrt, ← sqrt_mul' _ zero_le_two,
    eq_comm]
  ring_nf

theorem IsGood.sqrt_two_lt_of_one_lt (h : IsGood x A) (hx : 1 < x) : sqrt 2 < A := by
  rw [(isGood_iff_eq_sqrt hx).1 h]
  refine sqrt_lt_sqrt zero_le_two ?_
  linarith

theorem IsGood.eq_sqrt_two_iff_le_one (h : IsGood x A) : A = sqrt 2 ↔ x ≤ 1 :=
  ⟨fun hA ↦ not_lt.1 fun hx ↦ (h.sqrt_two_lt_of_one_lt hx).ne' hA, fun hx ↦
    (isGood_iff_eq_sqrt_two ⟨h.one_half_le, hx⟩).1 h⟩

theorem IsGood.sqrt_two_lt_iff_one_lt (h : IsGood x A) : sqrt 2 < A ↔ 1 < x :=
  ⟨fun hA ↦ not_le.1 fun hx ↦ hA.ne' <| h.eq_sqrt_two_iff_le_one.2 hx, h.sqrt_two_lt_of_one_lt⟩

theorem IsGood.sqrt_two_le (h : IsGood x A) : sqrt 2 ≤ A :=
  (le_or_gt x 1).elim (fun hx ↦ (h.eq_sqrt_two_iff_le_one.2 hx).ge) fun hx ↦
    (h.sqrt_two_lt_of_one_lt hx).le

theorem isGood_iff_of_sqrt_two_lt (hA : sqrt 2 < A) : IsGood x A ↔ x = (A / 2) ^ 2 + 1 / 2 := by
  have : 0 < A := lt_trans (by simp) hA
  constructor
  · intro h
    have hx : 1 < x := by rwa [h.sqrt_two_lt_iff_one_lt] at hA
    rw [isGood_iff_eq_sqrt hx, eq_comm, sqrt_eq_iff_eq_sq] at h <;> linarith
  · rintro rfl
    rw [isGood_iff_eq_sqrt]
    · conv_lhs => rw [← sqrt_sq this.le]
      ring_nf
    · rw [sqrt_lt' this] at hA
      linarith

theorem isGood_sqrt2_iff : IsGood x (sqrt 2) ↔ x ∈ Icc (1 / 2) 1 := by
  refine ⟨fun h ↦ ?_, fun h ↦ (isGood_iff_eq_sqrt_two h).2 rfl⟩
  exact ⟨h.one_half_le, not_lt.1 fun h₁ ↦ (h.sqrt_two_lt_of_one_lt h₁).false⟩

theorem not_isGood_one : ¬IsGood x 1 := fun h ↦
  h.sqrt_two_le.not_gt <| (lt_sqrt zero_le_one).2 (by simp)

theorem isGood_two_iff : IsGood x 2 ↔ x = 3 / 2 :=
  (isGood_iff_of_sqrt_two_lt <| (sqrt_lt' two_pos).2 (by norm_num)).trans <| by norm_num

end Imo1959Q2



=== LEAN SOURCE: Imo1960Q1.lean ===
/-
Copyright (c) 2020 Kevin Lacker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kevin Lacker
-/
import Mathlib.Data.Nat.Digits.Lemmas

/-!
# IMO 1960 Q1

Determine all three-digit numbers $N$ having the property that $N$ is divisible by 11, and
$\dfrac{N}{11}$ is equal to the sum of the squares of the digits of $N$.

Since Lean doesn't have a way to directly express problem statements of the form
"Determine all X satisfying Y", we express two predicates where proving that one implies the
other is equivalent to solving the problem. A human solver also has to discover the
second predicate.

The strategy here is roughly brute force, checking the possible multiples of 11.
-/


open Nat

namespace Imo1960Q1

def sumOfSquares (L : List ℕ) : ℕ :=
  (L.map fun x => x * x).sum

def ProblemPredicate (n : ℕ) : Prop :=
  (Nat.digits 10 n).length = 3 ∧ 11 ∣ n ∧ n / 11 = sumOfSquares (Nat.digits 10 n)

def SolutionPredicate (n : ℕ) : Prop :=
  n = 550 ∨ n = 803

/-
Proving that three digit numbers are the ones in [100, 1000).
-/
theorem not_zero {n : ℕ} (h1 : ProblemPredicate n) : n ≠ 0 :=
  have h2 : Nat.digits 10 n ≠ List.nil := List.ne_nil_of_length_eq_add_one h1.left
  digits_ne_nil_iff_ne_zero.mp h2

theorem ge_100 {n : ℕ} (h1 : ProblemPredicate n) : 100 ≤ n := by
  have h2 : 10 ^ 3 ≤ 10 * n := by
    rw [← h1.left]
    refine Nat.base_pow_length_digits_le 10 n ?_ (not_zero h1)
    simp
  omega

theorem lt_1000 {n : ℕ} (h1 : ProblemPredicate n) : n < 1000 := by
  have h2 : n < 10 ^ 3 := by
    rw [← h1.left]
    refine Nat.lt_base_pow_length_digits ?_
    simp
  omega

/-
We do an exhaustive search to show that all results are covered by `SolutionPredicate`.
-/
def SearchUpTo (c n : ℕ) : Prop :=
  n = c * 11 ∧ ∀ m : ℕ, m < n → ProblemPredicate m → SolutionPredicate m

theorem searchUpTo_start : SearchUpTo 9 99 :=
  ⟨rfl, fun n h p => by linarith [ge_100 p]⟩

theorem searchUpTo_step {c n} (H : SearchUpTo c n) {c' n'} (ec : c + 1 = c') (en : n + 11 = n') {l}
    (el : Nat.digits 10 n = l) (H' : c = sumOfSquares l → c = 50 ∨ c = 73) : SearchUpTo c' n' := by
  subst ec; subst en; subst el
  obtain ⟨rfl, H⟩ := H
  refine ⟨by ring, fun m l p => ?_⟩
  obtain ⟨h₁, ⟨m, rfl⟩, h₂⟩ := id p
  by_cases h : 11 * m < c * 11; · exact H _ h p
  obtain rfl : m = c := by omega
  rw [Nat.mul_div_cancel_left _ (by simp : 11 > 0), mul_comm] at h₂
  refine (H' h₂).imp ?_ ?_ <;> · rintro rfl; norm_num

theorem searchUpTo_end {c} (H : SearchUpTo c 1001) {n : ℕ} (ppn : ProblemPredicate n) :
    SolutionPredicate n :=
  H.2 _ (by linarith [lt_1000 ppn]) ppn

theorem right_direction {n : ℕ} : ProblemPredicate n → SolutionPredicate n := by
  have := searchUpTo_start
  iterate 82
    replace :=
      searchUpTo_step this (by norm_num1; rfl) (by norm_num1; rfl) rfl
        (by simp +decide)
  exact searchUpTo_end this

/-
Now we just need to prove the equivalence, for the precise problem statement.
-/
theorem left_direction (n : ℕ) (spn : SolutionPredicate n) : ProblemPredicate n := by
  rcases spn with (rfl | rfl) <;> refine ⟨?_, by decide, ?_⟩ <;> norm_num <;> rfl

end Imo1960Q1

open Imo1960Q1

theorem imo1960_q1 (n : ℕ) : ProblemPredicate n ↔ SolutionPredicate n :=
  ⟨right_direction, left_direction n⟩



=== LEAN SOURCE: Imo1960Q2.lean ===
/-
Copyright (c) 2024 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/
import Mathlib.Data.Real.Sqrt

/-!
# IMO 1960 Q2

For what values of the variable $x$ does the following inequality hold:

\[\dfrac{4x^2}{(1 - \sqrt {2x + 1})^2} < 2x + 9 \ ?\]

We follow solution at
[Art of Problem Solving](https://artofproblemsolving.com/wiki/index.php/1960_IMO_Problems/Problem_2)
with minor modifications.
-/

open Real Set

namespace Imo1960Q2

/-- The predicate says that `x` satisfies the inequality

\[\dfrac{4x^2}{(1 - \sqrt {2x + 1})^2} < 2x + 9\]

and belongs to the domain of the function on the left-hand side.
-/
@[mk_iff isGood_iff']
structure IsGood (x : ℝ) : Prop where
  /-- The number satisfies the inequality. -/
  ineq : 4 * x ^ 2 / (1 - sqrt (2 * x + 1)) ^ 2 < 2 * x + 9
  /-- The number belongs to the domain of \(\sqrt {2x + 1}\). -/
  sqrt_dom : 0 ≤ 2 * x + 1
  /-- The number belongs to the domain of the denominator. -/
  denom_dom : (1 - sqrt (2 * x + 1)) ^ 2 ≠ 0

/-- Solution of IMO 1960 Q2: solutions of the inequality
are the numbers of the half-closed interval \([-1/2, 45/8)\) except for the number zero. -/
theorem isGood_iff {x} : IsGood x ↔ x ∈ Ico (-1/2) (45/8) \ {0} := by
  -- First, note that the denominator is equal to zero at `x = 0`, hence it's not a solution.
  rcases eq_or_ne x 0 with rfl | hx
  · simp [isGood_iff']
  cases lt_or_ge x (-1/2) with
  | inl hx2 =>
    -- Next, if `x < -1/2`, then the square root is undefined.
    have : 2 * x + 1 < 0 := by linarith
    simp [hx2.not_ge, isGood_iff', this.not_ge]
  | inr hx2 =>
    -- Now, if `x ≥ -1/2`, `x ≠ 0`, then the expression is well-defined.
    have hx2' : 0 ≤ 2 * x + 1 := by linarith
    have H : 1 - sqrt (2 * x + 1) ≠ 0 := by
      rw [sub_ne_zero, ne_comm, ne_eq, sqrt_eq_iff_eq_sq hx2' zero_le_one]
      simpa
    calc
      -- Note that the fraction in the LHS is equal to `(1 + sqrt (2 * x + 1)) ^ 2`
      IsGood x ↔ (1 + sqrt (2 * x + 1)) ^ 2 < 2 * x + 9 := by
        have : 4 * x ^ 2 = (1 + sqrt (2 * x + 1)) ^ 2 * (1 - sqrt (2 * x + 1)) ^ 2 := by
          rw [← mul_pow, ← sq_sub_sq, sq_sqrt hx2']
          ring
        simp [isGood_iff', *]
      -- Simplify the inequality
      _ ↔ sqrt (2 * x + 1) < 7 / 2 := by
        rw [add_sq, sq_sqrt hx2']; constructor <;> intro <;> linarith
      _ ↔ 2 * x + 1 < (7 / 2) ^ 2 := sqrt_lt' <| by positivity
      _ ↔ x < 45 / 8 := by constructor <;> intro <;> linarith
      _ ↔ x ∈ Ico (-1/2) (45/8) \ {0} := by simp [*]

end Imo1960Q2



=== LEAN SOURCE: Imo1961Q3.lean ===
/-
Copyright (c) 2024 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/
import Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex

/-!
# IMO 1961 Q3

Solve the equation

$\cos^n x - \sin^n x = 1$,

where $n$ is a given positive integer.

The solution is based on the one at the
[Art of Problem Solving](https://artofproblemsolving.com/wiki/index.php/1961_IMO_Problems/Problem_3)
website.
-/

open Real

theorem Imo1961Q3 {n : ℕ} {x : ℝ} (h₀ : n ≠ 0) :
    (cos x) ^ n - (sin x) ^ n = 1 ↔
      (∃ k : ℤ, k * π = x) ∧ Even n ∨ (∃ k : ℤ, k * (2 * π) = x) ∧ Odd n ∨
        (∃ k : ℤ, -(π / 2) + k * (2 * π) = x) ∧ Odd n := by
  constructor
  · intro h
    rcases eq_or_ne (sin x) 0 with hsinx | hsinx
    · rw [hsinx, zero_pow h₀, sub_zero, pow_eq_one_iff_of_ne_zero h₀, cos_eq_one_iff,
        cos_eq_neg_one_iff] at h
      rcases h with ⟨k, rfl⟩ | ⟨⟨k, rfl⟩, hn⟩
      · cases n.even_or_odd with
        | inl hn => refine .inl ⟨⟨k * 2, ?_⟩, hn⟩; simp [mul_assoc]
        | inr hn => exact .inr <| .inl ⟨⟨_, rfl⟩, hn⟩
      · exact .inl ⟨⟨2 * k + 1, by push_cast; ring⟩, hn⟩
    · rcases eq_or_ne (cos x) 0 with hcosx | hcosx
      · right; right
        rw [hcosx, zero_pow h₀, zero_sub, ← neg_inj, neg_neg, pow_eq_neg_one_iff,
          sin_eq_neg_one_iff] at h
        simpa only [eq_comm] using h
      · have hcos1 : |cos x| < 1 := by
          rw [abs_cos_eq_sqrt_one_sub_sin_sq, sqrt_lt' one_pos]
          simp [sq_pos_of_ne_zero hsinx]
        have hsin1 : |sin x| < 1 := by
          rw [abs_sin_eq_sqrt_one_sub_cos_sq, sqrt_lt' one_pos]
          simp [sq_pos_of_ne_zero hcosx]
        match n with
        | 1 =>
          rw [pow_one, pow_one, sub_eq_iff_eq_add] at h
          have : 2 * sin x * cos x = 0 := by
            simpa [h, add_sq, add_assoc, ← two_mul, mul_add, mul_assoc, ← sq]
              using cos_sq_add_sin_sq x
          simp [hsinx, hcosx] at this
        | 2 =>
          rw [← cos_sq_add_sin_sq x, sub_eq_add_neg, add_right_inj, neg_eq_self ℝ] at h
          exact absurd (pow_eq_zero h) hsinx
        | (n + 1 + 2) =>
          set m := n + 1
          refine absurd ?_ h.not_lt
          calc
            (cos x) ^ (m + 2) - (sin x) ^ (m + 2) ≤ |cos x| ^ (m + 2) + |sin x| ^ (m + 2) := by
              simp only [← abs_pow, sub_eq_add_neg]
              gcongr
              exacts [le_abs_self _, neg_le_abs _]
            _ = |cos x| ^ m * cos x ^ 2 + |sin x| ^ m * sin x ^ 2 := by simp [pow_add]
            _ < 1 ^ m * cos x ^ 2 + 1 ^ m * sin x ^ 2 := by gcongr
            _ = 1 := by simp
  · rintro (⟨⟨k, rfl⟩, hn⟩ | ⟨⟨k, rfl⟩, -⟩ | ⟨⟨k, rfl⟩, hn⟩)
    · rw [sin_int_mul_pi, zero_pow h₀, sub_zero, ← hn.pow_abs, abs_cos_int_mul_pi, one_pow]
    · have : sin (k * (2 * π)) = 0 := by simpa [mul_assoc] using sin_int_mul_pi (k * 2)
      simp [h₀, this]
    · simp [hn.neg_pow, h₀]



=== LEAN SOURCE: Imo1962Q1.lean ===
/-
Copyright (c) 2020 Kevin Lacker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kevin Lacker
-/
import Mathlib.Data.Nat.Digits.Lemmas

/-!
# IMO 1962 Q1

Find the smallest natural number $n$ which has the following properties:

(a) Its decimal representation has 6 as the last digit.

(b) If the last digit 6 is erased and placed in front of the remaining digits,
the resulting number is four times as large as the original number $n$.

Since Lean does not explicitly express problems of the form "find the smallest number satisfying X",
we define the problem as a predicate, and then prove a particular number is the smallest member
of a set satisfying it.
-/


namespace Imo1962Q1

open Nat

def ProblemPredicate (n : ℕ) : Prop :=
  (digits 10 n).headI = 6 ∧ ofDigits 10 ((digits 10 n).tail.concat 6) = 4 * n

/-!
First, it's inconvenient to work with digits, so let's simplify them out of the problem.
-/

abbrev ProblemPredicate' (c n : ℕ) : Prop :=
  n = 10 * c + 6 ∧ 6 * 10 ^ (digits 10 c).length + c = 4 * n

lemma without_digits {n : ℕ} (hn : ProblemPredicate n) : ∃ c : ℕ, ProblemPredicate' c n := by
  use n / 10
  rcases n with - | n
  · have hpp : ¬ProblemPredicate 0 := by simp [ProblemPredicate]
    contradiction
  · rw [ProblemPredicate, digits_def' (by decide : 2 ≤ 10) n.succ_pos, List.headI, List.tail_cons,
      List.concat_eq_append] at hn
    constructor
    · rw [← hn.left, div_add_mod (n + 1) 10]
    · rw [← hn.right, ofDigits_append, ofDigits_digits, ofDigits_singleton, add_comm, mul_comm]

/-!
Now we can eliminate possibilities for `(digits 10 c).length` until we get to the one that works.
-/

lemma case_0_digits {c n : ℕ} (hc : (digits 10 c).length = 0) : ¬ProblemPredicate' c n := by
  intro hpp
  have hpow : 6 * 10 ^ 0 = 6 * 10 ^ (digits 10 c).length := by rw [hc]
  omega

lemma case_1_digits {c n : ℕ} (hc : (digits 10 c).length = 1) : ¬ProblemPredicate' c n := by
  intro hpp
  have hpow : 6 * 10 ^ 1 = 6 * 10 ^ (digits 10 c).length := by rw [hc]
  omega

lemma case_2_digits {c n : ℕ} (hc : (digits 10 c).length = 2) : ¬ProblemPredicate' c n := by
  intro hpp
  have hpow : 6 * 10 ^ 2 = 6 * 10 ^ (digits 10 c).length := by rw [hc]
  omega

lemma case_3_digits {c n : ℕ} (hc : (digits 10 c).length = 3) : ¬ProblemPredicate' c n := by
  intro hpp
  have hpow : 6 * 10 ^ 3 = 6 * 10 ^ (digits 10 c).length := by rw [hc]
  omega

lemma case_4_digits {c n : ℕ} (hc : (digits 10 c).length = 4) : ¬ProblemPredicate' c n := by
  intro hpp
  have hpow : 6 * 10 ^ 4 = 6 * 10 ^ (digits 10 c).length := by rw [hc]
  omega

/-- Putting this inline causes a deep recursion error, so we separate it out. -/
private lemma helper_5_digits {c : ℤ} (hc : 6 * 10 ^ 5 + c = 4 * (10 * c + 6)) : c = 15384 := by
  omega

lemma case_5_digits {c n : ℕ} (hc : (digits 10 c).length = 5) (hpp : ProblemPredicate' c n) :
    c = 15384 := by
  have hpow : 6 * 10 ^ 5 + c = 6 * 10 ^ (digits 10 c).length + c := by rw [hc]
  have hmul : 6 * 10 ^ 5 + c = 4 * (10 * c + 6) := by rw [hpow, hpp.right, hpp.left]
  zify at *
  exact helper_5_digits hmul

/-- `linarith` fails on numbers this large, so this lemma spells out some of the arithmetic
that normally would be automated.
-/
lemma case_more_digits {c n : ℕ} (hc : (digits 10 c).length ≥ 6) (hpp : ProblemPredicate' c n) :
    n ≥ 153846 := by
  have hnz : c ≠ 0 := by
    intro hc0
    have hcl : (digits 10 c).length = 0 := by simp [hc0]
    exact case_0_digits hcl hpp
  calc
    n ≥ 10 * c := le.intro hpp.left.symm
    _ ≥ 10 ^ (digits 10 c).length := base_pow_length_digits_le 10 c (by decide) hnz
    _ ≥ 10 ^ 6 := pow_right_mono₀ (by decide) hc
    _ ≥ 153846 := by simp

/-!
Now we combine these cases to show that 153846 is the smallest solution.
-/

lemma satisfied_by_153846 : ProblemPredicate 153846 := by
  norm_num [ProblemPredicate]
  decide

lemma no_smaller_solutions (n : ℕ) (hn : ProblemPredicate n) : n ≥ 153846 := by
  have ⟨c, hcn⟩ := without_digits hn
  cases lt_or_ge (digits 10 c).length 6 with
  | inl =>
    interval_cases hc : (digits 10 c).length
    · exfalso; exact case_0_digits hc hcn
    · exfalso; exact case_1_digits hc hcn
    · exfalso; exact case_2_digits hc hcn
    · exfalso; exact case_3_digits hc hcn
    · exfalso; exact case_4_digits hc hcn
    · exact (case_5_digits hc hcn ▸ hcn.left).ge
  | inr hge => exact case_more_digits hge hcn

end Imo1962Q1

open Imo1962Q1

theorem imo1962_q1 : IsLeast {n | ProblemPredicate n} 153846 :=
  ⟨satisfied_by_153846, no_smaller_solutions⟩



=== LEAN SOURCE: Imo1962Q4.lean ===
/-
Copyright (c) 2020 Kevin Lacker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kevin Lacker, Heather Macbeth
-/
import Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex
import Mathlib.Tactic.Polyrith

/-!
# IMO 1962 Q4

Solve the equation `cos x ^ 2 + cos (2 * x) ^ 2 + cos (3 * x) ^ 2 = 1`.

Since Lean does not have a concept of "simplest form", we just express what is
in fact the simplest form of the set of solutions, and then prove it equals the set of solutions.
-/

open Real

open scoped Real

namespace Imo1962Q4

noncomputable section

def ProblemEquation (x : ℝ) : Prop :=
  cos x ^ 2 + cos (2 * x) ^ 2 + cos (3 * x) ^ 2 = 1

def solutionSet : Set ℝ :=
  {x : ℝ | ∃ k : ℤ, x = (2 * ↑k + 1) * π / 4 ∨ x = (2 * ↑k + 1) * π / 6}

/-
The key to solving this problem simply is that we can rewrite the equation as
a product of terms, shown in `alt_formula`, being equal to zero.
-/
def altFormula (x : ℝ) : ℝ :=
  cos x * (cos x ^ 2 - 1 / 2) * cos (3 * x)

theorem cos_sum_equiv {x : ℝ} :
    (cos x ^ 2 + cos (2 * x) ^ 2 + cos (3 * x) ^ 2 - 1) / 4 = altFormula x := by
  simp only [Real.cos_two_mul, cos_three_mul, altFormula]
  ring

theorem alt_equiv {x : ℝ} : ProblemEquation x ↔ altFormula x = 0 := by
  rw [ProblemEquation, ← cos_sum_equiv, div_eq_zero_iff, sub_eq_zero]
  norm_num

theorem finding_zeros {x : ℝ} : altFormula x = 0 ↔ cos x ^ 2 = 1 / 2 ∨ cos (3 * x) = 0 := by
  simp only [altFormula, mul_assoc, mul_eq_zero, sub_eq_zero]
  constructor
  · rintro (h1 | h2)
    · right
      rw [cos_three_mul, h1]
      ring
    · exact h2
  · exact Or.inr

/-
Now we can solve for `x` using basic-ish trigonometry.
-/
theorem solve_cos2_half {x : ℝ} : cos x ^ 2 = 1 / 2 ↔ ∃ k : ℤ, x = (2 * ↑k + 1) * π / 4 := by
  rw [cos_sq]
  simp only [add_eq_left, div_eq_zero_iff]
  norm_num
  rw [cos_eq_zero_iff]
  constructor <;>
    · rintro ⟨k, h⟩
      use k
      linarith

theorem solve_cos3x_0 {x : ℝ} : cos (3 * x) = 0 ↔ ∃ k : ℤ, x = (2 * ↑k + 1) * π / 6 := by
  rw [cos_eq_zero_iff]
  refine exists_congr fun k => ?_
  constructor <;> intro <;> linarith

end

end Imo1962Q4

open Imo1962Q4

/-
The final theorem is now just gluing together our lemmas.
-/
theorem imo1962_q4 {x : ℝ} : ProblemEquation x ↔ x ∈ solutionSet := by
  rw [alt_equiv, finding_zeros, solve_cos3x_0, solve_cos2_half]
  exact exists_or.symm

namespace Imo1962Q4

/-
We now present a second solution.  The key to this solution is that, when the identity is
converted to an identity which is polynomial in `a` := `cos x`, it can be rewritten as a product of
terms, `a ^ 2 * (2 * a ^ 2 - 1) * (4 * a ^ 2 - 3)`, being equal to zero.
-/
theorem formula {R : Type*} [CommRing R] [IsDomain R] [CharZero R] (a : R) :
    a ^ 2 + ((2 : R) * a ^ 2 - (1 : R)) ^ 2 + ((4 : R) * a ^ 3 - 3 * a) ^ 2 = 1 ↔
      ((2 : R) * a ^ 2 - (1 : R)) * ((4 : R) * a ^ 3 - 3 * a) = 0 := by
  constructor <;> intro h
  · apply pow_eq_zero (n := 2)
    apply mul_left_injective₀ (b := 2) (by simp)
    linear_combination (8 * a ^ 4 - 10 * a ^ 2 + 3) * h
  · linear_combination 2 * a * h

/-
Again, we now can solve for `x` using basic-ish trigonometry.
-/
theorem solve_cos2x_0 {x : ℝ} : cos (2 * x) = 0 ↔ ∃ k : ℤ, x = (2 * ↑k + 1) * π / 4 := by
  rw [cos_eq_zero_iff]
  refine exists_congr fun k => ?_
  constructor <;> intro <;> linarith

end Imo1962Q4

open Imo1962Q4

/-
Again, the final theorem is now just gluing together our lemmas.
-/
theorem imo1962_q4' {x : ℝ} : ProblemEquation x ↔ x ∈ solutionSet :=
  calc
    ProblemEquation x ↔ cos x ^ 2 + cos (2 * x) ^ 2 + cos (3 * x) ^ 2 = 1 := by rfl
    _ ↔ cos (2 * x) = 0 ∨ cos (3 * x) = 0 := by simp [cos_two_mul, cos_three_mul, formula]
    _ ↔ x ∈ solutionSet := by rw [solve_cos2x_0, solve_cos3x_0, ← exists_or]; rfl



=== LEAN SOURCE: Imo1963Q5.lean ===
/-
Copyright (c) 2024 Rida Hamadani. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Rida Hamadani
-/
import Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex

/-!
# IMO 1963 Q5

Prove that `cos (π / 7) - cos (2 * π / 7) + cos (3 * π / 7) = 1 / 2`.

The main idea of the proof is to multiply both sides by `2 * sin (π / 7)`, then the result follows
through basic algebraic manipulations with the use of some trigonometric identities.

-/

open Real

lemma two_sin_pi_div_seven_ne_zero : 2 * sin (π / 7) ≠ 0 := by
  apply mul_ne_zero two_ne_zero (Real.sin_pos_of_pos_of_lt_pi _ _).ne' <;> linarith [pi_pos]

lemma sin_pi_mul_neg_div (a b : ℝ) : sin (π * (- a / b)) = - sin (π * (a / b)) := by
  ring_nf
  exact sin_neg _

theorem imo1963_q5 : cos (π / 7) - cos (2 * π / 7) + cos (3 * π / 7) = 1 / 2 := by
  rw [← mul_right_inj' two_sin_pi_div_seven_ne_zero, mul_add, mul_sub, ← sin_two_mul,
    two_mul_sin_mul_cos, two_mul_sin_mul_cos]
  ring_nf
  rw [← sin_pi_sub (π * (3 / 7)), sin_pi_mul_neg_div 2 7, sin_pi_mul_neg_div 1 7]
  ring_nf



=== LEAN SOURCE: Imo1964Q1.lean ===
/-
Copyright (c) 2020 Kevin Buzzard. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kevin Buzzard
-/
import Mathlib.Tactic.IntervalCases
import Mathlib.Data.Nat.ModEq
import Mathlib.Tactic.Ring

/-!
# IMO 1964 Q1

(a) Find all positive integers $n$ for which $2^n-1$ is divisible by $7$.
(b) Prove that there is no positive integer $n$ for which $2^n+1$ is divisible by $7$.

For (a), we find that the order of $2$ mod $7$ is $3$. Therefore for (b), it suffices to check
$n = 0, 1, 2$.
-/

open Nat

namespace Imo1964Q1

theorem two_pow_mod_seven (n : ℕ) : 2 ^ n ≡ 2 ^ (n % 3) [MOD 7] :=
  let t := n % 3
  calc 2 ^ n = 2 ^ (3 * (n / 3) + t) := by rw [Nat.div_add_mod]
    _ = (2 ^ 3) ^ (n / 3) * 2 ^ t := by rw [pow_add, pow_mul]
    _ ≡ 1 ^ (n / 3) * 2 ^ t [MOD 7] := by gcongr; decide
    _ = 2 ^ t := by ring

end Imo1964Q1

open Imo1964Q1

theorem imo1964_q1a (n : ℕ) (_ : 0 < n) : 7 ∣ 2 ^ n - 1 ↔ 3 ∣ n := by
  let t := n % 3
  have : t < 3 := Nat.mod_lt _ (by decide)
  calc 7 ∣ 2 ^ n - 1 ↔ 2 ^ n ≡ 1 [MOD 7] := by
        rw [Nat.ModEq.comm, Nat.modEq_iff_dvd']
        apply Nat.one_le_pow'
    _ ↔ 2 ^ t ≡ 1 [MOD 7] := ⟨(two_pow_mod_seven n).symm.trans, (two_pow_mod_seven n).trans⟩
    _ ↔ t = 0 := by interval_cases t <;> decide
    _ ↔ 3 ∣ n := by rw [dvd_iff_mod_eq_zero]

theorem imo1964_q1b (n : ℕ) : ¬7 ∣ 2 ^ n + 1 := by
  intro h
  let t := n % 3
  have : t < 3 := Nat.mod_lt _ (by decide)
  have H : 2 ^ t + 1 ≡ 0 [MOD 7] := calc
    2 ^ t + 1 ≡ 2 ^ n + 1 [MOD 7] := by gcongr ?_ + 1; exact (two_pow_mod_seven n).symm
      _ ≡ 0 [MOD 7] := h.modEq_zero_nat
  interval_cases t <;> contradiction



=== LEAN SOURCE: Imo1969Q1.lean ===
/-
Copyright (c) 2020 Kevin Lacker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kevin Lacker
-/
import Mathlib.Algebra.Ring.Identities
import Mathlib.Data.Int.NatPrime
import Mathlib.Data.Set.Finite.Lemmas
import Mathlib.Tactic.Linarith

/-!
# IMO 1969 Q1

Prove that there are infinitely many natural numbers $a$ with the following property:
the number $z = n^4 + a$ is not prime for any natural number $n$.
-/


open Int Nat

namespace Imo1969Q1

/-- `goodNats` is the set of natural numbers satisfying the condition in the problem
statement, namely the `a : ℕ` such that `n^4 + a` is not prime for any `n : ℕ`. -/
def goodNats : Set ℕ :=
  {a : ℕ | ∀ n : ℕ, ¬Nat.Prime (n ^ 4 + a)}

/-!
The key to the solution is that you can factor $z$ into the product of two polynomials,
if $a = 4*m^4$. This is Sophie Germain's identity, called `pow_four_add_four_mul_pow_four`
in mathlib.
-/


theorem factorization {m n : ℤ} :
    ((n - m) ^ 2 + m ^ 2) * ((n + m) ^ 2 + m ^ 2) = n ^ 4 + 4 * m ^ 4 :=
  pow_four_add_four_mul_pow_four.symm

/-!
To show that the product is not prime, we need to show each of the factors is at least 2,
which `nlinarith` can solve since they are each expressed as a sum of squares.
-/


theorem left_factor_large {m : ℤ} (n : ℤ) (h : 1 < m) : 1 < (n - m) ^ 2 + m ^ 2 := by nlinarith

theorem right_factor_large {m : ℤ} (n : ℤ) (h : 1 < m) : 1 < (n + m) ^ 2 + m ^ 2 := by nlinarith

/-!
The factorization is over the integers, but we need the nonprimality over the natural numbers.
-/


theorem int_large {m : ℤ} (h : 1 < m) : 1 < m.natAbs := by
  exact_mod_cast lt_of_lt_of_le h le_natAbs

theorem not_prime_of_int_mul' {m n : ℤ} {c : ℕ} (hm : 1 < m) (hn : 1 < n) (hc : m * n = (c : ℤ)) :
    ¬Nat.Prime c :=
  not_prime_of_int_mul (int_large hm).ne' (int_large hn).ne' hc

/-- Every natural number of the form `n^4 + 4*m^4` is not prime. -/
theorem polynomial_not_prime {m : ℕ} (h1 : 1 < m) (n : ℕ) : ¬Nat.Prime (n ^ 4 + 4 * m ^ 4) := by
  have h2 : 1 < (m : ℤ) := Int.ofNat_lt.mpr h1
  refine not_prime_of_int_mul' (left_factor_large (n : ℤ) h2) (right_factor_large (n : ℤ) h2) ?_
  apply factorization

/-- We define $a_{choice}(b) := 4*(2+b)^4$, so that we can take $m = 2+b$ in `polynomial_not_prime`.
-/
def aChoice (b : ℕ) : ℕ :=
  4 * (2 + b) ^ 4

theorem aChoice_good (b : ℕ) : aChoice b ∈ goodNats :=
  polynomial_not_prime (show 1 < 2 + b by linarith)

/-- `aChoice` is a strictly monotone function; this is easily proven by chaining together lemmas
in the `strictMono` namespace. -/
theorem aChoice_strictMono : StrictMono aChoice :=
  ((strictMono_id.const_add 2).nat_pow (by decide)).const_mul (by decide)

end Imo1969Q1

open Imo1969Q1

/-- We conclude by using the fact that `aChoice` is an injective function from the natural numbers
to the set `goodNats`. -/
theorem imo1969_q1 : Set.Infinite {a : ℕ | ∀ n : ℕ, ¬Nat.Prime (n ^ 4 + a)} :=
  Set.infinite_of_injective_forall_mem aChoice_strictMono.injective aChoice_good



=== LEAN SOURCE: Imo1972Q5.lean ===
/-
Copyright (c) 2020 Ruben Van de Velde, Stanislas Polu. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Ruben Van de Velde, Stanislas Polu
-/
import Mathlib.Data.Real.Basic
import Mathlib.Analysis.Normed.Module.Basic

/-!
# IMO 1972 Q5

Problem: `f` and `g` are real-valued functions defined on the real line. For all `x` and `y`,
`f(x + y) + f(x - y) = 2f(x)g(y)`. `f` is not identically zero and `|f(x)| ≤ 1` for all `x`.
Prove that `|g(x)| ≤ 1` for all `x`.
-/

/--
This proof begins by introducing the supremum of `f`, `k ≤ 1` as well as `k' = k / ‖g y‖`. We then
suppose that the conclusion does not hold (`hneg`) and show that `k ≤ k'` (by
`2 * (‖f x‖ * ‖g y‖) ≤ 2 * k` obtained from the main hypothesis `hf1`) and that `k' < k` (obtained
from `hneg` directly), finally raising a contradiction with `k' < k'`.

(Authored by Stanislas Polu inspired by Ruben Van de Velde).
-/
theorem imo1972_q5 (f g : ℝ → ℝ) (hf1 : ∀ x, ∀ y, f (x + y) + f (x - y) = 2 * f x * g y)
    (hf2 : ∀ y, ‖f y‖ ≤ 1) (hf3 : ∃ x, f x ≠ 0) (y : ℝ) : ‖g y‖ ≤ 1 := by
  -- Suppose the conclusion does not hold.
  by_contra! hneg
  set S := Set.range fun x => ‖f x‖
  -- Introduce `k`, the supremum of `f`.
  let k : ℝ := sSup S
  -- Show that `‖f x‖ ≤ k`.
  have hk₁ : ∀ x, ‖f x‖ ≤ k := by
    have h : BddAbove S := ⟨1, Set.forall_mem_range.mpr hf2⟩
    intro x
    exact le_csSup h (Set.mem_range_self x)
  -- Show that `2 * (‖f x‖ * ‖g y‖) ≤ 2 * k`.
  have hk₂ : ∀ x, 2 * (‖f x‖ * ‖g y‖) ≤ 2 * k := fun x ↦
    calc
      2 * (‖f x‖ * ‖g y‖) = ‖2 * f x * g y‖ := by simp [mul_assoc]
      _ = ‖f (x + y) + f (x - y)‖ := by rw [hf1]
      _ ≤ ‖f (x + y)‖ + ‖f (x - y)‖ := norm_add_le _ _
      _ ≤ k + k := add_le_add (hk₁ _) (hk₁ _)
      _ = 2 * k := (two_mul _).symm
  set k' := k / ‖g y‖
  -- Demonstrate that `k' < k` using `hneg`.
  have H₁ : k' < k := by
    have h₁ : 0 < k := by
      obtain ⟨x, hx⟩ := hf3
      calc
        0 < ‖f x‖ := norm_pos_iff.mpr hx
        _ ≤ k := hk₁ x
    rw [div_lt_iff₀]
    · apply lt_mul_of_one_lt_right h₁ hneg
    · exact zero_lt_one.trans hneg
  -- Demonstrate that `k ≤ k'` using `hk₂`.
  have H₂ : k ≤ k' := by
    have h₁ : ∃ x : ℝ, x ∈ S := by use ‖f 0‖; exact Set.mem_range_self 0
    have h₂ : ∀ x, ‖f x‖ ≤ k' := by
      intro x
      rw [le_div_iff₀]
      · apply (mul_le_mul_left zero_lt_two).mp (hk₂ x)
      · exact zero_lt_one.trans hneg
    apply csSup_le h₁
    rintro y' ⟨yy, rfl⟩
    exact h₂ yy
  -- Conclude by obtaining a contradiction, `k' < k'`.
  apply lt_irrefl k'
  calc
    k' < k := H₁
    _ ≤ k' := H₂

/-- IMO 1972 Q5

Problem: `f` and `g` are real-valued functions defined on the real line. For all `x` and `y`,
`f(x + y) + f(x - y) = 2f(x)g(y)`. `f` is not identically zero and `|f(x)| ≤ 1` for all `x`.
Prove that `|g(x)| ≤ 1` for all `x`.

This is a more concise version of the proof proposed by Ruben Van de Velde.
-/
theorem imo1972_q5' (f g : ℝ → ℝ) (hf1 : ∀ x, ∀ y, f (x + y) + f (x - y) = 2 * f x * g y)
    (hf2 : BddAbove (Set.range fun x => ‖f x‖)) (hf3 : ∃ x, f x ≠ 0) (y : ℝ) : ‖g y‖ ≤ 1 := by
  obtain ⟨x, hx⟩ := hf3
  set k := ⨆ x, ‖f x‖
  have h : ∀ x, ‖f x‖ ≤ k := le_ciSup hf2
  by_contra! H
  have hgy : 0 < ‖g y‖ := by linarith
  have k_pos : 0 < k := lt_of_lt_of_le (norm_pos_iff.mpr hx) (h x)
  have : k / ‖g y‖ < k := (div_lt_iff₀ hgy).mpr (lt_mul_of_one_lt_right k_pos H)
  have : k ≤ k / ‖g y‖ := by
    suffices ∀ x, ‖f x‖ ≤ k / ‖g y‖ from ciSup_le this
    intro x
    suffices 2 * (‖f x‖ * ‖g y‖) ≤ 2 * k by
      rwa [le_div_iff₀ hgy, ← mul_le_mul_left (zero_lt_two : (0 : ℝ) < 2)]
    calc
      2 * (‖f x‖ * ‖g y‖) = ‖2 * f x * g y‖ := by simp [mul_assoc]
      _ = ‖f (x + y) + f (x - y)‖ := by rw [hf1]
      _ ≤ ‖f (x + y)‖ + ‖f (x - y)‖ := abs_add _ _
      _ ≤ 2 * k := by linarith [h (x + y), h (x - y)]
  linarith



=== LEAN SOURCE: Imo1975Q1.lean ===
/-
Copyright (c) 2022 Mantas Bakšys. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mantas Bakšys
-/
import Mathlib.Algebra.BigOperators.Ring.Finset
import Mathlib.Algebra.Order.Rearrangement
import Mathlib.Data.Real.Basic
import Mathlib.Order.Interval.Finset.Nat

/-!
# IMO 1975 Q1

Let `x₁, x₂, ... , xₙ` and `y₁, y₂, ... , yₙ` be two sequences of real numbers, such that
`x₁ ≥ x₂ ≥ ... ≥ xₙ` and `y₁ ≥ y₂ ≥ ... ≥ yₙ`. Prove that if `z₁, z₂, ... , zₙ` is any permutation
of `y₁, y₂, ... , yₙ`, then `∑ (xᵢ - yᵢ)^2 ≤ ∑ (xᵢ - zᵢ)^2`

# Solution

Firstly, we expand the squares within both sums and distribute into separate finite sums. Then,
noting that `∑ yᵢ ^ 2 = ∑ zᵢ ^ 2`, it remains to prove that `∑ xᵢ * zᵢ ≤ ∑ xᵢ * yᵢ`, which is true
by the Rearrangement Inequality
-/


/- Let `n` be a natural number, `x` and `y` be as in the problem statement and `σ` be the
permutation of natural numbers such that `z = y ∘ σ` -/
variable (n : ℕ) (σ : Equiv.Perm ℕ) (x y : ℕ → ℝ)

theorem imo1975_q1 (hσ : {x | σ x ≠ x} ⊆ Finset.Icc 1 n)
    (hx : AntitoneOn x (Finset.Icc 1 n)) (hy : AntitoneOn y (Finset.Icc 1 n)) :
    ∑ i ∈ Finset.Icc 1 n, (x i - y i) ^ 2 ≤ ∑ i ∈ Finset.Icc 1 n, (x i - y (σ i)) ^ 2 := by
  simp only [sub_sq, Finset.sum_add_distrib, Finset.sum_sub_distrib]
  -- a finite sum is invariant if we permute the order of summation
  have hσy : ∑ i ∈ Finset.Icc 1 n, y i ^ 2 = ∑ i ∈ Finset.Icc 1 n, y (σ i) ^ 2 := by
    rw [← Equiv.Perm.sum_comp σ (Finset.Icc 1 n) _ hσ]
  -- let's cancel terms appearing on both sides
  rw [hσy, add_le_add_iff_right, sub_le_sub_iff_left]
  simp only [mul_assoc, ← Finset.mul_sum, zero_lt_two, mul_le_mul_left]
  -- what's left to prove is a version of the rearrangement inequality
  apply MonovaryOn.sum_mul_comp_perm_le_sum_mul _ hσ
  -- finally we need to show that `x` and `y` 'vary' together on `[1, n]` and this is due to both of
  -- them being `decreasing`
  exact AntitoneOn.monovaryOn hx hy



=== LEAN SOURCE: Imo1977Q6.lean ===
/-
Copyright (c) 2021 Tian Chen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Tian Chen
-/
import Mathlib.Data.PNat.Basic

/-!
# IMO 1977 Q6

Suppose `f : ℕ+ → ℕ+` satisfies `f(f(n)) < f(n + 1)` for all `n`.
Prove that `f(n) = n` for all `n`.

We first prove the problem statement for `f : ℕ → ℕ`
then we use it to prove the statement for positive naturals.
-/


namespace Imo1977Q6

theorem imo1977_q6_nat (f : ℕ → ℕ) (h : ∀ n, f (f n) < f (n + 1)) : ∀ n, f n = n := by
  have h' (k n : ℕ) (hk : k ≤ n) : k ≤ f n := by
    induction k generalizing n with
    | zero => exact Nat.zero_le _
    | succ k h_ind =>
      apply Nat.succ_le_of_lt
      calc
        k ≤ f (f (n - 1)) := h_ind _ (h_ind (n - 1) (le_tsub_of_add_le_right hk))
        _ < f n := tsub_add_cancel_of_le (le_trans (Nat.succ_le_succ (Nat.zero_le _)) hk) ▸ h _
  have hf : ∀ n, n ≤ f n := fun n => h' n n rfl.le
  have hf_mono : StrictMono f := strictMono_nat_of_lt_succ fun _ => lt_of_le_of_lt (hf _) (h _)
  intro
  exact Nat.eq_of_le_of_lt_succ (hf _) (hf_mono.lt_iff_lt.mp (h _))

end Imo1977Q6

open Imo1977Q6

theorem imo1977_q6 (f : ℕ+ → ℕ+) (h : ∀ n, f (f n) < f (n + 1)) : ∀ n, f n = n := by
  intro n
  have := by
    refine imo1977_q6_nat (fun m => if 0 < m then f m.toPNat' else 0) ?_ n
    intro x; cases x
    · simp
    · simpa using h _
  simpa



=== LEAN SOURCE: Imo1981Q3.lean ===
/-
Copyright (c) 2020 Kevin Lacker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kevin Lacker
-/
import Mathlib.Data.Int.Lemmas
import Mathlib.Data.Nat.Fib.Basic
import Mathlib.Tactic.Linarith
import Mathlib.Tactic.LinearCombination

/-!
# IMO 1981 Q3

Determine the maximum value of `m ^ 2 + n ^ 2`, where `m` and `n` are integers in
`{1, 2, ..., 1981}` and `(n ^ 2 - m * n - m ^ 2) ^ 2 = 1`.

The trick to this problem is that `m` and `n` have to be consecutive Fibonacci numbers,
because you can reduce any solution to a smaller one using the Fibonacci recurrence.
-/


/-
First, define the problem in terms of finding the maximum of a set.

We first generalize the problem to `{1, 2, ..., N}` and specialize to `N = 1981` at the very end.
-/
open Int Nat Set

namespace Imo1981Q3

variable (N : ℕ)

-- N = 1981
@[mk_iff]
structure ProblemPredicate (m n : ℤ) : Prop where
  m_range : m ∈ Ioc 0 (N : ℤ)
  n_range : n ∈ Ioc 0 (N : ℤ)
  eq_one : (n ^ 2 - m * n - m ^ 2) ^ 2 = 1

def specifiedSet : Set ℤ :=
  {k : ℤ | ∃ m : ℤ, ∃ n : ℤ, k = m ^ 2 + n ^ 2 ∧ ProblemPredicate N m n}

/-
We want to reduce every solution to a smaller solution. Specifically,
we show that when `(m, n)` is a solution, `(n - m, m)` is also a solution,
except for the base case of `(1, 1)`.
-/
namespace ProblemPredicate

variable {N}

theorem m_le_n {m n : ℤ} (h1 : ProblemPredicate N m n) : m ≤ n := by
  by_contra h2
  have h3 : 1 = (n * (n - m) - m ^ 2) ^ 2 := by linear_combination - h1.eq_one
  have h4 : n * (n - m) - m ^ 2 < -1 := by nlinarith [h1.n_range.left]
  have h5 : 1 < (n * (n - m) - m ^ 2) ^ 2 := by nlinarith
  exact h5.ne h3

theorem eq_imp_1 {n : ℤ} (h1 : ProblemPredicate N n n) : n = 1 :=
  have : n * (n * (n * n)) = 1 := by linear_combination h1.eq_one
  eq_one_of_mul_eq_one_right h1.m_range.left.le this

theorem reduction {m n : ℤ} (h1 : ProblemPredicate N m n) (h2 : 1 < n) :
    ProblemPredicate N (n - m) m := by
  obtain (rfl : m = n) | (h3 : m < n) := h1.m_le_n.eq_or_lt
  · have h4 : m = 1 := h1.eq_imp_1
    exact absurd h4.symm h2.ne
  exact
    { n_range := h1.m_range
      m_range := by
        have h5 : 0 < n - m := sub_pos.mpr h3
        have h6 : n - m < N := by
          calc
            _ < n := sub_lt_self n h1.m_range.left
            _ ≤ N := h1.n_range.right
        exact ⟨h5, h6.le⟩
      eq_one := by linear_combination h1.eq_one }

end ProblemPredicate

/-
It will be convenient to have the lemmas above in their natural number form.
Most of these can be proved with the `norm_cast` family of tactics.
-/
def NatPredicate (m n : ℕ) : Prop :=
  ProblemPredicate N ↑m ↑n

namespace NatPredicate

variable {N}

nonrec theorem m_le_n {m n : ℕ} (h1 : NatPredicate N m n) : m ≤ n := mod_cast h1.m_le_n

nonrec theorem eq_imp_1 {n : ℕ} (h1 : NatPredicate N n n) : n = 1 := mod_cast h1.eq_imp_1

nonrec theorem reduction {m n : ℕ} (h1 : NatPredicate N m n) (h2 : 1 < n) :
    NatPredicate N (n - m) m := by
  have : m ≤ n := h1.m_le_n
  exact mod_cast h1.reduction (mod_cast h2)

theorem n_pos {m n : ℕ} (h1 : NatPredicate N m n) : 0 < n := mod_cast h1.n_range.left

theorem m_pos {m n : ℕ} (h1 : NatPredicate N m n) : 0 < m := mod_cast h1.m_range.left

theorem n_le_N {m n : ℕ} (h1 : NatPredicate N m n) : n ≤ N := mod_cast h1.n_range.right

/-
Now we can use induction to show that solutions must be Fibonacci numbers.
-/
theorem imp_fib {n : ℕ} : ∀ m : ℕ, NatPredicate N m n → ∃ k : ℕ, m = fib k ∧ n = fib (k + 1) := by
  refine Nat.strong_induction_on n ?_
  intro n h1 m h2
  have h3 : m ≤ n := h2.m_le_n
  obtain (rfl : 1 = n) | (h4 : 1 < n) := (succ_le_iff.mpr h2.n_pos).eq_or_lt
  · use 1
    have h5 : 1 ≤ m := succ_le_iff.mpr h2.m_pos
    simpa using h3.antisymm h5
  · obtain (rfl : m = n) | (h6 : m < n) := h3.eq_or_lt
    · exact absurd h2.eq_imp_1 (Nat.ne_of_gt h4)
    · have h7 : NatPredicate N (n - m) m := h2.reduction h4
      obtain ⟨k : ℕ, hnm : n - m = fib k, rfl : m = fib (k + 1)⟩ := h1 m h6 (n - m) h7
      use k + 1, rfl
      rw [fib_add_two, ← hnm, tsub_add_cancel_of_le h3]

end NatPredicate

/-
Next, we prove that if `N < fib K + fib (K+1)`, then the largest `m` and `n`
satisfying `NatPredicate m n N` are `fib K` and `fib (K+1)`, respectively.
-/
variable {K : ℕ} (HK : N < fib K + fib (K + 1)) {N}

include HK in
theorem m_n_bounds {m n : ℕ} (h1 : NatPredicate N m n) : m ≤ fib K ∧ n ≤ fib (K + 1) := by
  obtain ⟨k : ℕ, hm : m = fib k, hn : n = fib (k + 1)⟩ := h1.imp_fib m
  by_cases h2 : k < K + 1
  · have h3 : k ≤ K := Nat.lt_succ_iff.mp h2
    constructor
    · calc
        m = fib k := hm
        _ ≤ fib K := fib_mono h3
    · have h6 : k + 1 ≤ K + 1 := succ_le_succ h3
      calc
        n = fib (k + 1) := hn
        _ ≤ fib (K + 1) := fib_mono h6
  · have h7 : N < n := by
      have h8 : K + 2 ≤ k + 1 := succ_le_succ (not_lt.mp h2)
      rw [← fib_add_two] at HK
      calc
        N < fib (K + 2) := HK
        _ ≤ fib (k + 1) := fib_mono h8
        _ = n := hn.symm
    have h9 : n ≤ N := h1.n_le_N
    exact absurd h7 h9.not_gt

/-
We spell out the consequences of this result for `specifiedSet N` here.
-/
variable {M : ℕ} (HM : M = fib K ^ 2 + fib (K + 1) ^ 2)
include HK HM

theorem k_bound {m n : ℤ} (h1 : ProblemPredicate N m n) : m ^ 2 + n ^ 2 ≤ M := by
  have h2 : 0 ≤ m := h1.m_range.left.le
  have h3 : 0 ≤ n := h1.n_range.left.le
  rw [← natAbs_of_nonneg h2, ← natAbs_of_nonneg h3] at h1; clear h2 h3
  obtain ⟨h4 : m.natAbs ≤ fib K, h5 : n.natAbs ≤ fib (K + 1)⟩ := m_n_bounds HK h1
  have h6 : m ^ 2 ≤ (fib K : ℤ) ^ 2 := Int.natAbs_le_iff_sq_le.mp h4
  have h7 : n ^ 2 ≤ (fib (K + 1) : ℤ) ^ 2 := Int.natAbs_le_iff_sq_le.mp h5
  linarith

theorem solution_bound : ∀ {k : ℤ}, k ∈ specifiedSet N → k ≤ M
  | _, ⟨_, _, rfl, h⟩ => k_bound HK HM h

theorem solution_greatest (H : ProblemPredicate N (fib K) (fib (K + 1))) :
    IsGreatest (specifiedSet N) M :=
  ⟨⟨fib K, fib (K + 1), by simp [HM], H⟩, fun k h => solution_bound HK HM h⟩

end Imo1981Q3

open Imo1981Q3

/-
Now we just have to demonstrate that 987 and 1597 are in fact the largest Fibonacci
numbers in this range, and thus provide the maximum of `specifiedSet`.
-/
theorem imo1981_q3 : IsGreatest (specifiedSet 1981) 3524578 := by
  have := fun h => @solution_greatest 1981 16 h 3524578
  simp +decide at this
  apply this
  simp +decide [problemPredicate_iff]



=== LEAN SOURCE: Imo1982Q1.lean ===
/-
Copyright (c) 2024 Alex Brodbelt. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Alex Brodbelt, Violeta Hernández
-/

import Mathlib.Tactic.NormNum
import Mathlib.Tactic.Linarith
import Mathlib.Data.PNat.Basic

/-!
# IMO 1982 Q1

The function `f` is defined for all positive integers `n` and takes on
non-negative integer values. Also, for all `m`, `n`

`f (m + n) - f(m) - f(n) = 0` or `1`
`f 2 = 0`, `f 3 > 0`, and `f 9999 = 3333`.

Determine `f 1982`.

The solution is based on the one at the
[Art of Problem Solving](https://artofproblemsolving.com/wiki/index.php/1982_IMO_Problems/Problem_1)
website.

We prove the helper lemmas:
1. `f m + f n ≤ f(m + n)` `superadditive`.
2. `n * f(m) ≤ f(m * n)` `superhomogeneous`.
3. `a * f a  + c * f d ≤ f (a * b + c * d)` `superlinear`, (derived from 1. and 2.).

So we can establish on the one hand that `f 1980 ≤ 660`,
by observing that `660 * 1 = 660 * f3 ≤ f 1980 = f (660 * 3)`.

On the other hand, we establish that `f 1980 ≥ 660`
from `5 * f 1980 + 33 * f 3 ≤ f (5 * 1980 + 33 * 1) = f 9999 = 3333`.

We then conclude `f 1980 = 660` and then eventually determine that either
`f 1982 = 660` or `f 1982 = 661`.

In the latter case we derive a contradiction, because if `f 1982 = 661` then
`3334 = 5 * f 1982 + 29 * f(3) + f(2) ≤ f (5 * 1982 + 29 * 3 + 2) = f 9999 = 3333`.
-/

namespace Imo1982Q1

structure IsGood (f : ℕ+ → ℕ) : Prop where
  /-- The function satisfies the functional relation. -/
  rel: ∀ m n : ℕ+, f (m + n) = f m + f n ∨ f (m + n) = f m + f n + 1
  f₂ : f 2 = 0
  hf₃ : 0 < f 3
  f_9999 : f 9999 = 3333

namespace IsGood

variable {f : ℕ+ → ℕ} (hf : IsGood f)
include hf

lemma f₁ : f 1 = 0 := by
  have h : f 2 = 2 * f 1 ∨ f 2 = 2 * f 1 + 1 := by rw [two_mul]; exact hf.rel 1 1
  obtain h₁ | h₂ := hf.f₂ ▸ h
  · rw [eq_comm, mul_eq_zero] at h₁
    apply h₁.resolve_left
    norm_num
  · cases Nat.succ_ne_zero _ h₂.symm

lemma f₃ : f 3 = 1 := by
  have h : f 3 = f 2 + f 1 ∨ f 3 = f 2 + f 1 + 1 := hf.rel 2 1
  rw [hf.f₁, hf.f₂, add_zero, zero_add] at h
  exact h.resolve_left hf.hf₃.ne'

lemma superadditive {m n : ℕ+} : f m + f n ≤ f (m + n) := by have h := hf.rel m n; grind

lemma superhomogeneous {m n : ℕ+} : ↑n * f m ≤ f (n * m) := by
  induction n with
  | one => simp
  | succ n' ih =>
    calc
    ↑(n' + 1) * f m = ↑n' * f m + f m := by rw [PNat.add_coe, add_mul, PNat.val_ofNat, one_mul]
    _ ≤ f (n' * m) + f m := by gcongr
    _ ≤ f (n' * m + m) := hf.superadditive
    _ = f ((n' + 1) * m) := by congr; rw [add_mul, one_mul]

lemma superlinear {a b c d : ℕ+} : a * f b + c * f d ≤ f (a * b + c * d) :=
  (add_le_add hf.superhomogeneous hf.superhomogeneous).trans hf.superadditive

lemma le_mul_three_apply (n : ℕ+) : n ≤ f (3 * n) := by
  rw [← mul_one (n : ℕ), ← hf.f₃, mul_comm 3]
  exact hf.superhomogeneous

lemma part_1 : 660 ≤ f (1980) := by
  exact hf.le_mul_three_apply 660

lemma part_2 : f 1980 ≤ 660 := by
  have h : 5 * f 1980 + 33 * f 3 ≤ 5 * 660 + 33 := by
    calc (5 : ℕ+) * f 1980 + (33 : ℕ+) * f 3 ≤ f (5 * 1980 + 33 * 3) := by apply hf.superlinear
    _ = f 9999 := by rfl
    _ = 5 * 660 + 33 := by rw [hf.f_9999]
  rw [hf.f₃, mul_one] at h
  -- from 5 * f 1980 + 33 ≤ 5 * 660 + 33 we show f 1980 ≤ 660
  linarith

end IsGood

end Imo1982Q1

open Imo1982Q1

lemma imo1982_q1 {f : ℕ+ → ℕ} (hf : IsGood f) : f 1982 = 660 := by
  have f_1980 := hf.part_2.antisymm hf.part_1
  have h : f 1982 = f 1980 + f 2 ∨ f 1982 = f 1980 + f 2 + 1 := hf.rel 1980 2
  rw [f_1980, hf.f₂, add_zero] at h
  apply h.resolve_right
  intro hr
  suffices h : 3334 ≤ 3333 by simp at h
  calc
    3334 = 5 * f 1982 + 29 * f 3 + f 2 := by rw [hf.f₃, hf.f₂, hr, add_zero, mul_one]
    (5 : ℕ+) * f 1982 + (29 : ℕ+) * f 3 + f 2 ≤ f (5 * 1982 + 29 * 3) + f 2 :=
      add_le_add_right hf.superlinear _
    _ ≤ f (5 * 1982 + 29 * 3 + 2) := hf.superadditive
    _ = 3333 := hf.f_9999



=== LEAN SOURCE: Imo1982Q3.lean ===
/-
Copyright (c) 2024 Violeta Hernández Palacios. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Violeta Hernández Palacios, Alex Brodbelt
-/
import Mathlib.Algebra.Order.BigOperators.Ring.Finset
import Mathlib.Algebra.GeomSum
import Mathlib.Data.NNReal.Basic

/-!
# IMO 1982 Q3

Consider infinite sequences $\{x_n\}$ of positive reals such that $x_0 = 1$ and
$x_0 \ge x_1 \ge x_2 \ge \ldots$

a) Prove that for every such sequence there is an $n \ge 1$ such that:

$$\frac{x_0^2}{x_1} + \ldots + \frac{x_{n-1}^2}{x_n} \ge 3.999$$

b) Find such a sequence such that for all $n$:

$$\frac{x_0^2}{x_1} + \ldots + \frac{x_{n-1}^2}{x_n} < 4$$

The solution is based on Solution 1 from the
[Art of Problem Solving](https://artofproblemsolving.com/wiki/index.php/1982_IMO_Problems/Problem_3)
website. For part a, we use Sedrakyan's lemma to show the sum is bounded below by
$\frac{4n}{n + 1}$, which can be made arbitrarily close to $4$ by taking large $n$. For part b, we
show the sequence $x_n = 2^{-n}$ satisfies the desired inequality.
-/

open Finset NNReal

variable {x : ℕ → ℝ} {n : ℕ} (hn : n ≠ 0) (hx : Antitone x)

namespace Imo1982Q3
include hn hx

/-- `x n` is at most the average of all previous terms in the sequence.

This is expressed here with `∑ k ∈ range n, x k` added to both sides. -/
lemma le_avg : ∑ k ∈ range (n + 1), x k ≤ (∑ k ∈ range n, x k) * (1 + 1 / n) := by
  rw [sum_range_succ, mul_one_add, add_le_add_iff_left, mul_one_div,
    le_div_iff₀ (mod_cast hn.bot_lt), mul_comm, ← nsmul_eq_mul]
  conv_lhs => rw [← card_range n, ← sum_const]
  gcongr with i hi
  refine hx <| le_of_lt ?_
  simpa using hi

/-- The main inequality used for part a. -/
lemma ineq (h0 : x 0 = 1) (hp : ∀ k, 0 < x k) :
    4 * n / (n + 1) ≤ ∑ k ∈ range (n + 1), x k ^ 2 / x (k + 1) := by
  calc
    -- We first use AM-GM.
    _ ≤ (∑ k ∈ range n, x (k + 1) + 1) ^ 2 / (∑ k ∈ range n, x (k + 1)) * n / (n + 1) := by
      gcongr
      rw [le_div_iff₀]
      · simpa using four_mul_le_sq_add (∑ k ∈ range n, x (k + 1)) 1
      · exact sum_pos (fun k _ ↦ hp _) (nonempty_range_iff.2 hn)
    -- We move the fraction into the denominator.
    _ = (∑ k ∈ range n, x (k + 1) + 1) ^ 2 / ((∑ k ∈ range n, x (k + 1)) * (1 + 1 / n)) := by
      field_simp
    -- We make use of the `le_avg` lemma.
    _ ≤ (∑ k ∈ range (n + 1), x k) ^ 2 / ∑ k ∈ range (n + 1), x (k + 1) := by
      gcongr
      · exact sum_pos (fun k _ ↦ hp _) nonempty_range_succ
      · exact add_nonneg (sum_nonneg fun k _ ↦ (hp _).le) zero_le_one
      · rw [sum_range_succ', h0]
      · exact le_avg hn (hx.comp_monotone @Nat.succ_le_succ)
    -- We conclude by Sedrakyan.
    _ ≤ _ := sq_sum_div_le_sum_sq_div _ x fun k _ ↦ hp (k + 1)

end Imo1982Q3

/-- Part a of the problem is solved by `n = 4000`. -/
theorem imo1982_q3a (hx : Antitone x) (h0 : x 0 = 1) (hp : ∀ k, 0 < x k) :
    ∃ n : ℕ, 3.999 ≤ ∑ k ∈ range n, (x k) ^ 2 / x (k + 1) := by
  use 4000
  convert Imo1982Q3.ineq (Nat.succ_ne_zero 3998) hx h0 hp
  norm_num

/-- Part b of the problem is solved by `x k = (1 / 2) ^ k`. -/
theorem imo1982_q3b : ∃ x : ℕ → ℝ, Antitone x ∧ x 0 = 1 ∧ (∀ k, 0 < x k)
    ∧ ∀ n, ∑ k ∈ range n, x k ^ 2 / x (k + 1) < 4 := by
  refine ⟨fun k ↦ 2⁻¹ ^ k, ?_, pow_zero _, ?_, fun n ↦ ?_⟩
  · apply (pow_right_strictAnti₀ _ _).antitone <;> norm_num
  · simp
  · have {k : ℕ} : (2 : ℝ)⁻¹ ^ (k * 2) * ((2 : ℝ)⁻¹ ^ k)⁻¹ = (2 : ℝ)⁻¹ ^ k := by
      rw [← pow_sub₀] <;> simp [mul_two]
    simp_rw [← pow_mul, pow_succ, ← div_eq_mul_inv, div_div_eq_mul_div, mul_comm, mul_div_assoc,
      ← mul_sum, div_eq_mul_inv, this, ← two_add_two_eq_four, ← mul_two,
      mul_lt_mul_iff_of_pos_left two_pos]
    convert NNReal.coe_lt_coe.2 <| geom_sum_lt (inv_ne_zero two_ne_zero) two_inv_lt_one n
    · simp
    · norm_num



=== LEAN SOURCE: Imo1985Q2.lean ===
/-
Copyright (c) 2025 Jeremy Tan. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Tan, David Renshaw
-/
import Mathlib.Algebra.Order.Ring.Canonical
import Mathlib.Algebra.Order.Star.Basic
import Mathlib.Data.Int.NatAbs
import Mathlib.Data.Nat.ModEq

/-!
# IMO 1985 Q2

Fix a natural number $n ≥ 3$ and define $N=\{1, 2, 3, \dots, n-1\}$. Fix another natural number
$j ∈ N$ coprime to $n$. Each number in $N$ is now colored with one of two colors, say red or black,
so that:

1. $i$ and $n-i$ always receive the same color, and
2. $i$ and $|j-i|$ receive the same color for all $i ∈ N, i ≠ j$.

Prove that all numbers in $N$ must receive the same color.

# Solution

Let $a \sim b$ denote that $a$ and $b$ have the same color.
Because $j$ is coprime to $n$, every number in $N$ is of the form $kj\bmod n$ for a unique
$1 ≤ k < n$, so it suffices to show that $kj\bmod n \sim (k-1)j\bmod n$ for $1 < k < n$.
In this range of $k$, $kj\bmod n ≠ j$, so

* if $kj\bmod n > j$, $kj\bmod n \sim kj\bmod n - j = (k-1)j\bmod n$ using rule 2;
* if $kj\bmod n < j$, $kj\bmod n \sim j - kj\bmod n \sim n - j + kj\bmod n = (k-1)j\bmod n$
  using rule 2 then rule 1.
-/

namespace Imo1985Q2

open Nat

/-- The conditions on the problem's coloring `C`.
Although its domain is all of `ℕ`, we only care about its values in `Set.Ico 1 n`. -/
def Condition (n j : ℕ) (C : ℕ → Fin 2) : Prop :=
  (∀ i ∈ Set.Ico 1 n, C i = C (n - i)) ∧ (∀ i ∈ Set.Ico 1 n, i ≠ j → C i = C (j - i : ℤ).natAbs)

/-- For `1 ≤ k < n`, `k * j % n` has the same color as `j`. -/
lemma C_mul_mod {n j : ℕ} (hn : 3 ≤ n) (hj : j ∈ Set.Ico 1 n) (cpj : Nat.Coprime n j)
    {C : ℕ → Fin 2} (hC : Condition n j C) {k : ℕ} (hk : k ∈ Set.Ico 1 n) :
    C (k * j % n) = C j := by
  induction k, hk.1 using Nat.le_induction with
  | base => rw [one_mul, Nat.mod_eq_of_lt hj.2]
  | succ k hk₁ ih =>
    have nej : (k + 1) * j % n ≠ j := by
      by_contra! h; nth_rw 2 [← Nat.mod_eq_of_lt hj.2, ← one_mul j] at h
      replace h : (k + 1) % n = 1 % n := Nat.ModEq.cancel_right_of_coprime cpj h
      rw [Nat.mod_eq_of_lt hk.2, Nat.mod_eq_of_lt (by omega)] at h
      omega
    have b₁ : (k + 1) * j % n ∈ Set.Ico 1 n := by
      refine ⟨?_, Nat.mod_lt _ (by omega)⟩
      by_contra! h; rw [Nat.lt_one_iff, ← Nat.dvd_iff_mod_eq_zero] at h
      have ek := Nat.eq_zero_of_dvd_of_lt (cpj.dvd_of_dvd_mul_right h) hk.2
      omega
    rw [← ih ⟨hk₁, Nat.lt_of_succ_lt hk.2⟩, hC.2 _ b₁ nej]
    rcases nej.lt_or_gt with h | h
    · rw [Int.natAbs_natCast_sub_natCast_of_ge h.le]
      have b₂ : j - (k + 1) * j % n ∈ Set.Ico 1 n :=
        ⟨Nat.sub_pos_iff_lt.mpr h, (Nat.sub_le ..).trans_lt hj.2⟩
      have q : n - (j - (k + 1) * j % n) = (k + 1) * j % n + (n - j) % n := by
        rw [tsub_tsub_eq_add_tsub_of_le h.le, add_comm, Nat.add_sub_assoc hj.2.le,
          Nat.mod_eq_of_lt (show n - j < n by omega)]
      rw [hC.1 _ b₂, q, ← Nat.add_mod_of_add_mod_lt (by omega), ← Nat.add_sub_assoc hj.2.le,
        add_comm, Nat.add_sub_assoc (Nat.le_mul_of_pos_left _ hk.1), ← tsub_one_mul,
        Nat.add_mod_left, add_tsub_cancel_right]
    · rw [Int.natAbs_natCast_sub_natCast_of_le h.le, Nat.mod_sub_of_le h.le]
      rw [add_mul, one_mul, add_tsub_cancel_right]

theorem result {n j : ℕ} (hn : 3 ≤ n) (hj : j ∈ Set.Ico 1 n) (cpj : Coprime n j)
    {C : ℕ → Fin 2} (hC : Condition n j C) {i : ℕ} (hi : i ∈ Set.Ico 1 n) :
    C i = C j := by
  obtain ⟨v, hv⟩ := exists_mul_emod_eq_one_of_coprime cpj.symm (by omega)
  have hvi : i = (v * i % n) * j % n := by
    rw [mod_mul_mod, ← mul_rotate, ← mod_mul_mod, hv, one_mul, mod_eq_of_lt hi.2]
  have vib : v * i % n ∈ Set.Ico 1 n := by
    refine ⟨(?_ : 0 < _), mod_lt _ (by omega)⟩
    by_contra! h; rw [le_zero, ← dvd_iff_mod_eq_zero] at h
    rw [mul_comm, ← mod_eq_of_lt (show 1 < n by omega)] at hv
    have i0 := eq_zero_of_dvd_of_lt
      ((coprime_of_mul_modEq_one _ hv).symm.dvd_of_dvd_mul_left h) hi.2
    subst i; simp at hi
  rw [hvi, C_mul_mod hn hj cpj hC vib]

end Imo1985Q2
