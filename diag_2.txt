Termination.lean:859:10
[Meta.Tactic.simp.rewrite] hrest:1000:
      rest
    ==>
      ω * (mu b + 1) + 2 
[Meta.Tactic.simp.rewrite] add_one_eq_succ:1000:
      mu b + 1
    ==>
      Order.succ (mu b) 
[Meta.Tactic.simp.rewrite] eq_self:1000:
      ω * Order.succ (mu b) + 2 = ω * Order.succ (mu b) + 2
    ==>
      True 
Termination.lean:867:8
[Meta.Tactic.simp.rewrite] this:1000:
      rest
    ==>
      ω * (mu b + 1) + 2 
[Meta.Tactic.simp.rewrite] add_one_eq_succ:1000:
      mu b + 1
    ==>
      Order.succ (mu b) 
[Meta.Tactic.simp.rewrite] gt_iff_lt:1000:
      ω * Order.succ (mu b) + 2 < ω * ω
    ==>
      ω * Order.succ (mu b) + 2 < ω * ω 
[Meta.Tactic.simp.rewrite] add_one_eq_succ:1000:
      mu b + 1
    ==>
      Order.succ (mu b) 
Termination.lean:868:6
type mismatch, term
  this
after simplification has type
  rest < ω * ω : Prop
but is expected to have type
  rest < ω ^ 2 : Prop
Termination.lean:868:6
[Meta.Tactic.simp.rewrite] gt_iff_lt:1000:
      rest < ω ^ 2
    ==>
      rest < ω ^ 2 
Termination.lean:870:33
`le_of_not_lt` has been deprecated: use `_root_.le_of_not_gt` instead
Termination.lean:871:38
type mismatch
  add_le_add_right hω 1
has type
  ω + 1 ≤ mu b + 1 : Prop
but is expected to have type
  ω ≤ mu b + 1 : Prop
Termination.lean:873:8
type mismatch
  mul_le_mul_left' hμ1 ω
has type
  ω * ω ≤ ω * (mu b + 1) : Prop
but is expected to have type
  ω * (mu b + 1) ≤ ω * ω : Prop
Termination.lean:876:10
[Meta.Tactic.simp.rewrite] hrest:1000:
      rest
    ==>
      ω * (mu b + 1) + 2 
[Meta.Tactic.simp.rewrite] add_one_eq_succ:1000:
      mu b + 1
    ==>
      Order.succ (mu b) 
[Meta.Tactic.simp.rewrite] eq_self:1000:
      ω * Order.succ (mu b) + 2 = ω * Order.succ (mu b) + 2
    ==>
      True 
Termination.lean:879:74
unknown identifier 'add_lt_of_lt_of_le'
Termination.lean:879:10
[Meta.Tactic.simp.rewrite] add_one_eq_succ:1000:
      mu b + 1
    ==>
      Order.succ (mu b) 
[Meta.Tactic.simp.rewrite] add_one_eq_succ:1000:
      mu b + 1
    ==>
      Order.succ (mu b) 
Termination.lean:880:8
[Meta.Tactic.simp.rewrite] ge_iff_le:1000:
      rest ≤ ω * ω
    ==>
      rest ≤ ω * ω 
[Meta.Tactic.simp.rewrite] add_one_eq_succ:1000:
      mu b + 1
    ==>
      Order.succ (mu b) 
Termination.lean:881:85
Application type mismatch: In the application
  le_of_eq pow_two
the argument
  pow_two
has type
  ∀ (a : ?m.85693), a ^ 2 = a * a : Prop
but is expected to have type
  ω * ω = ?m.85640 : Prop
Termination.lean:894:4
[Meta.Tactic.simp.rewrite] hμ_split:1000:
      mu (b.recΔ s n) + 1
    ==>
      tower + rest 
[Meta.Tactic.simp.rewrite] gt_iff_lt:1000:
      tower + rest < A
    ==>
      tower + rest < A 
Termination.lean:900:25
Application type mismatch: In the application
  LT.lt.trans this hμ1_lt
the argument
  hμ1_lt
has type
  mu (b.recΔ s n) + 1 < A : Prop
but is expected to have type
  ω ^ (mu (b.recΔ s n) + 1) < A : Prop
Termination.lean:903:25
Application type mismatch: In the application
  lt_trans ?m.98025 (add_lt_add_left h3pos ?m.98119)
the argument
  add_lt_add_left h3pos ?m.98119
has type
  ?m.98119 + 0 < ?m.98119 + 3 : Prop
but is expected to have type
  ?m.96179 < mu n.delta + mu s + 6 : Prop
Termination.lean:835:56
unsolved goals
case hpow_lt
b s n : Trace
A : Ordinal.{u_1} := ω ^ (mu n.delta + mu s + 6)
h_coeff : ω ^ 2 * (mu (b.recΔ s n) + 1) ≤ ω ^ (mu (b.recΔ s n) + 3)
tower : Ordinal.{u_1} := ω ^ (mu n + mu s + 6)
htower : tower = ω ^ (mu n + mu s + 6)
rest : Ordinal.{u_1} := ω * (mu b + 1) + 2
hrest : rest = ω * (mu b + 1) + 2
hμ_split : mu (b.recΔ s n) + 1 = tower + rest
htower_lt : tower < A
h₁ : rest < ω ^ 2
h₂ : ω ^ 2 < A
hrest_lt : rest < A
hμ1_lt : mu (b.recΔ s n) + 1 < A
hgap : mu (b.recΔ s n) + 3 < mu n.delta + mu s + 6
⊢ ?m.123395


b s n : Trace
A : Ordinal.{u_1} := ω ^ (mu n.delta + mu s + 6)
h_coeff : ω ^ 2 * (mu (b.recΔ s n) + 1) ≤ ω ^ (mu (b.recΔ s n) + 3)
tower : Ordinal.{u_1} := ω ^ (mu n + mu s + 6)
htower : tower = ω ^ (mu n + mu s + 6)
rest : Ordinal.{u_1} := ω * (mu b + 1) + 2
hrest : rest = ω * (mu b + 1) + 2
hμ_split : mu (b.recΔ s n) + 1 = tower + rest
htower_lt : tower < A
h₁ : rest < ω ^ 2
h₂ : ω ^ 2 < A
hrest_lt : rest < A
hμ1_lt : mu (b.recΔ s n) + 1 < A
hgap : mu (b.recΔ s n) + 3 < mu n.delta + mu s + 6
hpow_lt : ?m.123395
⊢ ω ^ 2 * (mu (b.recΔ s n) + 1) < A
Termination.lean:833:0
[diag] Diagnostics ▼
  [kernel] unfolded declarations (max: 174, num: 5): ▶
use `set_option diagnostics.threshold <num>` to control threshold for reporting counters
Termination.lean:833:0
[diag] Diagnostics ▼
  [reduction] unfolded declarations (max: 4537, num: 26): ▶
  [reduction] unfolded instances (max: 2093, num: 36): ▶
  [reduction] unfolded reducible declarations (max: 5666, num: 10): ▶
  [def_eq] heuristic for solving `f a =?= f b` (max: 1043, num: 7): ▶
  [kernel] unfolded declarations (max: 174, num: 5): ▶
use `set_option diagnostics.threshold <num>` to control threshold for reporting counters
@pow_two ?m.85693 ?m.85694 : ∀ (a : ?m.85693), a ^ 2 = a * a